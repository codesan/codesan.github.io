<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Linux Crontab 命令安装和使用教程：在 VPS 上设置定时任务</title>
    <url>/1.html</url>
    <content><![CDATA[<h2 id="一、Crontab-命令安装教程"><a href="#一、Crontab-命令安装教程" class="headerlink" title="一、Crontab 命令安装教程"></a><strong>一、Crontab 命令安装教程</strong></h2><p>首先检查一下 Crontab 是否安装：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">crontab -l</span><br></pre></td></tr></table></figure>

<p>如果没报错，就是已经安装好了，一般来说系统都会自带。</p>
<p>如果没安装，进行安装：</p>
<p>CentOS：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum install vixie-cron</span><br><span class="line">yum install crontabs</span><br></pre></td></tr></table></figure>

<p>Ubuntu：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apt-get install cron</span><br></pre></td></tr></table></figure>

<h2 id="二、Crontab-命令使用教程"><a href="#二、Crontab-命令使用教程" class="headerlink" title="二、Crontab 命令使用教程"></a><strong>二、Crontab 命令使用教程</strong></h2><p>命令格式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">crontab [-u user] file crontab [-u user] [ -e | -l | -r ]</span><br></pre></td></tr></table></figure>

<p>是不是觉得怪复杂的，其实一般来说其实就三个命令：</p>
<ul>
<li>列出所有定时任务：<code>crontab -l</code></li>
<li>编辑所有定时任务：<code>crontab -e</code></li>
<li>删除所有定时任务：<code>crontab -r</code></li>
</ul>
<p>使用 crontab -l 可以列出所有的定时任务，一行一个任务，一般来说，每行的格式如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">分 时 日 月 星期 要运行的命令</span><br></pre></td></tr></table></figure>

<ul>
<li>第 1 列：分钟，取值范围：0～59</li>
<li>第 2 列：小时，取值范围：0～23（0表示子夜）</li>
<li>第 3 列：日，取值范围：1～31</li>
<li>第 4 列：月，取值范围：1～12</li>
<li>第 5 列：星期，取值范围：0～7（0 和 7 表示星期天）</li>
<li>第 6 列：要运行的命令</li>
</ul>
<p>对于每一列，有如下几种表示方法：</p>
<ul>
<li>*：每单位（比如每分钟，每小时）</li>
<li>具体数字：就是具体的时间或者日期</li>
<li>取值范围：比如 3 – 5，就是从 3 到 5 的所有值都取</li>
<li>*/数字：比如 */2，就是每 2 分钟或者每 2 天之类的意思</li>
</ul>
<p>下面看几个例子：</p>
<p>实例 1：每 1 分钟执行一次 myCommand</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">* * * * * myCommand</span><br></pre></td></tr></table></figure>

<p>实例 2：每小时的第 3 和第 15 分钟执行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3,15 * * * * myCommand</span><br></pre></td></tr></table></figure>

<p>实例 3：在上午 8 点到 11 点的第 3 和第 15 分钟执行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3,15 8-11 * * * myCommand</span><br></pre></td></tr></table></figure>

<p>实例 4：每隔两天的上午 8 点到 11 点的第 3 和第 15 分钟执行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3,15 8-11 */2  *  * myCommand</span><br></pre></td></tr></table></figure>

<p>实例 5：每周一上午 8 点到 11 点的第 3 和第 15 分钟执行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3,15 8-11 * * 1 myCommand</span><br></pre></td></tr></table></figure>

<p>实例 6：每晚的 21:30 重启 smb</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">30 21 * * * /etc/init.d/smb restart</span><br></pre></td></tr></table></figure>

<p>实例 7：每月 1、10、22 日的 4 : 45 重启 smb</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">45 4 1,10,22 * * /etc/init.d/smb restart</span><br></pre></td></tr></table></figure>

<p>实例 8：每周六、周日的 1 : 10 重启 smb</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">10 1 * * 6,0 /etc/init.d/smb restart</span><br></pre></td></tr></table></figure>

<p>实例 9：每天 18 : 00 至 23 : 00 之间每隔 30 分钟重启 smb</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0,30 18-23 * * * /etc/init.d/smb restart</span><br></pre></td></tr></table></figure>

<p>实例 10：每星期六的晚上 11 : 00 pm 重启 smb</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0 23 * * 6 /etc/init.d/smb restart</span><br></pre></td></tr></table></figure>

<p>实例 11：每一小时重启 smb</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0 */1 * * * /etc/init.d/smb restart</span><br></pre></td></tr></table></figure>

<p>实例 12：晚上 11 点到早上 7 点之间，每隔一小时重启 smb</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0 23-7 * * * /etc/init.d/smb restart</span><br></pre></td></tr></table></figure>

<p>实例 13：5小时后 每一小时重启 smb</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0 5/1 * * * /etc/init.d/smb restart</span><br></pre></td></tr></table></figure>

<p><strong>错误示例</strong>:</p>
<p>如果你想定一个每天两点执行的任务:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0 2 * * * /etc/init.d/smb restart</span><br></pre></td></tr></table></figure>

<p>但不能写成:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">* 2 * * * /etc/init.d/smb restart</span><br></pre></td></tr></table></figure>

<p>这种写法表示每天两点开始每分钟执行一次任务, 可能会陷入嵌套重复执行的问题</p>
<h3 id="配置完后-最后启动定时任务"><a href="#配置完后-最后启动定时任务" class="headerlink" title="配置完后 最后启动定时任务"></a>配置完后 最后启动定时任务</h3><p>ubuntu下启动、停止与重启cron:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$sudo /etc/init.d/cron start</span><br><span class="line">$sudo /etc/init.d/cron stop</span><br><span class="line">$sudo /etc/init.d/cron restart</span><br><span class="line">$sudo service cron status# 查看当前cron服务运行状态</span><br></pre></td></tr></table></figure>

<h4 id="定时任务备份"><a href="#定时任务备份" class="headerlink" title="定时任务备份"></a>定时任务备份</h4><p>可以使用这种方法在$HOME目录中对crontab文件做一备份:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ crontab -l &gt; $HOME/mycron</span><br></pre></td></tr></table></figure>

<h3 id="问题排查"><a href="#问题排查" class="headerlink" title="问题排查"></a>问题排查</h3><p><strong>1. 启动cron 报错：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cron: can&apos;t lock /var/run/crond.pid, otherpid may be 4187: Resource temporarily unavailable</span><br></pre></td></tr></table></figure>

<p><strong>解决方案：</strong></p>
<p>依次执行以下三个命令</p>
<p>删除pid 重新加载配置 重启启动cron</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rm -rf /var/run/crond.pid</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cron reload</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cron restart</span><br></pre></td></tr></table></figure>

<p><strong>2.任务不执行 日志不打印</strong></p>
<p>指令必须以绝对路径开头 比如:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">* */2 * * *  /usr/bin/python3  /root/xxx/xxx.py &gt;&gt;/root/xxx/mylog_$(date +\%Y-\%m-\%d-\%H:\%M:\%S).log 2&gt;&amp;1</span><br></pre></td></tr></table></figure>

<p><strong>本文为作者原创 转载时请注明出处 谢谢</strong></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em>乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</em></p>
]]></content>
      <tags>
        <tag>python自动化</tag>
      </tags>
  </entry>
  <entry>
    <title>打赏博主</title>
    <url>/0.html</url>
    <content><![CDATA[<p>如果内容有帮助到您, 可以打赏一下哦~:moneybag:</p>
<h2 id="打赏方式一"><a href="#打赏方式一" class="headerlink" title="打赏方式一"></a>打赏方式一</h2><p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/alipay.jpg" alt="alipay"></p>
<h2 id="打赏方式二"><a href="#打赏方式二" class="headerlink" title="打赏方式二"></a>打赏方式二</h2><p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/wechatpay-1.jpg" alt="wechatpay"></p>
<p><a href="https://space.bilibili.com/485691562" target="_blank" rel="noopener">B站入口</a></p>
<p>微信公众号二维码如下:</p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt="img"></p>
<p><em><a href="https://code.newban.cn/">乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</a></em></p>
]]></content>
      <tags>
        <tag>打赏</tag>
      </tags>
  </entry>
  <entry>
    <title>UE4(虚幻引擎)之常用快捷键</title>
    <url>/100.html</url>
    <content><![CDATA[<p>虚幻4中有一些按键和快捷键很常用，牢记它们并运动到实际的项目开发中，将会大大地提高你的工作效率和使得工作更简便快捷。下面将列举它们出来：</p>
<table>
<thead>
<tr>
<th>按键</th>
<th>动作</th>
</tr>
</thead>
<tbody><tr>
<td>鼠标左键</td>
<td>选择actor</td>
</tr>
<tr>
<td>鼠标左键+拖动</td>
<td>前后移动和左右旋转摄像头</td>
</tr>
<tr>
<td>鼠标右键</td>
<td>选择actor并打开右键菜单</td>
</tr>
<tr>
<td>鼠标右键+拖动</td>
<td>旋转摄像头方向</td>
</tr>
<tr>
<td>鼠标左键+鼠标右键+拖动</td>
<td>摄像头上下左右移动</td>
</tr>
<tr>
<td>鼠标中键+拖动</td>
<td>摄像头上下左右移动</td>
</tr>
<tr>
<td>滑轮向上</td>
<td>摄像机向前移动</td>
</tr>
<tr>
<td>滑轮向下</td>
<td>摄像机向后移动</td>
</tr>
<tr>
<td>F</td>
<td>聚焦选中的actor</td>
</tr>
<tr>
<td>箭头方向键</td>
<td>摄像机前后左右移动</td>
</tr>
<tr>
<td>W</td>
<td>选中平移工具</td>
</tr>
<tr>
<td>E</td>
<td>选中旋转工具</td>
</tr>
<tr>
<td>R</td>
<td>选中缩放工具</td>
</tr>
<tr>
<td>W+任何鼠标按键</td>
<td>摄像机向前移动</td>
</tr>
<tr>
<td>S+任何鼠标按键</td>
<td>摄像机向后移动</td>
</tr>
<tr>
<td>A+任何鼠标按键</td>
<td>摄像机向左移动</td>
</tr>
<tr>
<td>D+任何鼠标按键</td>
<td>摄像机向右移动</td>
</tr>
<tr>
<td>E+任何鼠标按键</td>
<td>摄相机向上移动</td>
</tr>
<tr>
<td>Q+任何鼠标按键</td>
<td>摄像机向下移动</td>
</tr>
<tr>
<td>Z+任何鼠标按键</td>
<td>增加视野（鼠标释放后会恢复原状）</td>
</tr>
<tr>
<td>C+任何鼠标按键</td>
<td>缩小视野（鼠标释放后会恢复原状）</td>
</tr>
<tr>
<td>Ctrl+S</td>
<td>保存场景</td>
</tr>
<tr>
<td>Ctrl+N</td>
<td>创建新场景</td>
</tr>
<tr>
<td>Ctrl+O</td>
<td>打开一个已有的场景</td>
</tr>
<tr>
<td>Ctrl+Alt+S</td>
<td>另存为新场景</td>
</tr>
<tr>
<td>Alt+鼠标左键+拖动</td>
<td>复制当前选中的actor</td>
</tr>
<tr>
<td>Alt+鼠标右键+拖动</td>
<td>摄像机前后移动</td>
</tr>
<tr>
<td>Alt+P</td>
<td>进入Play预览模式</td>
</tr>
<tr>
<td>Esc</td>
<td>退出预览模式</td>
</tr>
<tr>
<td>F11</td>
<td>进入仿真模式</td>
</tr>
</tbody></table>
<h3 id="官方提供"><a href="#官方提供" class="headerlink" title="官方提供"></a>官方提供</h3><h2 id="Viewport"><a href="#Viewport" class="headerlink" title="Viewport"></a>Viewport</h2><table>
<thead>
<tr>
<th align="left">Hotkey</th>
<th align="left">Action</th>
</tr>
</thead>
<tbody><tr>
<td align="left">LMB</td>
<td align="left">Select actor under cursor, replacing selection.</td>
</tr>
<tr>
<td align="left">Ctrl + LMB</td>
<td align="left">Add / Remove actor under cursor to selection.</td>
</tr>
<tr>
<td align="left">Shift + LMB</td>
<td align="left">Add actor under cursor to selection.</td>
</tr>
<tr>
<td align="left">ESC</td>
<td align="left">Clears selection.</td>
</tr>
<tr>
<td align="left">TILDE</td>
<td align="left">Toggles command console.</td>
</tr>
<tr>
<td align="left"><strong>Perspective</strong></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">RMB + Drag Forward / Backward</td>
<td align="left">Rotate camera up / down.</td>
</tr>
<tr>
<td align="left">RMB + Drag Left / Right</td>
<td align="left">Rotate camera left / right.</td>
</tr>
<tr>
<td align="left">( RMB + W ) | Numpad8 | Up</td>
<td align="left">Move camera <em>forward</em>.</td>
</tr>
<tr>
<td align="left">( RMB + S ) | Numpad2 | Down</td>
<td align="left">Move camera <em>backward</em>.</td>
</tr>
<tr>
<td align="left">( RMB + A ) | Numpad4 | Left</td>
<td align="left">Move camera <em>left</em>.</td>
</tr>
<tr>
<td align="left">( RMB + D ) | Numpad6 | Right</td>
<td align="left">Move camera <em>right</em>.</td>
</tr>
<tr>
<td align="left">( RMB + E ) | Numpad9 | Page Up</td>
<td align="left">Move camera <em>up</em>.</td>
</tr>
<tr>
<td align="left">( RMB + Q ) | Numpad7 | Page Dn</td>
<td align="left">Move camera <em>down</em>.</td>
</tr>
<tr>
<td align="left">( RMB + C ) | Numpad3</td>
<td align="left">Zoom camera <em>in</em>.</td>
</tr>
<tr>
<td align="left">( RMB + Z ) | Numpad1</td>
<td align="left">Zoom camera <em>out</em>.</td>
</tr>
<tr>
<td align="left">LMB + Drag Forward/Backward</td>
<td align="left">Move camera <em>forward</em> /<em>backward</em></td>
</tr>
<tr>
<td align="left">LMB + Drag Left/Right</td>
<td align="left">Rotate camera <em>left</em> /<em>right</em></td>
</tr>
<tr>
<td align="left">LMB + RMB + Drag</td>
<td align="left">Move camera <em>up</em> /<em>down</em></td>
</tr>
<tr>
<td align="left"><strong>Orthographic ( Top | Front | Side )</strong></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">LMB + Drag</td>
<td align="left">Creates selection box, selects contained actors, replacing selection.</td>
</tr>
<tr>
<td align="left">Shift + LMB + Drag</td>
<td align="left"><em>Add</em> actors in selection box to selection.</td>
</tr>
<tr>
<td align="left">Ctrl + Alt + Drag</td>
<td align="left"><em>Remove</em> actors in selection box from selection.</td>
</tr>
<tr>
<td align="left">RMB + Drag</td>
<td align="left"><em>Pan</em> camera.</td>
</tr>
<tr>
<td align="left">LMB + RMB + Drag</td>
<td align="left">Zoom camera <em>in</em> /<em>out</em>.</td>
</tr>
<tr>
<td align="left"><strong>Focusing</strong></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">F</td>
<td align="left">Focus camera on selected object or group.</td>
</tr>
<tr>
<td align="left"><strong>Camera view</strong></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">Alt + G</td>
<td align="left">Perspective camera.</td>
</tr>
<tr>
<td align="left">Alt + K</td>
<td align="left">Side camera.</td>
</tr>
<tr>
<td align="left">Alt + J</td>
<td align="left">Top camera.</td>
</tr>
<tr>
<td align="left"><strong>Actor Manipulation</strong></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">Space</td>
<td align="left">Toggle between ( <em>Translate</em> | <em>Rotate</em> | <em>Scale</em> ), see toolbar for selection.</td>
</tr>
<tr>
<td align="left">W</td>
<td align="left">Selects <em>Move</em> tool.</td>
</tr>
<tr>
<td align="left">E</td>
<td align="left">Selects <em>Rotate</em> tool.</td>
</tr>
<tr>
<td align="left">R</td>
<td align="left">Selects <em>Scale</em> tool.</td>
</tr>
<tr>
<td align="left">V</td>
<td align="left">Toggles <em>vertex snapping</em>.</td>
</tr>
<tr>
<td align="left">LMB + Transform Axis + Drag</td>
<td align="left">Transforms selected actors depending on active tool.</td>
</tr>
<tr>
<td align="left"><strong>Perspective</strong> (scale works evenly on all axes, rotate/move works as expected)</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">Ctrl + LMB + Drag</td>
<td align="left">Transform selected actor(s) along the x-axis.</td>
</tr>
<tr>
<td align="left">Ctrl + RMB + Drag</td>
<td align="left">Transform selected actor(s) along the y-axis.</td>
</tr>
<tr>
<td align="left">Ctrl + LMB + RMB + Drag</td>
<td align="left">Transform selected actor/s along the z-axis.</td>
</tr>
<tr>
<td align="left"><strong>Orthographic</strong></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">Ctrl + LMB + Drag</td>
<td align="left">Transform selected actor(s) along the view plane axis.</td>
</tr>
<tr>
<td align="left">Ctrl + RMB + Drag</td>
<td align="left"><em>Rotate</em> selected actor(s) along the view plane axis.</td>
</tr>
<tr>
<td align="left"><strong>Display</strong></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">G</td>
<td align="left">Toggles <em>Game Mode</em> rendering.</td>
</tr>
<tr>
<td align="left">Ctrl + R</td>
<td align="left">Toggles real-time <em>playback</em>.</td>
</tr>
<tr>
<td align="left">F11</td>
<td align="left">Toggles <em>Fullscreen</em>.</td>
</tr>
</tbody></table>
<p>链接地址:<a href="https://leetnightshade.com/blog/unreal-engine-hotkeys" target="_blank" rel="noopener">https://leetnightshade.com/blog/unreal-engine-hotkeys</a></p>
<p><strong>本帖附件</strong></p>
<p><a href="https://u21519047.pipipan.com/fs/21519047-395416051" target="_blank" rel="noopener">点击下载</a></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em>乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</em></p>
]]></content>
      <tags>
        <tag>游戏开发</tag>
      </tags>
  </entry>
  <entry>
    <title>微信小程序开发入门篇</title>
    <url>/102.html</url>
    <content><![CDATA[<blockquote>
<p>对于初学者来讲,快速掌握一门新技能,不在于把每一步都搞透,而在于先把整个流程跑通,</p>
<p>先控大局,再究其细节   这是快速学习的基本技巧之一</p>
</blockquote>
<h2 id="第一步-申请小程序账号"><a href="#第一步-申请小程序账号" class="headerlink" title="第一步 申请小程序账号"></a>第一步 申请小程序账号</h2><p><strong>注:一个邮箱只能申请一个小程序账号</strong></p>
<p>注册链接:<a href="https://mp.weixin.qq.com/wxopen/waregister?action=step1" target="_blank" rel="noopener">https://mp.weixin.qq.com/wxopen/waregister?action=step1</a></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191121141714.png" alt></p>
<h2 id="第二步-获取小程序Appid"><a href="#第二步-获取小程序Appid" class="headerlink" title="第二步 获取小程序Appid"></a>第二步 获取小程序Appid</h2><p><strong>注册成功后登陆账号</strong></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191121141844.png" alt></p>
<p><strong>进入开发设置界面  复制appid 一会开发需要用到</strong></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191121141953.png" alt></p>
<h2 id="第三步-下载小程序开发工具"><a href="#第三步-下载小程序开发工具" class="headerlink" title="第三步 下载小程序开发工具"></a>第三步 下载小程序开发工具</h2><p>官方下载地址:<a href="https://developers.weixin.qq.com/miniprogram/dev/devtools/download.html" target="_blank" rel="noopener">https://developers.weixin.qq.com/miniprogram/dev/devtools/download.html</a></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191121142206.png" alt></p>
<p><strong>安装完毕后打开,然后新建项目</strong></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191121142516.png" alt></p>
<p><strong>填入之前复制的appid,新手的话选择不使用云服务即可,这样目录相对简单一些</strong></p>
<p><strong>创建成功后会自动生成一些目录和文件</strong></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191121142955.png" alt></p>
<h3 id="小程序初始化目录："><a href="#小程序初始化目录：" class="headerlink" title="小程序初始化目录："></a>小程序初始化目录：</h3><p>小程序包含一个描述整体程序的 <code>app</code> 和多个描述各自页面的 <code>page</code>。</p>
<p>一个小程序主体部分由三个文件组成，必须放在项目的根目录，如下：</p>
<table>
<thead>
<tr>
<th align="left">文件</th>
<th align="left">必需</th>
<th align="left">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/app-service/app.html" target="_blank" rel="noopener">app.js</a></td>
<td align="left">是</td>
<td align="left">小程序逻辑</td>
</tr>
<tr>
<td align="left"><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/config.html" target="_blank" rel="noopener">app.json</a></td>
<td align="left">是</td>
<td align="left">小程序公共配置</td>
</tr>
<tr>
<td align="left"><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/view/wxss.html" target="_blank" rel="noopener">app.wxss</a></td>
<td align="left">否</td>
<td align="left">小程序公共样式表</td>
</tr>
</tbody></table>
<p>一个小程序页面由四个文件组成，分别是：</p>
<table>
<thead>
<tr>
<th align="left">文件类型</th>
<th align="left">必需</th>
<th align="left">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/app-service/page.html" target="_blank" rel="noopener">js</a></td>
<td align="left">是</td>
<td align="left">页面逻辑</td>
</tr>
<tr>
<td align="left"><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/view/wxml/" target="_blank" rel="noopener">wxml</a></td>
<td align="left">是</td>
<td align="left">页面结构</td>
</tr>
<tr>
<td align="left"><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/config.html#页面配置" target="_blank" rel="noopener">json</a></td>
<td align="left">否</td>
<td align="left">页面配置</td>
</tr>
<tr>
<td align="left"><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/view/wxss.html" target="_blank" rel="noopener">wxss</a></td>
<td align="left">否</td>
<td align="left">页面样式表</td>
</tr>
</tbody></table>
<p>1：page 页面文件夹 存放项目页面渲染相关文件</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/20210811094834.png" alt></p>
<p>2：utils 存放js库和数字格式化文件</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/20210811094854.png" alt></p>
<p>3： 配置文件</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/20210811094912.png" alt></p>
<h2 id="第四步-程序开发"><a href="#第四步-程序开发" class="headerlink" title="第四步 程序开发"></a>第四步 程序开发</h2><p>需要具备前端相关知识,如果还不具备,建议先学习html+css+js 基础</p>
<p>个人开发大多以展示为主,可以不用开发后台</p>
<h2 id="第五步-上传小程序"><a href="#第五步-上传小程序" class="headerlink" title="第五步 上传小程序"></a>第五步 上传小程序</h2><p>开发完之后，可以在开发工具选项点击上传按钮将代码至微信后台。如下：</p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191121151046.png" alt></p>
<p><strong>填写版本号和项目备注</strong></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191121151252.png" alt></p>
<h2 id="第六步-提交审核"><a href="#第六步-提交审核" class="headerlink" title="第六步 提交审核"></a>第六步 提交审核</h2><p>上传成功后进入后台管理界面,将刚才上传的程序提交给微信官方审核</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/1574320522905.png" alt="1574320522905"></p>
<p><strong>一般一两天就能查看审核结果，通过审核之后，还需要发布上线</strong></p>
<p>线上版本发布后,这时你就可以在微信搜索中搜到我们自己的小程序了</p>
<p><strong>本帖附件</strong></p>
<p><a href="https://u21519047.pipipan.com/fs/21519047-395416051" target="_blank" rel="noopener">点击下载</a></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em>乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</em></p>
]]></content>
      <tags>
        <tag>大前端开发</tag>
      </tags>
  </entry>
  <entry>
    <title>Android Studio：如何使用Android Studio与夜神模拟器开发调试</title>
    <url>/10.html</url>
    <content><![CDATA[<h2 id="使用Android-Studio与夜神模拟器开发调试："><a href="#使用Android-Studio与夜神模拟器开发调试：" class="headerlink" title="使用Android Studio与夜神模拟器开发调试："></a>使用Android Studio与夜神模拟器开发调试：</h2><p>（1）运行夜神模拟器，</p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20200915184734.png" alt></p>
<p>（2）打开命令行窗口，</p>
<p>（3）打开到夜神安装目录（如cd D:\Program Files\NOX\Nox\bin），</p>
<p>（4）执行命令：nox_adb.exe connect 127.0.0.1:62001，连接模拟器，</p>
<p>（5）若Android Studio连接不上夜神，重启模拟器即可。</p>
<p>4、这时在Android Studio窗口上点击run ‘app’(或shift+F10)</p>
<p>会发现弹出的窗口如下所示：</p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20200915184707.png" alt></p>
<p>点击OK即可在模拟器上运行app</p>
<p><strong>本文为作者原创 转载时请注明出处 谢谢</strong></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em>乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</em></p>
]]></content>
      <tags>
        <tag>android开发</tag>
      </tags>
  </entry>
  <entry>
    <title>使用计算器进行开方的两种方法</title>
    <url>/101.html</url>
    <content><![CDATA[<blockquote>
<p>生活中很少使用到开方运算, 前段时间为了计算理财复合收益率, 运用到了这一块的内容, 在这里做个记录</p>
</blockquote>
<h3 id="场景复现"><a href="#场景复现" class="headerlink" title="场景复现"></a>场景复现</h3><p>比如64需要进行开６次方的操作, 计算器该如何操作呢?</p>
<h4 id="第一种"><a href="#第一种" class="headerlink" title="第一种"></a>第一种</h4><p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20200104132321.png" alt></p>
<h4 id="第二种"><a href="#第二种" class="headerlink" title="第二种"></a>第二种</h4><p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20200104132700.png" alt></p>
<iframe style="width:98%;height: 450px;" src="https://code.newban.cn/video/kaifang.mp4" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" autoplay="false" webkitallowfullscreen="true" mozallowfullscreen="true"> </iframe>







<p><strong>本帖附件</strong></p>
<p><a href="https://u21519047.pipipan.com/fs/21519047-395416051" target="_blank" rel="noopener">点击下载</a></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em>乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</em></p>
]]></content>
      <tags>
        <tag>其他</tag>
      </tags>
  </entry>
  <entry>
    <title>从源码角度分析Activity与Window及View之间的关系</title>
    <url>/104.html</url>
    <content><![CDATA[<p>我们都知道布局文件的加载是在Activity的onCreate()方法中,使用setContentView进行加载</p>
<p>这个方法是个重载方法</p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191206162608.png" alt></p>
<p><strong>它们无一例外都是使用的getWindow()进行加载</strong></p>
<p><strong>那么window是在什么时候创建的呢?</strong> </p>
<p><strong>我们知道Acitivity的生命周期是从onCreate开始的, 其实在它之前还有一个方法已经被执行了, 那就是attach方法</strong></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191206162844.png" alt></p>
<p><strong>PolicyManager创建了一个新的Window对象</strong></p>
<p><strong>接下来</strong></p>
<p><strong>我们进入到PolicyManager类中</strong></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191206163344.png" alt></p>
<p><strong>IPolicy是个接口</strong></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191206163509.png" alt></p>
<p><strong>我们需要找到它的实现类,通过寻找发现Pollicy.java实现了IPolicy接口</strong><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191206163925.png" alt></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191206164013.png" alt></p>
<p><strong>实现代码如下:</strong></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191206164105.png" alt></p>
<p><strong>直接创建了一个PhoneWindow对象,</strong></p>
<p><strong>那么意味着 每创建一个Activity都会创建一个PhoneWindow对象</strong></p>
<p><strong>那么PhoneWindow与Window到底是什么关系呢?</strong></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191206164400.png" alt></p>
<p><strong>PhoneWindow是Window的子类</strong></p>
<p><strong>那么到此为止, 我们知道了其实Activity中的setContentView实际上是PhoneWindow在处理</strong></p>
<p><strong>我们找到PhoneWindow.java能发现其对应的方法</strong></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191206164818.png" alt></p>
<p><strong>这里面的是三个重载方法咱们一个一个来分析</strong></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191206165008.png" alt></p>
<p><strong>首先第一个</strong></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191206165609.png" alt></p>
<p><strong>咱们平常开发时在xml中写的布局并不是根结点, 而是contentParent的子view</strong></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><h4 id="它们之间的关系可以大致理解为"><a href="#它们之间的关系可以大致理解为" class="headerlink" title="它们之间的关系可以大致理解为:"></a>它们之间的关系可以大致理解为:</h4><p><strong>Activity</strong>: 相当于一栋房子</p>
<p><strong>Window</strong>: 相当于房子里的一扇窗户</p>
<p><strong>View</strong>: 相当于窗户上的一朵窗花</p>
<h4 id="它们三个的创建顺序为"><a href="#它们三个的创建顺序为" class="headerlink" title="它们三个的创建顺序为:"></a>它们三个的创建顺序为:</h4><p><strong>Activity—&gt;Window—&gt;View</strong></p>
<p>具体时序图如下:</p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/Android%E7%9A%84Activity%E5%90%AF%E5%8A%A8%E6%97%B6%E5%BA%8F%E5%9B%BE.png" alt></p>
<p><strong>本帖附件</strong></p>
<p><a href="https://u21519047.pipipan.com/fs/21519047-395416051" target="_blank" rel="noopener">点击下载</a></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em>乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</em></p>
]]></content>
      <tags>
        <tag>Android源码</tag>
      </tags>
  </entry>
  <entry>
    <title>彻底搞懂Git Rebase</title>
    <url>/103.html</url>
    <content><![CDATA[<p>使用 Git 已经好几年了，却始终只是熟悉一些常用的操作。对于 Git Rebase 却很少用到，直到这一次，不得不用。</p>
<h4 id="一、起因"><a href="#一、起因" class="headerlink" title="一、起因"></a>一、起因</h4><p>上线构建的过程中扫了一眼代码变更，突然发现，<code>commit</code> 提交竟然多达 <code>62</code> 次。我们来看看都提交了什么东西：<br><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/git-rebase/commit1.png" alt="commit1"></p>
<p>这里我们先不说 <code>git</code> <a href="http://jartto.wang/2018/07/08/git-commit/" target="_blank" rel="noopener">提交规范</a>，就单纯这么多次无用的 <code>commit</code> 就很让人不舒服。可能很多人觉得无所谓，无非是多了一些提交纪录。</p>
<p>然而，并非如此，你可能听过破窗效应，编程也是如此！</p>
<h4 id="二、导致问题"><a href="#二、导致问题" class="headerlink" title="二、导致问题"></a>二、导致问题</h4><p>1.不利于代码 <code>review</code><br>设想一下，你要做 <code>code review</code> ，结果一个很小的功能，提交了 <code>60</code> 多次，会不会有一些崩溃？</p>
<p>2.会造成分支污染<br>你的项目充满了无用的 <code>commit</code> 纪录，如果有一天线上出现了紧急问题，你需要回滚代码，却发现海量的 <code>commit</code> 需要一条条来看。</p>
<p>遵循项目规范才能提高团队协作效率，而不是随心所欲。</p>
<h4 id="三、Rebase-场景一：如何合并多次提交纪录？"><a href="#三、Rebase-场景一：如何合并多次提交纪录？" class="headerlink" title="三、Rebase 场景一：如何合并多次提交纪录？"></a>三、Rebase 场景一：如何合并多次提交纪录？</h4><p>基于上面所说问题，我们不难想到：每一次功能开发， 对多个 commit 进行合并处理。</p>
<p>这时候就需要用到 <code>git rebase</code> 了。这个命令没有太难，不常用可能源于不熟悉，所以我们来通过示例学习一下。</p>
<p>1.我们来合并最近的 4 次提交纪录，执行：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git rebase -i HEAD~4</span><br></pre></td></tr></table></figure>

<p>2.这时候，会自动进入 <code>vi</code> 编辑模式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">s cacc52da add: qrcodes f072ef48 update: indexeddb hacks 4e84901a feat: add indexedDB floders 8f33126c feat: add test2.js# Rebase 5f2452b2..8f33126c onto 5f2452b2 (4 commands)## Commands:# p, pick = use commit# r, reword = use commit, but edit the commit message# e, edit = use commit, but stop for amending# s, squash = use commit, but meld into previous commit# f, fixup = like &quot;squash&quot;, but discard this commit&apos;s log message# x, exec = run command (the rest of the line) using shell# d, drop = remove commit## These lines can be re-ordered; they are executed from top to bottom.## If you remove a line here THAT COMMIT WILL BE LOST.## However, if you remove everything, the rebase will be aborted.#</span><br></pre></td></tr></table></figure>

<p>有几个命令需要注意一下：</p>
<ul>
<li>p, pick = use commit</li>
<li>r, reword = use commit, but edit the commit message</li>
<li>e, edit = use commit, but stop for amending</li>
<li>s, squash = use commit, but meld into previous commit</li>
<li>f, fixup = like “squash”, but discard this commit’s log message</li>
<li>x, exec = run command (the rest of the line) using shell</li>
<li>d, drop = remove commit</li>
</ul>
<p>按照如上命令来修改你的提交纪录：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">s cacc52da add: qrcodes f072ef48 update: indexeddb hacks 4e84901a feat: add indexedDB floderp 8f33126c feat: add test2.js</span><br></pre></td></tr></table></figure>

<p>3.如果保存的时候，你碰到了这个错误：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">error: cannot &apos;squash&apos; without a previous commit</span><br></pre></td></tr></table></figure>

<p>注意不要合并先前提交的东西，也就是已经提交远程分支的纪录。</p>
<p>4.如果你异常退出了 <code>vi</code> 窗口，不要紧张：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git rebase --edit-todo</span><br></pre></td></tr></table></figure>

<p>这时候会一直处在这个编辑的模式里，我们可以回去继续编辑，修改完保存一下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git rebase --continue</span><br></pre></td></tr></table></figure>

<p>5.查看结果</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git log</span><br></pre></td></tr></table></figure>

<p>三次提交合并成了一次，减少了无用的提交信息。</p>
<p><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/git-rebase/commit2.png" alt="commit2"></p>
<h4 id="四、Rebase-场景二：分支合并"><a href="#四、Rebase-场景二：分支合并" class="headerlink" title="四、Rebase 场景二：分支合并"></a>四、Rebase 场景二：分支合并</h4><p>1.我们先从 <code>master</code> 分支切出一个 <code>dev</code> 分支，进行开发：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git:(master) git checkout -b feature1</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/git-rebase/git1.png" alt="git1"><br>2.这时候，你的同事完成了一次 <code>hotfix</code>，并合并入了 <code>master</code> 分支，此时 <code>master</code> 已经领先于你的 <code>feature1</code> 分支了：<br><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/git-rebase/git2.png" alt="git2"><br>3.恰巧，我们想要同步 <code>master</code> 分支的改动，首先想到了 <code>merge</code>，执行：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git:(feature1) git merge master</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/git-rebase/git3.png" alt="git3"><br>图中绿色的点就是我们合并之后的结果，执行：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git:(feature1) git log</span><br></pre></td></tr></table></figure>

<p>就会在记录里发现一些 <code>merge</code> 的信息，但是我们觉得这样污染了 <code>commit</code> 记录，想要保持一份干净的 <code>commit</code>，怎么办呢？这时候，<code>git rebase</code> 就派上用场了。</p>
<p>4.让我们来试试 <code>git rebase</code> ，先回退到同事 <code>hotfix</code> 后合并 <code>master</code> 的步骤：<br><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/git-rebase/git4.png" alt="git4"><br>5.使用 <code>rebase</code> 后来看看结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git:(feature1) git rebase master</span><br></pre></td></tr></table></figure>

<p>这里补充一点：<code>rebase</code> 做了什么操作呢？</p>
<p>首先，<code>git</code> 会把 <code>feature1</code> 分支里面的每个 <code>commit</code> 取消掉；<br>其次，把上面的操作临时保存成 <code>patch</code> 文件，存在 <code>.git/rebase</code> 目录下；<br>然后，把 <code>feature1</code> 分支更新到最新的 <code>master</code> 分支；<br>最后，把上面保存的 <code>patch</code> 文件应用到 <code>feature1</code> 分支上；</p>
<p><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/git-rebase/git5.png" alt="git5"></p>
<p>从 <code>commit</code> 记录我们可以看出来，<code>feature1</code> 分支是基于 <code>hotfix</code> 合并后的 <code>master</code> ，自然而然的成为了最领先的分支，而且没有 <code>merge</code> 的 <code>commit</code> 记录，是不是感觉很舒服了。</p>
<p>6.在 <code>rebase</code> 的过程中，也许会出现冲突 <code>conflict</code>。在这种情况，<code>git</code> 会停止 <code>rebase</code> 并会让你去解决冲突。在解决完冲突后，用 <code>git add</code> 命令去更新这些内容。</p>
<p>注意，你无需执行 git-commit，只要执行 continue</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git rebase --continue</span><br></pre></td></tr></table></figure>

<p>这样 <code>git</code> 会继续应用余下的 <code>patch</code> 补丁文件。</p>
<p>7.在任何时候，我们都可以用 <code>--abort</code> 参数来终止 <code>rebase</code> 的行动，并且分支会回到 <code>rebase</code> 开始前的状态。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git rebase —abort</span><br></pre></td></tr></table></figure>

<h4 id="五、更多-Rebase-的使用场景"><a href="#五、更多-Rebase-的使用场景" class="headerlink" title="五、更多 Rebase 的使用场景"></a>五、更多 Rebase 的使用场景</h4><p>git-rebase 存在的价值是：对一个分支做「变基」操作。</p>
<p>1.当我们在一个过时的分支上面开发的时候，执行 <code>rebase</code> 以此同步 <code>master</code> 分支最新变动；<br>2.假如我们要启动一个放置了很久的并行工作，现在有时间来继续这件事情，很显然这个分支已经落后了。这时候需要在最新的基准上面开始工作，所以 <code>rebase</code> 是最合适的选择。</p>
<h4 id="六、为什么会是危险操作？"><a href="#六、为什么会是危险操作？" class="headerlink" title="六、为什么会是危险操作？"></a>六、为什么会是危险操作？</h4><p>根据上文来看，<code>git-rebase</code> 很完美，解决了我们的两个问题：<br>1.合并 <code>commit</code> 记录，保持分支整洁；<br>2.相比 <code>merge</code> 来说会减少分支合并的记录；</p>
<p>如果你提交了代码到远程，提交前是这样的：<br><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/git-rebase/git2.png" alt="git2"></p>
<p>提交后远程分支变成了这样：<br><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/git-rebase/git5.png" alt="git5"></p>
<p>而此时你的同事也在 <code>feature1</code> 上开发，他的分支依然还是：<br><img src="https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/git-rebase/git6.png" alt="git6"></p>
<p>那么当他 <code>pull</code> 远程 <code>master</code> 的时候，就会有丢失提交纪录。这就是为什么我们经常听到有人说 <code>git rebase</code> 是一个危险命令，因为它改变了历史，我们应该谨慎使用。</p>
<p>除非你可以肯定该 <code>feature1</code> 分支只有你自己使用，否则请谨慎操作。</p>
<p>结论：只要你的分支上需要 <code>rebase</code> 的所有 <code>commits</code> 历史还没有被 <code>push</code> 过，就可以安全地使用 <code>git-rebase</code>来操作。</p>
<p>本文转载自:<a href="http://jartto.wang/2018/12/11/git-rebase/" target="_blank" rel="noopener">http://jartto.wang/2018/12/11/git-rebase/</a></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em>乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</em></p>
]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>大脑开发之右脑开发</title>
    <url>/105.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>工欲善其事必先利其器,大脑是我们每个人最为珍贵的宝藏,它的潜能是无穷无尽的,强大到令人可怕,</p>
<p>但是普通人对于大脑的了解和使用是即为匮乏的  作为一名现代人 如果你想跑得比别人快 站得比别人高  那么就必须学会如何开发我们的大脑, 让大脑更好的为我们服务</p>
<h2 id="左脑和右脑分工"><a href="#左脑和右脑分工" class="headerlink" title="左脑和右脑分工"></a>左脑和右脑分工</h2><p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/e7cd7b899e510fb354b3c30fd333c895d0430cfb.jpg" alt></p>
<h2 id="左右脑检测"><a href="#左右脑检测" class="headerlink" title="左右脑检测"></a>左右脑检测</h2><p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/c9fcc3cec3fdfc03ddcca15ad23f8794a5c2269f.jpg" alt></p>
<p><strong>如果你看见这个跳舞女孩是顺时针转，说明你用的是右脑；</strong></p>
<p><strong>如果是逆时针转，说明你用的左脑。</strong></p>
<p>耶鲁大学耗时5年的研究成果。据说，14%的美国人可以两个方向都能看见。顺时针转的话，属於是用右脑较多的类型。逆时针转属於使用左脑较多的类型。大部分人的眼里里是逆时针方向转动，但也有人看来是顺时针方向转动的。</p>
<h2 id="为什么要开发右脑"><a href="#为什么要开发右脑" class="headerlink" title="为什么要开发右脑"></a>为什么要开发右脑</h2><ul>
<li><strong>左脑刺激机会相对比右脑多 大部分人左脑发达</strong></li>
</ul>
<p>人类左脑主管语言、逻辑、书写及右侧肢体运动，而右脑主管色彩、空间感、节奏和左侧肢体运动。在频繁使用语言的过程中，特别是国内的应试教育，侧重偏向于逻辑、记忆为主，人的左脑得到更多刺激，使左脑相对发达于右脑 </p>
<ul>
<li><strong>右脑的存储量是左脑的100万倍 反应时间要快于左脑</strong></li>
<li><strong>右脑记忆更容易转化为长期记忆 极大缩短知识的记忆时间</strong></li>
</ul>
<h2 id="右脑记忆的主要方式"><a href="#右脑记忆的主要方式" class="headerlink" title="右脑记忆的主要方式"></a>右脑记忆的主要方式</h2><ul>
<li><strong>图像记忆</strong></li>
<li><strong>声音记忆</strong></li>
<li><strong>感觉记忆</strong></li>
</ul>
<h2 id="如何训练和开发"><a href="#如何训练和开发" class="headerlink" title="如何训练和开发"></a>如何训练和开发</h2><ul>
<li><strong>养成将知识转成图像 声音或者感觉的形式进行记忆的习惯</strong></li>
<li><strong>养成听音频的习惯</strong></li>
<li><strong>养成画图的习惯</strong></li>
<li><strong>养成闭目空间想象回忆的习惯</strong></li>
</ul>
<p><strong>本帖附件</strong></p>
<p><a href="https://u21519047.pipipan.com/fs/21519047-395416051" target="_blank" rel="noopener">点击下载</a></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em>乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</em></p>
]]></content>
      <tags>
        <tag>大脑开发</tag>
      </tags>
  </entry>
  <entry>
    <title>告诉你为什么十六进制表示的颜色值是两位代表一种颜色</title>
    <url>/106.html</url>
    <content><![CDATA[<blockquote>
<p>学习本篇之前需要先了解《<a href="http://code.iww6.com/%E5%88%A9%E7%94%A88421%E6%B3%95%E8%BF%9B%E8%A1%8C%E5%8D%81%E5%85%AD%E8%BF%9B%E5%88%B6%E4%B8%8E%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%9A%84%E4%BA%92%E7%9B%B8%E8%BD%AC%E6%8D%A2-%E4%B8%80%E5%AD%A6%E5%B0%B1%E4%BC%9A.html" target="_blank" rel="noopener">十六进制和二进制的互相转换</a>》</p>
</blockquote>
<h3 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h3><p>我们知道每个像素都是由三原色红绿蓝三种颜色组成</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">RGB //Red(红色)  Green(绿色)  Blue(蓝色)</span><br></pre></td></tr></table></figure>

<p>一个像素点可以由4组8位二进制数表示(不要问为什么 重点)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 1 1 1   1 1 1 1    第一组 表示红色 R</span><br><span class="line"></span><br><span class="line">0 0 1 1   0 1 0 0    第二组 表示绿色 G</span><br><span class="line"></span><br><span class="line">1 1 1 1   1 1 1 1    第一组 表示蓝色 B</span><br><span class="line"></span><br><span class="line">1 1 1 1   1 1 1 1    第一组 表示表明度 A</span><br></pre></td></tr></table></figure>

<p>也就是我们熟知的<strong>RGBA</strong> </p>
<h2 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h2><p>既然我们已经知道了二进制的颜色, 根据二进制转十六进制 利用8421法必然会将每个颜色的二进制分为两组 比如:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">8 4 2 1   8 4 2 1</span><br><span class="line">0 0 1 1   0 1 0 0</span><br></pre></td></tr></table></figure>

<p><strong>第一组为:2+1=3</strong></p>
<p><strong>第二组为:4</strong></p>
<p>那么其对应的十六进制结果为<strong>0x34</strong></p>
<p>所以<strong>RGBA</strong>每个通道需要两位十六进制进行表示</p>
<p>你学会了吗</p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191204104857.png" alt></p>
<p><strong>本帖附件</strong></p>
<p><a href="https://u21519047.pipipan.com/fs/21519047-395416051" target="_blank" rel="noopener">点击下载</a></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em>乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</em></p>
]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>给老司机推荐几个学习网站</title>
    <url>/108.html</url>
    <content><![CDATA[<p><a href="http://www.mayadid.com/archiver/" target="_blank" rel="noopener">http://www.mayadid.com/archiver/</a></p>
<p><strong>本帖附件</strong></p>
<p><a href="https://u21519047.pipipan.com/fs/21519047-395416051" target="_blank" rel="noopener">点击下载</a></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em>乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</em></p>
]]></content>
      <tags>
        <tag>实用工具</tag>
      </tags>
  </entry>
  <entry>
    <title>给工程打jar包时如何把libs中的jar包一并打入</title>
    <url>/107.html</url>
    <content><![CDATA[<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/20200106103505.png" alt></p>
<p>当我们在进行maven打包时</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apply plugin: &apos;maven&apos;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">uploadArchives &#123; // 这里只是更新到本地，可以上传到自定义的maven仓库</span><br><span class="line">    repositories &#123;</span><br><span class="line">        mavenDeployer &#123;</span><br><span class="line">            //提交到远程服务器：</span><br><span class="line">            // repository(url: &quot;http://www.xxx.com/repos&quot;) &#123;</span><br><span class="line">            //    authentication(userName: &quot;admin&quot;, password: &quot;admin&quot;)</span><br><span class="line">            // &#125;</span><br><span class="line">            pom.groupId = &apos;com.insworks.plugin&apos;</span><br><span class="line">            pom.artifactId = &apos;framework-plugin&apos;</span><br><span class="line">            pom.version = &apos;1.0.3&apos;</span><br><span class="line">            repository(url: uri(&quot;$rootDir/global/repo&quot;))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果工程在本地引用了第三方jar包, 那么直接使用<code>uploadArchives</code>指令是无法将第三方jar包打进去的</p>
<p><strong>解决方案如下</strong>:</p>
<p><strong>方案一</strong>: 将jar包源代码拷入工程,然后一并打包(不推荐 )</p>
<p><strong>方案二</strong>: 只需加入以下代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">task makeJar(type: Jar) &#123;</span><br><span class="line">    //以下是需要打包进jar包中的内容</span><br><span class="line">    from(project.zipTree(&quot;libs/dom4j-2.1.1.jar&quot;))</span><br><span class="line">&#125;</span><br><span class="line">//包含第三方jar</span><br><span class="line">artifacts &#123;</span><br><span class="line">    archives makeJar</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="附加"><a href="#附加" class="headerlink" title="附加"></a>附加</h4><ol>
<li>如果我想打包源码, 那么加入以下代码:</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 源代码一起打包(不需要打包源代码的不要添加这几行)</span><br><span class="line">task androidSourcesJar(type: Jar) &#123;</span><br><span class="line">    classifier = &apos;sources&apos;</span><br><span class="line">    //指定源码目录</span><br><span class="line">    source = android.sourceSets.main.java.srcDirs</span><br><span class="line">    //加入第三方jar 这个是字节码文件</span><br><span class="line">    from(project.zipTree(&quot;libs/dom4j-2.1.1.jar&quot;))</span><br><span class="line">&#125;</span><br><span class="line">artifacts &#123;</span><br><span class="line">    archives androidSourcesJar</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>如果我想打包文档, 那么加入以下代码:</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//生成文档注释</span><br><span class="line">task androidJavadocs(type: Javadoc) &#123;</span><br><span class="line">    //如果出现错误 忽略不计</span><br><span class="line">    failOnError = false</span><br><span class="line">    //指定源码目录</span><br><span class="line">    source = android.sourceSets.main.java.srcDirs</span><br><span class="line">    ext.androidJar = &quot;$&#123;android.sdkDirectory&#125;/platforms/$&#123;android.compileSdkVersion&#125;/android.jar&quot;</span><br><span class="line">    classpath += files(ext.androidJar)</span><br><span class="line">&#125;</span><br><span class="line">//将文档打包成jar</span><br><span class="line">task androidJavadocsJar(type: Jar, dependsOn: androidJavadocs) &#123;</span><br><span class="line">    classifier = &apos;javadoc&apos;</span><br><span class="line">    from androidJavadocs.destinationDir</span><br><span class="line">&#125;</span><br><span class="line">//包含文档</span><br><span class="line">artifacts &#123;</span><br><span class="line">	 archives androidJavadocsJar</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>如果我想将两个jar包合并成一个jar包, 那么使用以下代码:</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">task makeJar(type: Jar) &#123;</span><br><span class="line">    //以下是需要打包进jar包中的内容</span><br><span class="line">    from(project.zipTree(&quot;libs/dom4j-2.1.1.jar&quot;))</span><br><span class="line">    from(project.zipTree(&quot;build/libs/lib_framework_plugin.jar&quot;))</span><br><span class="line">    //合体后的jar包名称</span><br><span class="line">    archiveName = &quot;framework-plugin-1.0.1.jar&quot;</span><br><span class="line">    //输出目录</span><br><span class="line">    destinationDir = file(&apos;build/libs&apos;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后执行<code>makeJar</code>指令</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/20191228113229.png" alt></p>
<p>成功后,可以在build目录中找到合并后的jar包</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/20191228113347.png" alt></p>
<p><strong>本帖附件</strong></p>
<p><a href="https://u21519047.pipipan.com/fs/21519047-395416051" target="_blank" rel="noopener">点击下载</a></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em>乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</em></p>
]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>将代码发布至jcenter步骤</title>
    <url>/109.html</url>
    <content><![CDATA[<h3 id="Step-1"><a href="#Step-1" class="headerlink" title="Step 1"></a>Step 1</h3><p>在项目的build.gradle中buildscript中添加如下脚本，使用最新版本号，在<code>https://github.com/novoda/bintray-release</code>查看：</p>
<p>      </p>
<pre><code>buildscript {
repositories {
    jcenter()
}
dependencies {
    //classpath &apos;com.novoda:bintray-release:&lt;latest-version&gt;&apos;
    classpath &apos;com.novoda:bintray-release:0.8.1&apos;
}
}</code></pre><h3 id="Step-2"><a href="#Step-2" class="headerlink" title="Step 2"></a>Step 2</h3><p>在库模块（需要上传的模块）的build.gradle中添加：</p>
<pre><code>apply plugin: &apos;com.novoda.bintray-release&apos;

publish {
    userOrg = &apos;组织ID&apos; //bintray账户下某个组织id 个人用户填写账户名
    groupId = &apos;com.insworks.plugin&apos; //maven仓库下库的包名，一般为模块包名
    artifactId = &apos;framework-plugin&apos; //项目名称
    publishVersion = &apos;1.0.2&apos; //版本号
    desc = &apos;组件化架构插件&apos; //项目介绍，可以不写
    website = &apos;&apos; //项目主页，可以不写
}
tasks.withType(Javadoc) {//防止编码问题
    options.addStringOption(&apos;Xdoclint:none&apos;, &apos;-quiet&apos;)
    options.addStringOption(&apos;encoding&apos;, &apos;UTF-8&apos;)
    options.addStringOption(&apos;charSet&apos;, &apos;UTF-8&apos;)
}</code></pre><h3 id="Step-3"><a href="#Step-3" class="headerlink" title="Step 3"></a>Step 3</h3><p>在bintray中创建仓库并获取仓库key。Bintray网站点击右上角用户名–&gt;Edit Your Profile -&gt; API Key –&gt;输入密码–&gt;Submit–&gt;Show。</p>
<h3 id="Step-4"><a href="#Step-4" class="headerlink" title="Step 4"></a>Step 4</h3><p>使用指令上传代码：</p>
<p> 在Android Studio的Terminal面板中执行下面命令，其中BINTRAY_USERNAME替换为你的binatray用户名，BINTRAY_KEY替换为上面获取的API Key，-PdryRun=false会上传到仓库中，如果为true，只会执行gradle任务，但不会上传。替换完成后回车执行</p>
<pre><code>示例
gradlew clean build bintrayUpload -PbintrayUser=BINTRAY_USERNAME -PbintrayKey=BINTRAY_KEY -PdryRun=false

我的
gradlew clean build bintrayUpload -PbintrayUser=songjianziana -PbintrayKey=5e7f0ea95e85af4cceca20cb109fb50ad7cba6bc -PdryRun=false</code></pre><p><strong>或者使用gradle快捷上传, 需要先编译项目(切记)</strong></p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/20200101002037.png" alt></p>
<h3 id="Step-5"><a href="#Step-5" class="headerlink" title="Step 5"></a>Step 5</h3><p> Android Studio中配置<a href="https://bintray.com仓库地址" target="_blank" rel="noopener">https://bintray.com仓库地址</a></p>
<pre><code>maven { url &apos;https://dl.bintray.com/songjianzaina/insoan&apos; }</code></pre><p>和然后在app模块build.gradle中添加依赖：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">implementation &apos;com.xxx.xxx.xx.:1.0.0&apos;</span><br></pre></td></tr></table></figure>

<h3 id="Step-6"><a href="#Step-6" class="headerlink" title="Step 6"></a>Step 6</h3><p>添加到JCenter。点击“Add to JCenter”，填写项目介绍，点击Send发送，然后等待审核，审核成功之后会发送站内通知</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/20191224171122.png" alt></p>
<p>上传成功之后将<code>maven { url &#39;https://dl.bintray.com/songjianzaina/insoan&#39; }</code>替换成jcenter即可</p>
<p><strong>本帖附件</strong></p>
<p><a href="https://u21519047.pipipan.com/fs/21519047-395416051" target="_blank" rel="noopener">点击下载</a></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em>乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</em></p>
]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>python requests库添加自定义cookies的方法</title>
    <url>/11.html</url>
    <content><![CDATA[<p>一般的情况使用requests.Session()方法就可以解决cookies问题，但是在途中添加cookie遇到了一些问题。</p>
<h3 id="第一种："><a href="#第一种：" class="headerlink" title="第一种："></a>第一种：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">session = requests.Session()</span><br><span class="line">session.cookies[&apos;cookie&apos;] = &apos;cookie-value&apos;12</span><br></pre></td></tr></table></figure>

<p>功能：可以添加cookie，不会清除原cookie<br>缺点：不能设置path，domain等参数</p>
<h3 id="第二种："><a href="#第二种：" class="headerlink" title="第二种："></a>第二种：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">session = requests.Session()</span><br><span class="line">session.cookies.set(&apos;cookie-name&apos;, &apos;cookie-value&apos;, path=&apos;/&apos;, domain=&apos;.abc.com&apos;)12</span><br></pre></td></tr></table></figure>

<p>功能：设置path、domain等参数。<br>缺点：清楚原来的cookies</p>
<h3 id="第三种："><a href="#第三种：" class="headerlink" title="第三种："></a>第三种：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">session = requests.Session()</span><br><span class="line">requests.utils.add_dict_to_cookiejar(session.cookies, cookie_dict)12</span><br></pre></td></tr></table></figure>

<p>功能：可以添加cookie，不会清除原cookie<br>缺点：不能设置path，domain等参数</p>
<h3 id="第四种："><a href="#第四种：" class="headerlink" title="第四种："></a>第四种：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">session = requests.Session()</span><br><span class="line">c = requests.cookies.RequestsCookieJar()</span><br><span class="line">c.set(&apos;cookie-name&apos;, &apos;cookie-value&apos;, path=&apos;/&apos;, domain=&apos;.abc.com&apos;)</span><br><span class="line">session.cookies.update(c)1234</span><br></pre></td></tr></table></figure>

<p>功能：既能添加cookies，还能添加path，domain等参数。</p>
<h3 id="cookie的path和domain属性"><a href="#cookie的path和domain属性" class="headerlink" title="cookie的path和domain属性"></a>cookie的path和domain属性</h3><ol>
<li>domain表示的是cookie所在的域，默认为请求的地址，如网址为<a href="http://www.test.com/test/test.aspx，那么domain默认为www.test.com。而跨域访问，如域A为t1.test.com，域B为t2.test.com，那么在域A生产一个令域A和域B都能访问的cookie就要将该cookie的domain设置为.test.com；如果要在域A生产一个令域A不能访问而域B能访问的cookie就要将该cookie的domain设置为t2.test.com。" target="_blank" rel="noopener">www.test.com/test/test.aspx，那么domain默认为www.test.com。而跨域访问，如域A为t1.test.com，域B为t2.test.com，那么在域A生产一个令域A和域B都能访问的cookie就要将该cookie的domain设置为.test.com；如果要在域A生产一个令域A不能访问而域B能访问的cookie就要将该cookie的domain设置为t2.test.com。</a></li>
<li>path表示cookie所在的目录，asp.net默认为/，就是根目录。在同一个服务器上有目录如下：/test/,/test/cd/,/test/dd/，现设一个cookie1的path为/test/，cookie2的path为/test/cd/，那么test下的所有页面都可以访问到cookie1，而/test/和/test/dd/的子页面不能访问cookie2。这是因为cookie能让其path路径下的页面访问。</li>
<li>浏览器会将domain和path都相同的cookie保存在一个文件里，cookie间用*隔开。</li>
<li>含值键值对的cookie：以前一直用的是nam=value单键值对的cookie，一说到含多个子键值对的就蒙了。现在总算弄清楚了。含多个子键值对的cookie格式是name=key1=value1&amp;key2=value2。可以理解为单键值对的值保存一个自定义的多键值字符串，其中的键值对分割符为&amp;，当然可以自定义一个分隔符，但用asp.net获取时是以&amp;为分割符。</li>
</ol>
<p><strong>本文为作者原创 转载时请注明出处 谢谢</strong></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em>乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</em></p>
]]></content>
      <tags>
        <tag>python基础</tag>
      </tags>
  </entry>
  <entry>
    <title>解决android中EditText设置末尾省略号不生效的情况</title>
    <url>/110.html</url>
    <content><![CDATA[<p>在Textiew中可以通过设置TextView的属性</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">android:maxEms</span><br></pre></td></tr></table></figure>

<p>和</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">android:ellipseize</span><br></pre></td></tr></table></figure>

<p>来使过多的文字显示为省略号，<strong>但在在EditText中设置只这两个属性则不行</strong>，</p>
<p><strong>android默认只有在文字不可编辑的状态下才可以显示这些效果</strong>，但是EditText重写了这个属性，使得文字默认都是可以编辑的。</p>
<p>所以若想要呈现TextView的效果，必须加上以下属性</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">android：editable= &quot;false&quot;</span><br></pre></td></tr></table></figure>

<p>另外EditText不支持跑马等的效果.咱们来看看android源码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">override</span><br><span class="line">public void setEllipsize(TextUtils.TruncateAt ellipsis) &#123;</span><br><span class="line">	if (ellipsis == TextUtils.TruncateAt.MARQUEE) &#123;</span><br><span class="line">		throw new IllegalArgumentException(&quot;EditText cannot use the ellipsize mode TextUtils.TruncateAt.MARQUEE&quot;);	</span><br><span class="line">	&#125;</span><br><span class="line">	super.setEllipsize(ellipsis);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>如果设置跑马灯效果,会直接抛出异常</strong></p>
<p>那么有同学会说了,editable设为false, 那岂不是没法进行文本编辑了?</p>
<p>这里呢, 建议大家自定义EditText并重写onTouchEvent方法,从外部进行控制是否获取焦点, 如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class FocusEditText(context: Context, attrs: AttributeSet) : EditText(context, attrs)&#123;</span><br><span class="line">    override fun onTouchEvent(event: MotionEvent?): Boolean &#123;</span><br><span class="line">        return isEnabled &amp;&amp; super.onTouchEvent(event)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>本帖附件</strong></p>
<p><a href="https://u21519047.pipipan.com/fs/21519047-395416051" target="_blank" rel="noopener">点击下载</a></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em>乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</em></p>
]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>老司机必备-图种快速制作神器</title>
    <url>/112.html</url>
    <content><![CDATA[<h2 id="什么是图种"><a href="#什么是图种" class="headerlink" title="什么是图种?"></a>什么是图种?</h2><blockquote>
<p>一种采用特殊方式将图片文件（如jpg格式）与压缩文件结合起来的文件。该文件一般输出为jpg图片文件，可以正常预览图片；当有人将该图片下载到本地后，可以通过修改文件的后缀，将.jpg改为.zip，并用winrar/7zip查看得到数据。由于这种方式有利于某些网友（老司机）传播种子文件，故称为图种，又叫作内涵图。</p>
</blockquote>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/test.jpg" alt></p>
<p><strong>比如上面这张图片,右键保存到本地将文件后缀改成zip后打开,会有意想不到的收获</strong></p>
<h2 id="如何制作类似上面的图种呢"><a href="#如何制作类似上面的图种呢" class="headerlink" title="如何制作类似上面的图种呢"></a>如何制作类似上面的图种呢</h2><ul>
<li><strong>第一种 原始方法</strong></li>
</ul>
<p>首先准备一张图片和一个要存放起来的压缩包，然后执行dos命令，如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">copy 1.jpg/b+2.zip=3.jpg</span><br></pre></td></tr></table></figure>

<p>执行以上指令后会生成一个3.jpg文件，这个图片如果用图片工具打开的话跟普通图片没什么区别，可以正常查看,如果修改后缀为zip或者用压缩工具打开的话可以看到自己存在压缩包里的内容</p>
<ul>
<li><strong>第二种 使用软件快速生成</strong></li>
</ul>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119162751.png" alt></p>
<p>使用方法很简单,直接提供下载地址</p>
<p><strong>本帖附件</strong></p>
<p><a href="https://sn9.us/file/21042697-408475532" target="_blank" rel="noopener">点击下载</a></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em>乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</em></p>
]]></content>
      <tags>
        <tag>实用工具</tag>
      </tags>
  </entry>
  <entry>
    <title>可能是把Docker的概念讲的最清楚的一篇文章</title>
    <url>/111.html</url>
    <content><![CDATA[<p>【编者的话】本文只是对Docker的概念做了较为详细的介绍，并不涉及一些像Docker环境的安装以及Docker的一些常见操作和命令。</p>
<p>Docker是世界领先的软件容器平台，所以想要搞懂Docker的概念我们必须先从容器开始说起。<strong>如果你想和更多Docker技术专家交流，可以加我微信liyingjiese，备注『加群』。群里每周都有全球各大公司的最佳实践以及行业最新动态</strong>。</p>
<h3 id="先从认识容器开始"><a href="#先从认识容器开始" class="headerlink" title="先从认识容器开始"></a>先从认识容器开始</h3><h4 id="什么是容器？"><a href="#什么是容器？" class="headerlink" title="什么是容器？"></a>什么是容器？</h4><p>先来看看容器较为官方的解释：</p>
<p>一句话概括容器：容器就是将软件打包成标准化单元，以用于开发、交付和部署。</p>
<ul>
<li>容器镜像是轻量的、可执行的独立软件包 ，包含软件运行所需的所有内容：代码、运行时环境、系统工具、系统库和设置。</li>
<li>容器化软件适用于基于Linux和Windows的应用，在任何环境中都能够始终如一地运行。</li>
<li>容器赋予了软件独立性，使其免受外在环境差异（例如，开发和预演环境的差异）的影响，从而有助于减少团队间在相同基础设施上运行不同软件时的冲突。</li>
</ul>
<p>再来看看容器较为通俗的解释：</p>
<p>如果需要通俗的描述容器的话，我觉得容器就是一个存放东西的地方，就像书包可以装各种文具、衣柜可以放各种衣服、鞋架可以放各种鞋子一样。我们现在所说的容器存放的东西可能更偏向于应用比如网站、程序甚至是系统环境。</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/0eb95638b712ca6ad211c76f73a366af.png" alt></p>
<h4 id="图解物理机、虚拟机与容器"><a href="#图解物理机、虚拟机与容器" class="headerlink" title="图解物理机、虚拟机与容器"></a>图解物理机、虚拟机与容器</h4><p>关于虚拟机与容器的对比在后面会详细介绍到，这里只是通过网上的图片加深大家对于物理机、虚拟机与容器这三者的理解。</p>
<p>物理机：</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/e9444d264eeaea2b178a71c9ed823c9c.jpeg" alt></p>
<p>虚拟机：</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/bb23f04f2b23b2312b04ba87dc8ad31d.jpeg" alt></p>
<p>容器：</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/e34f0f2a4b8718f09c8b366a14d5e9a9.jpeg" alt></p>
<p>通过上面这三张抽象图，我们大概可以通过类比概括出： 容器虚拟化的是操作系统而不是硬件，容器之间是共享同一套操作系统资源的。虚拟机技术是虚拟出一套硬件后，在其上运行一个完整操作系统。因此容器的隔离级别会稍低一些。</p>
<p>相信通过上面的解释大家对于容器这个既陌生又熟悉的概念有了一个初步的认识，下面我们就来谈谈Docker的一些概念。</p>
<h3 id="再来谈谈Docker的一些概念"><a href="#再来谈谈Docker的一些概念" class="headerlink" title="再来谈谈Docker的一些概念"></a>再来谈谈Docker的一些概念</h3><p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/57be762d7a61f06eedbec4142f3e2291.png" alt></p>
<h4 id="什么是Docker"><a href="#什么是Docker" class="headerlink" title="什么是Docker"></a>什么是Docker</h4><p>说实话关于Docker是什么并太好说，下面我通过四点向你说明Docker到底是个什么东西。</p>
<ul>
<li>Docker是世界领先的软件容器平台。</li>
<li>Docker使用Google公司推出的Go语言进行开发实现，基于Linux内核的cgroup，namespace，以及AUFS类的UnionFS等技术，对进程进行封装隔离，属于操作系统层面的虚拟化技术。 由于隔离的进程独立于宿主和其它的隔离的进程，因此也称其为容器。Docke最初实现是基于LXC。</li>
<li>Docker能够自动执行重复性任务，例如搭建和配置开发环境，从而解放了开发人员以便他们专注在真正重要的事情上：构建杰出的软件。</li>
<li>用户可以方便地创建和使用容器，把自己的应用放入容器。容器还可以进行版本管理、复制、分享、修改，就像管理普通的代码一样。</li>
</ul>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/125334d2b6dc3e34e6943ad5acc5e868.jpeg" alt></p>
<h4 id="Docker思想"><a href="#Docker思想" class="headerlink" title="Docker思想"></a>Docker思想</h4><ul>
<li>集装箱</li>
<li>标准化： ①运输方式、②存储方式、 ③API接口</li>
<li>隔离</li>
</ul>
<h4 id="Docker容器的特点"><a href="#Docker容器的特点" class="headerlink" title="Docker容器的特点"></a>Docker容器的特点</h4><ul>
<li>轻量，在一台机器上运行的多个Docker容器可以共享这台机器的操作系统内核；它们能够迅速启动，只需占用很少的计算和内存资源。镜像是通过文件系统层进行构造的，并共享一些公共文件。这样就能尽量降低磁盘用量，并能更快地下载镜像。</li>
<li>标准，Docker容器基于开放式标准，能够在所有主流Linux版本、Microsoft Windows以及包括VM、裸机服务器和云在内的任何基础设施上运行。</li>
<li>安全，Docker赋予应用的隔离性不仅限于彼此隔离，还独立于底层的基础设施。Docker默认提供最强的隔离，因此应用出现问题，也只是单个容器的问题，而不会波及到整台机器。</li>
</ul>
<h4 id="为什么要用Docker"><a href="#为什么要用Docker" class="headerlink" title="为什么要用Docker"></a>为什么要用Docker</h4><ul>
<li>Docker的镜像提供了除内核外完整的运行时环境，确保了应用运行环境一致性，从而不会再出现“这段代码在我机器上没问题啊”这类问题；——一致的运行环境</li>
<li>可以做到秒级、甚至毫秒级的启动时间。大大的节约了开发、测试、部署的时间。——更快速的启动时间</li>
<li>避免公用的服务器，资源会容易受到其他用户的影响。——隔离性</li>
<li>善于处理集中爆发的服务器使用压力；——弹性伸缩，快速扩展</li>
<li>可以很轻易的将在一个平台上运行的应用，迁移到另一个平台上，而不用担心运行环境的变化导致应用无法正常运行的情况。——迁移方便</li>
<li>使用Docker可以通过定制应用镜像来实现持续集成、持续交付、部署。——持续交付和部署</li>
</ul>
<p>每当说起容器，我们不得不将其与虚拟机做一个比较。</p>
<h3 id="容器-VS-虚拟机"><a href="#容器-VS-虚拟机" class="headerlink" title="容器 VS 虚拟机"></a>容器 VS 虚拟机</h3><p>简单来说： 容器和虚拟机具有相似的资源隔离和分配优势，但功能有所不同，因为容器虚拟化的是操作系统，而不是硬件，因此容器更容易移植，效率也更高。</p>
<h4 id="两者对比图"><a href="#两者对比图" class="headerlink" title="两者对比图"></a>两者对比图</h4><p>传统虚拟机技术是虚拟出一套硬件后，在其上运行一个完整操作系统，在该系统上再运行所需应用进程；而容器内的应用进程直接运行于宿主的内核，容器内没有自己的内核，而且也没有进行硬件虚拟。因此容器要比传统虚拟机更为轻便。</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/2e2b95eebf60b6d03f6c1476f4d7c697.png" alt></p>
<h4 id="容器与虚拟机-VM-总结"><a href="#容器与虚拟机-VM-总结" class="headerlink" title="容器与虚拟机 (VM) 总结"></a>容器与虚拟机 (VM) 总结</h4><p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/4ef8691d67eb1eb53217099d0a691eb5.png" alt></p>
<ul>
<li>容器是一个应用层抽象，用于将代码和依赖资源打包在一起。 多个容器可以在同一台机器上运行，共享操作系统内核，但各自作为独立的进程在用户空间中运行 。与虚拟机相比， 容器占用的空间较少（容器镜像大小通常只有几十兆），瞬间就能完成启动 。</li>
<li>虚拟机（VM）是一个物理硬件层抽象，用于将一台服务器变成多台服务器。 管理程序允许多个VM在一台机器上运行。每个VM都包含一整套操作系统、一个或多个应用、必要的二进制文件和库资源，因此占用大量空间。而且VM启动也十分缓慢 。</li>
</ul>
<p>通过Docker官网，我们知道了这么多Docker的优势，但是大家也没有必要完全否定虚拟机技术，因为两者有不同的使用场景。虚拟机更擅长于彻底隔离整个运行环境。例如，云服务提供商通常采用虚拟机技术隔离不同的用户。而Docker通常用于隔离不同的应用 ，例如前端，后端以及数据库。</p>
<h4 id="容器与虚拟机（VM）两者是可以共存的"><a href="#容器与虚拟机（VM）两者是可以共存的" class="headerlink" title="容器与虚拟机（VM）两者是可以共存的"></a>容器与虚拟机（VM）两者是可以共存的</h4><p>就我而言，对于两者无所谓谁会取代谁，而是两者可以和谐共存。</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/056c87751b9dd7b56f4264240fe96d00.png" alt></p>
<p>Docker中非常重要的三个基本概念，理解了这三个概念，就理解了 Docker 的整个生命周期。</p>
<h3 id="Docker基本概念"><a href="#Docker基本概念" class="headerlink" title="Docker基本概念"></a>Docker基本概念</h3><p>Docker包括三个基本概念：</p>
<ul>
<li>镜像（Image）</li>
<li>容器（Container）</li>
<li>仓库（Repository）</li>
</ul>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/e7c002d3b8de0b7c89f5ff81e6cd9e43.jpeg" alt></p>
<h4 id="镜像（Image）——一个特殊的文件系统"><a href="#镜像（Image）——一个特殊的文件系统" class="headerlink" title="镜像（Image）——一个特殊的文件系统"></a>镜像（Image）——一个特殊的文件系统</h4><p>操作系统分为内核和用户空间。对于Linux而言，内核启动后，会挂载root文件系统为其提供用户空间支持。而Docker镜像（Image），就相当于是一个root文件系统。</p>
<p>Docker镜像是一个特殊的文件系统，除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数（如匿名卷、环境变量、用户等）。 镜像不包含任何动态数据，其内容在构建之后也不会被改变。</p>
<p>Docker设计时，就充分利用Union FS的技术，将其设计为分层存储的架构。 镜像实际是由多层文件系统联合组成。</p>
<p>镜像构建时，会一层层构建，前一层是后一层的基础。每一层构建完就不会再发生改变，后一层上的任何改变只发生在自己这一层。比如，删除前一层文件的操作，实际不是真的删除前一层的文件，而是仅在当前层标记为该文件已删除。在最终容器运行的时候，虽然不会看到这个文件，但是实际上该文件会一直跟随镜像。因此，在构建镜像的时候，需要额外小心，每一层尽量只包含该层需要添加的东西，任何额外的东西应该在该层构建结束前清理掉。</p>
<p>分层存储的特征还使得镜像的复用、定制变的更为容易。甚至可以用之前构建好的镜像作为基础层，然后进一步添加新的层，以定制自己所需的内容，构建新的镜像。</p>
<h4 id="容器（Container）——镜像运行时的实体"><a href="#容器（Container）——镜像运行时的实体" class="headerlink" title="容器（Container）——镜像运行时的实体"></a>容器（Container）——镜像运行时的实体</h4><p>镜像（Image）和容器（Container）的关系，就像是面向对象程序设计中的类和实例一样，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等 。</p>
<p>容器的实质是进程，但与直接在宿主执行的进程不同，容器进程运行于属于自己的独立的命名空间。前面讲过镜像使用的是分层存储，容器也是如此。</p>
<p>容器存储层的生存周期和容器一样，容器消亡时，容器存储层也随之消亡。因此，任何保存于容器存储层的信息都会随容器删除而丢失。</p>
<p>按照Docker最佳实践的要求，容器不应该向其存储层内写入任何数据 ，容器存储层要保持无状态化。所有的文件写入操作，都应该使用数据卷（Volume）、或者绑定宿主目录，在这些位置的读写会跳过容器存储层，直接对宿主（或网络存储）发生读写，其性能和稳定性更高。数据卷的生存周期独立于容器，容器消亡，数据卷不会消亡。因此， 使用数据卷后，容器可以随意删除、重新run，数据却不会丢失。</p>
<h4 id="仓库（Repository）——集中存放镜像文件的地方"><a href="#仓库（Repository）——集中存放镜像文件的地方" class="headerlink" title="仓库（Repository）——集中存放镜像文件的地方"></a>仓库（Repository）——集中存放镜像文件的地方</h4><p>镜像构建完成后，可以很容易的在当前宿主上运行，但是， 如果需要在其它服务器上使用这个镜像，我们就需要一个集中的存储、分发镜像的服务，Docker Registry就是这样的服务。</p>
<p>一个Docker Registry中可以包含多个仓库（Repository）；每个仓库可以包含多个标签（Tag）；每个标签对应一个镜像。所以说：镜像仓库是Docker用来集中存放镜像文件的地方类似于我们之前常用的代码仓库。</p>
<p>通常，一个仓库会包含同一个软件不同版本的镜像，而标签就常用于对应该软件的各个版本 。我们可以通过&lt;仓库名&gt;:&lt;标签&gt;的格式来指定具体是这个软件哪个版本的镜像。如果不给出标签，将以latest作为默认标签。</p>
<p>这里补充一下Docker Registry公开服务和私有Docker Registry的概念：</p>
<p>Docker Registry公开服务是开放给用户使用、允许用户管理镜像的Registry服务。一般这类公开服务允许用户免费上传、下载公开的镜像，并可能提供收费服务供用户管理私有镜像。</p>
<p>最常使用的Registry公开服务是官方的Docker Hub ，这也是默认的Registry，并拥有大量的高质量的官方镜像，网址为：hub.docker.com/ 。在国内访问Docker Hub可能会比较慢国内也有一些云服务商提供类似于Docker Hub的公开服务。</p>
<p>除了使用公开服务外，用户还可以在本地搭建私有Docker Registry 。Docker官方提供了Docker Registry镜像，可以直接使用做为私有Registry服务。开源的Docker Registry镜像只提供了Docker Registry API的服务端实现，足以支持Docker命令，不影响使用。但不包含图形界面，以及镜像维护、用户管理、访问控制等高级功能。</p>
<h3 id="最后谈谈：Build，Ship，and-Run"><a href="#最后谈谈：Build，Ship，and-Run" class="headerlink" title="最后谈谈：Build，Ship，and Run"></a>最后谈谈：Build，Ship，and Run</h3><p>如果你搜索Docker官网，会发现如下的字样：“Docker - Build, Ship, and Run Any App, Anywhere”。那么Build，Ship，and Run到底是在干什么呢？</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/653dbc01d29a85f51cd32b045507d27c.png" alt></p>
<ul>
<li>Build（构建镜像）：镜像就像是集装箱包括文件以及运行环境等等资源。</li>
<li>Ship（运输镜像）：主机和仓库间运输，这里的仓库就像是超级码头一样。</li>
<li>Run （运行镜像）：运行的镜像就是一个容器，容器就是运行程序的地方。</li>
</ul>
<p>Docker运行过程也就是去仓库把镜像拉到本地，然后用一条命令把镜像运行起来变成容器。所以，我们也常常将Docker称为码头工人或码头装卸工，这和Docker的中文翻译搬运工人如出一辙。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本文主要把Docker中的一些常见概念做了详细的阐述，但是并不涉及Docker的安装、镜像的使用、容器的操作等内容。这部分东西，希望读者自己可以通过阅读书籍与官方文档的形式掌握。</p>
<p>本文转载自：<a href="https://mp.weixin.qq.com/s/xSbYTJmLuqsyYEDEIsndZw" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/xSbYTJmLuqsyYEDEIsndZw</a></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em>乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</em></p>
]]></content>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>利用8421法进行十六进制与二进制的互相转换 一学就会</title>
    <url>/113.html</url>
    <content><![CDATA[<h2 id="二进制转十六进制"><a href="#二进制转十六进制" class="headerlink" title="二进制转十六进制"></a>二进制转十六进制</h2><p>已知二进制值 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">110100</span><br></pre></td></tr></table></figure>

<p>从右到左4位4位的进行分割(不要问为什么)，位数不足的在左边添0 得到两组二进制:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0011 0100</span><br></pre></td></tr></table></figure>

<p>然后利用8421进行对应</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">8 4 2 1   8 4 2 1</span><br><span class="line">0 0 1 1   0 1 0 0</span><br></pre></td></tr></table></figure>

<p>把0对应的值去掉 1对应的值相加得到:</p>
<p><strong>第一组为:2+1=3</strong></p>
<p><strong>第二组为:4</strong></p>
<p>那么其对应的十六进制结果为<strong>0x34</strong></p>
<h2 id="十六进制转二进制"><a href="#十六进制转二进制" class="headerlink" title="十六进制转二进制"></a>十六进制转二进制</h2><p>同理 已知十六进制</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0x52</span><br></pre></td></tr></table></figure>

<p><strong>第一组是5 第二组是2</strong> 对应关系为:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">8 4 2 1   8 4 2 1</span><br><span class="line">0 1 0 1   0 0 1 0</span><br></pre></td></tr></table></figure>

<p>由于4+1=5 所以第一组4和1下面为1其余为0,同样第二组2下面值为1</p>
<p>最后得到二进制值为:<strong>01010010</strong></p>
<p><strong>本帖附件</strong></p>
<p><a href="https://u21519047.pipipan.com/fs/21519047-395416051" target="_blank" rel="noopener">点击下载</a></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em>乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</em></p>
]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>强制刷新gradle依赖缓存的方法</title>
    <url>/114.html</url>
    <content><![CDATA[<p>有时候我们需要在不改变版本号的前提下 同步gradle重新从远程更新依赖包</p>
<p><strong>方案一:</strong></p>
<p>修改项目任意一个依赖库版本号,然后同步gradle,同步完成后再改回来</p>
<p><strong>方案二:</strong></p>
<p>执行以下指令强制刷新</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Windows:    </span><br><span class="line">gradlew build --refresh-dependencies </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Mac:</span><br><span class="line">./gradlew build --refresh-dependencies</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/20191228170020.png" alt></p>
<p><strong>本帖附件</strong></p>
<p><a href="https://u21519047.pipipan.com/fs/21519047-395416051" target="_blank" rel="noopener">点击下载</a></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em>乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</em></p>
]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>十进制和二进制的快速转换 一学就会</title>
    <url>/116.html</url>
    <content><![CDATA[<h2 id="十进制转二进制"><a href="#十进制转二进制" class="headerlink" title="十进制转二进制"></a>十进制转二进制</h2><p>首先 我们需要背诵2的2到10的幂次方，这个我相信对大家都不难，它们分别是</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1、 2、4、8、16、32、64、128、 256、 512 、1024</span><br></pre></td></tr></table></figure>

<p>这些对应的二进制分别是</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1、10、 100 、1000 、10000 、100000、 1000000 、10000000、 100000000 、1000000000.</span><br></pre></td></tr></table></figure>

<p>接下来，就是开始心算的时候，比如：</p>
<pre><code>9=8+1  对应二进制 1001 

17=16+1 对应二进制  10001

 34=32+2  对应二进制    100010

  245=128+64+32+16+4+1  对应二进制 11110101</code></pre><p>每次从高位依次往下写，比如34 从32 往下写 依次是 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">32、16 、8 、4 、2 、1</span><br></pre></td></tr></table></figure>

<p>在该位数上分解的数有该数就写1，没有就写0。得到:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1、0、0、0、1、0 //也就是100010</span><br></pre></td></tr></table></figure>

<h2 id="二进制转十进制"><a href="#二进制转十进制" class="headerlink" title="二进制转十进制"></a>二进制转十进制</h2><pre><code>同理，也是从高位开始计算，；先数二进制数比如：

     101010   6个数  就从2的（6-1）次方开始计算

          分别是32+8+2=42</code></pre><p>找到最大位，依次往下数，该位上是1的话，就写出该数，最后相求和即可。</p>
<p>是不是很简单呢</p>
<p><strong>本帖附件</strong></p>
<p><a href="https://u21519047.pipipan.com/fs/21519047-395416051" target="_blank" rel="noopener">点击下载</a></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em>乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</em></p>
]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>轻量级组件化插件 告别传统组件化累赘和编译过慢</title>
    <url>/115.html</url>
    <content><![CDATA[<h3 id="framework-plugin-组件化架构插件"><a href="#framework-plugin-组件化架构插件" class="headerlink" title="framework-plugin 组件化架构插件"></a>framework-plugin 组件化架构插件</h3><p><a href="https://github.com/songjianzaina/framework-plugin" target="_blank" rel="noopener">Github</a></p>
<h2 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h2><ul>
<li>轻量级组件框架</li>
<li>即插即用</li>
<li>使用json文件动态配置, 减少同步时间</li>
</ul>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><ol>
<li>在项目的 <code>build.gradle</code> 中添加：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">buildscript &#123;</span><br><span class="line">  repositories &#123;</span><br><span class="line">   ...</span><br><span class="line">	maven &#123; url &apos;https://jitpack.io&apos; &#125;</span><br><span class="line">   &#125;</span><br><span class="line">  dependencies &#123;</span><br><span class="line">     classpath &apos;com.github.songjianzaina:framework-plugin:1.0.6-alpha&apos;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>在宿主module中使用插件</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apply plugin: &apos;framework-plugin&apos;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>同步工程,等待文件夹自动生成</li>
</ol>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>你可以在build.gradle中配置插件的几个属性，如果不设置，所有的属性都使用默认值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">frame&#123;</span><br><span class="line">    subDirName &quot;androidModule&quot;//子模块目录 App默认androidModule Lib默认androidLib</span><br><span class="line">    jsonName &quot;androidModule&quot;//子模块json文件名 默认同上</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>工程效果图:</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/a1616a6a09a84fa4874d4d0201c5ec6a~tplv-k3u1fbpfcp-zoom-1.image" alt></p>
<p>以上标红目录在应用插件后皆自动生成 无需手动创建</p>
<h2 id="更新历史"><a href="#更新历史" class="headerlink" title="更新历史"></a>更新历史</h2><table>
<thead>
<tr>
<th>版本号</th>
<th>功能点</th>
<th>链接</th>
</tr>
</thead>
<tbody><tr>
<td>1.0.0</td>
<td>初步实现架构文件自动生成</td>
<td><a href="https://bintray.com/songjianzaina/insoan/framework-plugin/1.0.0/link" target="_blank" rel="noopener"> [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-v7qfftdb-1627370867510)(https://api.bintray.com/packages/songjianzaina/insoan/framework-plugin/images/download.svg?version=1.0.0)] </a></td>
</tr>
<tr>
<td>1.0.1</td>
<td>增加全局文件夹以及全局libs</td>
<td><a href="https://bintray.com/songjianzaina/insoan/framework-plugin/1.0.1/link" target="_blank" rel="noopener"> [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-lXeFHBcf-1627370867512)(https://api.bintray.com/packages/songjianzaina/insoan/framework-plugin/images/download.svg?version=1.0.1)] </a></td>
</tr>
<tr>
<td>1.0.2</td>
<td>增加子模块目录名和配置文件名自定义配置</td>
<td><a href="https://bintray.com/songjianzaina/insoan/framework-plugin/1.0.2/link" target="_blank" rel="noopener"> [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-Ur648Ij1-1627370867513)(https://api.bintray.com/packages/songjianzaina/insoan/framework-plugin/images/download.svg?version=1.0.2)] </a></td>
</tr>
<tr>
<td>1.0.3</td>
<td>优化清单文件合并</td>
<td><a href="https://bintray.com/songjianzaina/insoan/framework-plugin/1.0.3/link" target="_blank" rel="noopener"> [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-p285dTfB-1627370867514)(https://api.bintray.com/packages/songjianzaina/insoan/framework-plugin/images/download.svg?version=1.0.3)] </a></td>
</tr>
<tr>
<td>1.0.4</td>
<td>增加Activity自动注册清单文件 (还未完善)</td>
<td><a href="https://bintray.com/songjianzaina/insoan/framework-plugin/1.0.4/link" target="_blank" rel="noopener"> [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-IKpgb7YM-1627370867514)(https://api.bintray.com/packages/songjianzaina/insoan/framework-plugin/images/download.svg?version=1.0.4)] </a></td>
</tr>
<tr>
<td>1.0.5</td>
<td>1.升级gradle依赖至4.0.0  <br> 2.新增values目录下attr和styles文件的自动生成 <br> 3.解决子模块libs目录so库无法引用的问题 <br> 4.优化插件加载方式 提升构建速度 <br> 5.移除多余log</td>
<td><a href="https://bintray.com/songjianzaina/insoan/framework-plugin/1.0.5/link" target="_blank" rel="noopener"> [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-66UCHd9Z-1627370867515)(https://api.bintray.com/packages/songjianzaina/insoan/framework-plugin/images/download.svg?version=1.0.5)] </a></td>
</tr>
</tbody></table>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em>乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</em></p>
]]></content>
      <tags>
        <tag>gradle插件</tag>
      </tags>
  </entry>
  <entry>
    <title>同一个局域网内远程控制电脑桌面的若干种方法</title>
    <url>/117.html</url>
    <content><![CDATA[<blockquote>
<p>本文持续更新中</p>
</blockquote>
<ul>
<li>第三方软件</li>
<li>局域网ip+3389端口</li>
</ul>
<p><strong>本帖附件</strong></p>
<p><a href="https://u21519047.pipipan.com/fs/21519047-395416051" target="_blank" rel="noopener">点击下载</a></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em>乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</em></p>
]]></content>
      <tags>
        <tag>实用技巧</tag>
      </tags>
  </entry>
  <entry>
    <title>外网电脑远程控制内网电脑桌面的若干种方法</title>
    <url>/118.html</url>
    <content><![CDATA[<blockquote>
<p>本文持续更新中</p>
</blockquote>
<ul>
<li>第三方软件(如:QQ、TeamViewer、向日葵、anydesk、Splashtop….)</li>
<li>路由器端口映射</li>
<li>frp</li>
</ul>
<p>咱们接下来挨个介绍, 首先</p>
<h2 id="第三方软件"><a href="#第三方软件" class="headerlink" title="第三方软件"></a>第三方软件</h2><p>如果你是小白, 追求实用性, 并且想快速上手远程控制, 那么第三方软件无疑是最好的选择, 如果你想用, 那么TeamViewer绝对是首选,个人版免费, 而且可设置无人值守, 只需一个ID和密码就能立马控制远程主机, 速度非常可观 </p>
<p>官网地址: <a href="https://www.teamviewer.cn/cn/" target="_blank" rel="noopener">https://www.teamviewer.cn/cn/</a></p>
<h2 id="路由器端口映射"><a href="#路由器端口映射" class="headerlink" title="路由器端口映射"></a>路由器端口映射</h2><p>如果你不情愿在电脑上装一堆软件, 或者想设置备用控制方案, 那么我建议你使用端口映射的方案, 将公网ip转发到内网需要控制的电脑ip上</p>
<h2 id="frp"><a href="#frp" class="headerlink" title="frp"></a>frp</h2><p>如果你有IT技术功底, 喜欢折腾, 并且有一颗耐操的脑袋, 同时不差钱, 那么我会建议你采用frp方案</p>
<p>详见《<a href="https://code.newban.cn/371.html">使用内网云进行内网穿透实现外网访问局域网中的服务器</a>》</p>
<h2 id="VNC桌面共享"><a href="#VNC桌面共享" class="headerlink" title="VNC桌面共享"></a>VNC桌面共享</h2><p>linux可参考:<a href="https://www.jianshu.com/p/3488968c81cb" target="_blank" rel="noopener">https://www.jianshu.com/p/3488968c81cb</a></p>
<p><strong>本帖附件</strong></p>
<p><a href="https://u21519047.pipipan.com/fs/21519047-395416051" target="_blank" rel="noopener">点击下载</a></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em>乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</em></p>
]]></content>
      <tags>
        <tag>实用技巧</tag>
      </tags>
  </entry>
  <entry>
    <title>右脑记忆法之联想记忆</title>
    <url>/120.html</url>
    <content><![CDATA[<p>严格来说 联想记忆不属于单独的右脑记忆法,由于在联想的过程中,涉及到图像 声音甚至是感觉,</p>
<p>因此 联想记忆更像是一种记忆检测和整理的手段 通过画思维图并且利用联想的手段联想出脑袋中所有的知识 这些知识的载体多种多样 有可能是一幅幅图像 也有可能是一段声音,或者是一阵刺骨的疼痛</p>
<p><strong>联想有检测右脑知识的功能  当然他也有记忆的功能</strong>, 通过联想手段记忆知识的<strong>特点</strong>是:</p>
<p><strong>用已知的知识去联想新的知识,或者说将新知识关联到熟悉的知识上</strong></p>
<p>这也是为什么懂得越多,学得越快</p>
<h2 id="联想记忆重要分为两大种"><a href="#联想记忆重要分为两大种" class="headerlink" title="联想记忆重要分为两大种"></a>联想记忆重要分为两大种</h2><ol>
<li>相似联想</li>
<li>对比联想</li>
</ol>
<h4 id="相似联想"><a href="#相似联想" class="headerlink" title="相似联想"></a>相似联想</h4><p>新事物和脑海中已知事物(图像 声音等等)相似或者接近,类似举一反三</p>
<h4 id="对比联想"><a href="#对比联想" class="headerlink" title="对比联想"></a>对比联想</h4><p>新事物和脑海中已知事物刚好是两个极端,例如水和火</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>联想记忆有</p>
<ul>
<li><p>总结复习和检测右脑知识的功能</p>
</li>
<li><p>快速记忆新知识的功能 (将信息联想于已知事物,可能是相似也可能是对比)</p>
</li>
</ul>
<p><strong>本帖附件</strong></p>
<p><a href="https://u21519047.pipipan.com/fs/21519047-395416051" target="_blank" rel="noopener">点击下载</a></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em>乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</em></p>
]]></content>
      <tags>
        <tag>大脑开发</tag>
      </tags>
  </entry>
  <entry>
    <title>新型冠状病毒肺炎安全防范手册健康宝典口罩选购佩戴正确洗手方式</title>
    <url>/119.html</url>
    <content><![CDATA[<h2 id="基本知识"><a href="#基本知识" class="headerlink" title="基本知识"></a>基本知识</h2><p>对于新型冠状病毒肺炎你需要了解一些基本知识：</p>
<p>　　一、<strong>病毒对外界环境耐受情况</strong>：对热敏感，56℃ 30分钟、75%酒精、含氯消毒剂（比如84消毒液）、过氧化氢消毒液（家庭很少用），氯仿等脂溶剂均可有效灭活病毒</p>
<p>　　二、<strong>传播途径</strong>：飞沫传播—打喷嚏；近距离面对面；接触传播。</p>
<p>　　三、<strong>感染后初期症状</strong>：发热（不一定高热，很多病例最初是低热），乏力，呼吸道症状以干咳为主，并逐渐出现呼吸困难，严重者急性呼吸窘迫综合征、脓毒症休克、难以纠正的代谢性酸中毒和出凝血功能障碍。部分患者起病症状轻微，可无发热。</p>
<p>　　四、<strong>化验检查</strong>：发病早期白细胞总数正常或减低，淋巴细胞计数减少。</p>
<p>　　多数患者C反应蛋白和血沉升高，降钙素原正常。</p>
<p>　　五、<strong>痊愈标准</strong>：体温恢复正常3天以上、呼吸道症状明显好转，连续两次呼吸道病原核酸检测阴性（间隔至少1天），可解除隔离出院或根据病情转至相应科室治疗其他疾病</p>
<p>　　<strong>提醒广大职工、研究生及离退休同志：</strong></p>
<p>　　一、减少外出，减少接触他人的机会</p>
<p>　　二、有接触疑似或者确诊病人史，或者接触过来自疫区人员，从疫区返回人员，应自行居家隔离14天</p>
<p>　　三、减少去生鲜市场，避免传染风险</p>
<p>　　四、外出戴好口罩，最好N95口罩，压好密封条</p>
<p>　　五、勤洗手</p>
<p>　　六、饮食清淡，穿衣适中，增强自身免疫力</p>
<p>​        七、避免在未加防护的情况下接触野生或养殖动物</p>
<p>​        八、少吃野味</p>
<p>　　九、假如出现类似症状，请您戴好口罩及时到发热门诊排查。</p>
<h2 id="口罩分类与选购"><a href="#口罩分类与选购" class="headerlink" title="口罩分类与选购"></a>口罩分类与选购</h2><p> 药店里五花八门的口罩该如何选择？出门是不是一定要佩戴“网红”N95口罩？</p>
<p>市面上常见的口罩可以分为三类：</p>
<p><strong>1.医用外科口罩</strong></p>
<p><strong>2.医用防护口罩（N95口罩）</strong></p>
<p><strong>3.普通棉纱口罩</strong></p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/00811rPngy1gb2snxptnpj30go0go7fb.jpg" alt></p>
<p> 其中医用外科口罩可以阻挡70%的细菌，N95口罩可以阻挡95%的细菌，而棉纱口罩只能阻挡36%的细菌，因此<strong>我们应该选择前两种口罩</strong>。</p>
<h2 id="口罩正确佩戴方法"><a href="#口罩正确佩戴方法" class="headerlink" title="口罩正确佩戴方法"></a>口罩正确佩戴方法</h2><p>  <strong>1.医用外科口罩</strong> </p>
<p>  医用外科口罩有三层，从外到内分别是<strong>防水层、过滤层、舒适层</strong>，舒适层是一层纱布，佩戴时白色的纱布朝内，<strong>蓝色的防水层朝外，有金属片的一边朝上</strong>，不要戴反，橡皮筋挂上双耳后捏紧金属片和鼻子贴合，抚平两颊，使口罩和面部之间尽量不留缝隙。</p>
<h4 id="具体佩戴步骤"><a href="#具体佩戴步骤" class="headerlink" title="具体佩戴步骤"></a>具体佩戴步骤</h4><p><strong>第一步 将口罩罩住鼻、口及下巴，橡皮筋系在双耳后</strong></p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/00811rPngy1gb2sp2ebk2g30hb09r7wi.gif" alt></p>
<p>*<em>第二步. 将双手指尖放在鼻夹上，从中间位置开始，用手指向内按压，并逐步向两侧移动，根据鼻梁形状塑造鼻夹, 调整系带的松紧度 *</em></p>
<p><img src="https://wx1.sinaimg.cn/large/00811rPngy1gb2sqdrhp9g30hb0a31kx.gif" alt="img"></p>
<p>  <strong>2. 医用防护口罩（N95口罩）</strong></p>
<p>  常用的N95口罩实际上分为两种，</p>
<ul>
<li><p>一种是防生物口罩（蓝绿色），型号1860或9132；</p>
</li>
<li><p>一种是防尘口罩（白色），型号8210。</p>
</li>
</ul>
<p>市民在购买时<strong>应选择防生物的医用防护口罩</strong>。佩戴防生物医用防护口罩时，将口罩罩在面部，先将下面的一根橡皮筋固定在脖子上，再将上面一根橡皮筋固定在头上，捏紧金属片，让口罩和面部贴合，不留缝隙。</p>
<h4 id="具体佩戴步骤-1"><a href="#具体佩戴步骤-1" class="headerlink" title="具体佩戴步骤"></a>具体佩戴步骤</h4><p>  <strong>第一步. 一手托住防护口罩，有鼻夹的一面背向外</strong></p>
<p>  <strong>第二步. 将防护口罩罩住鼻、口及下巴，鼻夹部位向上紧贴面部</strong></p>
<p><img src="https://wx3.sinaimg.cn/large/00811rPngy1gb2ssmdeyig30hr0ab1kx.gif" alt="img"></p>
<p>  <strong>第三步. 用另一只手将下方系带拉过头顶，放在颈后双耳下</strong></p>
<p><img src="https://wx4.sinaimg.cn/large/00811rPngy1gb2sw3s8xkg30hb0a3qv5.gif" alt="img"></p>
<p>  <strong>第四步. 再将上方系带拉至头顶中部</strong></p>
<p><img src="https://wx3.sinaimg.cn/large/00811rPngy1gb2ssls2k6g30hb0a3npd.gif" alt="img"></p>
<p>  <strong>第五步. 将双手指尖放在金属鼻夹上，从中间位置开始，用手指向内按鼻夹，并分别向两侧移动和按压，根据鼻梁的形状塑造鼻夹</strong></p>
<p><img src="https://wx4.sinaimg.cn/large/00811rPngy1gb2ssn7e3mg30hb0a3u0x.gif" alt="img"></p>
<h4 id="如果还是不太明白怎么佩戴口罩-以下有相关视频-点击即可跳转播放"><a href="#如果还是不太明白怎么佩戴口罩-以下有相关视频-点击即可跳转播放" class="headerlink" title="如果还是不太明白怎么佩戴口罩 以下有相关视频 点击即可跳转播放"></a>如果还是不太明白怎么佩戴口罩 以下有相关视频 点击即可跳转播放</h4><div align="center">
<a target="_blank" href="https://m.weibo.cn/status/4462861688989407?wm=3333_2001&from=10A1193010&sourcetype=dingding#&video"><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/20200121134433.png" border="0" width="60%"></a>
</div>

<h2 id="正确洗手法"><a href="#正确洗手法" class="headerlink" title="正确洗手法"></a>正确洗手法</h2><p>洗手应该在流动水下进行，取适量洗手液（肥皂），均匀涂抹至整个手掌，认真搓揉双手至少15秒，清洗所有皮肤和指缝，具体步骤有七步：</p>
<p><strong>1. 掌心相对，手指并拢相互揉搓</strong></p>
<p><strong>2. 手心对手背沿指缝互相揉搓，交替进行</strong></p>
<p><strong>3. 掌心相对，双手交叉指缝相互揉搓</strong></p>
<p><strong>4.双手指相扣互搓</strong></p>
<p><strong>5. 弯曲各手指关节在另一只手掌心旋转揉搓，交换进行</strong></p>
<p><strong>6. 一手握另一手大拇指旋转揉搓，交换进行</strong></p>
<p><strong>7. 将五个手指尖并拢放在另一手掌心旋转揉搓，交换进行</strong></p>
<p><strong>最后，在流动水下冲净双手，擦干，擦干宜使用纸巾。</strong></p>
<img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/20200121100247681.jpg" style="zoom:150%;">



<h2 id="家庭预防图解"><a href="#家庭预防图解" class="headerlink" title="家庭预防图解"></a>家庭预防图解</h2><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/48540923dd54564e14de69c8e3618984d3584fc9.jpeg">

<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/3ac79f3df8dcd1002dd6197431345216b8122f66.jpeg" alt></p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/b03533fa828ba61ec87a0781038b820c324e59c9.jpeg" alt></p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/f7246b600c3387447d3e467612b0ccffd62aa002.jpeg" alt></p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/86d6277f9e2f0708e138e8d6aa9bad9fa801f269.jpeg" alt></p>
<p><strong>本帖附件</strong></p>
<p><a href="https://sn9.us/file/21042697-418900652" target="_blank" rel="noopener">点击下载</a></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em>乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</em></p>
]]></content>
      <tags>
        <tag>时事热点</tag>
      </tags>
  </entry>
  <entry>
    <title>如何检测获取到的代理ip是否为高匿ip</title>
    <url>/12.html</url>
    <content><![CDATA[<h2 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h2><p>通过第三方接口检测</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">url = &quot;http://httpbin.org/ip&quot;  # 如果返回的ip里面有本机ip,则证明不是匿名代理</span><br><span class="line">url = &quot;http://httpbin.org/get?show_env=1&quot;  # &quot;origin&quot;对应的value如果是你的本机ip,则不是匿名代理</span><br></pre></td></tr></table></figure>

<p>示例:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 访问http://httpbin.org/ip 返回</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  &quot;origin&quot;: &quot;117.136.0.213&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>和</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 访问http://httpbin.org/get?show_env=1 返回</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  &quot;args&quot;: &#123;</span><br><span class="line">    &quot;show_env&quot;: &quot;1&quot;</span><br><span class="line">  &#125;, </span><br><span class="line">  &quot;headers&quot;: &#123;</span><br><span class="line">    &quot;Accept&quot;: &quot;text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8&quot;, </span><br><span class="line">    &quot;Accept-Encoding&quot;: &quot;gzip, deflate&quot;, </span><br><span class="line">    &quot;Accept-Language&quot;: &quot;zh-CN,zh;q=0.9&quot;, </span><br><span class="line">    &quot;Alexatoolbar-Alx-Ns-Ph&quot;: &quot;AlexaToolbar/alx-4.0.3&quot;, </span><br><span class="line">    &quot;Host&quot;: &quot;httpbin.org&quot;, </span><br><span class="line">    &quot;Upgrade-Insecure-Requests&quot;: &quot;1&quot;, </span><br><span class="line">    &quot;User-Agent&quot;: &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.110 Safari/537.36&quot;, </span><br><span class="line">    &quot;X-Amzn-Trace-Id&quot;: &quot;Root=1-5f5ebcfe-2047fe040ea2d1e594e5b6e0&quot;, </span><br><span class="line">    &quot;X-Forwarded-For&quot;: &quot;117.136.0.213&quot;, </span><br><span class="line">    &quot;X-Forwarded-Port&quot;: &quot;80&quot;, </span><br><span class="line">    &quot;X-Forwarded-Proto&quot;: &quot;http&quot;</span><br><span class="line">  &#125;, </span><br><span class="line">  &quot;origin&quot;: &quot;117.136.0.213&quot;, </span><br><span class="line">  &quot;url&quot;: &quot;http://httpbin.org/get?show_env=1&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>附上网站源码:<a href="https://github.com/postmanlabs/httpbin" target="_blank" rel="noopener">https://github.com/postmanlabs/httpbin</a></p>
<h2 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h2><p>利用某些禁止代理访问的网站进行代理访问测试,比如<a href="http://book.kongfz.com/175804/1038155437/" target="_blank" rel="noopener"><strong>孔夫子旧书网</strong></a></p>
<h4 id="步骤"><a href="#步骤" class="headerlink" title="步骤:"></a>步骤:</h4><p>第一步 先对孔夫子进行高频访问(不使用代理), 直到无法访问为止(说明本机ip已经被禁止)</p>
<p>第二步 换成代理进行访问 如果可以正常访问 则为高匿代理 </p>
<h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import requests</span><br><span class="line">import time</span><br><span class="line">from threading import Thread</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def get_gao_ni_ip(ip, file_save):</span><br><span class="line">    url = &quot;http://book.kongfz.com/175804/1038155437/&quot;</span><br><span class="line">    headers = &#123;</span><br><span class="line">        &apos;Cookie&apos;: &apos;PHPSESSID=0d12c303a92043f13a3cc2c329e444f36b44ef71; shoppingCartSessionId=74c831996eb9a1009d79244d7d915040; kfz_uuid=f53edd56-8938-48af-a447-9a07bde47ffa; reciever_area=1006000000; Hm_lvt_bca7840de7b518b3c5e6c6d73ca2662c=1552367977; Hm_lvt_33be6c04e0febc7531a1315c9594b136=1552367977; kfz_trace=f53edd56-8938-48af-a447-9a07bde47ffa|10072231|834871367e51d410|-; acw_tc=65c86a0a15523697386136416e812159c1e7ce1072aea90b9eb27c93ee05cc; BIGipServerpool_nxtqzj=527099402.24615.0000; Hm_lpvt_bca7840de7b518b3c5e6c6d73ca2662c=1552371456; Hm_lpvt_33be6c04e0febc7531a1315c9594b136=1552371456&apos;,</span><br><span class="line">        &apos;User-Agent&apos;: &apos;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/72.0.3626.121 Safari/537.36&apos;</span><br><span class="line">    &#125;</span><br><span class="line">    proxies = &#123;</span><br><span class="line">        &quot;http&quot;: &quot;http://&quot; + ip,</span><br><span class="line">    &#125;</span><br><span class="line">    try:</span><br><span class="line">        resp = requests.get(url=url, headers=headers, proxies=proxies, timeout=2)</span><br><span class="line">        # print(resp.text)</span><br><span class="line">        if &quot;胡适传论，上&quot; \</span><br><span class="line">           &quot;下。_胡明_孔夫子旧书网&quot; in resp.text:</span><br><span class="line">            print(&quot;ip可用&quot;,ip)</span><br><span class="line">            file_save.write(ip + &apos;\n&apos;)</span><br><span class="line">        else:</span><br><span class="line">            print(&quot;errer&quot;)</span><br><span class="line">    except:</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    start_time = time.time()</span><br><span class="line">    # 储存可用的ip地址</span><br><span class="line">    file_save = open(r&apos;D:\&apos;)</span><br><span class="line"></span><br><span class="line">    with open(r&apos;D:\&apos;, &apos;r&apos;,</span><br><span class="line">              encoding=&apos;utf-8&apos;) as file_ips:</span><br><span class="line">        ips_list = file_ips.readlines()</span><br><span class="line"></span><br><span class="line">    thread_list = []</span><br><span class="line">    total_num = 0</span><br><span class="line">    for ip_one in set(ips_list):</span><br><span class="line">        # 前面携带http的</span><br><span class="line">        ip = ip_one.strip()</span><br><span class="line">        # 直接ip+port的</span><br><span class="line">        thred_ip = Thread(target=get_gao_ni_ip, args=[ip, file_save])</span><br><span class="line">        thread_list.append(thred_ip)</span><br><span class="line">        thred_ip.start()</span><br><span class="line">        total_num += 1</span><br><span class="line">        print(total_num, total_num)</span><br><span class="line">        # 为了是电脑CPU不至于很卡</span><br><span class="line">        time.sleep(0.005)</span><br><span class="line">    for i in thread_list:</span><br><span class="line">        i.join()</span><br><span class="line">    file_save.close()</span><br><span class="line">    end_time = time.time()</span><br><span class="line">    print((end_time - start_time), &apos;秒&apos;)</span><br></pre></td></tr></table></figure>

<h2 id="方法三"><a href="#方法三" class="headerlink" title="方法三"></a>方法三</h2><p> 利用百度搜索关键字 IP，出来的网站的结果，进行爬取，然后利用自己电脑本机ip和request请求响应回来的代理ip进行比较，如果不一样，说明请求的代理IP就是高匿的。</p>
<p><strong>本文为作者原创 转载时请注明出处 谢谢</strong></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em>乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</em></p>
]]></content>
      <tags>
        <tag>免费代理</tag>
      </tags>
  </entry>
  <entry>
    <title>右脑记忆法之图像记忆</title>
    <url>/121.html</url>
    <content><![CDATA[<p><strong>本帖附件</strong></p>
<p><a href="https://u21519047.pipipan.com/fs/21519047-395416051" target="_blank" rel="noopener">点击下载</a></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em>乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</em></p>
]]></content>
      <tags>
        <tag>大脑开发</tag>
      </tags>
  </entry>
  <entry>
    <title>原生app如何跨进程调起微信小程序</title>
    <url>/122.html</url>
    <content><![CDATA[<p><strong>本帖附件</strong></p>
<p><a href="https://u21519047.pipipan.com/fs/21519047-395416051" target="_blank" rel="noopener">点击下载</a></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em>乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</em></p>
]]></content>
      <tags>
        <tag>大前端开发</tag>
      </tags>
  </entry>
  <entry>
    <title>使用nginx部署django项目需要注意的问题</title>
    <url>/123.html</url>
    <content><![CDATA[<h3 id="首先配置nginx-conf文件"><a href="#首先配置nginx-conf文件" class="headerlink" title="首先配置nginx.conf文件"></a>首先配置nginx.conf文件</h3><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="string">worker_processes</span>  <span class="number">1</span><span class="string">;</span></span><br><span class="line"><span class="string">events</span> <span class="string">&#123;</span></span><br><span class="line">        <span class="string">worker_connections</span>  <span class="number">1024</span><span class="string">;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">http&#123;</span></span><br><span class="line">	<span class="string">server&#123;</span></span><br><span class="line">        <span class="string">listen</span> <span class="number">80</span><span class="string">;</span></span><br><span class="line">        <span class="string">server_name</span> <span class="string">py.newban.cn;</span>   <span class="comment">#</span></span><br><span class="line">        <span class="string">root</span> <span class="string">/usr/share/nginx/html/blog;</span></span><br><span class="line">        <span class="string">index</span> <span class="string">index.html;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">server&#123;</span></span><br><span class="line">    <span class="string">listen</span> <span class="number">80</span><span class="string">;</span></span><br><span class="line">    <span class="string">server_name</span> <span class="string">blog.newban.cn;</span>   <span class="comment">#</span></span><br><span class="line">    <span class="string">root</span> <span class="string">/usr/share/nginx/html/blog2;</span></span><br><span class="line">    <span class="string">index</span> <span class="string">index.html;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="comment">#反向代理部分</span></span><br><span class="line"><span class="string">upstream</span> <span class="string">my.blog&#123;</span> <span class="comment">#部署django 名称不能使用下滑线分割比如my_blog 否则报错</span></span><br><span class="line">	<span class="string">server</span> <span class="number">118.10</span><span class="number">.25</span><span class="number">.17</span><span class="string">:8000</span> <span class="string">weight=1;</span></span><br><span class="line">	<span class="comment">#负载均衡 随机访问 权重1：1 各占50%</span></span><br><span class="line">	<span class="string">server</span> <span class="number">118.10</span><span class="number">.25</span><span class="number">.17</span><span class="string">:8001</span>  <span class="string">weight=1;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">server&#123;</span></span><br><span class="line">    <span class="string">listen</span> <span class="number">80</span><span class="string">;</span></span><br><span class="line">    <span class="string">server_name</span> <span class="string">py.insoan.com;</span>   <span class="comment">#</span></span><br><span class="line">	<span class="string">location</span> <span class="string">/</span> <span class="string">&#123;</span></span><br><span class="line">         <span class="string">proxy_pass</span> <span class="attr">http://my.blog;</span></span><br><span class="line">        <span class="string">index</span> <span class="string">index.html;</span></span><br><span class="line">		<span class="string">&#125;</span></span><br><span class="line">	<span class="string">&#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="问题1-DisallowedHost-at"><a href="#问题1-DisallowedHost-at" class="headerlink" title="问题1 DisallowedHost at /"></a>问题1 DisallowedHost at /</h3><p>使用 nginx 部署django时，会出现下面的错误</p>
<ol>
<li>首先使用的域名不符合 RFC 1034/1035.规范时，会出现下面的错误（如包含下划线）</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">DisallowedHost at /Invalid HTTP_HOST header: <span class="string">'learning_log.cent.com'</span>. The domain name provided <span class="keyword">is</span> <span class="keyword">not</span> valid according to RFC <span class="number">1034</span>/<span class="number">1035.</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>解决方式：</li>
</ol>
<p>修改域名，去除下划线，即将 learning_log.cent.com 修改成 llog.cent.com</p>
<ol start="3">
<li>再重新访问出现另外一个错误</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">invalid http_host header</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>解决方式</li>
</ol>
<p>将 setting.py 的 ALLOWED_HOSTS = [] 修改成 ALLOWED_HOSTS = [‘*’]</p>
<p><strong>本文为作者原创 转载时请注明出处 谢谢</strong></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em>乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</em></p>
]]></content>
      <tags>
        <tag>django</tag>
      </tags>
  </entry>
  <entry>
    <title>使用docker部署nginx</title>
    <url>/124.html</url>
    <content><![CDATA[<h2 id="部署nginx"><a href="#部署nginx" class="headerlink" title="部署nginx"></a>部署nginx</h2><ol>
<li>搜索nginx镜像</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker search nginx</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>拉取nginx镜像</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker pull nginx</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>创建容器 设置端口映射</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 在/root目录下创建nginx目录用于存储nginx数据信息</span><br><span class="line">mkdir ~/nginx</span><br><span class="line">cd ~/nginx</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>创建<code>nginx</code>配置文件 否则下一步会报错</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mkdir conf</span><br><span class="line">cd conf</span><br><span class="line">touch nginx.conf</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>在<code>nginx.conf</code>配置文件中添加以下配置信息（如果配置信息不对会导致无法正常启动）</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">worker_processes  1;</span><br><span class="line">events &#123;</span><br><span class="line">        worker_connections  1024;</span><br><span class="line">&#125;</span><br><span class="line">http&#123;</span><br><span class="line">server&#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    server_name your_server_name;   #erverName</span><br><span class="line">    root /usr/share/nginx/html;</span><br><span class="line">    index index.html;</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="6">
<li>创建并运行容器</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run -id \</span><br><span class="line">-p 80:80 \</span><br><span class="line">--name=c_nginx \</span><br><span class="line">-h c_nginx \</span><br><span class="line">-v $PWD/conf/nginx.conf:/etc/nginx/nginx.conf \</span><br><span class="line">-v $PWD/logs:/var/log/nginx \</span><br><span class="line">-v $PWD/html:/usr/share/nginx/html \</span><br><span class="line">nginx:latest</span><br></pre></td></tr></table></figure>

<ul>
<li>参数说明<ul>
<li><strong>-p 80：80 将容器的80端口映射到主机的80端口</strong></li>
<li><strong>-v $PWD/conf/nginx.conf:/etc/nginx/nginx.conf <br>-v $PWD/logs:/var/log/nginx <br>-v $PWD/html:/usr/share/nginx/html \ 将主机中当前目录挂载到容器</strong></li>
<li><strong>-h 设置容器的hostname</strong> </li>
<li><strong>$PWD表示当前所在目录</strong></li>
<li><strong>–name</strong>:表示容器别名, 但凡是两个杠都需要带=</li>
</ul>
</li>
</ul>
<h4 id="关于配置文件的修改"><a href="#关于配置文件的修改" class="headerlink" title="关于配置文件的修改"></a>关于配置文件的修改</h4><p>配置文件一旦修改需要重启<code>nginx</code>才生效,  重启前建议提前测试一下配置文件语法是否存在问题, 可以进入容器中, 执行以下指令进行测试:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nginx -t</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20220920144752833.png" alt="image-20220920144752833"></p>
<p>除了借助<code>docker</code>重启容器外, 还可以在容器内部直接执行<code>nginx</code>指令实现重载:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nginx -s reload</span><br></pre></td></tr></table></figure>

<h4 id="附带配置文件内容参考"><a href="#附带配置文件内容参考" class="headerlink" title="附带配置文件内容参考"></a>附带配置文件内容参考</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#主模块指令，指定Nginx Worker进程运行用户以及用户组</span><br><span class="line">user  nginx;</span><br><span class="line">#主模块指令，指定Nginx要开启的进程数，建议设置成和cpu的数量相等</span><br><span class="line">worker_processes  1;</span><br><span class="line">#主模块指令，定义全局错误日志文件；日志级别：debug、info、notice、warn、error、crit</span><br><span class="line">error_log  /var/log/nginx/error.log warn;</span><br><span class="line">#主模块指令，指定进程pid的存储文件位置</span><br><span class="line">pid        /var/run/nginx.pid;</span><br><span class="line">#事件指令，设定Nginx的工作模式及连接数上限</span><br><span class="line">events &#123;</span><br><span class="line">    #指定Nginx的工作模式；Nginx工作模式：select、poll、kqueue、epoll、rtsig和/dev/poll</span><br><span class="line">    use  epoll; #epoll工作模式是首选</span><br><span class="line">    #定义Nginx每个进程的最大连接数，默认是1024</span><br><span class="line">    worker_connections  1024;</span><br><span class="line">&#125;</span><br><span class="line">#HTTP服务器配置</span><br><span class="line">http &#123;</span><br><span class="line">    #主模块指令，实现对配置文件所包含的文件的设定，可以减少主配置文件的复杂度</span><br><span class="line">    include       mime.types;</span><br><span class="line">    #HTTP核心模块指令，默认类型为二进制流</span><br><span class="line">    default_type  application/octet-stream;</span><br><span class="line">    #设定日志格式</span><br><span class="line">    log_format  main  &apos;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &apos;</span><br><span class="line">                      &apos;$status $body_bytes_sent &quot;$http_referer&quot; &apos;</span><br><span class="line">                      &apos;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&apos;;</span><br><span class="line">    #定义全局的日志文件</span><br><span class="line">    access_log  /var/log/nginx/access.log  main;</span><br><span class="line">    #指定Nginx是否调用sendfile函数（zero copy方式）来输出文件，对于普通应用，必须设为on,</span><br><span class="line">    #注：如果用来进行下载等应用磁盘IO重负载应用，可设置为off，以平衡磁盘与网络I/O处理速度，降低系统的uptime.</span><br><span class="line">    sendfile        on;</span><br><span class="line">    #防止网络阻塞</span><br><span class="line">    #tcp_nopush     on;</span><br><span class="line">    #连接超时时间</span><br><span class="line">    keepalive_timeout  65;</span><br><span class="line"> </span><br><span class="line">一、Web服务器</span><br><span class="line">------------------------------------------------------------------------------------------------</span><br><span class="line">    #server虚拟主机配置</span><br><span class="line">    server &#123;</span><br><span class="line">        #监听端口号</span><br><span class="line">        listen       80;</span><br><span class="line">        #域名：可有多个，支持种类：通配符名称、正则表达式名称、IP、localhost、其他(_、@)</span><br><span class="line">        server_name  *.example.org;</span><br><span class="line">                     ~^(www\.)?(.+)$;</span><br><span class="line">                     101.200.149.141;</span><br><span class="line">                     ...</span><br><span class="line">                     localhost;</span><br><span class="line">                     _;</span><br><span class="line">        #location URL匹配配置</span><br><span class="line">		#配置根目录转发到本机目录位置</span><br><span class="line">		location / &#123;</span><br><span class="line">            root /usr/share/nginx/project_1/dist;</span><br><span class="line">            index index.html index.htm;  # 主页现寻找index.html，如果没有index.html，再寻找index.htm</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        error_page 404 /404.html;</span><br><span class="line"> </span><br><span class="line">        location = /40x.html &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        error_page 500 502 503 504 /50x.html;</span><br><span class="line"> </span><br><span class="line">        location = /50x.html &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">二、反向代理（配置SSL证书，http转发到https）</span><br><span class="line">------------------------------------------------------------------------------------------------</span><br><span class="line">   #web-http</span><br><span class="line">    server &#123;</span><br><span class="line">        listen       80;</span><br><span class="line">        server_name  www.xxxxxx.com;</span><br><span class="line">        rewrite ^(.*)$ https://$&#123;server_name&#125;$1 permanent;#将80端口的访问转发到443端口</span><br><span class="line">    &#125;</span><br><span class="line">    #web-https</span><br><span class="line">    server &#123;</span><br><span class="line">        listen       443 ssl;</span><br><span class="line">        server_name  www.xxxxxx.com;</span><br><span class="line">        #ssl on;  #需要注释，命令过时（1.15.0版本以后）</span><br><span class="line">        #配置证书的路径</span><br><span class="line">        ssl_certificate   cert/2547204_www.xxxxxx.com.pem; #使用相对路线，放在nginx目录下，绝对路径报错</span><br><span class="line">        ssl_certificate_key  cert/2547204_www.xxxxxx.com.key;</span><br><span class="line">        #ssl_session_cache    shared:SSL:1m;</span><br><span class="line">        ssl_session_timeout  10m;</span><br><span class="line"> </span><br><span class="line">		#配置根目录转发到相应端口(例，82端口）使用单机服务</span><br><span class="line">        location / &#123;</span><br><span class="line">            proxy_pass http://172.241.27.9:82; #nginx and tomcat 在同一台机器，使用http链接</span><br><span class="line">            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">            proxy_set_header X-Forwarded-Proto $scheme;</span><br><span class="line">            proxy_set_header X-Forwarded-Port $server_port;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        error_page 404 /404.html;</span><br><span class="line">		</span><br><span class="line">        location = /40x.html &#123;</span><br><span class="line">		</span><br><span class="line">        &#125;</span><br><span class="line">        error_page 500 502 503 504 /50x.html;</span><br><span class="line"> </span><br><span class="line">        location = /50x.html &#123;</span><br><span class="line">		</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">三、负载均衡</span><br><span class="line">------------------------------------------------------------------------------------------------</span><br><span class="line">    #设定负载均衡的服务器列表</span><br><span class="line">    #1.轮询（默认）：</span><br><span class="line">    #每个请求按时间顺序逐一分配到不同的后端服务器，如果某台服务器宕机将被自动剔除，使用户访问不受影响</span><br><span class="line">    upstream myapp1 &#123;</span><br><span class="line">        #i.down表示当前的server暂时不参与负载均衡；</span><br><span class="line">        server 192.168.8.1:28 down;</span><br><span class="line">        #ii.backup：预留的备份机器。</span><br><span class="line">        server 192.168.8.2:80 backup;</span><br><span class="line">        server 192.168.8.3:80;</span><br><span class="line">    &#125;</span><br><span class="line">    #2.Weight权重：</span><br><span class="line">    #指定轮询权值，Weight值越大，分配到的访问机率越高，主要用于后端每个服务器性能不均的情况下</span><br><span class="line">    upstream myapp2 &#123;</span><br><span class="line">        server 192.168.8.1:28 weight=5;</span><br><span class="line">        server 192.168.8.2:80  weight=1;</span><br><span class="line">        server 192.168.8.3:80  weight=6;</span><br><span class="line">    &#125;</span><br><span class="line">    #3.ip_hash：</span><br><span class="line">    #每个请求按访问IP的hash结果分配，自同一个IP的访客固定访问一个后端服务器，有效解决了动态网页存在的session共享问题；</span><br><span class="line">    upstream myapp3 &#123;</span><br><span class="line">        ip_hash;</span><br><span class="line">        server 192.168.8.1:28;</span><br><span class="line">        server 192.168.8.2:80;</span><br><span class="line">        #iii.max_fails允许请求失败的次数，默认1。当超过最大次数时，返回proxy_next_upstream 模块定义的错误；</span><br><span class="line">        #iv.fail_timeout在经历了max_fails次失败后，暂停服务的时间。max_fails可以和fail_timeout一起使用。</span><br><span class="line">        server 192.168.8.3:80  max_fails=6 fail_timeout=20s;</span><br><span class="line">        server 192.168.8.4:80;</span><br><span class="line">    &#125;</span><br><span class="line">    #4.fair：更加智能的负载均衡算法。依据页面大小和加载时间长短智能地进行负载均衡，根据后端服务器的响应时间来分配请求，响应时间短的优先分配。</span><br><span class="line">    #  注：Nginx本身是不支持fair，如果需要使用这种调度算法，必须下载Nginx的upstream_fair模块。</span><br><span class="line">    #5.url_hash：按访问url的hash结果来分配请求，使每个url定向到同一个后端服务器，可以进一步提高后端缓存服务器的效率。</span><br><span class="line">    #  注：Nginx本身是不支持url_hash，如果需要使用这种调度算法，必须安装Nginx的hash软件包。</span><br><span class="line"> </span><br><span class="line">    server &#123;</span><br><span class="line">        listen 80;</span><br><span class="line">        server_name  www.hanxiaozhang.xyz;</span><br><span class="line">        location / &#123;</span><br><span class="line">            proxy_pass http://myapp1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><p>如果对<code>Nginx</code>配置文件进行了修改操作, 需要重启<code>Nginx</code>容器才能生效</p>
<p><strong>本文为作者原创 转载时请注明出处 谢谢</strong></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em>乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</em></p>
]]></content>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql百万数据字符串匹配查询速度优化之覆盖索引法</title>
    <url>/126.html</url>
    <content><![CDATA[<h2 id="什么是“索引覆盖”？"><a href="#什么是“索引覆盖”？" class="headerlink" title="什么是“索引覆盖”？"></a>什么是“索引覆盖”？</h2><p>简单来的说，就是让查询的字段（包括where子句中的字段），都是索引字段。索引覆盖的好处是什么？好处是极大的、极大的、极大的提高查询的效率！重要的说三遍！</p>
<p><strong>特别说明：</strong></p>
<ol>
<li>where条件中如果使用like关键词，即使字段是索引中的，也不构成索引覆盖。</li>
<li>单个字段的索引，对于搜索单个where条件有较好的效果。但索引覆盖需要使用多字列索引。</li>
</ol>
<p>假设创建一个zaho_user表：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> CREATE TABLE `zaho_user` (</span><br><span class="line"> `u_id` int(11) NOT NULL AUTO_INCREMENT,</span><br><span class="line"> `insert_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP,</span><br><span class="line"> `u_name` varchar(20) NOT NULL DEFAULT &apos;&apos; COMMENT &apos;用户名&apos;,</span><br><span class="line"> `u_sex` tinyint(4) NOT NULL DEFAULT &apos;1&apos; COMMENT &apos;性别&apos;,</span><br><span class="line"> `u_desc` varchar(200) NOT NULL DEFAULT &apos;&apos; COMMENT &apos;介绍&apos;</span><br><span class="line">) ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8 COMMENT &apos;用户表&apos;;</span><br></pre></td></tr></table></figure>

<p>这里我们创建一个索引：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">alter table `zaho_user` add index (`u_name`,`insert_time`,`u_sex`);</span><br></pre></td></tr></table></figure>

<p>那么，我们执行如下查询时，效率将会非常高：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select `u_name`,`insert_time` from `zaho_user` where `u_sex`=1</span><br></pre></td></tr></table></figure>

<p>例子中的三个字段：<code>u_name</code>,<code>insert_time</code>,<code>u_sex</code>创建了一个多列索引，而SQL查询时形成了索引覆盖。 在百万数据量匹配查询时速度提升非常可观</p>
<h3 id="网站速度优化"><a href="#网站速度优化" class="headerlink" title="网站速度优化"></a>网站速度优化</h3><p>为什么网站访问很慢, 想优化可以参考以下方式, 优先级由高到低:</p>
<ol>
<li><strong>数据库位置优化 (优先采用内网访问而非外网)</strong></li>
<li><strong>硬盘优化 (优先固态硬盘)</strong></li>
<li><strong>SQL语句优化</strong></li>
<li><strong>服务器硬件和外网带宽升级</strong></li>
<li><strong>应用代码优化</strong></li>
<li><strong>定期重启mysql 连接优化 (亲测效果明显)</strong> </li>
</ol>
<h3 id="网站维护记录"><a href="#网站维护记录" class="headerlink" title="网站维护记录"></a>网站维护记录</h3><p>本人有一个博客采集站, 内置文章3万左右, 访问和渲染速度非常快, 后来爬取文章增量到6万左右, 感觉网站速度明显变慢, 起初以为是内容过多导致, 可是也才6万就这么慢了那百万数据岂不没法玩了</p>
<p>我甚至在想 可能是服务器配置以及博客程序有限导致的 也没再管它</p>
<p>直到有一天 数据库容器挂了 , 重启数据库后, 网站恢复访问, 速度竟惊人地变快, 和最开始没两样, 于是乎我否断了之前的猜测, 之前速度慢有可能仅仅是数据库连接过多 垃圾缓存导致的</p>
<p>因此 定期重启数据库 似乎可以纳入我的定时任务计划中 </p>
<p><strong>本文为作者原创 转载时请注明出处 谢谢</strong></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em>乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</em></p>
]]></content>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>docker部署Django项目</title>
    <url>/125.html</url>
    <content><![CDATA[<h1 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h1><p>已经写好了一个Django项目，需要将这个项目用docker封装一个镜像，使用k8s发布！</p>
<p>在封装并运行的过程中，发现了很多问题，这里会一一介绍！</p>
<h1 id="二、时区问题"><a href="#二、时区问题" class="headerlink" title="二、时区问题"></a>二、时区问题</h1><p>采用的是镜像是 ubuntu:16.04 默认的时区是UTC，比中国时间，晚了8个小时！</p>
<p>那么因此，需要将默认的时区给覆盖掉！</p>
<p>默认是没有安装 tzdata，因此没有 /usr/share/zoneinfo 目录！</p>
<p>安装tzdata，使用命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apt-get install -y tzdata</span><br></pre></td></tr></table></figure>

<p> 设置时区为 上海，使用以下命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">TZ=Asia/Shanghai</span><br><span class="line">ln -snf /usr/share/zoneinfo/$TZ /etc/localtime &amp;&amp; echo $TZ &gt; /etc/timezone</span><br></pre></td></tr></table></figure>

<h1 id="三、中文乱码问题"><a href="#三、中文乱码问题" class="headerlink" title="三、中文乱码问题"></a>三、中文乱码问题</h1><p>默认的系统编码是ascii，因此不支持中文！</p>
<p>需要安装 locales 软件包</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apt-get install -y locales</span><br></pre></td></tr></table></figure>

<p>设置utf-8编码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">locale-gen en_US.UTF-8</span><br></pre></td></tr></table></figure>

<p>设置全局变量</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">LANG en_US.UTF-8</span><br><span class="line">LANGUAGE en_US:en</span><br><span class="line">LC_ALL en_US.UTF-8</span><br></pre></td></tr></table></figure>

<p>设置utf-8编码之后，那么在python的print命令，就可以输出中文了，而不会提示</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&apos;ascii&apos; codec can&apos;t encode characters in position 8-50: ordinal not in range(128)</span><br></pre></td></tr></table></figure>

<p>在python文件头部，记得增加一行代码，指定utf-8编码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># coding: utf-8</span><br></pre></td></tr></table></figure>

<h1 id="四、任务计划问题"><a href="#四、任务计划问题" class="headerlink" title="四、任务计划问题"></a>四、任务计划问题</h1><h2 id="启动问题"><a href="#启动问题" class="headerlink" title="启动问题"></a>启动问题</h2><p>在ubuntu:16.04 的镜像中，默认是没有cron包的，所以需要手动安装</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apt-get install -y cron</span><br></pre></td></tr></table></figure>

<p>那么启动任务计划时，不能使用命令 /etc/init.d/cron start 以及 service cron start</p>
<p>在dockerfile中，会启动不成功的。</p>
<p><strong>必须使用 /usr/sbin/cron 命令，才能启动成功！</strong></p>
<h2 id="添加问题"><a href="#添加问题" class="headerlink" title="添加问题"></a>添加问题</h2><p>一般来讲，添加任务计划，直接修改 /etc/crontab 文件即可。</p>
<p>在dockerfile 中，不能使用echo EOF 等命令修改/etc/crontab文件</p>
<p><strong>必须使用 sed 命令修改/etc/crontab文件，才能成功！</strong></p>
<p>如果需要在最后一行添加任务计划，可以使用以下命令：</p>
<p>语法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sed -i &apos;$a需要添加的内容&apos; 文件名</span><br></pre></td></tr></table></figure>

<p>比如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sed -i &apos;$a* * * * * root python3 /messagecenter/cron/voc_receipt.py&apos; /etc/crontab</span><br></pre></td></tr></table></figure>

<h1 id="五、封装Django项目镜像"><a href="#五、封装Django项目镜像" class="headerlink" title="五、封装Django项目镜像"></a>五、封装Django项目镜像</h1><p> 新建空目录</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mkdir /opt/messagecenter</span><br></pre></td></tr></table></figure>

<p>目录结构如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">./</span><br><span class="line">├── dockerfile</span><br><span class="line">├── messagecenter.tar</span><br><span class="line">├── run.sh</span><br><span class="line">└── sources.list</span><br></pre></td></tr></table></figure>

<p><strong>dockerfile</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">FROM ubuntu:16.04</span><br><span class="line"># 修改更新源为阿里云</span><br><span class="line">ADD sources.list /etc/apt/sources.list</span><br><span class="line">ADD messagecenter.tar /</span><br><span class="line"># 时区为上海</span><br><span class="line">ENV TZ Asia/Shanghai</span><br><span class="line"></span><br><span class="line"># 设置时区,设置utf-8编码,安装django,添加任务计划</span><br><span class="line">RUN apt-get update &amp;&amp; apt-get install -y tzdata locales python3-pip cron &amp;&amp; apt-get clean all &amp;&amp; \</span><br><span class="line">    ln -snf /usr/share/zoneinfo/$TZ /etc/localtime &amp;&amp; echo $TZ &gt; /etc/timezone &amp;&amp; \</span><br><span class="line">    locale-gen en_US.UTF-8 &amp;&amp; \</span><br><span class="line">    pip3 install django requests</span><br><span class="line"></span><br><span class="line"># 解决中文乱码问题</span><br><span class="line">#RUN locale-gen en_US.UTF-8</span><br><span class="line">ENV LANG en_US.UTF-8</span><br><span class="line">ENV LANGUAGE en_US:en</span><br><span class="line">ENV LC_ALL en_US.UTF-8</span><br><span class="line"></span><br><span class="line">EXPOSE 8000</span><br><span class="line"># 添加启动脚本</span><br><span class="line">ADD run.sh .</span><br><span class="line">RUN chmod 755 run.sh</span><br><span class="line">ENTRYPOINT [ &quot;/run.sh&quot;]</span><br></pre></td></tr></table></figure>

<p><strong>messagecenter.tar</strong> 这个是Django项目，已经打成tar包了。在dockerfile中，执行ADD命令时，会自动解压tar包</p>
<p><strong>run.sh</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"></span><br><span class="line"># 启动任务计划</span><br><span class="line">/usr/sbin/cron</span><br><span class="line"></span><br><span class="line"># 最后一行增加任务计划</span><br><span class="line">sed -i &apos;$a* * * * * root python3 /messagecenter/cron/voc_receipt.py&apos; /etc/crontab</span><br><span class="line"></span><br><span class="line"># 启动django项目</span><br><span class="line">cd /messagecenter/</span><br><span class="line">python3 manage.py runserver 0.0.0.0:8000</span><br></pre></td></tr></table></figure>

<p>在Django项目中，有一个python脚本，需要每分钟执行一次！</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">deb http://mirrors.aliyun.com/ubuntu/ xenial main restricted</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ xenial-updates main restricted</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ xenial universe</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ xenial-updates universe</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ xenial multiverse</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ xenial-updates multiverse</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ xenial-backports main restricted universe multiverse</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu xenial-security main restricted</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu xenial-security universe</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu xenial-security multiverse</span><br></pre></td></tr></table></figure>

<p>生成镜像</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker build -t messagecenter /opt/messagecenter</span><br></pre></td></tr></table></figure>

<p>启动镜像</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run -d -it -p 8000:8000 messagecenter</span><br></pre></td></tr></table></figure>

<p>访问页面：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http://192.168.0.162:8000</span><br></pre></td></tr></table></figure>

<p>就可以访问Django的默认页面了！</p>
<p><strong>本文为作者原创 转载时请注明出处 谢谢</strong></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em>乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</em></p>
]]></content>
      <tags>
        <tag>django</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL8.0登录提示caching_sha2_password问题解决方法</title>
    <url>/128.html</url>
    <content><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>用docker构建mysql容器后连接遇到以下问题</p>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Authentication plugin &apos;caching_sha2_password&apos; cannot be loaded: dlopen(/usr/local/mysql/lib/plugin/caching_sha2_password.so, 2): image not found</span><br><span class="line">1</span><br><span class="line">mysqli_real_connect(): The server requested authentication method unknown to the client [caching_sha2_password]</span><br><span class="line">1</span><br><span class="line">mysqli_real_connect(): (HY000/2054): The server requested authentication method unknown to the client</span><br><span class="line">1</span><br></pre></td></tr></table></figure>

<p><a href="https://mysqlserverteam.com/mysql-8-0-4-new-default-authentication-plugin-caching_sha2_password/" target="_blank" rel="noopener">MySQL官方说明</a></p>
<h2 id="解决方法1-docker"><a href="#解决方法1-docker" class="headerlink" title="解决方法1(docker)"></a>解决方法1(docker)</h2><h4 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h4><ol>
<li>第一次构建容器/安装</li>
<li>已安装完成后新增用户</li>
</ol>
<h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><p>配置 <strong>mysql.cnf</strong> 配置默认身份验证插件</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="section">[mysqld]</span></span><br><span class="line"><span class="attr">default_authentication_plugin</span> = mysql_native_password</span><br><span class="line">12</span><br></pre></td></tr></table></figure>

<h4 id="验证是否生效"><a href="#验证是否生效" class="headerlink" title="验证是否生效"></a>验证是否生效</h4><p>使用CLI进入MySQL</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> mysql -u root -p</span></span><br><span class="line">1</span><br><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> use mysql;</span></span><br><span class="line">Reading table information for completion of table and column names</span><br><span class="line">You can turn off this feature to get a quicker startup with -A</span><br><span class="line"></span><br><span class="line">Database changed</span><br><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> SELECT Host, User, plugin from user;</span></span><br><span class="line">+-----------+------------------+-----------------------+</span><br><span class="line">| Host      | User             | plugin                |</span><br><span class="line">+-----------+------------------+-----------------------+</span><br><span class="line">| %         | root             | mysql_native_password |</span><br><span class="line">| localhost | mysql.infoschema | caching_sha2_password |</span><br><span class="line">| localhost | mysql.session    | caching_sha2_password |</span><br><span class="line">| localhost | mysql.sys        | caching_sha2_password |</span><br><span class="line">| localhost | root             | mysql_native_password |</span><br><span class="line">+-----------+------------------+-----------------------+</span><br><span class="line">5 rows in set (0.00 sec)</span><br><span class="line">12345678910111213141516</span><br></pre></td></tr></table></figure>

<p>root用户的身份验证器插件已经变为：<strong>mysql_native_password</strong></p>
<h2 id="解决方法2"><a href="#解决方法2" class="headerlink" title="解决方法2"></a>解决方法2</h2><h4 id="适用场景-1"><a href="#适用场景-1" class="headerlink" title="适用场景"></a>适用场景</h4><ol>
<li><strong>MySQL</strong> 已成功安装完成后</li>
</ol>
<h4 id="查看身份验证类型"><a href="#查看身份验证类型" class="headerlink" title="查看身份验证类型"></a>查看身份验证类型</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; use mysql;</span><br><span class="line">Database changed</span><br><span class="line"></span><br><span class="line">mysql&gt; SELECT Host, User, plugin from user;</span><br><span class="line">+-----------+------------------+-----------------------+</span><br><span class="line">| Host      | User             | plugin                |</span><br><span class="line">+-----------+------------------+-----------------------+</span><br><span class="line">| %         | root             | caching_sha2_password |</span><br><span class="line">| localhost | mysql.infoschema | caching_sha2_password |</span><br><span class="line">| localhost | mysql.session    | caching_sha2_password |</span><br><span class="line">| localhost | mysql.sys        | caching_sha2_password |</span><br><span class="line">| localhost | root             | caching_sha2_password |</span><br><span class="line">+-----------+------------------+-----------------------+</span><br><span class="line">5 rows in set (0.00 sec)</span><br><span class="line">1234567891011121314</span><br></pre></td></tr></table></figure>

<p><code>root</code> 用户的验证器插件为 <strong>caching_sha2_password</strong></p>
<h4 id="修改身份验证类型-修改密码"><a href="#修改身份验证类型-修改密码" class="headerlink" title="修改身份验证类型(修改密码)"></a>修改身份验证类型(修改密码)</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; ALTER USER &apos;root&apos;@&apos;%&apos; IDENTIFIED WITH mysql_native_password BY &apos;123456&apos;;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; ALTER USER &apos;root&apos;@&apos;localhost&apos; IDENTIFIED WITH mysql_native_password BY &apos;123456&apos;;</span><br><span class="line">Query OK, 0 rows affected (0.01 sec)</span><br><span class="line">12345</span><br></pre></td></tr></table></figure>

<h4 id="使生效"><a href="#使生效" class="headerlink" title="使生效"></a>使生效</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; FLUSH PRIVILEGES;</span><br><span class="line">1</span><br></pre></td></tr></table></figure>

<h4 id="验证是否生效-1"><a href="#验证是否生效-1" class="headerlink" title="验证是否生效"></a>验证是否生效</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT Host, User, plugin from user;</span><br><span class="line">+-----------+------------------+-----------------------+</span><br><span class="line">| Host      | User             | plugin                |</span><br><span class="line">+-----------+------------------+-----------------------+</span><br><span class="line">| %         | root             | mysql_native_password |</span><br><span class="line">| localhost | mysql.infoschema | caching_sha2_password |</span><br><span class="line">| localhost | mysql.session    | caching_sha2_password |</span><br><span class="line">| localhost | mysql.sys        | caching_sha2_password |</span><br><span class="line">| localhost | root             | mysql_native_password |</span><br><span class="line">+-----------+------------------+-----------------------+</span><br><span class="line">5 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em>乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</em></p>
]]></content>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>使用docker部署wordpress</title>
    <url>/127.html</url>
    <content><![CDATA[<h2 id="部署wordpress"><a href="#部署wordpress" class="headerlink" title="部署wordpress"></a>部署wordpress</h2><ol>
<li>搜索wordpress镜像</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker search wordpress</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>拉取wordpress镜像</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker pull wordpress</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>使用Nginx进行反向代理</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http&#123;</span><br><span class="line">upstream wordpress_sex&#123;</span><br><span class="line">server 119.33.15.174:7778;</span><br><span class="line">&#125;</span><br><span class="line">server&#123;</span><br><span class="line">        listen       80;</span><br><span class="line">    server_name sex.newban.cn;</span><br><span class="line">    location / &#123;</span><br><span class="line">            proxy_redirect off;</span><br><span class="line">            proxy_set_header Host $host;</span><br><span class="line">            proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line">            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">            proxy_pass http://wordpress_sex;</span><br><span class="line">            break;</span><br><span class="line">                 &#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ol start="4">
<li>创建并运行容器</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run -id \</span><br><span class="line">--name=wordpress_sex \</span><br><span class="line">-p 7778:80 \</span><br><span class="line">-h wordpress_sex \</span><br><span class="line">-v /root/songjian/wordpress/sex_www:/var/www/html \</span><br><span class="line">-e WORDPRESS_DB_HOST=119.33.15.174:3306 \</span><br><span class="line">-e WORDPRESS_DB_USESR=root \</span><br><span class="line">-e WORDPRESS_DB_PASSWORD=songjian \</span><br><span class="line">-e WORDPRESS_DB_NAME=wordpress_sex \</span><br><span class="line">-d wordpress:latest</span><br></pre></td></tr></table></figure>

<h4 id="参数说明"><a href="#参数说明" class="headerlink" title="参数说明"></a>参数说明</h4><ul>
<li><p><strong>WORDPRESS_DB_HOST</strong>         数据库主机地址（默认为与其 link 的 mysql 容器的 IP 和 3306 端口：）</p>
</li>
<li><p><strong>WORDPRESS_DB_USER</strong>         数据库用户名（默认为 root）</p>
</li>
<li><p><strong>WORDPRESS_DB_PASSWORD</strong>     数据库密码（默认为与其 link 的 mysql 容器提供的 MYSQL_ROOT_PASSWORD 变量的值）</p>
</li>
<li><p><strong>WORDPRESS_DB_NAME</strong>         数据库名（默认为 wordpress）</p>
</li>
<li><p><strong>WORDPRESS_TABLE_PREFIX</strong>     数据库表名前缀（默认为空，您可以从该变量覆盖 wp-config.php 中的配置）</p>
<p><strong>如果 WORDPRESS_DB_NAME 变量指定的数据库不存在时，那么 wordpress容器在启动时就会自动尝试创建该数据库，</strong></p>
</li>
</ul>
<p><strong>本文为作者原创 转载时请注明出处 谢谢</strong></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em>乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</em></p>
]]></content>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>怎样修改Wordpress地址和站点地址怎样改回IP地址</title>
    <url>/130.html</url>
    <content><![CDATA[<h2 id="wordpress搭建后地址栏页面显示IP地址的问题"><a href="#wordpress搭建后地址栏页面显示IP地址的问题" class="headerlink" title="wordpress搭建后地址栏页面显示IP地址的问题"></a>wordpress搭建后地址栏页面显示IP地址的问题</h2><h3 id="如果可以登录wordpress后台管理面板"><a href="#如果可以登录wordpress后台管理面板" class="headerlink" title="如果可以登录wordpress后台管理面板"></a>如果可以登录wordpress后台管理面板</h3><p>1.先点击wordpress右边的小房子图标</p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20200930112809.png" alt> </p>
<p>2.点击仪表盘图片进入仪表盘菜单</p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20200930112830.png" alt></p>
<p>3.点击设置，进入设置界面，找到WordPress地址（URL）和站点地址（URL）所对应的ip地址，如下图</p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20200930112846.png" alt></p>
<p>4.将ip地址更改为你网站的域名，之后保存，如下图</p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20200930112859.png" alt></p>
<p>5.清空浏览器的缓存，之后用域名访问网站，就不会在地址栏出现ip地址了。</p>
<h3 id="如果无法登陆wordpress"><a href="#如果无法登陆wordpress" class="headerlink" title="如果无法登陆wordpress"></a>如果无法登陆wordpress</h3><p>那么需要修改数据库 如图</p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/%E6%8D%95%E8%8E%B72.PNG" alt></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/%E6%8D%95%E8%8E%B7.PNG" alt></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/%E6%8D%95%E8%8E%B72.PNG" alt><br><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/%E6%8D%95%E8%8E%B7.PNG" alt></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em>乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</em></p>
]]></content>
      <tags>
        <tag>wordpress</tag>
      </tags>
  </entry>
  <entry>
    <title>全球免费代理获取接口api</title>
    <url>/13.html</url>
    <content><![CDATA[<h1 id="免费代理IP库"><a href="#免费代理IP库" class="headerlink" title="免费代理IP库"></a>免费代理IP库</h1><h3 id="警告"><a href="#警告" class="headerlink" title="警告"></a>警告</h3><p>代理IP采集于网络，仅供个人学习使用。请勿用于非法途径，违者后果自负！</p>
<h3 id="获取一个验证通过的代理IP"><a href="#获取一个验证通过的代理IP" class="headerlink" title="获取一个验证通过的代理IP"></a>获取一个验证通过的代理IP</h3><ul>
<li>URL: <a href="https://ip.jiangxianli.com/api/proxy_ip" target="_blank" rel="noopener">https://ip.jiangxianli.com/api/proxy_ip</a></li>
<li>响应数据</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;code&quot;:0,</span><br><span class="line">    &quot;msg&quot;:&quot;成功&quot;,</span><br><span class="line">    &quot;data&quot;:&#123;</span><br><span class="line">        &quot;unique_id&quot;:&quot;ad0611edba534fd2c39a36d77e383cfb&quot;,</span><br><span class="line">        &quot;ip&quot;:&quot;118.193.107.80&quot;,</span><br><span class="line">        &quot;port&quot;:&quot;80&quot;,</span><br><span class="line">        &quot;ip_address&quot;:&quot;北京市 北京市&quot;,</span><br><span class="line">        &quot;anonymity&quot;:0,</span><br><span class="line">        &quot;protocol&quot;:&quot;http&quot;,</span><br><span class="line">        &quot;isp&quot;:&quot;电信&quot;,</span><br><span class="line">        &quot;speed&quot;:375,</span><br><span class="line">        &quot;validated_at&quot;:&quot;2017-12-25 14:38:25&quot;,</span><br><span class="line">        &quot;created_at&quot;:&quot;2017-12-25 14:38:25&quot;,</span><br><span class="line">        &quot;updated_at&quot;:&quot;2017-12-25 14:38:25&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="获取代理IP列表"><a href="#获取代理IP列表" class="headerlink" title="获取代理IP列表"></a>获取代理IP列表</h3><ul>
<li>URL: <a href="https://ip.jiangxianli.com/api/proxy_ips" target="_blank" rel="noopener">https://ip.jiangxianli.com/api/proxy_ips</a></li>
<li>请求参数</li>
</ul>
<table>
<thead>
<tr>
<th>参数名</th>
<th>数据类型</th>
<th>必传</th>
<th>说明</th>
<th>例子</th>
</tr>
</thead>
<tbody><tr>
<td>page</td>
<td>int</td>
<td>N</td>
<td>第几页</td>
<td>1</td>
</tr>
<tr>
<td>country</td>
<td>string</td>
<td>N</td>
<td>所属国</td>
<td>中国,美国</td>
</tr>
<tr>
<td>isp</td>
<td>string</td>
<td>N</td>
<td>ISP</td>
<td>电信,阿里云</td>
</tr>
<tr>
<td>order_by</td>
<td>string</td>
<td>N</td>
<td>排序字段</td>
<td>speed:响应速度,validated_at:最新校验时间 created_at:存活时间</td>
</tr>
<tr>
<td>order_rule</td>
<td>string</td>
<td>N</td>
<td>排序方向</td>
<td>DESC:降序 ASC:升序</td>
</tr>
</tbody></table>
<ul>
<li>响应数据</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;code&quot;:0,</span><br><span class="line">    &quot;msg&quot;:&quot;成功&quot;,</span><br><span class="line">    &quot;data&quot;:&#123;</span><br><span class="line">        &quot;current_page&quot;:1,</span><br><span class="line">        &quot;data&quot;:[</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;unique_id&quot;:&quot;dd2aa4a97ab900ad5c7b679e445d9cde&quot;,</span><br><span class="line">                &quot;ip&quot;:&quot;119.167.153.50&quot;,</span><br><span class="line">                &quot;port&quot;:&quot;8118&quot;,</span><br><span class="line">                &quot;ip_address&quot;:&quot;山东省 青岛市&quot;,</span><br><span class="line">                &quot;anonymity&quot;:0,</span><br><span class="line">                &quot;protocol&quot;:&quot;http&quot;,</span><br><span class="line">                &quot;isp&quot;:&quot;联通&quot;,</span><br><span class="line">                &quot;speed&quot;:46,</span><br><span class="line">                &quot;validated_at&quot;:&quot;2017-12-25 15:11:05&quot;,</span><br><span class="line">                &quot;created_at&quot;:&quot;2017-12-25 15:11:05&quot;,</span><br><span class="line">                &quot;updated_at&quot;:&quot;2017-12-25 15:11:05&quot;</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;unique_id&quot;:&quot;7468e4ee73bf2be35b36221231ab02d5&quot;,</span><br><span class="line">                &quot;ip&quot;:&quot;119.5.0.42&quot;,</span><br><span class="line">                &quot;port&quot;:&quot;22&quot;,</span><br><span class="line">                &quot;ip_address&quot;:&quot;四川省 南充市&quot;,</span><br><span class="line">                &quot;anonymity&quot;:0,</span><br><span class="line">                &quot;protocol&quot;:&quot;http&quot;,</span><br><span class="line">                &quot;isp&quot;:&quot;联通&quot;,</span><br><span class="line">                &quot;speed&quot;:127,</span><br><span class="line">                &quot;validated_at&quot;:&quot;2017-12-25 15:10:04&quot;,</span><br><span class="line">                &quot;created_at&quot;:&quot;2017-12-25 14:38:14&quot;,</span><br><span class="line">                &quot;updated_at&quot;:&quot;2017-12-25 15:10:04&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        ],</span><br><span class="line">        &quot;last_page&quot;:1,</span><br><span class="line">        &quot;per_page&quot;:15,</span><br><span class="line">        &quot;to&quot;:8,</span><br><span class="line">        &quot;total&quot;:8</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="访问频率限制"><a href="#访问频率限制" class="headerlink" title="访问频率限制"></a>访问频率限制</h2><p>请注意访问频率以及防止无效页的数据获取。多次违规操作访问将被限制IP访问。如需解除IP请在修正操作后，ISSUE中申请解除限制。</p>
<p>详情参见:<a href="https://github.com/jiangxianli/ProxyIpLib" target="_blank" rel="noopener">https://github.com/jiangxianli/ProxyIpLib</a></p>
<p><strong>本文为作者原创 转载时请注明出处 谢谢</strong></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em>乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</em></p>
]]></content>
      <tags>
        <tag>免费代理</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql使用命令导入和导出sql文件</title>
    <url>/131.html</url>
    <content><![CDATA[<h3 id="window下"><a href="#window下" class="headerlink" title="window下"></a>window下</h3><p><strong>1.导出整个数据库，首先打开要导出的目录</strong></p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">mysqldump -u 用户名 -p 数据库名 &gt; 导出的文件名</span><br><span class="line"></span><br><span class="line">mysqldump -u dbuser -p dbname &gt; dbname.sql 下一行需要输入密码</span><br><span class="line"></span><br><span class="line">mysqldump -uroot -proot [dbname]&gt; english.sql 在本行直接输入密码</span><br></pre></td></tr></table></figure>

<p><strong>2.导出一个表</strong></p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">mysqldump -u 用户名 -p 数据库名 表名&gt; 导出的文件名</span><br><span class="line"></span><br><span class="line">mysqldump -u dbuser -p dbname users&gt; dbname_users.sql</span><br></pre></td></tr></table></figure>

<p><strong>3.导出一个数据库结构</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysqldump -u dbuser -p -d <span class="comment">--add-drop-table dbname &gt;d:/dbname_db.sql</span></span><br><span class="line"></span><br><span class="line">-d 没有数据 <span class="comment">--add-drop-table 在每个create语句之前增加一个drop table</span></span><br></pre></td></tr></table></figure>

<p><strong>4.导入数据库</strong></p>
<p>常用<code>source</code> 命令</p>
<p>进入<code>mysql</code>数据库控制台，如</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">mysql -u root -p</span><br><span class="line"></span><br><span class="line">mysql&gt;use 数据库名;</span><br></pre></td></tr></table></figure>

<p>如果数据库不存在 则则新建:</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">mysql&gt;create database 数据库名;</span><br></pre></td></tr></table></figure>

<p>然后使用<code>source</code>命令，后面参数为脚本文件(如这里用到的.sql)</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">mysql&gt;source d:/dbname.sql</span><br></pre></td></tr></table></figure>





<h3 id="linux下"><a href="#linux下" class="headerlink" title="linux下"></a>linux下</h3><p><strong>一、导出数据库用mysqldump命令（注意mysql的安装路径，即此命令的路径）：</strong></p>
<p>1、导出数据和表结构：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysqldump -u用户名 -p密码 数据库名 &gt; 数据库名.sql</span><br><span class="line"></span><br><span class="line">\#/usr/local/mysql/bin/  mysqldump -uroot -p abc &gt; abc.sql</span><br></pre></td></tr></table></figure>

<p>敲回车后会提示输入密码</p>
<p>2、只导出表结构</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysqldump -u用户名 -p密码 -d 数据库名 &gt; 数据库名.sql</span><br><span class="line"></span><br><span class="line">\#/usr/local/mysql/bin/  mysqldump -uroot -p -d abc &gt; abc.sql</span><br><span class="line"></span><br><span class="line">注：/usr/local/mysql/bin/ ---&gt; mysql的data目录</span><br></pre></td></tr></table></figure>



<p><strong>二、导入数据库</strong></p>
<p>1、首先建空数据库</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt;create database abc;</span><br></pre></td></tr></table></figure>

<p>2、导入数据库</p>
<p>方法一：</p>
<p>（1）选择数据库</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt;use abc;</span><br></pre></td></tr></table></figure>

<p>（2）设置数据库编码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt;set names utf8;</span><br></pre></td></tr></table></figure>

<p>（3）导入数据（注意sql文件的路径）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt;source /home/abc/abc.sql;</span><br></pre></td></tr></table></figure>

<p>方法二：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql -u用户名 -p密码 数据库名 &lt; 数据库名.sql</span><br><span class="line"></span><br><span class="line">\#mysql -uabc_f -p abc &lt; abc.sql</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em>乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</em></p>
]]></content>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>关于WordPress 安装主题或插件时提示需要登陆FTP解决方法</title>
    <url>/129.html</url>
    <content><![CDATA[<p>wp-config.php里加入下面代码:</p>
<p><strong>在wp-config.php里加入下面代码:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">define( &apos;FS_METHOD&apos;,  &apos;direct&apos;);</span><br><span class="line">define( &apos;FS_CHMOD_DIR&apos;, 0777);</span><br><span class="line">define( &apos;FS_CHMOD_FILE&apos;, 0777);</span><br></pre></td></tr></table></figure>

<p><strong>加入完毕后不再提示FTP登录, 但是有可能安装插件时提示 安装失败，无法创建目录</strong></p>
<p>解决方案:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">chmod -R 777 wp-content/ </span><br><span class="line">chmod -R 777 theme/ </span><br><span class="line">chmod -R 777 plugin/ </span><br><span class="line">chmod -R 777 language/</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em>乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</em></p>
]]></content>
      <tags>
        <tag>wordpress</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux文件误删后如何恢复</title>
    <url>/132.html</url>
    <content><![CDATA[<p><strong>以下方法适用于文件或目录被删,如果被覆盖则无法恢复</strong></p>
<h3 id="方法一-使用系统自带的还原工具debugfs"><a href="#方法一-使用系统自带的还原工具debugfs" class="headerlink" title="方法一 使用系统自带的还原工具debugfs"></a>方法一 使用系统自带的还原工具<code>debugfs</code></h3><ol>
<li>第一步 查看文件或目录锁挂载的磁盘名</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">df  /root/你被删的目录</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>输入<code>debugfs</code>指令进入命令区</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">root@xxx:# /debugfs</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>进入挂载磁盘 查找被删目录和文件</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">open dev/vda1 #这个是我服务磁盘名 你的也许不一样</span><br><span class="line">ls -d /root/你被删的目录 #查找被删文件</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20200930130559.png" alt></p>
<p><strong>带尖括号开头的文件表示已经被删除的 无尖括号表示当前已经存在的文件</strong></p>
<p>接下来 咱们需要借助尖括号中的地址进行文件还原</p>
<ol start="4">
<li>根据node地址查找文件信息, 在debugfs命令区中输入</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">logdump -i &lt;19662057&gt;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20200930131041.png" alt></p>
<ol start="5">
<li><p>文件还原</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dd  if=/dev/vda1 of=/root/被删除文件  bs=3456 count=1 skip=524974</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>*　bs对应offset 表示文件大小<br>*　count 表示需要还原几份<br>*　skip对应block值 表示跳过blocks个块后再开始复制</p>
<p>至此　恢复完毕</p>
<p>###　方法二 使用第三方的还原工具<code>extundelete</code></p>
<ol>
<li>第一步 安装 </li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apt-get install extundelete -y</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>第二步 获取被删文件或目录的node</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ls -lia 目标目录</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>根据node查看文件信息</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">extundelete /dev/sda5 --inode 24904454</span><br></pre></td></tr></table></figure>

<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="comment">#以下为控制台输出信息</span></span><br><span class="line">File name                                       <span class="params">| Inode number |</span> Deleted status</span><br><span class="line">.                                                 <span class="number">2</span></span><br><span class="line">..                                                <span class="number">2</span></span><br><span class="line">deletetest                                        <span class="number">12</span>             Deleted</span><br><span class="line">tmppasswd                                         <span class="number">14</span>             Deleted</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>恢复全部数据</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">extundelete /dev/sda5 --restore-all</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>恢复单个数据</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">extundelete /dev/sdb5 --restore-file xxx</span><br></pre></td></tr></table></figure>

<ol start="6">
<li>恢复指定目录</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">extundelete /dev/sdb5 --restore-directory  xxx</span><br></pre></td></tr></table></figure>

<p>至此 ，恢复完毕</p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em>乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</em></p>
]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux系统查看时区以及时区修改</title>
    <url>/133.html</url>
    <content><![CDATA[<p><code>wp-config.php</code>里加入下面代码:</p>
<h4 id="这里以Ubuntu系统为例"><a href="#这里以Ubuntu系统为例" class="headerlink" title="这里以Ubuntu系统为例"></a>这里以Ubuntu系统为例</h4><p><strong>查看时区:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">date -R</span><br></pre></td></tr></table></figure>

<p><strong>修改时区为东八区</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">timedatectl set-timezone Asia/Shanghai</span><br></pre></td></tr></table></figure>

<h5 id="老版本系统以上修改时区指令可能不生效-需要采用以下办法"><a href="#老版本系统以上修改时区指令可能不生效-需要采用以下办法" class="headerlink" title="老版本系统以上修改时区指令可能不生效, 需要采用以下办法"></a>老版本系统以上修改时区指令可能不生效, 需要采用以下办法</h5><p><strong>1.运行tzselect</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">root@ubuntu:/# tzselect</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20201012105429.png" alt></p>
<p><strong>在这里我们选择亚洲 Asia，确认之后选择中国（China)，最后选择北京(Beijing)</strong></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20201012105446.png" alt>**</p>
<p><strong>2.复制文件到/etc目录下</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">root@ubuntu:/# cp /usr/share/zoneinfo/Asia/Shanghai  /etc/localtime</span><br></pre></td></tr></table></figure>

<p><strong>3.再次查看时间date -R，已经修改为北京时间</strong></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20201012105502.png" alt></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em>乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</em></p>
]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>docker设置启动docker后 开启或关闭自启容器</title>
    <url>/134.html</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>我们需要在<code>docker</code>启动的时候自动运行容器, 具体操作分为以下两种情况</p>
<h3 id="容器未创建"><a href="#容器未创建" class="headerlink" title="容器未创建"></a>容器未创建</h3><p>如果容器还没有创建, 可以采用增加容器运行参数的方式实现</p>
<p>命令如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run xxx –-restart=always</span><br></pre></td></tr></table></figure>

<h3 id="容器已创建"><a href="#容器已创建" class="headerlink" title="容器已创建"></a>容器已创建</h3><p>当然如果你的容器已经启动,可以通过<code>update</code>命令进行修改.<br>命令如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker update –-restart=always &lt;CONTAINER ID&gt;</span><br></pre></td></tr></table></figure>

<h3 id="取消自启动"><a href="#取消自启动" class="headerlink" title="取消自启动"></a>取消自启动</h3><p>如果你想取消掉<br>命令如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker update --restart=no &lt;CONTAINER ID&gt;</span><br></pre></td></tr></table></figure>

<h3 id="容器批量操作"><a href="#容器批量操作" class="headerlink" title="容器批量操作"></a>容器批量操作</h3><ol>
<li><p>给已启动所有容器设置自启动</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker update --restart=no $(docker ps -q)</span><br></pre></td></tr></table></figure>
</li>
<li><p>给所有容器设置自启动 包括停止的容器</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker update --restart=no $(docker ps -aq)</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看容器是否配置成功</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker inspect 容器名</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20210916151358153.png" alt="image-20210916151358153"></p>
</li>
</ol>
<p><strong>本文为作者原创 转载时请注明出处 谢谢</strong></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em>乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</em></p>
]]></content>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>使用docker在服务器部署vscode实现云端web开发</title>
    <url>/135.html</url>
    <content><![CDATA[<p><strong>采用codercom/code-server</strong></p>
<h3 id="拉取codercom-code-server镜像"><a href="#拉取codercom-code-server镜像" class="headerlink" title="拉取codercom/code-server镜像"></a>拉取codercom/code-server镜像</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker pull codercom/code-server</span><br></pre></td></tr></table></figure>

<h3 id="运行code-server-容器"><a href="#运行code-server-容器" class="headerlink" title="运行code-server 容器"></a>运行code-server 容器</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -it --name=code_server  -p 8443:8080 -p 4001:4000 -v /root/songjian:/home/coder/songjian -h code_server -e PASSWORD=123  codercom/code-server</span><br></pre></td></tr></table></figure>

<h3 id="浏览器中输入ip：8843-开始云端开发之旅"><a href="#浏览器中输入ip：8843-开始云端开发之旅" class="headerlink" title="浏览器中输入ip：8843 开始云端开发之旅"></a>浏览器中输入ip：8843 开始云端开发之旅</h3><h3 id="编辑代码时出现权限问题"><a href="#编辑代码时出现权限问题" class="headerlink" title="编辑代码时出现权限问题"></a>编辑代码时出现权限问题</h3><p>解决方案：<br>在宿主机中开放读写权限</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">chmod a+rwx -R /root/songjian/</span><br></pre></td></tr></table></figure>

<p>或者在容器运行的时候指定用户组为root <strong>(推荐)</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -it -u root --name=code_server  -p 8443:8080 -p 4001:4000 -v /root/songjian:/home/coder/songjian -h code_server -e PASSWORD=123  codercom/code-server</span><br></pre></td></tr></table></figure>

<p>问题解决</p>
<h3 id><a href="#" class="headerlink" title></a></h3><p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em>乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</em></p>
]]></content>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>如何创建Xposed模块工程进行代码hook</title>
    <url>/137.html</url>
    <content><![CDATA[<h1 id="快速搭建模块工程"><a href="#快速搭建模块工程" class="headerlink" title="快速搭建模块工程"></a>快速搭建模块工程</h1><ol>
<li><strong>第一步 使用Android Studio创建空工程</strong></li>
<li><strong>第二步 导入依赖</strong></li>
</ol>
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line">compileOnly <span class="string">'de.robv.android.xposed:api:53'</span></span><br><span class="line">compileOnly <span class="string">'de.robv.android.xposed:api:53:sources'</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li><strong>在AndroidManifest.xml清单文件application节点下加入以下代码</strong></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;meta-data</span><br><span class="line">          android:name=<span class="string">"xposedmodule"</span></span><br><span class="line">          android:value=<span class="string">"true"</span> /&gt;</span><br><span class="line">      &lt;meta-data</span><br><span class="line">          android:name=<span class="string">"xposeddescription"</span></span><br><span class="line">          android:value=<span class="string">"Xposed模块初体验"</span> /&gt;</span><br><span class="line">      &lt;meta-data</span><br><span class="line">          android:name=<span class="string">"xposedminversion"</span></span><br><span class="line">          android:value=<span class="string">"53"</span> /&gt;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li><strong>创建Hook逻辑类,该类继承自IXposedHookLoadPackage,示例如下:</strong></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HookTest</span> <span class="keyword">implements</span> <span class="title">IXposedHookLoadPackage</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleLoadPackage</span><span class="params">(XC_LoadPackage.LoadPackageParam lpparam)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        XposedBridge.log(<span class="string">"HOOK初体验："</span> + lpparam.processName + <span class="string">":"</span> + lpparam.packageName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li><strong>在assets目录下创建xposed_init文件并将Hook逻辑类引用路径填入,比如:</strong></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">com.example.test.HookTest</span><br></pre></td></tr></table></figure>

<ol start="6">
<li><strong>编译并运行至装有xposed容器app的设备中即可, 重启设备生效</strong></li>
</ol>
<h4 id="注-以上操作成功的前提是你需要一台拥有root权限的手机或者模拟器-并已经安装了xposed安装器"><a href="#注-以上操作成功的前提是你需要一台拥有root权限的手机或者模拟器-并已经安装了xposed安装器" class="headerlink" title="注:以上操作成功的前提是你需要一台拥有root权限的手机或者模拟器,并已经安装了xposed安装器"></a>注:以上操作成功的前提是你需要一台拥有root权限的手机或者模拟器,并已经安装了xposed安装器</h4><p><strong>搭建本文为作者原创 转载时请注明出处 谢谢</strong></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em>乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</em></p>
]]></content>
      <tags>
        <tag>android反编译</tag>
      </tags>
  </entry>
  <entry>
    <title>Xposed 如何Hook静态变量or构造方法or复杂参数的方法or替换函数执行内容or内部类中的函数or匿名类的函数</title>
    <url>/136.html</url>
    <content><![CDATA[<h2 id="Xposed框架Hook相关api的使用"><a href="#Xposed框架Hook相关api的使用" class="headerlink" title="Xposed框架Hook相关api的使用"></a>Xposed框架Hook相关api的使用</h2><p><strong>首先创建测试类继承IXposedHookLoadPackage, 以下所有的hook方法都在handleLoadPackage方法内部进行调用</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HookTest</span> <span class="keyword">implements</span> <span class="title">IXposedHookLoadPackage</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleLoadPackage</span><span class="params">(XC_LoadPackage.LoadPackageParam lpparam)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        XposedBridge.log(<span class="string">"HOOK初体验："</span> + lpparam.processName + <span class="string">":"</span> + lpparam.packageName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="准备需要被hook的代码用于测试"><a href="#准备需要被hook的代码用于测试" class="headerlink" title="准备需要被hook的代码用于测试"></a>准备需要被hook的代码用于测试</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HookDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String Tag = <span class="string">"HookDemo"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span>  <span class="keyword">int</span> staticInt = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">public</span>  <span class="keyword">int</span> publicInt = <span class="number">200</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> privateInt = <span class="number">300</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HookDemo</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(<span class="string">"NOHook"</span>);</span><br><span class="line">        Log.d(Tag, <span class="string">"HookDemo() was called|||"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">HookDemo</span><span class="params">(String str)</span></span>&#123;</span><br><span class="line">        Log.d(Tag, <span class="string">"HookDemo(String str) was called|||"</span> + str);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hookDemoTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Log.d(Tag, <span class="string">"staticInt = "</span> + staticInt);</span><br><span class="line">        Log.d(Tag, <span class="string">"PublicInt = "</span> + publicInt);</span><br><span class="line">        Log.d(Tag, <span class="string">"privateInt = "</span> + privateInt);</span><br><span class="line">        publicFunc(<span class="string">"NOHook"</span>);</span><br><span class="line">        Log.d(Tag, <span class="string">"PublicInt = "</span> + publicInt);</span><br><span class="line">        Log.d(Tag, <span class="string">"privateInt = "</span> + privateInt);</span><br><span class="line">        privateFunc(<span class="string">"NOHook"</span>);</span><br><span class="line">        staticPrivateFunc(<span class="string">"NOHook"</span>);</span><br><span class="line"></span><br><span class="line">        String[][] str = <span class="keyword">new</span> String[<span class="number">1</span>][<span class="number">2</span>];</span><br><span class="line">        Map map = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</span><br><span class="line">        map.put(<span class="string">"key"</span>, <span class="string">"value"</span>);</span><br><span class="line">        ArrayList arrayList = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        arrayList.add(<span class="string">"listValue"</span>);</span><br><span class="line">        complexParameterFunc(<span class="string">"NOHook"</span>, str, map, arrayList);</span><br><span class="line"></span><br><span class="line">        repleaceFunc();</span><br><span class="line">        anonymousInner(<span class="keyword">new</span> Animal() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eatFunc</span><span class="params">(String value)</span> </span>&#123;</span><br><span class="line">                Log.d(Tag, <span class="string">"eatFunc(String value)  was called|||"</span> + value);</span><br><span class="line">                Log.d(Tag, <span class="string">"anonymoutInt =  "</span> + anonymoutInt);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"NOHook"</span>);</span><br><span class="line"></span><br><span class="line">        InnerClass innerClass = <span class="keyword">new</span> InnerClass();</span><br><span class="line">        innerClass.InnerFunc(<span class="string">"NOHook"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">publicFunc</span><span class="params">(String value)</span></span>&#123;</span><br><span class="line">        Log.d(Tag, <span class="string">"publicFunc(String value) was called|||"</span> + value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">privateFunc</span><span class="params">(String value)</span></span>&#123;</span><br><span class="line">        Log.d(Tag, <span class="string">"privateFunc(String value) was called|||"</span> + value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">private</span> <span class="keyword">void</span> <span class="title">staticPrivateFunc</span><span class="params">(String value)</span></span>&#123;</span><br><span class="line">        Log.d(<span class="string">"HookDemo"</span>, <span class="string">"staticPrivateFunc(Strin value) was called|||"</span> + value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">complexParameterFunc</span><span class="params">(String value, String[][] str, Map&lt;String,String&gt; map, ArrayList arrayList)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Log.d(<span class="string">"HookDemo"</span>, <span class="string">"complexParameter(Strin value) was called|||"</span> + value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">repleaceFunc</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Log.d(Tag, <span class="string">"repleaceFunc will be replace|||"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">anonymousInner</span><span class="params">(Animal dog, String value)</span></span>&#123;</span><br><span class="line">        Log.d(Tag, <span class="string">"anonymousInner was called|||"</span> + value);</span><br><span class="line">        dog.eatFunc(<span class="string">"NOHook"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">hideFunc</span><span class="params">(String value)</span></span>&#123;</span><br><span class="line">        Log.d(Tag, <span class="string">"hideFunc was called|||"</span> + value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">argFunc</span><span class="params">(Objcet... value)</span></span>&#123;</span><br><span class="line">        Log.d(Tag, <span class="string">"argFunc was called|||"</span> + value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">InnerClass</span></span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> innerPublicInt = <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> innerPrivateInt = <span class="number">20</span>;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">InnerClass</span><span class="params">()</span></span>&#123;</span><br><span class="line">            Log.d(Tag, <span class="string">"InnerClass constructed func was called"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">InnerFunc</span><span class="params">(String value)</span></span>&#123;</span><br><span class="line">            Log.d(Tag, <span class="string">"InnerFunc(String value) was called|||"</span> + value);</span><br><span class="line">            Log.d(Tag, <span class="string">"innerPublicInt = "</span> + innerPublicInt);</span><br><span class="line">            Log.d(Tag, <span class="string">"innerPrivateInt = "</span> + innerPrivateInt);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><strong>修改类中的私有静态变量</strong></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class&lt;?&gt; clazz = XposedHelpers.findClass(<span class="string">"com.example.xposedhooktarget.HookDemo"</span>, lpparam.classLoader);</span><br><span class="line">XposedHelpers.setStaticIntField(clazz, <span class="string">"staticInt"</span>, <span class="number">99</span>);</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><strong>Hook无参构造函数</strong></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class&lt;?&gt; clazz = XposedHelpers.findClass(<span class="string">"com.example.xposedhooktarget.HookDemo"</span>, loadPackageParam.classLoader);</span><br><span class="line">XposedHelpers.findAndHookConstructor(clazz, <span class="keyword">new</span> XC_MethodHook() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">beforeHookedMethod</span><span class="params">(MethodHookParam param)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">                XposedBridge.log(<span class="string">"Haha, HookDemo constructed was hooked"</span>);</span><br><span class="line">                <span class="comment">//大坑，此时对象还没有建立，即不能获取对象，也不能修改非静态变量的值</span></span><br><span class="line">                <span class="comment">//XposedHelpers.setIntField(param.thisObject, "publicInt", 199);</span></span><br><span class="line">                <span class="comment">//XposedHelpers.setIntField(param.thisObject, "privateInt", 299);</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><strong>Hook有参构造函数，并修改参数</strong></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">XposedHelpers.findAndHookConstructor(clazz, String.class,  <span class="keyword">new</span> XC_MethodHook() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">beforeHookedMethod</span><span class="params">(MethodHookParam param)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">                param.args[<span class="number">0</span>] = <span class="string">"Haha, HookDemo(str) are hooked"</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure>

<ol start="4">
<li><strong>Hook公有方法publicFunc，并修改参数以及修改下publicInt和privateInt的值,再顺便调用一下隐藏函数hideFunc</strong></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">XposedHelpers.findAndHookMethod(clazz, <span class="string">"publicFunc"</span>, String.class, <span class="keyword">new</span> XC_MethodHook() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">beforeHookedMethod</span><span class="params">(MethodHookParam param)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">                    param.args[<span class="number">0</span>] = <span class="string">"Haha, publicFunc are hooked"</span>;</span><br><span class="line">                    <span class="comment">//修改成员变量的值</span></span><br><span class="line">                    XposedHelpers.setIntField(param.thisObject, <span class="string">"publicInt"</span>, <span class="number">199</span>);</span><br><span class="line">                    XposedHelpers.setIntField(param.thisObject, <span class="string">"privateInt"</span>, <span class="number">299</span>);</span><br><span class="line">                  	<span class="comment">//调用函数</span></span><br><span class="line">                    XposedHelpers.callMethod(param.thisObject, <span class="string">"hideFunc"</span>, <span class="string">"Haha, hideFunc was hooked"</span>);</span><br><span class="line"></span><br><span class="line">                   </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br></pre></td></tr></table></figure>

<ol start="5">
<li><strong>Hook私有方法privateFunc，并修改参数</strong></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">XposedHelpers.findAndHookMethod(clazz, <span class="string">"privateFunc"</span>, String.class, <span class="keyword">new</span> XC_MethodHook() &#123;</span><br><span class="line">               <span class="meta">@Override</span></span><br><span class="line">               <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">beforeHookedMethod</span><span class="params">(MethodHookParam param)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">                   param.args[<span class="number">0</span>] = <span class="string">"Haha, privateFunc are hooked"</span>;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;);</span><br></pre></td></tr></table></figure>

<ol start="6">
<li><strong>Hook私有静态方法staticPrivateFunc, 并修改参数</strong></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">XposedHelpers.findAndHookMethod(clazz, <span class="string">"staticPrivateFunc"</span>, String.class, <span class="keyword">new</span> XC_MethodHook() &#123;</span><br><span class="line">              <span class="meta">@Override</span></span><br><span class="line">              <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">beforeHookedMethod</span><span class="params">(MethodHookParam param)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">                  param.args[<span class="number">0</span>] = <span class="string">"Haha, staticPrivateFunc are hooked"</span>;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;);</span><br></pre></td></tr></table></figure>

<ol start="7">
<li><strong>Hook复杂参数函数complexParameterFunc</strong></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class fclass1 = XposedHelpers.findClass(<span class="string">"java.util.Map"</span>, loadPackageParam.classLoader);</span><br><span class="line">           Class fclass2 = XposedHelpers.findClass(<span class="string">"java.util.ArrayList"</span>, loadPackageParam.classLoader);</span><br><span class="line">           XposedHelpers.findAndHookMethod(clazz, <span class="string">"complexParameterFunc"</span>, String.class,</span><br><span class="line">                   <span class="string">"[[Ljava.lang.String;"</span>, fclass1, fclass2, <span class="keyword">new</span> XC_MethodHook() &#123;</span><br><span class="line">                       <span class="meta">@Override</span></span><br><span class="line">                       <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">beforeHookedMethod</span><span class="params">(MethodHookParam param)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">                           param.args[<span class="number">0</span>] = <span class="string">"Haha, complexParameterFunc are hooked"</span>;</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;);</span><br></pre></td></tr></table></figure>

<ol start="8">
<li><strong>Hook私有方法repleaceFunc, 并替换打印内容</strong></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">XposedHelpers.findAndHookMethod(clazz, <span class="string">"repleaceFunc"</span>, <span class="keyword">new</span> XC_MethodReplacement() &#123;</span><br><span class="line">             <span class="meta">@Override</span></span><br><span class="line">             <span class="function"><span class="keyword">protected</span> Object <span class="title">replaceHookedMethod</span><span class="params">(MethodHookParam methodHookParam)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">                 Log.d(<span class="string">"HookDemo"</span>, <span class="string">"Haha, repleaceFunc are replaced"</span>);</span><br><span class="line">                 <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;);</span><br></pre></td></tr></table></figure>

<ol start="9">
<li><strong>Hook方法, anonymousInner， 参数是抽象类，先加载所需要的类即可</strong></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class animalClazz  = loadPackageParam.classLoader.loadClass(<span class="string">"com.example.xposedhooktarget.Animal"</span>);</span><br><span class="line">           XposedHelpers.findAndHookMethod(clazz, <span class="string">"anonymousInner"</span>, animalClazz, String.class, <span class="keyword">new</span> XC_MethodHook() &#123;</span><br><span class="line">               <span class="meta">@Override</span></span><br><span class="line">               <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">beforeHookedMethod</span><span class="params">(MethodHookParam param)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">                   XposedBridge.log(<span class="string">"HookDemo This is test"</span>);</span><br><span class="line">                   param.args[<span class="number">1</span>] = <span class="string">"Haha, anonymousInner are hooked"</span>;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;);</span><br></pre></td></tr></table></figure>

<ol start="10">
<li><strong>Hook匿名类的eatFunc方法，修改参数，顺便修改类中的anonymoutInt变量</strong></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">XposedHelpers.findAndHookMethod(<span class="string">"com.example.xposedhooktarget.HookDemo$1"</span>, clazz.getClassLoader(),</span><br><span class="line">                    <span class="string">"eatFunc"</span>, String.class, <span class="keyword">new</span> XC_MethodHook() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">beforeHookedMethod</span><span class="params">(MethodHookParam param)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">                            param.args[<span class="number">0</span>] = <span class="string">"Haha, eatFunc are hooked"</span>;</span><br><span class="line">                            XposedHelpers.setIntField(param.thisObject, <span class="string">"anonymoutInt"</span>, <span class="number">499</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br></pre></td></tr></table></figure>

<ol start="11">
<li><strong>Hook内部类InnerClass的InnerFunc方法，修改参数，顺便修改类中的innerPublicInt和innerPrivateInt变量</strong></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> Class&lt;?&gt; clazz1 = XposedHelpers.findClass(<span class="string">"com.example.xposedhooktarget.HookDemo$InnerClass"</span>, loadPackageParam.classLoader);</span><br><span class="line">            XposedHelpers.findAndHookMethod(clazz1, <span class="string">"InnerFunc"</span>, String.class, <span class="keyword">new</span> XC_MethodHook() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">beforeHookedMethod</span><span class="params">(MethodHookParam param)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">                            param.args[<span class="number">0</span>] = <span class="string">"Haha, InnerFunc was hooked"</span>;</span><br><span class="line">                            XposedHelpers.setIntField(param.thisObject, <span class="string">"innerPublicInt"</span>, <span class="number">9</span>);</span><br><span class="line">                            XposedHelpers.setIntField(param.thisObject, <span class="string">"innerPrivateInt"</span>, <span class="number">19</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br></pre></td></tr></table></figure>

<ol start="12">
<li><strong>对于一些延迟动态加载的代码,hook方式</strong></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">XposedHelpers.findAndHookMethod(<span class="string">"dalvik.system.DexFile"</span>, lpparam.classLoader, <span class="string">"loadClass"</span>,</span><br><span class="line">                String.class, <span class="string">"java.lang.ClassLoader"</span>, <span class="keyword">new</span> XC_MethodHook() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">afterHookedMethod</span><span class="params">(MethodHookParam param)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">                        String className = (String) param.args[<span class="number">0</span>];</span><br><span class="line">                        Object result = param.getResult();</span><br><span class="line">                        <span class="keyword">if</span> (result != <span class="keyword">null</span> &amp;&amp; result <span class="keyword">instanceof</span> Class) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (<span class="string">"com.alipay.mobile.nebulauc.impl.UCWebViewClient"</span>.equals(className)) &#123;</span><br><span class="line">                                <span class="comment">// hookLoadWebViewClient(((Class) result).getClassLoader());</span></span><br><span class="line">                            &#125; </span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125;);</span><br></pre></td></tr></table></figure>

<ol start="13">
<li><strong>Hook有可变参数的方法</strong></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">XposedHelpers.findAndHookMethod(clazz, <span class="string">"argFunc"</span>, Object[].class,<span class="keyword">new</span> XC_MethodHook() &#123;</span><br><span class="line">             <span class="meta">@Override</span></span><br><span class="line">             <span class="function"><span class="keyword">protected</span> Object <span class="title">afterHookedMethod</span><span class="params">(MethodHookParam methodHookParam)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">                </span><br><span class="line">             &#125;</span><br><span class="line">         &#125;);</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol>
<li><p>无论hook公有私有方法还是静态方法 ,抑或可变参方法,甚至是带返回值的方法,统一使用<code>findAndHookMethod</code>这个Api</p>
</li>
<li><p>xposed无法hook接口和抽象类方法</p>
</li>
<li><p>Hook逻辑类可实现的接口有 : </p>
<ul>
<li><p>安卓系统启动的时候（使用 IXposedHookZygoteInit 接口）、</p>
</li>
<li><p>一个新的app被加载的时候（使用 IXposedHookLoadPackage 接口）、</p>
</li>
<li><p>一个资源被初始化的时候（ 使用 IXposedHookInitPackageResources 接口 )</p>
</li>
</ul>
</li>
<li><p>实现IXposedHookLoadPackage 并使用 XposedBridge.log 打印的日志,当启动第三方应用后,Android Studio控制台无法查看到日志信息,需要在xposed应用内进行查看</p>
</li>
<li><p>参数为基本数据类型时需要传对应包装类的type属性,比如int传Integer.TYPE, 否则提示找不到方法,如果参数为引用数据类型,那直接传xxx.class即可</p>
</li>
<li><ul>
<li><p>beforeHookedMethod 会在调用原方法前执行，如果使用setResult则跳过原方法，并返回setResult参数中的值。</p>
</li>
<li><p>afterHookedMethod 会在调用原方法后执行，setResult可改变返回值</p>
</li>
<li><p>replaceHookedMethod 会完全替换原方法，即原方法不执行，且返回值可以直接return，setResult不生效。</p>
</li>
</ul>
</li>
</ol>
<p><strong>注:每次修改完毕后需要重启才生效</strong></p>
<h2 id="附"><a href="#附" class="headerlink" title="附"></a>附</h2><h5 id="Hook-修改方法返回值"><a href="#Hook-修改方法返回值" class="headerlink" title="Hook 修改方法返回值"></a>Hook 修改方法返回值</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">XposedHelpers.findAndHookMethod(clazz, method, <span class="keyword">new</span> Object[]&#123;<span class="keyword">new</span> XC_MethodHook() &#123;</span><br><span class="line">     <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">afterHookedMethod</span><span class="params">(MethodHookParam param)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">                   param.setResult(result);  <span class="comment">// 设置返回值</span></span><br><span class="line">               &#125;</span><br><span class="line">           &#125;&#125;);</span><br></pre></td></tr></table></figure>

<h5 id="Hook-获取方法返回值"><a href="#Hook-获取方法返回值" class="headerlink" title="Hook 获取方法返回值"></a>Hook 获取方法返回值</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">XposedHelpers.findAndHookMethod(clazz, method, <span class="keyword">new</span> Object[]&#123;<span class="keyword">new</span> XC_MethodHook() &#123;</span><br><span class="line">      <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">afterHookedMethod</span><span class="params">(MethodHookParam param)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">                    Object result = param.getResult(); <span class="comment">//获取返回值</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;&#125;);</span><br></pre></td></tr></table></figure>

<h5 id="Hook-获取方法传入的参数值"><a href="#Hook-获取方法传入的参数值" class="headerlink" title="Hook 获取方法传入的参数值"></a>Hook 获取方法传入的参数值</h5><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">XposedHelpers.findAndHookMethod(claName, cl, <span class="string">"i"</span>, String.<span class="keyword">class</span>, String.<span class="keyword">class</span>, Object[].<span class="keyword">class</span>, new XC_MethodHook() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> void afterHookedMethod(MethodHookParam param) throws Throwable &#123;</span><br><span class="line">         <span class="comment">// 数组param.args存储的参数列表里的值</span></span><br><span class="line">         XposedBridge.log(TAG + param.args[<span class="number">0</span>]);</span><br><span class="line">         XposedBridge.log(TAG + param.args[<span class="number">1</span>]);</span><br><span class="line">         XposedBridge.log(TAG + param.args[<span class="number">2</span>]);</span><br><span class="line">          &#125;</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>

<h5 id="Hook-给方法传值"><a href="#Hook-给方法传值" class="headerlink" title="Hook 给方法传值"></a>Hook 给方法传值</h5><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">Class cla = XposedHelpers.findClass(className, loadPackageParam.classLoader);</span><br><span class="line"><span class="built_in">Object</span> com = XposedHelpers.callStaticMethod(cla, <span class="string">"getInstance"</span>);</span><br><span class="line">XposedHelpers.callMethod(com, <span class="string">"setDebug"</span>, <span class="keyword">true</span>); <span class="comment">// 传入指定值</span></span><br></pre></td></tr></table></figure>

<h5 id="Hook-获取Intent的值"><a href="#Hook-获取Intent的值" class="headerlink" title="Hook 获取Intent的值"></a>Hook 获取Intent的值</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">hookGetIntent</span><span class="params">(XC_LoadPackage.LoadPackageParam loadPackageParam)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        XposedHelpers.findAndHookMethod(<span class="string">"android.app.Activity"</span>, loadPackageParam.classLoader, <span class="string">"getIntent"</span>, <span class="keyword">new</span> XC_MethodHook() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">afterHookedMethod</span><span class="params">(MethodHookParam param)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">                Intent sou = (Intent) param.getResult();</span><br><span class="line">                KLog.d(<span class="string">"hookGetIntent:"</span> + sou.toURI().toString());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="Hook-广播发送的Intent信息"><a href="#Hook-广播发送的Intent信息" class="headerlink" title="Hook 广播发送的Intent信息"></a>Hook 广播发送的Intent信息</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">hookSendBroadcast</span><span class="params">(XC_LoadPackage.LoadPackageParam loadPackageParam)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        XposedHelpers.findAndHookMethod(<span class="string">"android.content.ContextWrapper"</span>, loadPackageParam.classLoader, <span class="string">"sendBroadcast"</span>, Intent.class, <span class="keyword">new</span> XC_MethodHook() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">afterHookedMethod</span><span class="params">(MethodHookParam param)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">                Intent sou = (Intent) param.args[<span class="number">0</span>];</span><br><span class="line">                KLog.d(<span class="string">"sendBroadcast:"</span> + sou.toURI().toString());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Xposed一般Hook的是默认的dex文件，但是现在很多的APP都有多个Dex文件，所以使用Xposed时，经常遇到类名路径正确却出现ClassNotFoundError找不到类的错误。要解决这个问题，需要获取对应Dex文件的上下文环境。</p>
<p>Android在加载dex文件后会创建一个Application类，然后会调用attach方法，attach方法的参数就是上下文context，而且attach方法是final方法，不会因为被覆盖而hook不到，拿到这个context就可以获取对应的classload，然后就可以顺利hook到multidex的类了。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">XposedHelpers.findAndHookMethod(Application.<span class="keyword">class</span>, <span class="string">"attach"</span>, Context.<span class="keyword">class</span>, new XC_MethodHook() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> void afterHookedMethod(MethodHookParam param) throws Throwable &#123;</span><br><span class="line">        ClassLoader cl = ((Context) param.args[<span class="number">0</span>]).getClassLoader(); <span class="comment">// 获取ClassLoader</span></span><br><span class="line">        Class&lt;?&gt; hookClass = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            hookClass = cl.loadClass(claName); <span class="comment">// 获取Class</span></span><br><span class="line">            <span class="comment">// 使用cl 和 hookClass 完成hook</span></span><br><span class="line">            XposedHelpers.setStaticIntField(hookClass, fieldName, <span class="keyword">val</span>);</span><br><span class="line">            XposedHelpers.findAndHookMethod(claName, cl, <span class="string">"i"</span>, String.<span class="keyword">class</span>, String.<span class="keyword">class</span>, Object[].<span class="keyword">class</span>, new XC_MethodHook() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">protected</span> void afterHookedMethod(MethodHookParam param) throws Throwable &#123;</span><br><span class="line">                    XposedBridge.log(TAG + param.args[<span class="number">0</span>]);</span><br><span class="line">                    XposedBridge.log(TAG + param.args[<span class="number">1</span>]);</span><br><span class="line">                    XposedBridge.log(TAG + param.args[<span class="number">2</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><strong>本文为作者原创 转载时请注明出处 谢谢</strong></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em>乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</em></p>
]]></content>
      <tags>
        <tag>android反编译</tag>
      </tags>
  </entry>
  <entry>
    <title>windows平台下一款强大的免费代理获取工具ProxyFire(烈火代理)</title>
    <url>/14.html</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p> proxyfire是一个强大的在线代理收集和分类工具。它支持http、socks4、socks5、隧道和ssl代理验证。它可以将代理分为socks代理、超级匿名代理、一般匿名代理、透明代理、网关代理。它具有强大的论坛吸收功能、搜索引擎吸收功能、代理扫描功能。并对代理的查询国家、代理重复、智能删除代理水印、代理无序等功能进行了研究。默认设置可用于每天获取数千个新的代理列表 </p>
<h2 id="截图"><a href="#截图" class="headerlink" title="截图"></a>截图</h2><p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20200914134850.png" alt></p>
<p><strong>本帖附件</strong></p>
<p><a href="https://545c.com/file/21042697-461309310" target="_blank" rel="noopener">点击下载</a></p>
<p><strong>本文为作者原创 转载时请注明出处 谢谢</strong></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em>乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</em></p>
]]></content>
      <tags>
        <tag>免费代理</tag>
      </tags>
  </entry>
  <entry>
    <title>Xposed进阶之app资源替换</title>
    <url>/138.html</url>
    <content><![CDATA[<h2 id="替换Boolean-Color-Integer-int-String-and-String-类型的简单资源"><a href="#替换Boolean-Color-Integer-int-String-and-String-类型的简单资源" class="headerlink" title="替换Boolean, Color, Integer, int[], String and String[]类型的简单资源"></a>替换Boolean, Color, Integer, int[], String and String[]类型的简单资源</h2><h3 id="1-替换系统框架（Android-Framwork）资源"><a href="#1-替换系统框架（Android-Framwork）资源" class="headerlink" title="1.替换系统框架（Android Framwork）资源"></a>1.替换系统框架（Android Framwork）资源</h3><p>替换系统框架资源（对所有app 起作用）需要实现 <code>IXposedHookZygoteInit</code>接口的 <code>initZygote</code> 方法，并在该方法中调用<code>Resources.setSystemWideReplacement(...)</code> 方法替换资源</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> de.robv.android.xposed.mods.tutorial;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.content.res.XResources;</span><br><span class="line"><span class="keyword">import</span> de.robv.android.xposed.IXposedHookZygoteInit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Tutorial2</span>  <span class="keyword">implements</span> <span class="title">IXposedHookZygoteInit</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initZygote</span><span class="params">(StartupParam arg0)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        XResources.setSystemWideReplacement(<span class="string">"android"</span>, <span class="string">"bool"</span>, <span class="string">"config_unplugTurnsOnScreen"</span>, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-替换app应用资源"><a href="#2-替换app应用资源" class="headerlink" title="2.替换app应用资源"></a>2.替换app应用资源</h3><p>替换app应用资源需要实现 <code>IXposedHookInitPackageResources</code> 类的<br><code>andleInitPackageResources</code>方法，并在该方法中调用<code>res.setReplacement(...)</code>方法替换资源，注意在该方法中不要使用<code>XResources.setSystemWideReplacement</code> 方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> de.robv.android.xposed.mods.tutorial;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.content.res.XResources;</span><br><span class="line"><span class="keyword">import</span> android.graphics.Color;</span><br><span class="line"><span class="keyword">import</span> android.graphics.drawable.ColorDrawable;</span><br><span class="line"><span class="keyword">import</span> android.graphics.drawable.Drawable;</span><br><span class="line"><span class="keyword">import</span> de.robv.android.xposed.IXposedHookInitPackageResources;</span><br><span class="line"><span class="keyword">import</span> de.robv.android.xposed.callbacks.XC_InitPackageResources.InitPackageResourcesParam;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Tutorial3</span> <span class="keyword">implements</span>  <span class="title">IXposedHookInitPackageResources</span>  </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleInitPackageResources</span><span class="params">(InitPackageResourcesParam resparam)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="comment">//只替换systemui应用的资源</span></span><br><span class="line">        <span class="keyword">if</span> (!resparam.packageName.equals(<span class="string">"com.android.systemui"</span>))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 替换资源的不同方式</span></span><br><span class="line">        resparam.res.setReplacement(<span class="number">0x7f080083</span>, <span class="string">"YEAH!"</span>); <span class="comment">// WLAN toggle text. You should not do this because the id is not fixed. Only for framework resources, you could use android.R.string.something</span></span><br><span class="line">        resparam.res.setReplacement(<span class="string">"com.android.systemui:string/quickpanel_bluetooth_text"</span>, <span class="string">"WOO!"</span>);</span><br><span class="line">        resparam.res.setReplacement(<span class="string">"com.android.systemui"</span>, <span class="string">"string"</span>, <span class="string">"quickpanel_gps_text"</span>, <span class="string">"HOO!"</span>);</span><br><span class="line">        resparam.res.setReplacement(<span class="string">"com.android.systemui"</span>, <span class="string">"integer"</span>, <span class="string">"config_maxLevelOfSignalStrengthIndicator"</span>, <span class="number">6</span>);</span><br><span class="line">        resparam.res.setReplacement(<span class="string">"com.android.systemui"</span>, <span class="string">"drawable"</span>, <span class="string">"status_bar_background"</span>, <span class="keyword">new</span> XResources.DrawableLoader() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Drawable <span class="title">newDrawable</span><span class="params">(XResources res, <span class="keyword">int</span> id)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> ColorDrawable(Color.WHITE);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);<span class="comment">//你不能直接使用Drawble类进行替换，因为Drawble类可以影响其他引用Ddrawble类实例的ImageView ,最好使用一个包装器。</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="替换复杂的资源"><a href="#替换复杂的资源" class="headerlink" title="替换复杂的资源"></a>替换复杂的资源</h2><p>对于复制的资源，如动画资源 ，我们也能够替换，下面我们来替换battery icon</p>
<p>动画资源布局</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">animation-list</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">     <span class="attr">android:oneshot</span>=<span class="string">"true"</span> &gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">android:drawable</span>=<span class="string">"@drawable/icon1"</span> <span class="attr">android:duration</span>=<span class="string">"150"</span>&gt;</span><span class="tag">&lt;/<span class="name">item</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">android:drawable</span>=<span class="string">"@drawable/icon2"</span> <span class="attr">android:duration</span>=<span class="string">"150"</span>&gt;</span><span class="tag">&lt;/<span class="name">item</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">android:drawable</span>=<span class="string">"@drawable/icon3"</span> <span class="attr">android:duration</span>=<span class="string">"150"</span>&gt;</span><span class="tag">&lt;/<span class="name">item</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">android:drawable</span>=<span class="string">"@drawable/icon4"</span> <span class="attr">android:duration</span>=<span class="string">"150"</span>&gt;</span><span class="tag">&lt;/<span class="name">item</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">android:drawable</span>=<span class="string">"@drawable/icon5"</span> <span class="attr">android:duration</span>=<span class="string">"150"</span>&gt;</span><span class="tag">&lt;/<span class="name">item</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">android:drawable</span>=<span class="string">"@drawable/icon6"</span> <span class="attr">android:duration</span>=<span class="string">"150"</span>&gt;</span><span class="tag">&lt;/<span class="name">item</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">animation-list</span>&gt;</span></span><br><span class="line">123456789101112</span><br></pre></td></tr></table></figure>

<p>代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> de.robv.android.xposed.mods.tutorial;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.example.xposedmoduletest.R;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.content.res.XModuleResources;</span><br><span class="line"><span class="keyword">import</span> de.robv.android.xposed.IXposedHookInitPackageResources;</span><br><span class="line"><span class="keyword">import</span> de.robv.android.xposed.IXposedHookZygoteInit;</span><br><span class="line"><span class="keyword">import</span> de.robv.android.xposed.callbacks.XC_InitPackageResources.InitPackageResourcesParam;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Tutorial4</span> <span class="keyword">implements</span> <span class="title">IXposedHookZygoteInit</span>, <span class="title">IXposedHookInitPackageResources</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String MODULE_PATH = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initZygote</span><span class="params">(StartupParam startupParam)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        MODULE_PATH = startupParam.modulePath;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleInitPackageResources</span><span class="params">(InitPackageResourcesParam resparam)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!resparam.packageName.equals(<span class="string">"com.android.systemui"</span>))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        XModuleResources modRes = XModuleResources.createInstance(MODULE_PATH, resparam.res);</span><br><span class="line">        resparam.res.setReplacement(<span class="string">"com.android.systemui"</span>, <span class="string">"drawable"</span>, <span class="string">"stat_sys_battery"</span>,</span><br><span class="line">                modRes.fwd(R.drawable.animation));</span><br><span class="line">        resparam.res.setReplacement(<span class="string">"com.android.systemui"</span>, <span class="string">"drawable"</span>, <span class="string">"stat_sys_battery_charge"</span>,</span><br><span class="line">                modRes.fwd(R.drawable.animation));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Xposed框架会将模块请求资源的请求指向你模块中的资源 </p>
<h2 id="替换布局"><a href="#替换布局" class="headerlink" title="替换布局"></a>替换布局</h2><p>你可以用替换资源的方法来替换布局文件，但这样你不得不将目标apk中的整个layout文件复制出来进行修改，这样会使模块的Rom兼容性降低。并且如果两个以上的模块修改布局后，最后修改布局的模块会起作用。更重要的是，布局中指向其它资源的ID很难确定下来。推荐使用下面的方法修改布局：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> de.robv.android.xposed.mods.tutorial;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.graphics.Color;</span><br><span class="line"><span class="keyword">import</span> android.widget.TextView;</span><br><span class="line"><span class="keyword">import</span> de.robv.android.xposed.IXposedHookInitPackageResources;</span><br><span class="line"><span class="keyword">import</span> de.robv.android.xposed.XposedBridge;</span><br><span class="line"><span class="keyword">import</span> de.robv.android.xposed.callbacks.XC_InitPackageResources.InitPackageResourcesParam;</span><br><span class="line"><span class="keyword">import</span> de.robv.android.xposed.callbacks.XC_LayoutInflated;</span><br><span class="line"><span class="keyword">import</span> de.robv.android.xposed.callbacks.XC_LayoutInflated.LayoutInflatedParam;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Tutorial5</span> <span class="keyword">implements</span>   <span class="title">IXposedHookInitPackageResources</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleInitPackageResources</span><span class="params">(InitPackageResourcesParam resparam)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">         <span class="keyword">if</span> (!resparam.packageName.equals(<span class="string">"com.android.systemui"</span>))</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">            resparam.res.hookLayout(<span class="string">"com.android.systemui"</span>, <span class="string">"layout"</span>, <span class="string">"status_bar"</span>, <span class="keyword">new</span> XC_LayoutInflated() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleLayoutInflated</span><span class="params">(LayoutInflatedParam liparam)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">                    TextView clock = (TextView) liparam.view.findViewById(</span><br><span class="line">                            liparam.res.getIdentifier(<span class="string">"clock"</span>, <span class="string">"id"</span>, <span class="string">"com.android.systemui"</span>));</span><br><span class="line">                    clock.setTextColor(Color.RED);</span><br><span class="line">                    XposedBridge.log(<span class="string">"layout  resNames.fullname:"</span>+liparam.resNames.fullName);</span><br><span class="line">                    XposedBridge.log(<span class="string">"layout  resNames.id:"</span>+liparam.resNames.id);</span><br><span class="line">                    XposedBridge.log(<span class="string">"layout  resNames.name:"</span>+liparam.resNames.name);</span><br><span class="line">                    XposedBridge.log(<span class="string">"layout  resNames.pkg:"</span>+liparam.resNames.pkg);</span><br><span class="line">                    XposedBridge.log(<span class="string">"layout  resNames.type:"</span>+liparam.resNames.type);</span><br><span class="line"></span><br><span class="line">                    XposedBridge.log(<span class="string">"layout  resNames.variant:"</span>+liparam.variant);</span><br><span class="line">                    XposedBridge.log(<span class="string">"layout  resNames.view:"</span>+liparam.view);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;); </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>回调方法<code>handleLayoutInflated</code> 会在layout文件被填充后回调，在方法的 LayoutInflatedParam 对象 参数中，你可以找到你想修改的View组件。你也可以通过调用<code>resNames</code>来确定加载的那一个布局文件。用 <code>variant</code>来确定加载的布局的目录’layout-land‘。<code>res</code> 同时也会帮你获取资源的ID和其它的资源。</p>
<h1 id="五、用反射来hook方法"><a href="#五、用反射来hook方法" class="headerlink" title="五、用反射来hook方法"></a>五、用反射来hook方法</h1><p>每当应用加载的时候，IXposedHookLoadPackPage接口的handLoadPackage方法就会被调用执行，为了让我们在正确的进程中执行，需要先判断被加载的包是不是正确的包</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> de.robv.android.xposed.mods.tutorial;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> de.robv.android.xposed.IXposedHookLoadPackage;</span><br><span class="line"><span class="keyword">import</span> de.robv.android.xposed.callbacks.XC_LoadPackage.LoadPackageParam;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Tutorial6</span> <span class="keyword">implements</span> <span class="title">IXposedHookLoadPackage</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleLoadPackage</span><span class="params">(LoadPackageParam param)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!param.packageName.equals(<span class="string">"com.android.systemui"</span>))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一旦我们进入到正确的进程进后，我们就能用param变中的ClassLoad来访问该进程中加载的类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> de.robv.android.xposed.mods.tutorial;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.webkit.WebView.FindListener;</span><br><span class="line"><span class="keyword">import</span> de.robv.android.xposed.IXposedHookLoadPackage;</span><br><span class="line"><span class="keyword">import</span> de.robv.android.xposed.XC_MethodHook;</span><br><span class="line"><span class="keyword">import</span> de.robv.android.xposed.XC_MethodHook.MethodHookParam;</span><br><span class="line"><span class="keyword">import</span> de.robv.android.xposed.callbacks.XC_LoadPackage.LoadPackageParam;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> de.robv.android.xposed.XposedHelpers.findAndHookMethod;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Tutorial6</span> <span class="keyword">implements</span> <span class="title">IXposedHookLoadPackage</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleLoadPackage</span><span class="params">(LoadPackageParam param)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!param.packageName.equals(<span class="string">"com.android.systemui"</span>))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">         findAndHookMethod(<span class="string">"com.android.systemui.statusbar.policy.Clock"</span>,param.classLoader, <span class="string">"updateClock"</span>, <span class="keyword">new</span> XC_MethodHook() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">beforeHookedMethod</span><span class="params">(MethodHookParam param)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">                    <span class="comment">// this will be called before the clock was updated by the original method</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">afterHookedMethod</span><span class="params">(MethodHookParam param)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">                    <span class="comment">// this will be called after the clock was updated by the original method</span></span><br><span class="line">                &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/rovo89/XposedBridge/wiki/Helpers" target="_blank" rel="noopener">XposedHelpers</a>是一个重要的工具类，推荐用Eclipse的同学静态导入该类中的方法 <code>import static de.robv.android.xposed.XposedHelpers.findAndHookMethod;</code>。该类能够通过反射机制来访问方法、构造器、域。<br><code>findAndHookMehthod(String packageName,Class clazz, String methodName, Object... args))</code>方法来对函数进行Hook。如果在方法前和方法后Hook,该方法最后一个参数需要实现<code>XC_MethodHook</code>类的<code>beforeHookedMethod</code>和<code>afterHookedMethod</code>方法，如果想要替换整个方法，则需要实现<code>XC_MethodReplacement</code>类的<code>replaceHookedMethod</code>方法<br>XposedBridge保存了每个Hook方法的回调方法。优先级高的回调方法被优先调用<code>A.before -&gt; B.before -&gt; original method -&gt; B.after -&gt; A.after</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> de.robv.android.xposed.mods.tutorial;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.graphics.Color;</span><br><span class="line"><span class="keyword">import</span> android.webkit.WebView.FindListener;</span><br><span class="line"><span class="keyword">import</span> android.widget.TextView;</span><br><span class="line"><span class="keyword">import</span> de.robv.android.xposed.IXposedHookLoadPackage;</span><br><span class="line"><span class="keyword">import</span> de.robv.android.xposed.XC_MethodHook;</span><br><span class="line"><span class="keyword">import</span> de.robv.android.xposed.XC_MethodHook.MethodHookParam;</span><br><span class="line"><span class="keyword">import</span> de.robv.android.xposed.callbacks.XC_LoadPackage.LoadPackageParam;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> de.robv.android.xposed.XposedHelpers.findAndHookMethod;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Tutorial6</span> <span class="keyword">implements</span> <span class="title">IXposedHookLoadPackage</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleLoadPackage</span><span class="params">(LoadPackageParam param)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!param.packageName.equals(<span class="string">"com.android.systemui"</span>))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">         findAndHookMethod(<span class="string">"com.android.systemui.statusbar.policy.Clock"</span>,param.classLoader, <span class="string">"updateClock"</span>, <span class="keyword">new</span> XC_MethodHook() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">beforeHookedMethod</span><span class="params">(MethodHookParam param)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">                    <span class="comment">// this will be called before the clock was updated by the original method</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">afterHookedMethod</span><span class="params">(MethodHookParam param)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">                    TextView tv = (TextView) param.thisObject;<span class="comment">//获取调用该方法类的对象</span></span><br><span class="line">                    String text = tv.getText().toString();</span><br><span class="line">                    tv.setText(text + <span class="string">" :)"</span>);</span><br><span class="line">                    tv.setTextColor(Color.RED);</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>搭建本文为作者原创 转载时请注明出处 谢谢</strong></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em>乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</em></p>
]]></content>
      <tags>
        <tag>android反编译</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot开发之采用RestTemplate进行第三方网络请求</title>
    <url>/140.html</url>
    <content><![CDATA[<blockquote>
<p>在Spring-Boot开发中，RestTemplate同样提供了对外访问的接口API，这里主要介绍Get和Post方法的使用。Get请求提供了两种方式的接口getForObject 和 getForEntity，getForEntity提供如下三种方法的实现。</p>
</blockquote>
<h3 id="Get请求之——getForEntity-Stringurl-Class-responseType-Object…urlVariables"><a href="#Get请求之——getForEntity-Stringurl-Class-responseType-Object…urlVariables" class="headerlink" title="Get请求之——getForEntity(Stringurl,Class responseType,Object…urlVariables)"></a><strong>Get请求之——getForEntity(Stringurl,Class responseType,Object…urlVariables)</strong></h3><p>该方法提供了三个参数，其中url为请求的地址，responseType为请求响应body的包装类型，urlVariables为url中的参数绑定，该方法的参考调用如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// http://USER-SERVICE/user?name=&#123;name)</span><br><span class="line">RestTemplate restTemplate=new RestTemplate();</span><br><span class="line">Map&lt;String,String&gt; params=new HashMap&lt;&gt;();</span><br><span class="line">params.put(&quot;name&quot;,&quot;dada&quot;);  //</span><br><span class="line">ResponseEntity&lt;String&gt; responseEntity=restTemplate.getForEntity(&quot;http://USERSERVICE/user?name=&#123;name&#125;&quot;,String.class,params);</span><br></pre></td></tr></table></figure>

<h3 id="Get请求之——getForEntity-URI-url-Class-responseType"><a href="#Get请求之——getForEntity-URI-url-Class-responseType" class="headerlink" title="Get请求之——getForEntity(URI url,Class responseType)"></a><strong>Get请求之——getForEntity(URI url,Class responseType)</strong></h3><p>该方法使用URI对象来替代之前的url和urlVariables参数来指定访问地址和参数绑定。URI是JDK <a href="https://link.zhihu.com/?target=http%3A//java.net" target="_blank" rel="noopener">http://java.net</a>包下的一个类，表示一个统一资源标识符(Uniform Resource Identifier)引用。参考如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">RestTemplate restTemplate=new RestTemplate();</span><br><span class="line">UriComponents uriComponents=UriComponentsBuilder.fromUriString(&quot;http://USER-SERVICE/user?name=&#123;name&#125;&quot;)</span><br><span class="line">    .build()</span><br><span class="line">    .expand(&quot;dodo&quot;)</span><br><span class="line">    .encode();</span><br><span class="line">URI uri=uriComponents.toUri();</span><br><span class="line">ResponseEntity&lt;String&gt; responseEntity=restTemplate.getForEntity(uri,String.class).getBody();</span><br></pre></td></tr></table></figure>

<h3 id="Get请求之——getForObject"><a href="#Get请求之——getForObject" class="headerlink" title="Get请求之——getForObject"></a><strong>Get请求之——getForObject</strong></h3><p>getForObject方法可以理解为对getForEntity的进一步封装，它通过HttpMessageConverterExtractor对HTTP的请求响应体body内容进行对象转换，实现请求直接返回包装好的对象内容。getForObject方法有如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">getForObject(String url,Class responseType,Object...urlVariables)</span><br><span class="line">getForObject(String url,Class responseType,Map urlVariables)</span><br><span class="line">getForObject(URI url,Class responseType)</span><br></pre></td></tr></table></figure>

<h3 id="Post-请求"><a href="#Post-请求" class="headerlink" title="Post 请求"></a><strong>Post 请求</strong></h3><p>Post请求提供有三种方法，postForEntity、postForObject和postForLocation。其中每种方法都存在三种方法，postForEntity方法使用如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">RestTemplate restTemplate=new RestTemplate();</span><br><span class="line">User user=newUser(&quot;didi&quot;,30);</span><br><span class="line">ResponseEntity&lt;String&gt; responseEntity=restTemplate.postForEntity(&quot;http://USER-SERVICE/user&quot;,user,String.class); //提交的body内容为user对象，请求的返回的body类型为String</span><br><span class="line">String body=responseEntity.getBody();</span><br></pre></td></tr></table></figure>

<p>postForEntity存在如下三种方法的重载</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">postForEntity(String url,Object request,Class responseType,Object... uriVariables)</span><br><span class="line">postForEntity(String url,Object request,Class responseType,Map uriVariables)</span><br><span class="line">postForEntity(URI url,Object request，Class responseType)</span><br></pre></td></tr></table></figure>

<p>postForEntity中的其它参数和getForEntity的参数大体相同在此不做介绍。</p>
<p><strong>本文为作者原创 转载时请注明出处 谢谢</strong></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em>乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</em></p>
]]></content>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Android Studio快速集成SpringBoot项目</title>
    <url>/139.html</url>
    <content><![CDATA[<h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>主要从事Android开发的小伙伴,偶尔进行后端开发,由于Android Studio是Idea的子系,直接使用Studio进行开发即可,无需另外下载Idea工具</p>
<h2 id="配置环境"><a href="#配置环境" class="headerlink" title="配置环境"></a>配置环境</h2><ul>
<li>Android Studio</li>
<li>Jdk8</li>
<li>gradle-6.1.1</li>
</ul>
<h2 id="快速集成SpringBoot工程"><a href="#快速集成SpringBoot工程" class="headerlink" title="快速集成SpringBoot工程"></a>快速集成SpringBoot工程</h2><ol>
<li><strong>第一步</strong> </li>
</ol>
<p>前往 <a href="https://start.spring.io/下载启动demo" target="_blank" rel="noopener">https://start.spring.io/下载启动demo</a>, 我这里选择的是gradle工程java语言 已经添加web依赖</p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20201019111548.png" alt></p>
<ol start="2">
<li><p><strong>第二步 打开demo工程, 将修改gradle属性文件</strong></p>
<p>这一步为非必需操作, 由于我这边使用的是all版本, 为了节省网络资源,直接复用</p>
</li>
</ol>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20201019111827600.png" alt></p>
<ol start="3">
<li><p><strong>第三步 调整build.gradle文件, 示例如下</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">   buildscript &#123;</span><br><span class="line">	ext &#123;</span><br><span class="line">		springIOVersion = &apos;1.0.10.RELEASE&apos;</span><br><span class="line">		springBootVersion = &apos;1.5.9.RELEASE&apos;</span><br><span class="line">	&#125;</span><br><span class="line">	repositories &#123;</span><br><span class="line">		mavenLocal()</span><br><span class="line">		mavenCentral()</span><br><span class="line">		maven &#123; url &quot;http://repo.spring.io/release&quot; &#125;</span><br><span class="line">		maven &#123; url &quot;http://repo.spring.io/milestone&quot; &#125;</span><br><span class="line">		maven &#123; url &quot;http://repo.spring.io/snapshot&quot; &#125;</span><br><span class="line">		maven &#123; url &quot;https://plugins.gradle.org/m2/&quot; &#125;</span><br><span class="line">	&#125;</span><br><span class="line">	dependencies &#123;</span><br><span class="line">		classpath &quot;io.spring.gradle:dependency-management-plugin:$&#123;springIOVersion&#125;&quot;</span><br><span class="line">		classpath &quot;org.springframework.boot:spring-boot-gradle-plugin:$&#123;springBootVersion&#125;&quot;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">   </span><br><span class="line">   plugins &#123;</span><br><span class="line">  	id &apos;org.springframework.boot&apos; version &apos;1.5.9.RELEASE&apos;// 同步工程提示找不到 如果直接注释不影响启动 无法使用插件打包发布</span><br><span class="line">   	id &apos;io.spring.dependency-management&apos; version &apos;1.0.10.RELEASE&apos;</span><br><span class="line">   	id &apos;java&apos;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   group = &apos;com.example&apos;</span><br><span class="line">   version = &apos;0.0.1-SNAPSHOT&apos;</span><br><span class="line">   sourceCompatibility = &apos;1.8&apos;//默认demo使用的是jdk11 这里根据自身电脑安装的环境进行修改</span><br><span class="line">   </span><br><span class="line">   repositories &#123;//增加国内仓库 加快下载速度</span><br><span class="line">   	mavenCentral()</span><br><span class="line">   	maven&#123;</span><br><span class="line">   		url (&apos;http://maven.aliyun.com/nexus/content/groups/public/&apos;)</span><br><span class="line">   	&#125;</span><br><span class="line">   	google()</span><br><span class="line">   	jcenter()</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   dependencies &#123;</span><br><span class="line">   	compile &apos;org.springframework.boot:spring-boot-starter:2.3.4.RELEASE&apos;</span><br><span class="line">   	compile &apos;org.springframework.boot:spring-boot-starter-web:2.3.4.RELEASE&apos;</span><br><span class="line">   //implementation 打包时打不进 暂时未找到原因 改用 compile</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   test &#123;</span><br><span class="line">   	useJUnitPlatform()</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>第四步 编写接口测试</strong></p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">*注意controller包是在引导类的同一级目录或者子包</span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QuickStartController</span> </span>&#123;</span><br><span class="line">	<span class="meta">@RequestMapping</span>(<span class="string">"/quick"</span>)</span><br><span class="line">	<span class="meta">@ResponseBody</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">quick</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">"hello SpringBoot !"</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>5.<strong>第五步 启动springBoot项目</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">运行引导类的main方法,观察日志</span><br><span class="line"><span class="function">Tomcat started on <span class="title">port</span><span class="params">(s)</span>: 8080 <span class="params">(http)</span> with context path ''</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">说明该项目发布到8080端口,虚拟路径为空,浏览器访问</span></span><br><span class="line"><span class="function">http:localhost:8080/quick</span></span><br></pre></td></tr></table></figure>

<p>至此, 大功告成</p>
<p><strong>本文为作者原创 转载时请注明出处 谢谢</strong></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em>乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</em></p>
]]></content>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot开发之采用Feign进行第三方网络请求</title>
    <url>/141.html</url>
    <content><![CDATA[<p>1、在maven项目中添加依赖</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-feign&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.2.2.RELEASE&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p>2、编写接口，放置在service层</p>
<p>这里的decisionEngine.url 是配置在properties中的 是ip地址和端口号<br>decisionEngine.url=<a href="https://link.zhihu.com/?target=http%3A//10.2.1.148%3A3333/decision/person" target="_blank" rel="noopener">http://10.2.1.148:3333/decision/person</a> 是接口名字</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@FeignClient(url = &quot;$&#123;decisionEngine.url&#125;&quot;,name=&quot;engine&quot;)</span><br><span class="line">public interface DecisionEngineService &#123;</span><br><span class="line">　　@RequestMapping(value=&quot;/decision/person&quot;,method= RequestMethod.POST)</span><br><span class="line">　　public JSONObject getEngineMesasge(@RequestParam(&quot;uid&quot;) String uid,@RequestParam(&quot;productCode&quot;) String productCode);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3、在Java的启动类上加上@EnableFeignClients</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@EnableFeignClients //参见此处</span><br><span class="line">@EnableDiscoveryClient</span><br><span class="line">@SpringBootApplication</span><br><span class="line">@EnableResourceServer</span><br><span class="line">public class Application   implements CommandLineRunner &#123;</span><br><span class="line">    private static final Logger LOGGER = LoggerFactory.getLogger(Application.class);</span><br><span class="line">    @Autowired</span><br><span class="line">    private AppMetricsExporter appMetricsExporter;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private AddMonitorUnitService addMonitorUnitService;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        new SpringApplicationBuilder(Application.class).web(true).run(args);</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4、在代码中调用接口即可</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Autowired</span><br><span class="line">private DecisionEngineService decisionEngineService ;</span><br><span class="line">// ...</span><br><span class="line">decisionEngineService.getEngineMesasge(&quot;uid&quot; ,  &quot;productCode&quot;);</span><br></pre></td></tr></table></figure>

<h3 id><a href="#" class="headerlink" title></a></h3><p><strong>本文为作者原创 转载时请注明出处 谢谢</strong></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em>乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</em></p>
]]></content>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>使用docker部署springboot项目</title>
    <url>/143.html</url>
    <content><![CDATA[<h2 id="部署springboot项目"><a href="#部署springboot项目" class="headerlink" title="部署springboot项目"></a>部署springboot项目</h2><ol>
<li><strong>搜索java镜像</strong></li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker search java</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><strong>拉取java镜像</strong></li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker pull java</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><strong>创建容器 设置端口映射</strong></li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run -id \</span><br><span class="line">-p 8080:8080 \</span><br><span class="line">--name=c_java \</span><br><span class="line">-h c_java \</span><br><span class="line">-v /root/springboot:/root/springboot \</span><br><span class="line">java:latest</span><br></pre></td></tr></table></figure>

<ul>
<li>参数说明<ul>
<li><strong>-p 8080：8080 将容器的8080端口映射到主机的8080端口</strong></li>
<li>*<em>-v /root/springboot:/root/springboot \将主机中当前目录挂载到容器springboot *</em></li>
<li><strong>-h 设置容器的hostname</strong> </li>
<li><strong>$PWD表示当前所在目录</strong></li>
</ul>
</li>
</ul>
<ol start="4">
<li><strong>运行项目</strong></li>
</ol>
<p>将springboot项目jar包传至 /root/springboot目录下,进入刚刚创建的java容器中,</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker exec -it c_java bash</span><br></pre></td></tr></table></figure>

<p> 然后使用java -jar指令运行项目</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">java -jar spring-demo.jar</span><br></pre></td></tr></table></figure>

<ol start="5">
<li><strong>浏览器访问</strong></li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">http://服务器ip:8080</span><br></pre></td></tr></table></figure>

<h4 id="小提示"><a href="#小提示" class="headerlink" title="小提示"></a>小提示</h4><p>如果你是使用的阿里云ECS 测试java和mysql的时候可能会无法访问， 这是因为 阿里云ECS处于安全考虑，默认的安全组规则只开通了22和3389号端口，而我们在实际使用当中可能会需要80、8888、21等端口号，这时只要去阿里云管理后台进行安全组设置新增开放端口号即可</p>
<p><strong>本文为作者原创 转载时请注明出处 谢谢</strong></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em>乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</em></p>
]]></content>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Windows环境下使用ndk-build指令编译c/c++生成so库</title>
    <url>/144.html</url>
    <content><![CDATA[<h2 id="编译环境"><a href="#编译环境" class="headerlink" title="编译环境"></a>编译环境</h2><ul>
<li><p>android-ndk-r9b （这里使用老版本库为例 ，将该库目录下的ndk-build.cmd添加至系统环境变量中，方便后续操作，不同版本的ndk库ndk-build位置可能不太一样，这里你也可以使用最新库）</p>
</li>
<li><p>Windows10</p>
</li>
</ul>
<h2 id="编译步骤"><a href="#编译步骤" class="headerlink" title="编译步骤"></a>编译步骤</h2><ol>
<li><strong>第一步 创建工程文件夹， 这里以E盘下App目录为例</strong></li>
<li><strong>第二步 在App文件夹下创建子文件夹jni， 并将编写好的源代码以及Android.mk文件放入</strong></li>
<li><strong>打开命令窗口，执行编译命令</strong></li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ndk-build.cmd  NDK_PROJECT_PATH=E:\App</span><br></pre></td></tr></table></figure>

<ol start="4">
<li><strong>等待编译 完成后会在jni同级目录下生成libs和obj两个文件夹，libs目录下存放的是编译好的so库，obj目录下存放的是.o链接库, 如果有需要，使用以下命令可以清除obj目录下文件：</strong></li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ndk-build.cmd  clean</span><br></pre></td></tr></table></figure>

<h2 id="编译扩展配置"><a href="#编译扩展配置" class="headerlink" title="编译扩展配置"></a>编译扩展配置</h2><ol>
<li>默认情况下编译只生成armeabi架构的so库，如果要生成x86以及其他cpu架构的so，需要在Android.mk文件所在目录下新建Application.mk文件，并加入以下配置：</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">APP_ABI := armeabi armeabi-v7a x86</span><br><span class="line">或者编译所有架构</span><br><span class="line">APP_ABI := all # 注意必须小写</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>默认情况下使用Andorid.mk作为编译脚本，如果想指定编译脚本文件可以添加<code>APP_BUILD_SCRIPT</code>参数进行指定：</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ndk-build.cmd  NDK_PROJECT_PATH=E:\App APP_BUILD_SCRIPT=new_android.mk</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>默认情况下使用Andorid.mk同级目录下找Application.mk 如果想指定Application.mk文件路径，可以添加<code>NDK_APPLICATION_MK</code>进行指定：</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ndk-build.cmd  NDK_PROJECT_PATH=E:\App NDK_APPLICATION_MK=new_application.mk</span><br></pre></td></tr></table></figure>

<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ol>
<li><p>编译时默认找jni目录下源码进行编译，所以需要在工程目录下新建jni子目录，原因在此</p>
</li>
<li><p>android工程在引用so库时,必须放在对应架构目录下,否则打包apk时会忽略该文件的打包, 比如指定jni目录为libs ,引用的so是x86架构的,那么必须在libs目录下再新建一个名为x86的文件夹,然后将so放进去, 否则so库不打包</p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20201211165808.png" alt></p>
</li>
</ol>
<h2 id="附加"><a href="#附加" class="headerlink" title="附加"></a>附加</h2><p>ndk编译脚本文件Android.mk配置:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">LOCAL_PATH := $(call my-dir)</span><br><span class="line"></span><br><span class="line">include $(CLEAR_VARS)</span><br><span class="line"></span><br><span class="line">LOCAL_MODULE := key #so库引用名称  编译时会自动添加lib前缀，最后的结果为libkey.so</span><br><span class="line">LOCAL_SRC_FILES := Test.cpp # 需要编译的源码</span><br><span class="line"></span><br><span class="line">include $(BUILD_SHARED_LIBRARY)</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em>乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</em></p>
]]></content>
      <tags>
        <tag>ndk</tag>
      </tags>
  </entry>
  <entry>
    <title>使用nginx反向代理后如何获取客户端ip</title>
    <url>/142.html</url>
    <content><![CDATA[<h4 id="一、nginx-反向代理"><a href="#一、nginx-反向代理" class="headerlink" title="一、nginx 反向代理"></a>一、nginx 反向代理</h4><p>nginx反向代理后，在应用中取得的ip都是反向代理服务器的ip，取得的域名也是反向代理配置的url的域名，解决该问题，需要在nginx反向代理配置中添加一些配置信息，目的将客户端的真实ip和域名传递到应用程序中。</p>
<p><strong>nginx反向代理配置时，一般会添加下面的配置：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">`proxy_set_header Host $host;``proxy_set_header X-Real-IP $remote_addr;``proxy_set_header REMOTE-HOST $remote_addr;``proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;`</span><br></pre></td></tr></table></figure>

<p><strong>1. proxy_set_header X-real-ip $remote_addr;</strong></p>
<p>这句话之前已经解释过，有了这句就可以在web服务器端获得用户的真实ip</p>
<p>但是，实际上要获得用户的真实ip，不是只有这一个方法，下面我们继续看。</p>
<p><strong>2.  proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</strong></p>
<p>我们先看看这里有个X-Forwarded-For变量，这是一个squid开发的，用于识别通过HTTP代理或负载平衡器原始IP一个连接到Web服务器的客户机地址的非rfc标准，如果有做X-Forwarded-For设置的话,每次经过proxy转发都会有记录,格式就是client1, proxy1, proxy2,以逗号隔开各个地址，由于他是非rfc标准，所以默认是没有的，需要强制添加，在默认情况下经过proxy转发的请求，在后端看来远程地址都是proxy端的ip 。也就是说在默认情况下我们使用request.getAttribute(“X-Forwarded-For”)获取不到用户的ip，如果我们想要通过这个变量获得用户的ip，我们需要自己在nginx添加如下配置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br></pre></td></tr></table></figure>

<p>意思是增加一个$proxy_add_x_forwarded_for到X-Forwarded-For里去，注意是增加，而不是覆盖，当然由于默认的X-Forwarded-For值是空的，所以我们总感觉X-Forwarded-For的值就等于$proxy_add_x_forwarded_for的值，实际上当你搭建两台nginx在不同的ip上，并且都使用了这段配置，那你会发现在web服务器端通过request.getAttribute(“X-Forwarded-For”)获得的将会是客户端ip和第一台nginx的ip。</p>
<p><strong>那么$proxy_add_x_forwarded_for又是什么？</strong></p>
<p>$proxy_add_x_forwarded_for变量包含客户端请求头中的”X-Forwarded-For”，与$remote_addr两部分，他们之间用逗号分开。</p>
<p>举个例子，有一个web应用，在它之前通过了两个nginx转发，<a href="http://www.linuxidc.com" target="_blank" rel="noopener">www.linuxidc.com</a> 即用户访问该web通过两台nginx。</p>
<p>在第一台nginx中,使用 proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</p>
<p>现在的$proxy_add_x_forwarded_for变量的”X-Forwarded-For”部分是空的，所以只有$remote_addr，而$remote_addr的值是用户的ip，于是赋值以后，X-Forwarded-For变量的值就是用户的真实的ip地址了。</p>
<p>到了第二台nginx，使用 proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</p>
<p>现在的$proxy_add_x_forwarded_for变量，X-Forwarded-For部分包含的是用户的真实ip，$remote_addr部分的值是上一台nginx的ip地址，于是通过这个赋值以后现在的X-Forwarded-For的值就变成了“用户的真实ip，第一台nginx的ip”，这样就清楚了吧。</p>
<p>最后我们看到还有一个$http_x_forwarded_for变量，这个变量就是X-Forwarded-For，由于之前我们说了，默认的这个X-Forwarded-For是为空的，所以当我们直接使用proxy_set_header X-Forwarded-For $http_x_forwarded_for时会发现，web服务器端使用request.getAttribute(“X-Forwarded-For”)获得的值是null。如果想要通过request.getAttribute(“X-Forwarded-For”)获得用户ip，就必须先使用proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;这样就可以获得用户真实ip。</p>
<h4 id="二、Java获取客户端真实IP地址"><a href="#二、Java获取客户端真实IP地址" class="headerlink" title="二、Java获取客户端真实IP地址"></a>二、Java获取客户端真实IP地址</h4><p>在JSP里，获取客户端的IP地址的方法是：request.getRemoteAddr（），这种方法在大部分情况下都是有效的。但是在通过了Apache，Squid等反向代理软件就不能获取到客户端的真实IP地址了。</p>
<p>如果使用了反向代理软件，将<a href="http://192.168.1.110：2046/" target="_blank" rel="noopener">http://192.168.1.110：2046/</a> 的URL反向代理为 <a href="http://www.javapeixun.com.cn" target="_blank" rel="noopener">http://www.javapeixun.com.cn</a> / 的URL时，用request.getRemoteAddr（）方法获取的IP地址是：127.0.0.1　或　192.168.1.110，而并不是客户端的真实IP。</p>
<p>经过代理以后，由于在客户端和服务之间增加了中间层，因此服务器无法直接拿到客户端的IP，服务器端应用也无法直接通过转发请求的地址返回给客户端。但是在转发请求的HTTP头信息中，增加了X－FORWARDED－FOR信息。用以跟踪原有的客户端IP地址和原来客户端请求的服务器地址。当我们访问<a href="http://www.javapeixun.com.cn" target="_blank" rel="noopener">http://www.javapeixun.com.cn</a> /index.jsp/ 时，其实并不是我们浏览器真正访问到了服务器上的index.jsp文件，而是先由代理服务器去访问<a href="http://192.168.1.110：2046/index.jsp" target="_blank" rel="noopener">http://192.168.1.110：2046/index.jsp</a> ，代理服务器再将访问到的结果返回给我们的浏览器，因为是代理服务器去访问index.jsp的，所以index.jsp中通过request.getRemoteAddr（）的方法获取的IP实际上是代理服务器的地址，并不是客户端的IP地址。</p>
<p><strong>于是可得出获得客户端真实IP地址的方法一：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">`public` `String getRemortIP(HttpServletRequest request) &#123; ``  ``if` `(request.getHeader(``&quot;x-forwarded-for&quot;``) == ``null``) &#123; ``    ``return` `request.getRemoteAddr(); ``  ``&#125; ``  ``return` `request.getHeader(``&quot;x-forwarded-for&quot;``); ``&#125;`</span><br></pre></td></tr></table></figure>

<p>可是当我访问<a href="http://www.5a520.cn" target="_blank" rel="noopener">http://www.5a520.cn</a> /index.jsp/ 时，返回的IP地址始终是unknown，也并不是如上所示的127.0.0.1　或　192.168.1.110了，而我访问<a href="http://192.168.1.110：2046/index.jsp" target="_blank" rel="noopener">http://192.168.1.110：2046/index.jsp</a> 时，则能返回客户端的真实IP地址，写了个方法去验证。原因出在了Squid上。squid.conf 的配制文件　forwarded_for 项默认是为on，如果 forwarded_for 设成了 off 　则：X-Forwarded-For： unknown</p>
<p><strong>于是可得出获得客户端真实IP地址的方法二：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">`public` `String getIpAddr(HttpServletRequest request) &#123; ``  ``String ip = request.getHeader(``&quot;x-forwarded-for&quot;``); ``  ``if``(ip == ``null` `|| ip.length() == ``0` `|| ``&quot;unknown&quot;``.equalsIgnoreCase(ip)) &#123; ``    ``ip = request.getHeader(``&quot;Proxy-Client-IP&quot;``); ``  ``&#125; ``  ``if``(ip == ``null` `|| ip.length() == ``0` `|| ``&quot;unknown&quot;``.equalsIgnoreCase(ip)) &#123; ``    ``ip = request.getHeader(``&quot;WL-Proxy-Client-IP&quot;``); ``  ``&#125; ``  ``if``(ip == ``null` `|| ip.length() == ``0` `|| ``&quot;unknown&quot;``.equalsIgnoreCase(ip)) &#123; ``    ``ip = request.getRemoteAddr(); ``  ``&#125; ``  ``return` `ip; ``&#125;`</span><br></pre></td></tr></table></figure>

<p>可是，如果通过了多级反向代理的话，X-Forwarded-For的值并不止一个，而是一串Ｉｐ值，究竟哪个才是真正的用户端的真实IP呢？</p>
<p>答案是取X-Forwarded-For中第一个非unknown的有效IP字符串。</p>
<p>如：X-Forwarded-For：192.168.1.110， 192.168.1.120， 192.168.1.130， 192.168.1.100用户真实IP为： 192.168.1.110</p>
<p><strong>本文为作者原创 转载时请注明出处 谢谢</strong></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em>乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</em></p>
]]></content>
      <tags>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>linux查看系统架构的几种方法</title>
    <url>/146.html</url>
    <content><![CDATA[<blockquote>
<p>有时候,咱们不清楚自己安装的操作系统是什么架构的x86还是arm, 64位还是32位， 可以通过以下指令进行查询</p>
</blockquote>
<h2 id="查看是x86还是arm系统"><a href="#查看是x86还是arm系统" class="headerlink" title="查看是x86还是arm系统"></a>查看是x86还是arm系统</h2><h4 id="1-uname-a-命令"><a href="#1-uname-a-命令" class="headerlink" title="1.uname -a 命令"></a>1.<code>uname -a</code> 命令</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">uname -a  //如果输出带有x86字样即为x86系统 带有arm字样则位arm系统</span><br></pre></td></tr></table></figure>

<h4 id="2-file-命令"><a href="#2-file-命令" class="headerlink" title="2. file 命令"></a>2. <strong>file</strong> 命令</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">file /sbin/init //如果输出带有x86字样即为x86系统</span><br></pre></td></tr></table></figure>

<h2 id="查看系统是64位还是32位"><a href="#查看系统是64位还是32位" class="headerlink" title="查看系统是64位还是32位"></a>查看系统是64位还是32位</h2><h4 id="1-getconf-命令"><a href="#1-getconf-命令" class="headerlink" title="1.getconf 命令"></a>1.getconf 命令</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">getconf LONG_BIT  //如果输出32即为32位系统 输出64即为64位系统</span><br></pre></td></tr></table></figure>

<h4 id="2-dpkg-命令"><a href="#2-dpkg-命令" class="headerlink" title="2.dpkg 命令"></a>2.dpkg 命令</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">dpkg --print-architecturemkdir mydir //如果当前 Linux 是 64 位则输出 amd64，是 32 位则会输出 i386</span><br></pre></td></tr></table></figure>

<h4 id="3-arch-命令"><a href="#3-arch-命令" class="headerlink" title="3.arch 命令"></a>3.arch 命令</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">arch   //如果输出 x86_64 则表示为 64 位系统，如果输出 i686 或 i386 则表示为 32 位系统</span><br></pre></td></tr></table></figure>

<h4 id="4-hostnamectl-指令"><a href="#4-hostnamectl-指令" class="headerlink" title="4. hostnamectl 指令"></a>4. hostnamectl 指令</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hostnamectl</span><br></pre></td></tr></table></figure>

<p>​    如下:<img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20210914145006176.png" alt="image-20210914145006176"></p>
<p><strong>本文为作者原创 转载时请注明出处 谢谢</strong></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em>乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</em></p>
]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>android在adb shell进入linux之后mkdir提示Read-only file system解决方法</title>
    <url>/145.html</url>
    <content><![CDATA[<blockquote>
<p>前提是你手机拥有root权限, 这边以模拟器为例</p>
</blockquote>
<h4 id="1-进入shell模式"><a href="#1-进入shell模式" class="headerlink" title="1.进入shell模式"></a>1.进入shell模式</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">adb shell</span><br></pre></td></tr></table></figure>

<h4 id="2-切换root用户"><a href="#2-切换root用户" class="headerlink" title="2.切换root用户"></a>2.切换root用户</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">su</span><br></pre></td></tr></table></figure>

<h4 id="3-更改system权限"><a href="#3-更改system权限" class="headerlink" title="3.更改system权限"></a>3.更改system权限</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mount -o remount ,rw /</span><br></pre></td></tr></table></figure>

<h4 id="4-接下来即可成功创建文件夹"><a href="#4-接下来即可成功创建文件夹" class="headerlink" title="4.接下来即可成功创建文件夹"></a>4.接下来即可成功创建文件夹</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir mydir</span><br></pre></td></tr></table></figure>

<p><strong>本文为作者原创 转载时请注明出处 谢谢</strong></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em>乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</em></p>
]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>linux 压缩和解压缩命令gz、tar、zip、bz2</title>
    <url>/147.html</url>
    <content><![CDATA[<h2 id="gzip"><a href="#gzip" class="headerlink" title="gzip"></a>gzip</h2><ul>
<li>压缩后的格式为：*.gz</li>
<li>这种压缩方式不能保存原文件；且不能压缩目录</li>
<li>命令举例：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#压缩</span><br><span class="line">[root@localhost tmp]# gzip buodo</span><br><span class="line">[root@localhost tmp]# ls</span><br><span class="line">buodo.gz</span><br><span class="line">#解压</span><br><span class="line">[root@localhost tmp]# gunzip buodo.gz </span><br><span class="line">[root@localhost tmp]# ls</span><br><span class="line">buodo12345678</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="tar"><a href="#tar" class="headerlink" title="tar"></a>tar</h2><ul>
<li>命令选项：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-z(gzip)      用gzip来压缩/解压缩文件</span><br><span class="line">-j(bzip2)     用bzip2来压缩/解压缩文件</span><br><span class="line">-v(verbose)   详细报告tar处理的文件信息</span><br><span class="line">-c(create)    创建新的档案文件</span><br><span class="line">-x(extract)   解压缩文件或目录</span><br><span class="line">-f(file)      使用档案文件或设备，这个选项通常是必选的。123456</span><br></pre></td></tr></table></figure>

<ul>
<li>命令举例：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#压缩</span><br><span class="line">[root@localhost tmp]# tar -zvcf buodo.tar.gz buodo</span><br><span class="line">[root@localhost tmp]# tar -jvcf buodo.tar.bz2 buodo </span><br><span class="line"></span><br><span class="line">#解压</span><br><span class="line">[root@localhost tmp]# tar -zvxf buodo.tar.gz </span><br><span class="line">[root@localhost tmp]# tar -jvxf buodo.tar.bz21234567</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="zip"><a href="#zip" class="headerlink" title="zip"></a>zip</h2><ul>
<li>与gzip相比：1）可以压缩目录； 2）可以保留原文件；</li>
<li>选项：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-r(recursive)    递归压缩目录内的所有文件和目录1</span><br></pre></td></tr></table></figure>

<ul>
<li>命令举例：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#压缩和解压文件</span><br><span class="line">[root@localhost tmp]# zip boduo.zip boduo</span><br><span class="line">[root@localhost tmp]# unzip boduo.zip</span><br><span class="line"></span><br><span class="line">#压缩和解压目录</span><br><span class="line">[root@localhost tmp]# zip -r Demo.zip Demo</span><br><span class="line">  adding: Demo/ (stored 0%)</span><br><span class="line">  adding: Demo/Test2/ (stored 0%)</span><br><span class="line">  adding: Demo/Test1/ (stored 0%)</span><br><span class="line">  adding: Demo/Test1/test4 (stored 0%)</span><br><span class="line">  adding: Demo/test3 (stored 0%)</span><br><span class="line">[root@localhost tmp]# unzip Demo.zip </span><br><span class="line">Archive:  Demo.zip</span><br><span class="line">   creating: Demo/</span><br><span class="line">   creating: Demo/Test2/</span><br><span class="line">   creating: Demo/Test1/</span><br><span class="line"> extracting: Demo/Test1/test4        </span><br><span class="line"> extracting: Demo/test3  123456789101112131415161718</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="bzip2"><a href="#bzip2" class="headerlink" title="bzip2"></a>bzip2</h2><ul>
<li>压缩后的格式：.bz2</li>
<li>参数</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-k    产生压缩文件后保留原文件1</span><br></pre></td></tr></table></figure>

<ul>
<li>命令举例</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#压缩</span><br><span class="line">[root@localhost tmp]# bzip2 boduo</span><br><span class="line">[root@localhost tmp]# bzip2 -k boduo</span><br><span class="line"></span><br><span class="line">#解压</span><br><span class="line">[root@localhost tmp]# bunzip2 boduo.bz2</span><br></pre></td></tr></table></figure>

<p><strong>本文为作者原创 转载时请注明出处 谢谢</strong></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em>乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</em></p>
]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>arm32系统的树莓派4b docker安装32位java镜像并部署springboot项目</title>
    <url>/149.html</url>
    <content><![CDATA[<p>最近通过docker在树莓派上部署springboot项目，然而报错了，因为直接下载的jdk不支持。<br>先看一下之前的docker文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">FROM java:8</span><br><span class="line">ADD meeting-0.0.1-SNAPSHOT.jar /meeting-1.0-SNAPSHOT.jar</span><br><span class="line">EXPOSE 8084</span><br><span class="line">ENTRYPOINT [&quot;java&quot;, &quot;-jar&quot;, &quot;/meeting-1.0-SNAPSHOT.jar&quot;, &quot;&quot;]</span><br><span class="line">1234</span><br></pre></td></tr></table></figure>

<p>这里从docker镜像官网获取的java是64位的，树莓派32位系统不能用，所以需要自己弄一个镜像。<br><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20201026115311.png" alt></p>
<ol>
<li>首先去oracle下载一个32位的arm镜像，我下载了<code>jdk-8u241-linux-arm32-vfp-hflt.tar.gz</code>，注意不能下载错。</li>
<li>将镜像解压缩并放置到Linux的<code>/usr/lib/jvm</code>文件夹下<br><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20201026115325.png" alt></li>
<li>打开文件<code>~/.bashrc</code>，增加以下内容</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nano ~/.bashrc</span><br><span class="line">1</span><br><span class="line">export JAVA_HOME=/usr/lib/jvm/jdk1.8.0_241</span><br><span class="line">export JRE_HOME=$&#123;JAVA_HOME&#125;/jre</span><br><span class="line">export CLASSPATH=.:$&#123;JAVA_HOME&#125;/lib:$&#123;JRE_HOME&#125;/lib</span><br><span class="line">export PATH=$&#123;JAVA_HOME&#125;/bin:$PATH</span><br><span class="line">1234</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20201026115339.png" alt></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20201026115352.png" alt></p>
<ol start="4">
<li>查看是否生效</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">source ~/.bashrc</span><br><span class="line">java -version</span><br><span class="line">12</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20201026115434.png" alt></p>
<ol>
<li>编写Dockerfile文件：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#Docker image of JDK8 in ARM32</span><br><span class="line"># VERSION 8</span><br><span class="line"># Author: yuwen</span><br><span class="line">#基础镜像使用的是OpenJDK官方镜像公用的</span><br><span class="line">FROM buildpack-deps:stretch-scm</span><br><span class="line">#作者</span><br><span class="line">MAINTAINER yuwen &lt;yuwengoku@163.com&gt;</span><br><span class="line"># Default to UTF-8 file.encoding</span><br><span class="line">ENV LANG C.UTF-8</span><br><span class="line">ENV JAVA_HOME /usr/local/jdk8</span><br><span class="line">ENV PATH $JAVA_HOME/bin:$PATH</span><br><span class="line">ENV JDK_FILE jdk-8u241-linux-arm32-vfp-hflt.tar.gz</span><br><span class="line">COPY $JDK_FILE /usr/local/</span><br><span class="line">RUN mkdir -p &quot;$JAVA_HOME&quot;; \</span><br><span class="line">    tar --extract \</span><br><span class="line">		--file /usr/local/$JDK_FILE \</span><br><span class="line">		--directory &quot;$JAVA_HOME&quot; \</span><br><span class="line">		--strip-components 1 \</span><br><span class="line">		--no-same-owner; \</span><br><span class="line">    rm /usr/local/$JDK_FILE</span><br><span class="line">1234567891011121314151617181920</span><br></pre></td></tr></table></figure>

<p>其中，<strong>from</strong>不要修改，<strong>作者</strong>可以修改，其他的不要变化即可。</p>
<ol>
<li>将Dockerfile文件和下载的镜像一起拷贝到同一个目录，并创建镜像<br> <img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20201026115516.png" alt><br>然后执行创建镜像命令：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker build -t arm32jdk:8 .</span><br><span class="line">1</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20201026115529.png" alt><br>\7. 创建好了以后，就可以利用这个我们自己创建的jdk镜像部署springboot项目了<br>我创建自己的springboot项目的Dockerfile文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">FROM arm32jdk:8</span><br><span class="line">ADD meeting-0.0.1-SNAPSHOT.jar /meeting-1.0-SNAPSHOT.jar</span><br><span class="line">EXPOSE 8084</span><br><span class="line">ENTRYPOINT [&quot;java&quot;, &quot;-jar&quot;, &quot;/meeting-1.0-SNAPSHOT.jar&quot;, &quot;&quot;]</span><br><span class="line">1234</span><br></pre></td></tr></table></figure>

<ol>
<li>这里我创建好自己的镜像后，创建容器还遇到了一个问题，就是容器创建默认的时区是中时区，即(UTC+0)<br><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20201026115544.png" alt><br>那么获取的系统时间就不对，所以创建容器的时候需要指定时区为上海(UTC+8)，即东八区：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run --name meeting -e TZ=&quot;Asia/Shanghai&quot; -p 8084:8084 -d --restart=always meeting</span><br><span class="line">1</span><br></pre></td></tr></table></figure>

<p>然后进入容器重新查看时区：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker exec -i -t  gateway-server /bin/bash</span><br><span class="line">date -R</span><br><span class="line">12</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20201026115556.png" alt></p>
<p><strong>本文为作者原创 转载时请注明出处 谢谢</strong></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em>乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</em></p>
]]></content>
      <tags>
        <tag>arm32</tag>
      </tags>
  </entry>
  <entry>
    <title>adb shell中设置android系统linux内部环境变量</title>
    <url>/148.html</url>
    <content><![CDATA[<blockquote>
<p>Android系统本身就是基于linux系统， 有时候我们需要给其配置环境变量，如下操作：</p>
</blockquote>
<h2 id="配置步骤"><a href="#配置步骤" class="headerlink" title="配置步骤"></a>配置步骤</h2><ol>
<li><strong>进入shell环境</strong></li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">adb shell</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><strong>更改system系统为可读写</strong></li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mount -o remount ,rw /</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><strong>将 /system/etc/目录下的 mkshrc文件拉出来进行修改  该文件几位系统环境变量配置文件</strong></li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">adb -s 设备名 pull /system/etc/mkshrc  ./</span><br></pre></td></tr></table></figure>

<ol start="4">
<li><p><strong>使用文本编辑器编辑 mkshrc文件，找到 ${TERM:=vt100} ${HOME:=/data} ${MKSH:=/system/bin/sh}  这么一行</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">&#123;TERM:=vt100&#125; <span class="variable">$&#123;HOME:=/data&#125;</span> <span class="variable">$&#123;MKSH:=/system/bin/sh&#125;</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>将环境变量依葫芦画瓢添加至改行尾部， 如</strong></p>
</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">&#123;TERM:=vt100&#125; <span class="variable">$&#123;HOME:=/data&#125;</span> <span class="variable">$&#123;MKSH:=/system/bin/sh&#125;</span> <span class="variable">$&#123;mypath:=/system/bin/my&#125;</span></span></span><br></pre></td></tr></table></figure>

<ol start="6">
<li><p><strong>然后找到export处，将自己的环境变量加到后面：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export HOME HOSTNAME MKSH SHELL TERM USER mypath</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>将修改完后的mkshrc文件push会Android系统进行替换</strong></p>
</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">adb -s 设备名 push ./mkshrc /system/etc/mkshrc</span><br></pre></td></tr></table></figure>

<ol start="8">
<li><strong>进入shell环境 使用 export 命令即可查看刚刚配置的环境变量参数</strong></li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">export</span><br></pre></td></tr></table></figure>

<p><strong>本文为作者原创 转载时请注明出处 谢谢</strong></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em>乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</em></p>
]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>如何判断客户端是否使用了代理</title>
    <url>/15.html</url>
    <content><![CDATA[<p>要判断客户端是否使用代理服务器，可以从客户端所发送的环境变量信息来判断。</p>
<p>具体来说，就是看HTTP_VIA字段，如果这个字段设置了，说明客户端使用了代理服务器。</p>
<p>匿名级别可以参考下表来判断。</p>
<p>给出一个应用例子，可以挂上代理试试效果: <a href="http://ip.mixsec.org/" target="_blank" rel="noopener">http://ip.mixsec.org/</a></p>
<p><strong>一、没有使用代理服务器的情况</strong>：<br>   REMOTE_ADDR = 您的 IP<br>   HTTP_VIA = 没数值或不显示<br>   HTTP_X_FORWARDED_FOR = 没数值或不显示</p>
<p><strong>二、使用透明代理服务器的情况：</strong>Transparent Proxies</p>
<p>  REMOTE_ADDR = 代理服务器 IP<br>  HTTP_VIA = 代理服务器 IP (<strong>补充：这个字段由代理服务器填充，有时会填充网关信息等</strong>)<br>  HTTP_X_FORWARDED_FOR = 您的真实 IP<br>  这类代理服务器还是将您的信息转发给您的访问对象，无法达到隐藏真实身份的目的。</p>
<p><strong>三、使用普通匿名代理服务器的情况：</strong>Anonymous Proxies<br>  REMOTE_ADDR = 代理服务器 IP<br>  HTTP_VIA = 代理服务器 IP (<strong>补充：这个字段由代理服务器填充，有时会填充网关信息等</strong>)<br>  HTTP_X_FORWARDED_FOR = 代理服务器 IP<br>  隐藏了您的真实IP，但是向访问对象透露了您是使用代理服务器访问他们的。</p>
<p><strong>四、使用欺骗性代理服务器的情况：</strong>Distorting Proxies<br>  REMOTE_ADDR = 代理服务器 IP<br>  HTTP_VIA = 代理服务器 IP (<strong>补充：这个字段由代理服务器填充，有时会填充网关信息等</strong>)<br>  HTTP_X_FORWARDED_FOR = 随机的 IP<br>  告诉了访问对象您使用了代理服务器，但编造了一个虚假的随机IP代替您的真实IP欺骗它。</p>
<p><strong>五、使用高匿名代理服务器的情况：</strong>High Anonymity Proxies<br>  REMOTE_ADDR = 代理服务器 IP<br>  HTTP_VIA = 没数值或不显示<br>  HTTP_X_FORWARDED_FOR = 没数值或不显示<br>  完全用代理服务器的信息替代了您的所有信息，就象您就是完全使用那台代理服务器直接访问对象。</p>
<p>  除此之外，可以通过<a href="http://www.mixsec.org/ip/pj.php" target="_blank" rel="noopener">proxy judges</a>总 结其他一些可供参考的判定信息，一遍于在实践中加以利用。</p>
<p><strong>最后写一个php例子,仅供大家参考:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if(!empty($_SERVER[&apos;HTTP_VIA&apos;]))  //使用了代理</span><br><span class="line">&#123;</span><br><span class="line">  if(!isset($_SERVER[&apos;HTTP_X_FORWARDED_FOR&apos;]))</span><br><span class="line">  &#123;</span><br><span class="line">    //Anonymous Proxies  普通匿名代理服务器</span><br><span class="line"></span><br><span class="line">​    //代理IP地址为 $_SERVER[&apos;REMOTE_ADDR&apos;]</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">  else</span><br><span class="line">  &#123;</span><br><span class="line">    //Transparent Proxies 透明代理服务器</span><br><span class="line">    //代理IP地址为 $_SERVER[&apos;REMOTE_ADDR&apos;]</span><br><span class="line">    //真实ip地址为 $_SERVER[&apos;HTTP_X_FORWARDED_FOR&apos;]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">else  //没有代理或者是高匿名代理</span><br><span class="line">&#123;</span><br><span class="line">  //真实ip地址为 $_SERVER[&apos;REMOTE_ADDR&apos;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>本文为作者原创 转载时请注明出处 谢谢</strong></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em>乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</em></p>
]]></content>
      <tags>
        <tag>后台开发</tag>
      </tags>
  </entry>
  <entry>
    <title>apk逆向工具之脱壳神器反射大师（附脱壳环境搭建、脱壳实战）</title>
    <url>/150.html</url>
    <content><![CDATA[<p>相信点击进入这篇博客的小伙伴都知道并且搞过<code>App</code>逆向，不过有时候会遇到各种加壳的<code>App</code>，不让你反编译。但是<code>道高一尺，魔高一丈</code>，有<code>正向加密</code>，就有<code>逆向解密</code>。此篇博客博主带大家搭建脱壳环境，并且手动脱一个加了某60的壳的<code>App</code>。闲话少叙，直接开始吧！</p>
<h1 id="一、Android系统"><a href="#一、Android系统" class="headerlink" title="一、Android系统"></a>一、<code>Android</code>系统</h1><p>  环境需要一个<code>Android</code>系统，并且系统的版本控制在<code>4.0-6.0</code>之间。建议使用<code>虚拟机</code>/<code>模拟器</code>，不然你还要获取<code>root</code>权限，容易搞坏真机。我这里用的是网易模拟器，<code>Android</code>系统的版本为<code>6.0.1</code>.<br><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20201027142546.png" alt><br><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20201027142531.png" alt></p>
<h1 id="二、安装Xposed框架"><a href="#二、安装Xposed框架" class="headerlink" title="二、安装Xposed框架"></a>二、安装Xposed框架</h1><p>  需要<code>root</code>权限，虚拟机直接允许即可，真机要用第三方工具获取，网上有很多教程。</p>
<h2 id="1、下载Xposed-Installer"><a href="#1、下载Xposed-Installer" class="headerlink" title="1、下载Xposed Installer"></a>1、下载<code>Xposed Installer</code></h2><p>官网地址：<code>https://repo.xposed.info/module/de.robv.android.xposed.installer</code><br> <img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20201027142503.png" alt> </p>
<h2 id="2、安装Xposed-Installer"><a href="#2、安装Xposed-Installer" class="headerlink" title="2、安装Xposed Installer"></a>2、安装<code>Xposed Installer</code></h2><p>下载完毕后，直接拖入模拟器安装即可。然后打开这个App<br><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20201027142438.png" alt><br><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20201027142426.png" alt><br>  由于我之前安装过，所以没提示要root权限，第一次安装的时候会提示授权的，授予即可。</p>
<h1 id="三、安装反射大师"><a href="#三、安装反射大师" class="headerlink" title="三、安装反射大师"></a>三、安装<code>反射大师</code></h1><p>  <code>反射大师</code>是一个支持一键脱壳的神器，貌似什么壳都能脱，不过后面更新的壳会不会添加检测机制就说不清了。。。</p>
<h2 id="1、下载反射大师"><a href="#1、下载反射大师" class="headerlink" title="1、下载反射大师"></a>1、下载<code>反射大师</code></h2><p>下载地址：<code>https://www.lanzous.com/i6x1kaf</code><br><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20201027142411.png" alt></p>
<h2 id="2、安装ReflectMaster并授权"><a href="#2、安装ReflectMaster并授权" class="headerlink" title="2、安装ReflectMaster并授权"></a>2、安装<code>ReflectMaster</code>并授权</h2><p>  直接拖入模拟器中进行安装，然后打开。会提示让你激活Xposed。<br><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20201027142357.png" alt><br><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20201027142344.png" alt><br><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20201027142331.png" alt><br><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20201027142318.png" alt><br>然 后 重 启 模 拟 器 ! \color{red}然后重启模拟器!然后重启模拟器!</p>
<h1 id="四、脱壳实战"><a href="#四、脱壳实战" class="headerlink" title="四、脱壳实战"></a>四、脱壳实战</h1><h2 id="1、安装待脱壳的软件"><a href="#1、安装待脱壳的软件" class="headerlink" title="1、安装待脱壳的软件"></a>1、安装待脱壳的软件</h2><p>  首先在模拟器中安装好待脱壳的软件，用MT管理器可以查看软件加的是什么壳。（<code>反射大师</code>不区分壳类型，是壳都可以脱。）<br><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20201027142303.png" alt></p>
<h2 id="2、用反射大师打开待脱壳App"><a href="#2、用反射大师打开待脱壳App" class="headerlink" title="2、用反射大师打开待脱壳App"></a>2、用<code>反射大师</code>打开待脱壳App</h2><p>  先把软件选中，然后打开待脱壳的App。<br><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20201027142249.png" alt><br><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20201027142236.png" alt><br><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20201027142223.png" alt></p>
<h2 id="3、脱壳-核心步骤"><a href="#3、脱壳-核心步骤" class="headerlink" title="3、脱壳(核心步骤)"></a>3、脱壳(核心步骤)</h2><p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20201027142159.png" alt><br> <img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20201027142134.png" alt><br><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20201027142057.png" alt><br><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20201027142043.png" alt><br><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20201027142025.png" alt><br><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20201027142009.png" alt></p>
<h2 id="4、用jadx反编译"><a href="#4、用jadx反编译" class="headerlink" title="4、用jadx反编译"></a>4、用jadx反编译</h2><p>  jadx工具可以将dex反编译成java代码。<br><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20201027141946.png" alt></p>
<h1 id="五、总结与体会"><a href="#五、总结与体会" class="headerlink" title="五、总结与体会"></a>五、总结与体会</h1><p>  以上就是脱壳环境搭建与脱某60壳实战的主要内容。壳确实脱了，但是没有修复步骤，比如修改<code>Apk</code>中的<code>xml</code>、程序入口等操作。这主要是由于不同的壳，修复步骤不同</p>
<h2 id="六、附上视频教程"><a href="#六、附上视频教程" class="headerlink" title="六、附上视频教程"></a>六、附上视频教程</h2><iframe src="//player.bilibili.com/player.html?aid=669167483&bvid=BV1ba4y1J72d&cid=223857852&page=1&autoplay=no" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>





<p><strong>本文转载自</strong><a href="https://blog.csdn.net/qq_41855420/article/details/106276824" target="_blank" rel="noopener">https://blog.csdn.net/qq_41855420/article/details/106276824</a></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em>乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</em></p>
]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>Android常见App加固厂商脱壳方法的整理</title>
    <url>/152.html</url>
    <content><![CDATA[<h3 id="目录简述（脱壳前学习的知识、壳的历史、脱壳方法）"><a href="#目录简述（脱壳前学习的知识、壳的历史、脱壳方法）" class="headerlink" title="目录简述（脱壳前学习的知识、壳的历史、脱壳方法）"></a>目录简述（脱壳前学习的知识、壳的历史、脱壳方法）</h3><ul>
<li>第一代壳</li>
<li>第二代壳</li>
<li>第三代壳</li>
<li>第N代壳<h4 id="简述Apk文件结构Dex文件结构壳史壳的识别Apk文件结构"><a href="#简述Apk文件结构Dex文件结构壳史壳的识别Apk文件结构" class="headerlink" title="简述Apk文件结构Dex文件结构壳史壳的识别Apk文件结构"></a>简述Apk文件结构Dex文件结构壳史壳的识别Apk文件结构</h4></li>
</ul>
<p><img src="https://img.jbzj.com/file_images/article/201801/2018012720435089.png" alt="1"></p>
<p>Dex文件结构</p>
<p><img src="https://img.jbzj.com/file_images/article/201801/2018012720435091.png" alt="2"></p>
<h3 id="壳史"><a href="#壳史" class="headerlink" title="壳史"></a>壳史</h3><p><strong>第一代壳 Dex加密</strong></p>
<ol>
<li>Dex字符串加密</li>
<li>资源加密</li>
<li>对抗反编译</li>
<li>反调试</li>
<li>自定义DexClassLoader</li>
</ol>
<p><strong>第二代壳 Dex抽取与So加固</strong></p>
<ol>
<li>对抗第一代壳常见的脱壳法</li>
<li>Dex Method代码抽取到外部（通常企业版）</li>
<li>Dex动态加载</li>
<li>So加密</li>
</ol>
<p><strong>第三代壳 Dex动态解密与So混淆</strong></p>
<ol>
<li>Dex Method代码动态解密</li>
<li>So代码膨胀混淆</li>
<li>对抗之前出现的所有脱壳法</li>
</ol>
<p><strong>第四代壳 arm vmp（未来）</strong></p>
<ol>
<li>vmp</li>
</ol>
<h3 id="壳的识别"><a href="#壳的识别" class="headerlink" title="壳的识别"></a>壳的识别</h3><p><strong>1.用加固厂商特征：</strong></p>
<ul>
<li>娜迦： libchaosvmp.so , libddog.solibfdog.so</li>
<li>爱加密：libexec.so, libexecmain.so</li>
<li>梆梆： libsecexe.so, libsecmain.so , libDexHelper.so</li>
<li>360：libprotectClass.so, libjiagu.so</li>
<li>通付盾：libegis.so</li>
<li>网秦：libnqshield.so</li>
<li>百度：libbaiduprotect.so</li>
<li>腾讯御安全:  libshell-super.so, libshella.so</li>
</ul>
<p><strong>2.基于特征的识别代码</strong></p>
<p><img src="https://img.jbzj.com/file_images/article/201801/2018012720435092.png" alt="3"></p>
<h2 id="第一代壳"><a href="#第一代壳" class="headerlink" title="第一代壳"></a>第一代壳</h2><ol>
<li>内存Dump法</li>
<li>文件监视法</li>
<li>Hook法</li>
<li>定制系统</li>
<li>动态调试法</li>
</ol>
<h3 id="内存Dump法"><a href="#内存Dump法" class="headerlink" title="内存Dump法"></a>内存Dump法</h3><ul>
<li><strong>内存中寻找dex.035或者dex.036</strong></li>
<li><strong>/proc/xxx/maps中查找后，手动Dump</strong></li>
</ul>
<p><img src="https://img.jbzj.com/file_images/article/201801/2018012720435093.png" alt="4"></p>
<p><strong>android-unpacker <a href="https://github.com/strazzere/android-unpacker" target="_blank" rel="noopener">https://github.com/strazzere/android-unpacker</a></strong></p>
<p><img src="https://img.jbzj.com/file_images/article/201801/2018012720435094.png" alt="5"></p>
<ul>
<li><p><strong>drizzleDumper <a href="https://link.jianshu.com?t=https://github.com/DrizzleRisk/drizzleDumper" target="_blank" rel="noopener">https://github.com/DrizzleRisk/drizzleDumper</a></strong></p>
</li>
<li><p><strong>升级版的android-unpacker，read和lseek64代替pread，匹配dex代替匹配odex</strong></p>
</li>
</ul>
<p><img src="https://img.jbzj.com/file_images/article/201801/2018012720435095.png" alt="6"></p>
<p><strong>IDA Pro + dumpDEX**</strong>dumpDex <a href="https://github.com/CvvT/dumpDex" target="_blank" rel="noopener">https://github.com/CvvT/dumpDex</a>**</p>
<p><img src="https://img.jbzj.com/file_images/article/201801/2018012720435096.png" alt="7"></p>
<h3 id="文件监视法"><a href="#文件监视法" class="headerlink" title="文件监视法"></a>文件监视法</h3><ul>
<li><strong>Dex优化生成odex</strong></li>
<li><strong>inotifywait-for-Android <a href="https://link.jianshu.com?t=https://github.com/mkttanabe/inotifywait-for-Android" target="_blank" rel="noopener">https://github.com/mkttanabe/inotifywait-for-Android</a></strong></li>
<li><strong>监视文件变化</strong></li>
</ul>
<p><img src="https://img.jbzj.com/file_images/article/201801/2018012720435097.png" alt="8"></p>
<ul>
<li><strong>notifywait-for-Android <a href="https://link.jianshu.com/?t=https://github.com/mkttanabe/inotifywait-for-Android" target="_blank" rel="noopener">https://github.com/mkttanabe/inotifywait-for-Android</a></strong></li>
<li><strong>监视DexOpt输出</strong></li>
</ul>
<p><img src="https://img.jbzj.com/file_images/article/201801/2018012720435098.png" alt="9"></p>
<p><img src="https://img.jbzj.com/file_images/article/201801/2018012720435099.png" alt="10"></p>
<h3 id="Hook法"><a href="#Hook法" class="headerlink" title="Hook法"></a>Hook法</h3><ul>
<li><strong>Hook dvmDexFileOpenPartial</strong></li>
<li><strong><a href="https://link.jianshu.com/?t=http://androidxref.com/4.4_r1/xref/dalvik/vm/DvmDex.cpp" target="_blank" rel="noopener">http://androidxref.com/4.4_r1/xref/dalvik/vm/DvmDex.cpp</a></strong></li>
</ul>
<p><img src="https://img.jbzj.com/file_images/article/201801/20180127204350100.png" alt="11"></p>
<p><img src="https://img.jbzj.com/file_images/article/201801/20180127204350101.png" alt="12"></p>
<h3 id="定制系统"><a href="#定制系统" class="headerlink" title="定制系统"></a>定制系统</h3><ul>
<li><strong>修改安卓源码并刷机</strong></li>
</ul>
<p><img src="https://img.jbzj.com/file_images/article/201801/20180127204350102.png" alt="13"></p>
<ul>
<li><strong>DumpApk <a href="https://link.jianshu.com/?t=https://github.com/CvvT/DumpApk" target="_blank" rel="noopener">https://github.com/CvvT/DumpApk</a></strong></li>
<li><strong>只针对部分壳</strong></li>
</ul>
<p><img src="https://img.jbzj.com/file_images/article/201801/20180127204350103.png" alt="14"></p>
<h3 id="动态调试法"><a href="#动态调试法" class="headerlink" title="动态调试法"></a>动态调试法</h3><ul>
<li><strong>IDA Pro</strong></li>
</ul>
<p><img src="https://img.jbzj.com/file_images/article/201801/20180127204351104.png" alt="15"></p>
<p><img src="https://img.jbzj.com/file_images/article/201801/20180127204351105.png" alt="16"></p>
<p><img src="https://img.jbzj.com/file_images/article/201801/20180127204351106.png" alt="17"></p>
<p><strong>gdb gcore法</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.gdbserver :1234 –attach pid .gdb (gdb) target remote :1234 (gdb) gcore</span><br></pre></td></tr></table></figure>

<p>coredump文件中搜索“dex.035”</p>
<p><img src="https://img.jbzj.com/file_images/article/201801/20180127204351107.png" alt="18"></p>
<h2 id="第二代壳"><a href="#第二代壳" class="headerlink" title="第二代壳"></a>第二代壳</h2><ol>
<li>内存重组法</li>
<li>Hook法</li>
<li>动态调试</li>
<li>定制系统</li>
<li>静态脱壳机</li>
</ol>
<h3 id="内存重组法"><a href="#内存重组法" class="headerlink" title="内存重组法"></a>内存重组法</h3><p><strong>Dex篇</strong></p>
<p>ZjDroid <a href="https://link.jianshu.com?t=http://bbs.pediy.com/showthread.php?t=190494" target="_blank" rel="noopener">http://bbs.pediy.com/showthread.php?t=190494</a></p>
<p>对付一切内存中完整的dex，包括壳与动态加载的jar</p>
<p><img src="https://img.jbzj.com/file_images/article/201801/20180127204351108.png" alt="19"></p>
<p><img src="https://img.jbzj.com/file_images/article/201801/20180127204351109.png" alt="20"></p>
<p><strong>so篇</strong></p>
<p>elfrebuild</p>
<p><img src="https://img.jbzj.com/file_images/article/201801/20180127204351110.png" alt="21"></p>
<p><img src="https://img.jbzj.com/file_images/article/201801/20180127204351111.png" alt="22"></p>
<p>构造soinfo，然后对其进行重建</p>
<p><img src="https://img.jbzj.com/file_images/article/201801/20180127204351112.png" alt="23"></p>
<p><img src="https://img.jbzj.com/file_images/article/201801/20180127204351113.png" alt="24"></p>
<h4 id="Hook法-1"><a href="#Hook法-1" class="headerlink" title="Hook法"></a>Hook法</h4><p>针对无代码抽取且Hook dvmDexFileOpenPartial失败</p>
<p>Hook dexFileParse</p>
<p><a href="http://androidxref.com/4.4_r1/xref/dalvik/vm/DvmDex.cpp" target="_blank" rel="noopener">http://androidxref.com/4.4_r1/xref/dalvik/vm/DvmDex.cpp</a></p>
<p><img src="https://img.jbzj.com/file_images/article/201801/20180127204351114.png" alt="25"></p>
<p><a href="https://github.com/WooyunDota/DumpDex" target="_blank" rel="noopener">https://github.com/WooyunDota/DumpDex</a></p>
<p><img src="https://img.jbzj.com/file_images/article/201801/20180127204351115.png" alt="26"></p>
<p>针对无代码抽取且Hook dexFileParse失败</p>
<p>Hook memcmp</p>
<p><a href="http://androidxref.com/4.4_r1/xref/dalvik/vm/DvmDex.cpp" target="_blank" rel="noopener">http://androidxref.com/4.4_r1/xref/dalvik/vm/DvmDex.cpp</a></p>
<p><img src="https://img.jbzj.com/file_images/article/201801/20180127204351116.png" alt="27"></p>
<p><img src="https://img.jbzj.com/file_images/article/201801/20180127204351117.png" alt="28"></p>
<h4 id="定制系统-1"><a href="#定制系统-1" class="headerlink" title="定制系统"></a>定制系统</h4><p>修改安卓源码并刷机－针对无抽取代码</p>
<p><a href="https://github.com/bunnyblue/DexExtractor" target="_blank" rel="noopener">https://github.com/bunnyblue/DexExtractor</a></p>
<p><img src="https://img.jbzj.com/file_images/article/201801/20180127204351118.png" alt="29"></p>
<p>Hook dexfileParse</p>
<p><img src="https://img.jbzj.com/file_images/article/201801/20180127204351119.png" alt="30"></p>
<p><img src="https://img.jbzj.com/file_images/article/201801/20180127204351120.png" alt="31"></p>
<h3 id="DexHunter-最强大的二代壳脱壳工具"><a href="#DexHunter-最强大的二代壳脱壳工具" class="headerlink" title="DexHunter-最强大的二代壳脱壳工具"></a>DexHunter-最强大的二代壳脱壳工具</h3><p><a href="https://github.com/zyq8709/DexHunter" target="_blank" rel="noopener">https://github.com/zyq8709/DexHunter</a></p>
<p><strong>DexHunter的工作流程：</strong></p>
<p><img src="https://img.jbzj.com/file_images/article/201801/20180127204351121.png" alt="32"></p>
<p>DexHunter的工作原理：</p>
<p><img src="https://img.jbzj.com/file_images/article/201801/20180127204352122.png" alt="33"></p>
<p><strong>绕过三进程反调试</strong></p>
<p><a href="http://bbs.pediy.com/showthread.php?p=1439627" target="_blank" rel="noopener">http://bbs.pediy.com/showthread.php?p=1439627</a></p>
<p><img src="https://img.jbzj.com/file_images/article/201801/20180127204352123.png" alt="34"></p>
<p><img src="https://img.jbzj.com/file_images/article/201801/20180127204352124.png" alt="35"></p>
<p>修改系统源码后：</p>
<p><img src="https://img.jbzj.com/file_images/article/201801/20180127204352125.png" alt="36"></p>
<p><a href="http://www.cnblogs.com/lvcha/p/3903669.html" target="_blank" rel="noopener">http://www.cnblogs.com/lvcha/p/3903669.html</a></p>
<p><img src="https://img.jbzj.com/file_images/article/201801/20180127204352126.png" alt="37"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ls /proc/345/task</span><br></pre></td></tr></table></figure>

<p><img src="https://img.jbzj.com/file_images/article/201801/20180127204352127.png" alt="38"></p>
<p>./gdbserver :1234 –attach346 … (gdb) gcore</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="gcore防Dump解决方案："><a href="#gcore防Dump解决方案：" class="headerlink" title="gcore防Dump解决方案："></a>gcore防Dump解决方案：</h4><p><a href="http://bbs.pediy.com/showthread.php?t=198995" target="_blank" rel="noopener">http://bbs.pediy.com/showthread.php?t=198995</a></p>
<p>断点mmap调试，针对Hook dexFileParse无效</p>
<p>原理： dexopt优化时， dvmContinueOptimization()-&gt;mmap()</p>
<p><img src="https://img.jbzj.com/file_images/article/201801/20180127204352128.png" alt="39"></p>
<p><strong>静态脱壳机</strong></p>
<p>分析壳so逻辑并还原加密算法</p>
<p><a href="http://www.cnblogs.com/2014asm/p/4924342.html" target="_blank" rel="noopener">http://www.cnblogs.com/2014asm/p/4924342.html</a></p>
<p><img src="https://img.jbzj.com/file_images/article/201801/20180127204352129.png" alt="40"></p>
<p><strong>自定义linker脱so壳</strong></p>
<p><a href="https://github.com/devilogic/udog" target="_blank" rel="noopener">https://github.com/devilogic/udog</a></p>
<p>main() -&gt; dump_file()</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="https://img.jbzj.com/file_images/article/201801/20180127204352130.png" alt="41"></p>
<h2 id="第三代壳"><a href="#第三代壳" class="headerlink" title="第三代壳"></a>第三代壳</h2><ol>
<li>dex2oat法</li>
<li>定制系统</li>
</ol>
<h3 id="dex2oat法"><a href="#dex2oat法" class="headerlink" title="dex2oat法"></a>dex2oat法</h3><p>ART模式下，dex2oat生成oat时，内存中的DEX是完整的</p>
<p><a href="https://link.jianshu.com?t=http://bbs.pediy.com/showthread.php?t=210532" target="_blank" rel="noopener">http://bbs.pediy.com/showthread.php?t=210532</a></p>
<p><img src="https://img.jbzj.com/file_images/article/201801/20180127204352131.png" alt="43"></p>
<h4 id="定制系统-2"><a href="#定制系统-2" class="headerlink" title="定制系统"></a>定制系统</h4><p>Hook Dalvik_dalvik_system_DexFile_defineClassNative</p>
<p>枚举所有DexClassDef，对所有的class，调用dvmDefineClass进行强制加载</p>
<p><img src="https://img.jbzj.com/file_images/article/201801/20180127204352132.png" alt="44"></p>
<p>第N代壳so + vmp动态调试 ＋ 人肉还原</p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em>乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</em></p>
]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>逆向工具之unidbg（在pc端模拟执行so文件中的函数）</title>
    <url>/151.html</url>
    <content><![CDATA[<p> 昨天在逆向某<code>App</code>的时候，发现有个加密工具类中的<code>native</code>方法是用<code>C语言</code>编写的，隐藏在<code>so</code>文件中。某大佬推荐逆向工具<code>unidbg</code>，能在<code>pc</code>端直接调用<code>so</code>文件中的函数，最终成功解决了问题。</p>
<h1 id="一、unidbg引入"><a href="#一、unidbg引入" class="headerlink" title="一、unidbg引入"></a>一、<code>unidbg</code>引入</h1><p>  逆向某<code>App</code>，反编译<code>dex</code>得到<code>Java</code>代码，但是有两个加密工具类中的方法放到<code>so</code>文件中。<br><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20201027141909.png" alt><br> <img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20201027141856.png" alt><br><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20201027141819.png" alt><br>  方法的实现用的<code>C语言</code>编写的，放在了<code>so</code>文件中。在<code>Java</code>中，动态加载<code>so</code>文件，使用<code>native</code>方法的形式隐藏了方法的方法体。难道伟大的逆向工程就此放弃？这显然不符合我们技术人的性格，肯定要想方设法弄出来。</p>
<h1 id="二、unidbg概述"><a href="#二、unidbg概述" class="headerlink" title="二、unidbg概述"></a>二、<code>unidbg</code>概述</h1><p>  <code>unidbg</code> 是一个基于 <code>unicorn</code> 的逆向工具，可以直接调用<code>Android</code>和<code>iOS</code>中的 <code>so</code> 文件。项目的<code>GitHub</code>地址为<code>https://github.com/zhkl0228/unidbg</code><br>  我使用<code>unidbg</code>，直接调用<code>libbaseEncryptLib.so</code>、<code>libencryptLib.so</code>中的方法，这样就不用想破脑袋去逆向<code>so</code>文件了。</p>
<p>备 注 : \color{red}备注:备注:<code>so</code>文件是<code>unix</code>系统中的动态连接库，属于二进制文件，作用相当于<code>windows</code>系统中的<code>.dll</code>文件。在<code>Android</code>中也可调用动态库文件(*.so)，一般会将加密算法、密码等重要的方法、信息使用<code>C语言</code>编写，然后编译成<code>so</code>文件，增强了软件的<code>安全性</code>。</p>
<h1 id="三、unidbg使用姿势"><a href="#三、unidbg使用姿势" class="headerlink" title="三、unidbg使用姿势"></a>三、<code>unidbg</code>使用姿势</h1><h2 id="1、下载unidbg项目"><a href="#1、下载unidbg项目" class="headerlink" title="1、下载unidbg项目"></a>1、下载<code>unidbg</code>项目</h2><p>  <strong>下载地址：<code>https://github.com/zhkl0228/unidbg</code></strong><br><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20201027141803.png" alt></p>
<h2 id="2、导入到IDEA中"><a href="#2、导入到IDEA中" class="headerlink" title="2、导入到IDEA中"></a>2、导入到IDEA中</h2><p>  <code>unidbg</code>项目用<code>Java</code>编写，并且上面下载的是一个标准的<code>maven</code>项目。我这里演示导入到<code>IDEA</code>中，如果你熟悉其它的<code>IDE</code>，也可以自己去弄。（顺带一提，如果你之前没接触过Java语言，要确保电脑安装好<code>JDK</code>、<code>maven</code>）</p>
<h3 id="①、解压压缩包"><a href="#①、解压压缩包" class="headerlink" title="①、解压压缩包"></a>①、解压压缩包</h3><p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20201027141749.png" alt></p>
<h3 id="②、打开IDEA，导入解压的项目"><a href="#②、打开IDEA，导入解压的项目" class="headerlink" title="②、打开IDEA，导入解压的项目"></a>②、打开<code>IDEA</code>，导入解压的项目</h3><p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20201027141736.png" alt><br>  浏览到刚刚解压好的文件夹<br> <img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20201027142632.png" alt><br><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20201027141655.png" alt><br>  后面一路无脑<code>next</code>即可。。。<br><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20201027141641.png" alt><br><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20201027141629.png" alt><br><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20201027141613.png" alt><br><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20201027141556.png" alt><br>  第一次导入此项目会自动下载一些<code>jar</code>包，和网速、<code>maven</code>服务器有关，耐心等待吧。<br><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20201027141534.png" alt></p>
<h2 id="3、测试unidbg"><a href="#3、测试unidbg" class="headerlink" title="3、测试unidbg"></a>3、测试<code>unidbg</code></h2><p>  项目中的<code>src/test/java/com/xxxx/frameworks/core/encrypt</code>路径中有一个<code>TTEncrypt</code>测试用例，直接执行其中的<code>main</code>方法。<br><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20201027141521.png" alt></p>
<p>  控制台打印相关调用信息，说明项目导入成功。<br><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20201027141507.png" alt></p>
<h2 id="4、运行自己的so文件"><a href="#4、运行自己的so文件" class="headerlink" title="4、运行自己的so文件"></a>4、运行自己的<code>so</code>文件</h2><p>  在前面，我们不是遇到了<code>libbaseEncryptLib.so</code>、<code>libencryptLib.so</code>文件么，利用<code>unidbg</code>直接调用<code>so</code>文件中 的方法。下面演示调用<code>libencryptLib.so</code>文件中的<code>getGameKey</code>函数。</p>
<h3 id="①、编写EncryptUtilsJni类"><a href="#①、编写EncryptUtilsJni类" class="headerlink" title="①、编写EncryptUtilsJni类"></a>①、编写<code>EncryptUtilsJni</code>类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.hestyle;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.github.unidbg.Module;</span><br><span class="line"><span class="keyword">import</span> com.github.unidbg.arm.ARMEmulator;</span><br><span class="line"><span class="keyword">import</span> com.github.unidbg.linux.android.AndroidARMEmulator;</span><br><span class="line"><span class="keyword">import</span> com.github.unidbg.linux.android.AndroidResolver;</span><br><span class="line"><span class="keyword">import</span> com.github.unidbg.linux.android.dvm.*;</span><br><span class="line"><span class="keyword">import</span> com.github.unidbg.memory.Memory;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * description: EncryptUtils调用so</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> hestyle</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@className</span> unidbg-&gt;EncryptUtilsJni</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020-05-20 22:01</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EncryptUtilsJni</span> <span class="keyword">extends</span> <span class="title">AbstractJni</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ARM模拟器</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ARMEmulator emulator;</span><br><span class="line">    <span class="comment">// vm</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> VM vm;</span><br><span class="line">    <span class="comment">// 载入的模块</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Module <span class="keyword">module</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> DvmClass TTEncryptUtils;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> soFilePath   需要执行的so文件路径</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> classPath    需要执行的函数所在的Java类路径</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">EncryptUtilsJni</span><span class="params">(String soFilePath, String classPath)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 创建app进程，包名可任意写</span></span><br><span class="line">        emulator = <span class="keyword">new</span> AndroidARMEmulator(<span class="string">"cn.hestyle"</span>);</span><br><span class="line">        Memory memory = emulator.getMemory();</span><br><span class="line">        <span class="comment">// 作者支持19和23两个sdk</span></span><br><span class="line">        memory.setLibraryResolver(<span class="keyword">new</span> AndroidResolver(<span class="number">23</span>));</span><br><span class="line">        <span class="comment">// 创建DalvikVM，利用apk本身，可以为null</span></span><br><span class="line">        vm = ((AndroidARMEmulator) emulator).createDalvikVM(<span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">// （关键处1）加载so，填写so的文件路径</span></span><br><span class="line">        DalvikModule dm = vm.loadLibrary(<span class="keyword">new</span> File(soFilePath), <span class="keyword">false</span>);</span><br><span class="line">        <span class="comment">// 调用jni</span></span><br><span class="line">        dm.callJNI_OnLoad(emulator);</span><br><span class="line">        <span class="keyword">module</span> = dm.getModule();</span><br><span class="line">        <span class="comment">// （关键处2）加载so文件中的哪个类，填写完整的类路径</span></span><br><span class="line">        TTEncryptUtils = vm.resolveClass(classPath);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 调用so文件中的指定函数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> methodSign 传入你要执行的函数信息，需要完整的smali语法格式的函数签名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args       是即将调用的函数需要的参数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 函数调用结果</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">myJni</span><span class="params">(String methodSign, Object ...args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 使用jni调用传入的函数签名对应的方法（）</span></span><br><span class="line">        Number ret = TTEncryptUtils.callStaticJniMethod(emulator, methodSign, args);</span><br><span class="line">        <span class="comment">// ret存放返回调用结果存放的地址，获得函数执行后返回值</span></span><br><span class="line">        StringObject str = vm.getObject(ret.intValue() &amp; <span class="number">0xffffffffL</span>);</span><br><span class="line">        <span class="keyword">return</span> str.getValue();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 关闭模拟器</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        emulator.close();</span><br><span class="line">        System.out.println(<span class="string">"emulator destroy..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 1、需要调用的so文件所在路径</span></span><br><span class="line">        String soFilePath = <span class="string">"src/test/resources/myso/libencryptLib.so"</span>;</span><br><span class="line">        <span class="comment">// 2、需要调用函数所在的Java类完整路径，比如a/b/c/d等等，注意需要用/代替.</span></span><br><span class="line">        String classPath = <span class="string">"com/.../EncryptUtils"</span>;</span><br><span class="line">        <span class="comment">// 3、需要调用函数的函数签名，我这里调用EncryptUtils中的getGameKey方法，由于此方法没有参数列表，所以不需要传入</span></span><br><span class="line">        String methodSign = <span class="string">"getGameKey()Ljava/lang/String;"</span>;</span><br><span class="line">        EncryptUtilsJni encryptUtilsJni = <span class="keyword">new</span> EncryptUtilsJni(soFilePath, classPath);</span><br><span class="line">        <span class="comment">// 输出getGameKey方法调用结果</span></span><br><span class="line">        System.err.println(encryptUtilsJni.myJni(methodSign));</span><br><span class="line">        encryptUtilsJni.destroy();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990</span></span><br></pre></td></tr></table></figure>

<h3 id="②、参数说明"><a href="#②、参数说明" class="headerlink" title="②、参数说明"></a>②、参数说明</h3><p>  <code>EncryptUtilsJni</code>类中最重要的设置为<code>main</code>方法中的<code>soFilePath</code>、<code>classPath</code>、<code>methodSign</code>三个参数，它们的作用在main方法中已经注释过了，这里再次解释一下。</p>
<p><code>soFilePath</code>，填写你需要调用的so文件路径<br><code>classPath</code>，填写你需要调用的函数所在Java类的完整类路径。<br><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20201027141448.png" alt><br><code>methodSign</code>，填写你要调用的函数签名，语法为smali。（在<code>jadx</code>中，直接可以看<code>smali</code>代码）</p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20201027141434.png" alt><br>备 注 : \color{red}备注:备注:如果你要调用的函数还需要传入参数，直接传入<code>myJni</code>方法中即可，<code>myJni</code>方法中省略<code>args</code>参数就是供你传入参数。</p>
<h3 id="③、执行结果"><a href="#③、执行结果" class="headerlink" title="③、执行结果"></a>③、执行结果</h3><p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20201027141422.png" alt></p>
<h1 id="四、分析so文件的IDA工具"><a href="#四、分析so文件的IDA工具" class="headerlink" title="四、分析so文件的IDA工具"></a>四、分析<code>so</code>文件的<code>IDA</code>工具</h1><p>  <code>IDA</code>工具是反汇编<code>so</code>文件的强大工具，由于<code>libencryptLib.so</code>文件比较简单，并且<code>getGameKey</code>函数返回的是一个常量，并没有复杂的处理过程，所以可以直接查看。</p>
<p>  首先用<code>IDA</code>打开<code>libencryptLib.so</code>文件<br><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20201027141409.png" alt><br><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20201027141356.png" alt><br><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20201027141341.png" alt><br>  查看反汇编得到的代码。<br><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20201027141326.png" alt><br><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20201027141309.png" alt><br><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20201027141242.png" alt></p>
<h1 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h1><p>  <code>unidbg</code>确实很强大，直接在<code>pc</code>端模拟调用<code>so</code>文件，省去了反汇编逆向<code>so</code>文件的麻烦。上面的教程只演示了<code>unidbg</code>项目的导入、封装自己的调用<code>so</code>文件的<code>API</code>，其实这只是入门了，<code>unidbg</code>还支持断点调试<code>so</code>文件，也能导入到<code>IDA</code>中进行动态调试</p>
<p><strong>本文为作者原创 转载时请注明出处 谢谢</strong></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em>乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</em></p>
]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>apk逆向之so库的破解和调用</title>
    <url>/153.html</url>
    <content><![CDATA[<blockquote>
<p>当你习惯了python的便捷,在逆向安卓是碰到so库的加密分析时,除了使用ida进行函数分析之外,so库的调用也成了一个问题,尤其是遇到只有arm架构的so时,明显感觉到头疼</p>
</blockquote>
<h1 id="so库调用方式尝试"><a href="#so库调用方式尝试" class="headerlink" title="so库调用方式尝试"></a>so库调用方式尝试</h1><h4 id="1-重新编写一个app进行so库的调用-不推荐"><a href="#1-重新编写一个app进行so库的调用-不推荐" class="headerlink" title="1.重新编写一个app进行so库的调用 (不推荐)"></a>1.重新编写一个app进行so库的调用 (不推荐)</h4><p>痛点: </p>
<ul>
<li>前期开发费时费力,</li>
<li>开发完毕后只能运行在真机或者模拟器, </li>
<li>如果要执行定时任务相较python或者javaweb而言效率和性能相差太大</li>
</ul>
<h4 id="2-使用javaweb的形式进行调用-局限性太大，若熟悉树莓派可优选"><a href="#2-使用javaweb的形式进行调用-局限性太大，若熟悉树莓派可优选" class="headerlink" title="2.使用javaweb的形式进行调用(局限性太大，若熟悉树莓派可优选)"></a>2.使用javaweb的形式进行调用(局限性太大，若熟悉树莓派可优选)</h4><p>优势:</p>
<ul>
<li>调试方便</li>
<li>可拉进服务器直接定时执行</li>
</ul>
<p>痛点:</p>
<ul>
<li>如果使用windows的服务器那么只支持x86的so库, linux的服务器同样不支持arm的so库,即便使用docker也无法运行arm的容器, 除非服务器系统是arm架构, 目前现存的arm系统除了android之外估计都在树莓派了</li>
</ul>
<h4 id="３-使用python调用so库（若熟悉树莓派可优选）"><a href="#３-使用python调用so库（若熟悉树莓派可优选）" class="headerlink" title="３.使用python调用so库（若熟悉树莓派可优选）"></a>３.使用python调用so库（若熟悉树莓派可优选）</h4><p>痛点： </p>
<ul>
<li>和上面的问题一样， 不支持arm的so库</li>
</ul>
<h4 id="4-使用-python第三方库-AndroidNativeEmu-调用so-观望"><a href="#4-使用-python第三方库-AndroidNativeEmu-调用so-观望" class="headerlink" title="4.使用 python第三方库 AndroidNativeEmu 调用so(观望)"></a>4.使用 python第三方库 AndroidNativeEmu 调用so(观望)</h4><ul>
<li><p>项目连接:<a href="https://github.com/AeonLucid/AndroidNativeEmu" target="_blank" rel="noopener">https://github.com/AeonLucid/AndroidNativeEmu</a></p>
</li>
<li><p>简介: AndroidNativeEmu是基于Unicron实现的一个指令解析器, 让您能够使用python跨平台模拟安卓虚拟机环境</p>
</li>
<li><p>使用资料参考:</p>
<ul>
<li><a href="https://blog.csdn.net/zhangmiaoping23/article/details/101708171" target="_blank" rel="noopener">https://blog.csdn.net/zhangmiaoping23/article/details/101708171</a></li>
<li><a href="https://blog.csdn.net/qq_26914291/article/details/103395857#Invalid%20get_reference%28%25d%29%E9%97%AE%E9%A2%98" target="_blank" rel="noopener">https://blog.csdn.net/qq_26914291/article/details/103395857#Invalid%20get_reference%28%25d%29%E9%97%AE%E9%A2%98</a></li>
<li><a href="https://www.anquanke.com/post/id/95199" target="_blank" rel="noopener">https://www.anquanke.com/post/id/95199</a></li>
</ul>
</li>
</ul>
<p><strong>痛点</strong>： </p>
<ul>
<li>该库目前只支持简单的函数调用,很多功能还未实现,期待后期的发展</li>
</ul>
<h4 id="5-使用unidbg（推荐）"><a href="#5-使用unidbg（推荐）" class="headerlink" title="5. 使用unidbg（推荐）"></a>5. 使用<code>unidbg</code>（推荐）</h4><p>优势:</p>
<ul>
<li>虚拟jvm环境，支持arm32和arm64的so库</li>
<li>弥补了上面javaweb的不足</li>
</ul>
<p>痛点:</p>
<ul>
<li>该库的原理是从so中寻找函数,面对动态加载的so比较麻烦, 不如原生System.loadXXX加载方便</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>有条件折腾的话还是选择树莓派吧</p>
<h2 id="小记"><a href="#小记" class="headerlink" title="小记"></a>小记</h2><ol>
<li><strong>最近在ubuntu x86 32位的系统上启动springboot调用so库,出现以下问题:</strong></li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/tmp/lib/jniLibs/libkey.so: libstdc++.so: cannot open shared object file: No such file or directory</span><br></pre></td></tr></table></figure>

<p>由于自身能力有限,对C语言不熟,暂时搁置, 来日再处理</p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em>乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</em></p>
]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>android NDK编译涉及的cpu架构种类</title>
    <url>/155.html</url>
    <content><![CDATA[<blockquote>
<p>在使用NDK编译过程中发现针对不同的CPU架构，部分支持编译调试，部分不支持调试，故记录下来，以防忘记</p>
</blockquote>
<p>在Application.mk文件中有个预定义命令参数APP_ABI，是指明编译与调试的CPU架构。</p>
<p>目前Android系统支持以下七种不同的CPU架构：<strong>ARMv5</strong>，<strong>ARMv7</strong>（从2010年起），<strong>x86</strong>（从2011年），<strong>MIPS</strong>（从2012年），<strong>ARMv8</strong>，<strong>MIPS64</strong>和<strong>x86_64</strong>（从2014年），每一种都对应相应的ABI。</p>
<table>
<thead>
<tr>
<th>CPU架构</th>
<th>ABI</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>ARMv5</td>
<td>armeabi</td>
<td>32位，从2010年</td>
</tr>
<tr>
<td>ARMv7</td>
<td>armeabi-v7a</td>
<td>32位，从2010年</td>
</tr>
<tr>
<td>x86</td>
<td>x86</td>
<td>32位，从2011年</td>
</tr>
<tr>
<td>MIPS</td>
<td>mips</td>
<td>32位，从2012年</td>
</tr>
<tr>
<td>ARMv8</td>
<td>arm64-v8a</td>
<td>64位，从2014年</td>
</tr>
<tr>
<td>MIPS64</td>
<td>mips64</td>
<td>64位，从2014年</td>
</tr>
<tr>
<td>x86_64</td>
<td>x86_64</td>
<td>64位，从2014年</td>
</tr>
</tbody></table>
<p><strong>相应生成arm64-v8a，mips64，x86_64下的文件需要NDK_r10以上版本支持</strong>。在Application.mk文件里配置APP_ABI的内容。例如指明某个具体的CPU架构</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">APP_ABI := arm64-v8a</span><br></pre></td></tr></table></figure>

<p>或者直接生成所有的版本</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">APP_ABI := all</span><br></pre></td></tr></table></figure>

<p>注意：根据不同的NDK版本，APP_ABI := all仅能生成当前版本支持的ABI信息库文件，如果需要生成最新的必须更新相应的NDK版本。</p>
<p>或者明确写明支持的CPU架构</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">APP_ABI := armeabi，armeabi-v7a，x86，mips，arm64-v8a，mips64，x86_64</span><br></pre></td></tr></table></figure>

<p>建议采用该方法</p>
<p>注意：由于目前版本支持的问题，采用Eclipse+NDK+Windows集成方式开发，对应编译生成对应CPU架构的so文件是没有问题的。但是不一定可以执行调试工作，启动NDK调试模式时将会提示无法识别对应的ABI。</p>
<p>注意：</p>
<p>(1)、目前模拟器只有x86_64的没有arm64-v8a的；</p>
<p>(2)、在用真机测试armv8-a时，最好先通过<code>adb shell</code>， <code>cat /proc/cpuinfo</code> ，来查看下真机是否是支持armv8-a；</p>
<p>(3)、arm32和arm64有些配置参数不能共存，如-msoft-float仅在arm32位下支持，在arm64位下是不支持的. </p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em>乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</em></p>
]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>Termux：Android 上的一款终端神器</title>
    <url>/156.html</url>
    <content><![CDATA[<p><a href="https://termux.com/" target="_blank" rel="noopener">Termux</a> 是一款基于 Android 平台的开源 Linux 终端模拟器，使用 pkg(apt) 进行软件包的管理。最重要的是，它无需 root 权限，因此，绝大多数 Android 都可以运行。</p>
<p>目前来说，它能做一些简单的 Linux 任务：</p>
<ul>
<li>享受 Bash 和 Zsh</li>
<li>使用 Vim 编辑文件</li>
<li>通过 SSH 访问服务器</li>
<li>使用 GCC 和 Clang 编译代码</li>
<li>使用 Git 检查项目</li>
<li>运行 MySQL，Redis 等服务器</li>
<li>…</li>
</ul>
<h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20201028110821.png" alt></p>
<p>因为 Termux 是一款 Linux 终端模拟器，因此，在命令的使用方面和 Linux 是一致的。在这里，我将介绍一些针对 Termux 工具的一些使用方法。</p>
<h3 id="初次使用的准备工作"><a href="#初次使用的准备工作" class="headerlink" title="初次使用的准备工作"></a>初次使用的准备工作</h3><p>业内已经有了一种共识，在涉及包管理方面，尽量都会将官方源替换成国内镜像源，Termux 也不例外。初次进入 Termux 后，我们可以使用 TUNA 的 <a href="https://mirror.tuna.tsinghua.edu.cn/help/termux/" target="_blank" rel="noopener">Termux 镜像</a>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ sed -i &apos;s@^\(deb.*stable main\)$@#\1\ndeb https://mirrors.tuna.tsinghua.edu.cn/termux stable main@&apos; $PREFIX/etc/apt/sources.list # 更换源文件$ pkg up # 更新源文件$ pkg udpate -y &amp;&amp; pkge upgrade # 更新系统及软件</span><br></pre></td></tr></table></figure>

<p>替换为国内镜像后，接下来，需要开启 Termux 的存储权限：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ termux-setup-storage</span><br></pre></td></tr></table></figure>

<p>执行命令之后，会弹出权限确认窗口，选择「始终允许」即可。</p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20201028110806.png" alt>权限确认</p>
<h3 id="pkg-使用命令速记"><a href="#pkg-使用命令速记" class="headerlink" title="pkg 使用命令速记"></a>pkg 使用命令速记</h3><ul>
<li>pkg search <query>    搜索包</query></li>
<li>pkg install <query> 安装包</query></li>
<li>pkg uninstall <query> 卸载包</query></li>
<li>pkg update 更新源</li>
<li>pkg upgrade 升级软件包</li>
<li>pkg shoe <packge> 显示某个包的详细信息</packge></li>
</ul>
<h3 id="长按屏幕"><a href="#长按屏幕" class="headerlink" title="长按屏幕"></a>长按屏幕</h3><p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20201028110752.png" alt></p>
<p>如果需要对 Termux 中的内容进行复制以及粘贴内容至 Termux，可以通过长按屏幕实现。</p>
<h3 id="额外按键视图"><a href="#额外按键视图" class="headerlink" title="额外按键视图"></a>额外按键视图</h3><p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20201028110737.png" alt></p>
<p>可以看到，在正常的键盘上方，还有一盘额外的功能键，分别是：ESC 键，Tab 键，CTRL 键，ALT 键，- 符号，向下以及向上功能键。有了这一行额外视图，可以更加方便地实现 Android 键盘上没有，而电脑键盘上有的功能。</p>
<h3 id="音量-组合"><a href="#音量-组合" class="headerlink" title="音量+组合"></a>音量+组合</h3><p>因为 Android 键盘没有电脑键盘上的一些功能按键，此时，我们可以通过按住音量键+，再输入键盘某个字母数字键，可以达到一些功能键的作用。</p>
<ul>
<li>音量+ Q：显示/隐藏额外按键视图</li>
<li>音量+数字键：Fx（电脑键盘上的数字功能键)</li>
<li>音量+L：|（管道字符）</li>
<li>音量+H：~（波浪字符）</li>
<li>音量+U：_（下划线字符）</li>
<li>音量+P：上一页</li>
<li>音量+N：下一页</li>
</ul>
<h2 id="一些简单的应用"><a href="#一些简单的应用" class="headerlink" title="一些简单的应用"></a>一些简单的应用</h2><h3 id="HTTP-Server"><a href="#HTTP-Server" class="headerlink" title="HTTP Server"></a>HTTP Server</h3><p>有些时候，我们需要将 Android 上的某些文件发送到其他设备（例如笔记本，分享）。以往的解决方案一般是用微信或者 QQ 来作为中转站，现在，可以利用 Termux 搭建一个简单的文件服务器来实现。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ pkg install python -y # 需要使用 Python$ ifconfig wlan0 # 查看 Android 在局域网中的 IP 地址（我的为 192.168.2.104）$ python -m http.serverServing HTTP on 0.0.0.0 port 8000 (http://0.0.0.0:8000/)...</span><br></pre></td></tr></table></figure>

<p>命令成功运行之后，可以看到输出信息中包含了端口地址（我这里是 8000）。此时，用另外一台处于相同局域网（例如 Wi-Fi）的设备在浏览器地址输入 <code>192.168.2.104:8000</code> 即可访问文件服务器了。</p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20201028110721.png" alt></p>
<h3 id="看起来像黑客"><a href="#看起来像黑客" class="headerlink" title="看起来像黑客"></a>看起来像黑客</h3><p>一提到命令行，怎能少得了那些酷炫的字符如降雨一般，这看起来就很黑客。我们可以通过安装 <code>pkg install cmartix</code> 来实现这种效果。</p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20201028110658.png" alt></p>
<h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p><a href="https://github.com/breathiness/learn-termux" target="_blank" rel="noopener">Learn Termux</a></p>
<p><a href="https://www.sqlsec.com/2018/05/termux.html#toc-heading-2" target="_blank" rel="noopener">Termux 高级终端安装使用配置教程</a></p>
<p><a href="http://www.ruanyifeng.com/blog/2019/07/termux-tutorial.html" target="_blank" rel="noopener">Termux 入门教程：架设手机 Server 下载文件</a></p>
<p>本文转自:<a href="https://sspai.com/post/56031" target="_blank" rel="noopener">https://sspai.com/post/56031</a></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em>乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</em></p>
]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>android原生shell中端可使用的命令</title>
    <url>/154.html</url>
    <content><![CDATA[<blockquote>
<p>android系统本身属于简化版的linux, 有些功能缺失,很多linux命令用不了,这边总结几个可以使用的命令</p>
</blockquote>
<h2 id="首先"><a href="#首先" class="headerlink" title="首先"></a>首先</h2><p>1.使用adb进入shell中端</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">adb -s 设备名 shell</span><br></pre></td></tr></table></figure>

<p>2.更改读写权限,否则无法操作指令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mount -o remount ,rw /</span><br></pre></td></tr></table></figure>

<h2 id="可用指令"><a href="#可用指令" class="headerlink" title="可用指令"></a>可用指令</h2><ol>
<li><strong>ping</strong></li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ping baidu.com</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><strong>cat</strong></li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat xxx.txt //查看文件</span><br><span class="line">cat  /proc/cpuinfo  //查看cpu信息</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><strong>curl</strong></li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl -o xxxxx //下载文件</span><br></pre></td></tr></table></figure>

<ol start="4">
<li><strong>mv</strong></li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mv ./a.txt  ../  //移动文件</span><br></pre></td></tr></table></figure>

<ol start="5">
<li><strong>date</strong></li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">date //查看当前时间</span><br></pre></td></tr></table></figure>

<ol start="6">
<li><strong>top</strong></li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">top //查看当前系统资源消耗</span><br></pre></td></tr></table></figure>

<ol start="7">
<li><strong>调用Dalvik VM执行apk文件</strong></li>
</ol>
<p><strong>创建java文件</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Foo&#123;</span><br><span class="line">    public static void main(String [] args)&#123;</span><br><span class="line">            System.out.println(&quot;Hello, world!haha&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>将.java转换成.class文件</strong></p>
   <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dx --dex --output=foo.apk Foo.class</span><br></pre></td></tr></table></figure>

<p><strong>安装到设备上</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">adb push foo.apk /sdcard/</span><br></pre></td></tr></table></figure>

<p><strong>调用Dalvik VM执行foo.apk</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">adb shell</span><br><span class="line"></span><br><span class="line">dalvikvm -cp /sdcard/foo.apk Foo</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20201103163303.png" alt></p>
<ol start="8">
<li>查看当前Activity信息</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">adb shell dumpsys activity top   //可快速定位当前activity路径</span><br></pre></td></tr></table></figure>

<ol start="9">
<li>命令行启动调试模式 </li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">adb shell am start -D -n packagename/ MainActivity</span><br></pre></td></tr></table></figure>

<ol start="10">
<li>获取进程pid </li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ps | grep packagename</span><br></pre></td></tr></table></figure>

<ol start="11">
<li>建立端口转发</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">adb forward tcp:8700 jdwp:pid</span><br></pre></td></tr></table></figure>

<ol start="12">
<li>查看设备参数</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">getprop  #该指令可以查看设备所有信息 包括cpu 网络 model等等</span><br></pre></td></tr></table></figure>

<ol start="13">
<li>查看设备可用命令</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd system/bin  #该目录下可以查看所有可用的指令</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em>乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</em></p>
]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>python字符串str和字节数组相互转化</title>
    <url>/158.html</url>
    <content><![CDATA[<h2 id="字符串转字节数组"><a href="#字符串转字节数组" class="headerlink" title="字符串转字节数组"></a>字符串转字节数组</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s = <span class="string">"Hello, world!"</span>   <span class="comment"># str object </span></span><br><span class="line"></span><br><span class="line"><span class="comment">#一共有三种方式 任选其一</span></span><br><span class="line">print(<span class="string">'str --&gt; bytes'</span>)</span><br><span class="line">print(bytes(s, encoding=<span class="string">"utf8"</span>))    </span><br><span class="line">print(str.encode(s))   <span class="comment"># 默认 encoding="utf-8"</span></span><br><span class="line">print(s.encode())      <span class="comment"># 默认 encoding="utf-8"</span></span><br></pre></td></tr></table></figure>

<h2 id="字节数组转字符串"><a href="#字节数组转字符串" class="headerlink" title="字节数组转字符串"></a>字节数组转字符串</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">b = <span class="string">b"Hello, world!"</span>  <span class="comment"># bytes object  </span></span><br><span class="line"></span><br><span class="line"><span class="comment">#一共有三种方式 任选其一</span></span><br><span class="line">print(<span class="string">'\nbytes --&gt; str'</span>)</span><br><span class="line">print(str(b, encoding=<span class="string">"utf-8"</span>))   </span><br><span class="line">print(bytes.decode(b))  <span class="comment"># 默认 encoding="utf-8"</span></span><br><span class="line">print(b.decode())       <span class="comment"># 默认 encoding="utf-8"</span></span><br></pre></td></tr></table></figure>

<p><strong>本文为作者原创 转载时请注明出处 谢谢</strong></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em>乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</em></p>
]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python进行DES 加密和解密 解决和java结果不一致的问题</title>
    <url>/159.html</url>
    <content><![CDATA[<h2 id="Python-DES-CBC-加密解密代码示范"><a href="#Python-DES-CBC-加密解密代码示范" class="headerlink" title="Python DES CBC 加密解密代码示范"></a>Python DES CBC 加密解密代码示范</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> binascii</span><br><span class="line"><span class="keyword">from</span> pyDes <span class="keyword">import</span> des, CBC, PAD_PKCS5</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">des_encrypt</span><span class="params">(s)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    DES 加密</span></span><br><span class="line"><span class="string">    :param s: 原始字符串</span></span><br><span class="line"><span class="string">    :return: 加密后字符串，16进制</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    secret_key = <span class="string">'20171117'</span></span><br><span class="line">    iv = secret_key</span><br><span class="line">    k = des(secret_key, CBC, iv, pad=<span class="literal">None</span>, padmode=PAD_PKCS5)</span><br><span class="line">    en = k.encrypt(s, padmode=PAD_PKCS5)</span><br><span class="line">    <span class="keyword">return</span> binascii.b2a_hex(en)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">des_descrypt</span><span class="params">(s)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    DES 解密</span></span><br><span class="line"><span class="string">    :param s: 加密后的字符串，16进制</span></span><br><span class="line"><span class="string">    :return:  解密后的字符串</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    secret_key = <span class="string">'20171117'</span></span><br><span class="line">    iv = secret_key</span><br><span class="line">    k = des(secret_key, CBC, iv, pad=<span class="literal">None</span>, padmode=PAD_PKCS5)</span><br><span class="line">    de = k.decrypt(binascii.a2b_hex(s), padmode=PAD_PKCS5)</span><br><span class="line">    <span class="keyword">return</span> de</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">str_en = des_encrypt(<span class="string">'zx'</span>)</span><br><span class="line">print(str_en)</span><br><span class="line">str_de = des_descrypt(str_en)</span><br><span class="line">print(str_de)</span><br></pre></td></tr></table></figure>

<p>执行以上 Python 代码，得到以下输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1dbbd4e9246ebffa</span><br><span class="line">zx</span><br></pre></td></tr></table></figure>

<h2 id="Java-DES-CBC-加密解密代码示范"><a href="#Java-DES-CBC-加密解密代码示范" class="headerlink" title="Java DES CBC 加密解密代码示范"></a>Java DES CBC 加密解密代码示范</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.crypto.spec.IvParameterSpec;</span><br><span class="line"><span class="keyword">import</span> javax.crypto.Cipher;</span><br><span class="line"><span class="keyword">import</span> javax.crypto.SecretKey;</span><br><span class="line"><span class="keyword">import</span> javax.crypto.SecretKeyFactory;</span><br><span class="line"><span class="keyword">import</span> javax.crypto.spec.DESKeySpec;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class Main &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        String content = <span class="string">"zx"</span>;</span><br><span class="line">        String key = <span class="string">"20171117"</span>;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"加密前："</span> + content);</span><br><span class="line">        byte[] encrypted = DES_CBC_Encrypt(content.getBytes(), key.getBytes());</span><br><span class="line">        System.out.println(<span class="string">"加密后："</span> + byteToHexString(encrypted));</span><br><span class="line"></span><br><span class="line">        byte[] decrypted = DES_CBC_Decrypt(encrypted, key.getBytes());</span><br><span class="line">        System.out.println(<span class="string">"解密后："</span> + new String(decrypted));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static byte[] DES_CBC_Encrypt(byte[] content, byte[] keyBytes) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            DESKeySpec keySpec = new DESKeySpec(keyBytes);</span><br><span class="line">            SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(<span class="string">"DES"</span>);</span><br><span class="line">            SecretKey key = keyFactory.generateSecret(keySpec);</span><br><span class="line"></span><br><span class="line">            Cipher cipher = Cipher.getInstance(<span class="string">"DES/CBC/PKCS5Padding"</span>);</span><br><span class="line">            cipher.init(Cipher.ENCRYPT_MODE, key, new IvParameterSpec(keySpec.getKey()));</span><br><span class="line">            byte[] result = cipher.doFinal(content);</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            System.out.println(<span class="string">"exception:"</span> + e.toString());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static byte[] DES_CBC_Decrypt(byte[] content, byte[] keyBytes) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            DESKeySpec keySpec = new DESKeySpec(keyBytes);</span><br><span class="line">            SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(<span class="string">"DES"</span>);</span><br><span class="line">            SecretKey key = keyFactory.generateSecret(keySpec);</span><br><span class="line"></span><br><span class="line">            Cipher cipher = Cipher.getInstance(<span class="string">"DES/CBC/PKCS5Padding"</span>);</span><br><span class="line">            cipher.init(Cipher.DECRYPT_MODE, key, new IvParameterSpec(keyBytes));</span><br><span class="line">            byte[] result = cipher.doFinal(content);</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            System.out.println(<span class="string">"exception:"</span> + e.toString());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static String byteToHexString(byte[] bytes) &#123;</span><br><span class="line">        StringBuffer sb = new StringBuffer(bytes.length);</span><br><span class="line">        String sTemp;</span><br><span class="line">        <span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt; bytes.length; i++) &#123;</span><br><span class="line">            sTemp = Integer.toHexString(<span class="number">0xFF</span> &amp; bytes[i]);</span><br><span class="line">            <span class="keyword">if</span> (sTemp.length() &lt; <span class="number">2</span>)</span><br><span class="line">                sb.append(<span class="number">0</span>);</span><br><span class="line">            sb.append(sTemp.toUpperCase());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行以上 Java 代码，输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">加密前：zx</span><br><span class="line">加密后：1DBBD4E9246EBFFA</span><br><span class="line">解密后：zx</span><br></pre></td></tr></table></figure>

<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p><strong>python中还有一个库Crypto 也是用于加密的, 但是加密的结果和java不一致, 这是个坑, 以下是Crypto加密的代码, 用于对比:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from Crypto.Cipher import DES</span><br><span class="line">import binascii</span><br><span class="line">import base64</span><br><span class="line"></span><br><span class="line"># data-&gt;被加密的字符串 key-&gt;密钥 同样传入字符串</span><br><span class="line">def des_decode(data, key):</span><br><span class="line">    b_data = base64.b64decode(data)</span><br><span class="line">    iv = key.encode()</span><br><span class="line">    cipher = DES.new(key.encode(), iv,DES.MODE_CBC)</span><br><span class="line">    decrypted = cipher.decrypt(b_data)</span><br><span class="line">    decrypted.rstrip(b&apos; &apos;)</span><br><span class="line">    return decrypted.decode()  # 解密完成后将加密时添加的多余字符&apos;\0&apos;删除</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># data-&gt;被加密的字符串 key-&gt;密钥 同样传入字符串</span><br><span class="line">def aes_encrypt(data, key):</span><br><span class="line">    # DES CBC模式 需向量iv</span><br><span class="line">    iv = key.encode()</span><br><span class="line">    cipher = DES.new(key.encode(),iv, DES.MODE_CBC)</span><br><span class="line">    # 字符串转字节数组</span><br><span class="line">    b_data = data.encode()</span><br><span class="line">    # ------ 按照16位对其 不足的补空格 ----</span><br><span class="line">    block_size = DES.block_size</span><br><span class="line">    count = len(b_data)</span><br><span class="line">    # text不是16的倍数那就补足为16的倍数</span><br><span class="line">    add_count = block_size - (count % block_size)</span><br><span class="line">    s_plaintext = data + (&apos; &apos; * add_count)</span><br><span class="line">    # ------ 按照16位对其 不足的补空格 ----</span><br><span class="line">  </span><br><span class="line">    b_plaintext = s_plaintext.encode()</span><br><span class="line">    encrypted = cipher.encrypt(b_plaintext)  # des加密</span><br><span class="line"></span><br><span class="line">    return base64.b64encode(encrypted).decode()</span><br></pre></td></tr></table></figure>

<p><strong>本文为作者原创 转载时请注明出处 谢谢</strong></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em>乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</em></p>
]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>python中的base64加密解密</title>
    <url>/157.html</url>
    <content><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>Base64是网络上最常见的用于传输8Bit<a href="https://baike.baidu.com/item/字节码/9953683" target="_blank" rel="noopener">字节码</a>的编码方式之一，Base64就是一种基于64个可打印字符来表示<a href="https://baike.baidu.com/item/二进制/361457" target="_blank" rel="noopener">二进制</a>数据的方法。可查看RFC2045～RFC2049，上面有MIME的详细规范。</p>
<p>Base64编码是从二进制到字符的过程，可用于在<a href="https://baike.baidu.com/item/HTTP" target="_blank" rel="noopener">HTTP</a>环境下传递较长的标识信息。采用Base64编码具有不可读性，需要解码后才能阅读。</p>
<p>Base64由于以上优点被广泛应用于计算机的各个领域，然而由于输出内容中包括两个以上“符号类”字符（+, /, =)，不同的应用场景又分别研制了Base64的各种“变种”。为统一和规范化Base64的输出，Base62x被视为无符号化的改进版本。</p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20201029122454.png" alt></p>
<h1 id="python中的base64"><a href="#python中的base64" class="headerlink" title="python中的base64"></a>python中的base64</h1><h3 id="将url编码成base64"><a href="#将url编码成base64" class="headerlink" title="将url编码成base64"></a>将url编码成base64</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 想将字符串转编码成base64,要先将字符串转换成二进制数据</span><br><span class="line">url = &quot;https://www.cnblogs.com/songzhixue/&quot;</span><br><span class="line">bytes_url = url.encode(&quot;utf-8&quot;)</span><br><span class="line">str_url = base64.b64encode(bytes_url)  # 被编码的参数必须是二进制数据</span><br><span class="line">print(str_url)</span><br><span class="line"></span><br><span class="line">b&apos;aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vc29uZ3poaXh1ZS8=&apos;</span><br></pre></td></tr></table></figure>

<h3 id="解码base64"><a href="#解码base64" class="headerlink" title="解码base64"></a>解码base64</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 将base64解码成字符串</span><br><span class="line">import base64</span><br><span class="line">url = &quot;aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vc29uZ3poaXh1ZS8=&quot;</span><br><span class="line">str_url = base64.b64decode(url).decode(&quot;utf-8&quot;)</span><br><span class="line">print(str_url)</span><br><span class="line"></span><br><span class="line">&apos;https://www.cnblogs.com/songzhixue/&apos;</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>python中base64不论是编码还是解码，返回值都为字节数组</li>
<li>解码解的是字符串， 编码编的是字节数组</li>
</ul>
<p><strong>本文为作者原创 转载时请注明出处 谢谢</strong></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em>乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</em></p>
]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Create Spring Boot Project With Android Studio</title>
    <url>/161.html</url>
    <content><![CDATA[<h2 id="Step-1"><a href="#Step-1" class="headerlink" title="Step 1"></a>Step 1</h2><h3 id="Modify-build-gradle"><a href="#Modify-build-gradle" class="headerlink" title="Modify build.gradle"></a>Modify build.gradle</h3><ol>
<li><strong>Module Dir</strong></li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">apply plugin: <span class="string">'org.springframework.boot'</span></span><br><span class="line">apply plugin: <span class="string">'java'</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">    implementation fileTree(dir: <span class="string">"libs"</span>, include: [<span class="string">"*.jar"</span>])</span><br><span class="line">    compile <span class="string">'org.springframework.boot:spring-boot-starter:2.3.4.RELEASE'</span></span><br><span class="line">    compile <span class="string">'org.springframework.boot:spring-boot-starter-web:2.3.4.RELEASE'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><strong>Project Dir</strong></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">buildscript &#123;</span><br><span class="line">    ext &#123;</span><br><span class="line">        springBootVersion = <span class="string">'1.5.9.RELEASE'</span></span><br><span class="line">    &#125;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        mavenLocal()</span><br><span class="line">        mavenCentral()</span><br><span class="line">    &#125;</span><br><span class="line">    dependencies &#123;</span><br><span class="line">        classpath <span class="string">"org.springframework.boot:spring-boot-gradle-plugin:$&#123;springBootVersion&#125;"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">allprojects &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        google()</span><br><span class="line">        jcenter()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">task <span class="title">clean</span><span class="params">(type: Delete)</span> </span>&#123;</span><br><span class="line">    delete rootProject.buildDir</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Step-2"><a href="#Step-2" class="headerlink" title="Step 2"></a>Step 2</h2><ol>
<li><strong>Rename Res dir And create application.properties</strong></li>
<li><strong>delete useless files</strong></li>
</ol>
<h2 id="Step-3"><a href="#Step-3" class="headerlink" title="Step 3"></a>Step 3</h2><ol>
<li><p><strong>Create Boot Point Class DemoApplication.java</strong></p>
</li>
<li><p><strong>Create Control</strong> </p>
</li>
<li><p><strong>Boot And Test</strong></p>
</li>
<li><p><strong>Package Jar</strong></p>
</li>
</ol>
<p><strong>本文为作者原创 转载时请注明出处 谢谢</strong></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em>乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</em></p>
]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>关于Andriod热更新</title>
    <url>/16.html</url>
    <content><![CDATA[<p>项目场景：</p>
<ul>
<li>紧急发现了一个bug，影响用户体验，阻断项目流程。这个时候，只能紧急发布一个强制更新的新版本，让用户升级。</li>
<li>最近百团大战开始。需要增加一个活动弹窗入口，越快越好。这个时候，只能紧急发布一个强制更新的新版本，让用户升级。</li>
</ul>
<p>存在需求：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">可不可以不让用户重新安装就可以解决上述场景？</span><br></pre></td></tr></table></figure>

<h3 id="什么是热更新："><a href="#什么是热更新：" class="headerlink" title="什么是热更新："></a>什么是热更新：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">让应用能够在无需重新安装的情况实现更新，帮助应用快速建立动态修复能力。</span><br></pre></td></tr></table></figure>

<p>从上面的定义来看，热补丁节省Android大量应用市场发布的时间。同时用户也无需重新安装，只要上线就能无感知的更新。</p>
<h3 id="热更新的原理："><a href="#热更新的原理：" class="headerlink" title="热更新的原理："></a>热更新的原理：</h3><p>现在市面上主流的几大热更新技术：</p>
<ul>
<li>淘宝 Dexposed</li>
<li>支付宝 AndFix</li>
<li>Qzone 超级热补丁</li>
<li>微信 Tinker</li>
</ul>
<h4 id="Dexposed"><a href="#Dexposed" class="headerlink" title="Dexposed"></a>Dexposed</h4><p>基于 Xposed 实现的无侵入的运行时 AOP (Aspect-oriented Programming) 框架，可以实现在线修复 Bug，修复粒度方法级别，这也就意味着我们没有办法进行类的增减操作。而且由于对 ART 虚拟机不支持，导致其对 Android 5.0、6.0 均不支持，使用局限性太大。</p>
<h3 id="AndFix"><a href="#AndFix" class="headerlink" title="AndFix"></a>AndFix</h3><p>native hook 方式，其核心部分在 JNI 层对方法进行替换，替换有问题的方法,修复粒度方法级别，无法在类中新增和删减字段，可以做到即时生效。也就是运行时生效。但是因为它的核心部分在JNI，所以会出现很多适配兼容的问题。因为国内的rom厂商多才多艺.</p>
<h3 id="超级热补丁"><a href="#超级热补丁" class="headerlink" title="超级热补丁"></a>超级热补丁</h3><p>使用新的 ClassLoader 加载 patch.dex，hack 默认的 ClassLoader，替换有问题的类，修复粒度类级别，一般无法做到即时生效，需要在应用下一次启动时生效。但是在art虚拟机中，如果改变了类变量，和方法名，有可能导致内存错乱的问题，没有开源这个项目。但在github上的Nuwa采用了相同的方式，这个是开源。</p>
<h3 id="Tinker"><a href="#Tinker" class="headerlink" title="Tinker"></a>Tinker</h3><p>dex 文件全量替换，基于 DexDiff 技术，对比修复前后的 dex 文件，生成 patch.dex，再根据 patch.dex 更新有问题的 dex 文件。简单来说，在编译时通过新旧两个Dex生成差异patch.dex。在运行时，将差异patch.dex重新跟原始安装包的旧Dex还原为新的Dex。这个过程可能比较耗费时间与内存，所以我们是单独放在一个后台进程:patch中。为了补丁包尽量的小，微信自研了DexDiff算法，它深度利用Dex的格式来减少差异的大小。</p>
<h3 id="热更新方案的比较："><a href="#热更新方案的比较：" class="headerlink" title="热更新方案的比较："></a>热更新方案的比较：</h3><table>
<thead>
<tr>
<th align="left">Tables</th>
<th align="left">Tinker</th>
<th align="left">Qzone</th>
<th align="left">Andfix</th>
<th align="left">Dexposed</th>
</tr>
</thead>
<tbody><tr>
<td align="left">类替换</td>
<td align="left">yes</td>
<td align="left">yes</td>
<td align="left">no</td>
<td align="left">no</td>
</tr>
<tr>
<td align="left">lib替换</td>
<td align="left">yes</td>
<td align="left">no</td>
<td align="left">no</td>
<td align="left">no</td>
</tr>
<tr>
<td align="left">资源替换</td>
<td align="left">yes</td>
<td align="left">yes</td>
<td align="left">no</td>
<td align="left">no</td>
</tr>
<tr>
<td align="left">全平台支持</td>
<td align="left">yes</td>
<td align="left">yes</td>
<td align="left">yes</td>
<td align="left">no</td>
</tr>
<tr>
<td align="left">即时生效</td>
<td align="left">no</td>
<td align="left">no</td>
<td align="left">yes</td>
<td align="left">yes</td>
</tr>
<tr>
<td align="left">性能损耗</td>
<td align="left">较小</td>
<td align="left">较大</td>
<td align="left">较小</td>
<td align="left">较小</td>
</tr>
<tr>
<td align="left">补丁包大小</td>
<td align="left">较小</td>
<td align="left">较大</td>
<td align="left">一般</td>
<td align="left">一般</td>
</tr>
<tr>
<td align="left">开发透明</td>
<td align="left">yes</td>
<td align="left">yes</td>
<td align="left">no</td>
<td align="left">no</td>
</tr>
<tr>
<td align="left">复杂度</td>
<td align="left">较低</td>
<td align="left">较低</td>
<td align="left">复杂</td>
<td align="left">复杂</td>
</tr>
<tr>
<td align="left">gradle支持</td>
<td align="left">yes</td>
<td align="left">yes</td>
<td align="left">no</td>
<td align="left">no</td>
</tr>
<tr>
<td align="left">接口文档</td>
<td align="left">丰富</td>
<td align="left">一般</td>
<td align="left">一般</td>
<td align="left">较少</td>
</tr>
<tr>
<td align="left">占rom体积</td>
<td align="left">较大</td>
<td align="left">较小</td>
<td align="left">较小</td>
<td align="left">较小</td>
</tr>
<tr>
<td align="left">成功率</td>
<td align="left">较好</td>
<td align="left">最高</td>
<td align="left">一般</td>
<td align="left">一般</td>
</tr>
</tbody></table>
<h3 id="热更新的使用场景："><a href="#热更新的使用场景：" class="headerlink" title="热更新的使用场景："></a>热更新的使用场景：</h3><p>热补丁技术也可以理解为一个动态修改代码与资源的通道，它适合于修改量较少的情况。</p>
<p>我们看一下微信的版本升级的情况：</p>
<table>
<thead>
<tr>
<th align="left">Tables</th>
<th align="left">普通升级</th>
<th align="left">布丁升级</th>
</tr>
</thead>
<tbody><tr>
<td align="left">数据大小</td>
<td align="left">33M</td>
<td align="left">145K</td>
</tr>
<tr>
<td align="left">更新速度</td>
<td align="left">10天</td>
<td align="left">1天（70%）</td>
</tr>
<tr>
<td align="left">自动升级</td>
<td align="left">wifi</td>
<td align="left">移动网络</td>
</tr>
</tbody></table>
<p>以Android用户的升级习惯，即使是相对活跃的微信也需要10天以上的时间去覆盖50%的用户。使用补丁技术，我们能做到1天覆盖70%以上。这也是基于补丁体积较小，可以直接使用移动网络下载更新。</p>
<h3 id="热更新使用限制"><a href="#热更新使用限制" class="headerlink" title="热更新使用限制"></a>热更新使用限制</h3><ul>
<li>补丁只能针对单一客户端版本，随着版本差异变大补丁体积也会增大；</li>
<li>补丁不能支持所有的修改，例如AndroidManifest；</li>
<li>补丁无论对代码还是资源的更新成功率都无法达到100%。</li>
</ul>
<h3 id="如何在一个项目中增加热更新功能？"><a href="#如何在一个项目中增加热更新功能？" class="headerlink" title="如何在一个项目中增加热更新功能？"></a>如何在一个项目中增加热更新功能？</h3><ul>
<li><p>在工程目录 build.gradle 文件中添加插件依赖。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">buildscript &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        jcenter()</span><br><span class="line">    &#125;</span><br><span class="line">    dependencies &#123;</span><br><span class="line">        // tinkersupport插件，其中latest.release指代最新版本号，也可以指定明确的版本号，例如1.0.8</span><br><span class="line">        classpath &quot;com.tencent.bugly:tinker-support:latest.release&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在app module 下的build.gradle 文件中添加 配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">      compile &quot;com.android.support:multidex:1.0.1&quot; </span><br><span class="line">      compile &apos;com.tencent.bugly:crashreport_upgrade:latest.release&apos;</span><br><span class="line">&#125;</span><br><span class="line">// 依赖插件脚本</span><br><span class="line">apply from: &apos;tinker-support.gradle&apos;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在同级目录下创建 tinker-support.gradle</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apply plugin: &apos;com.tencent.bugly.tinker-support&apos;</span><br><span class="line"></span><br><span class="line">def bakPath = file(&quot;$&#123;buildDir&#125;/bakApk/&quot;)</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 此处填写每次构建生成的基准包目录</span><br><span class="line"> */</span><br><span class="line">def baseApkDir = &quot;app-0912-17-04-44&quot;</span><br><span class="line">/**</span><br><span class="line"> * 对于插件各参数的详细解析请参考</span><br><span class="line"> */</span><br><span class="line">tinkerSupport &#123;</span><br><span class="line"></span><br><span class="line">    // 开启tinker-support插件，默认值true</span><br><span class="line">    enable = true</span><br><span class="line"></span><br><span class="line">    //自动生成tinkerId，无须关注此。默认为false</span><br><span class="line">    //autoGenerateTinkerId = true</span><br><span class="line"></span><br><span class="line">    tinkerEnable = true</span><br><span class="line"></span><br><span class="line">    // 指定归档目录，默认值当前module的子目录tinker</span><br><span class="line">    autoBackupApkDir = &quot;$&#123;bakPath&#125;&quot;</span><br><span class="line"></span><br><span class="line">    // 是否启用覆盖tinkerPatch配置功能，默认值false</span><br><span class="line">    // 开启后tinkerPatch配置不生效，即无需添加tinkerPatch</span><br><span class="line">    overrideTinkerPatchConfiguration = true</span><br><span class="line"></span><br><span class="line">    // 编译补丁包时，必需指定基线版本的apk，默认值为空</span><br><span class="line">    // 如果为空，则表示不是进行补丁包的编译</span><br><span class="line">    // @&#123;link tinkerPatch.oldApk &#125;</span><br><span class="line">    baseApk = &quot;$&#123;bakPath&#125;/$&#123;baseApkDir&#125;/com.nongfenqi.sherlock-release-v2.3.2_32.apk&quot;</span><br><span class="line">    // 对应tinker插件applyMapping</span><br><span class="line">    baseApkProguardMapping = &quot;$&#123;bakPath&#125;/$&#123;baseApkDir&#125;/app-release-mapping.txt&quot;</span><br><span class="line"></span><br><span class="line">    // 对应tinker插件applyResourceMapping</span><br><span class="line">    baseApkResourceMapping = &quot;$&#123;bakPath&#125;/$&#123;baseApkDir&#125;/app-release-R.txt&quot;</span><br><span class="line"></span><br><span class="line">    // 构建基准包和补丁包都要指定不同的tinkerId，并且必须保证唯一性</span><br><span class="line">    tinkerId = &quot;2.3.2-0912-patch&quot;</span><br><span class="line"></span><br><span class="line">    // 构建多渠道补丁时使用</span><br><span class="line">    // buildAllFlavorsDir = &quot;$&#123;bakPath&#125;/$&#123;baseApkDir&#125;&quot;</span><br><span class="line"></span><br><span class="line">    // 是否启用加固模式，默认为false.(tinker-spport 1.0.7起支持）</span><br><span class="line">    // isProtectedApp = true</span><br><span class="line"></span><br><span class="line">    // 是否开启反射Application模式</span><br><span class="line">    enableProxyApplication = false</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 一般来说,我们无需对下面的参数做任何的修改</span><br><span class="line"> * 对于各参数的详细介绍请参考:</span><br><span class="line"> * https://github.com/Tencent/tinker/wiki/Tinker-%E6%8E%A5%E5%85%A5%E6%8C%87%E5%8D%97</span><br><span class="line"> */</span><br><span class="line">tinkerPatch &#123;</span><br><span class="line">    //oldApk =&quot;$&#123;bakPath&#125;/$&#123;appName&#125;/app-release.apk&quot;</span><br><span class="line">    tinkerEnable = true</span><br><span class="line">    ignoreWarning = false</span><br><span class="line">    useSign = true</span><br><span class="line">    dex &#123;</span><br><span class="line">        dexMode = &quot;jar&quot;</span><br><span class="line">        pattern = [&quot;classes*.dex&quot;]</span><br><span class="line">        loader = []</span><br><span class="line">    &#125;</span><br><span class="line">    lib &#123;</span><br><span class="line">        pattern = [&quot;lib/*/*.so&quot;]</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    res &#123;</span><br><span class="line">        pattern = [&quot;res/*&quot;, &quot;r/*&quot;, &quot;assets/*&quot;, &quot;resources.arsc&quot;, &quot;AndroidManifest.xml&quot;]</span><br><span class="line">        ignoreChange = []</span><br><span class="line">        largeModSize = 100</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    packageConfig &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    sevenZip &#123;</span><br><span class="line">        zipArtifact = &quot;com.tencent.mm:SevenZip:1.1.10&quot;</span><br><span class="line">//        path = &quot;/usr/local/bin/7za&quot;</span><br><span class="line">    &#125;</span><br><span class="line">    buildConfig &#123;</span><br><span class="line">        keepDexApply = false</span><br><span class="line">        //tinkerId = &quot;1.0.1-base&quot;</span><br><span class="line">        //applyMapping = &quot;$&#123;bakPath&#125;/$&#123;appName&#125;/app-release-mapping.txt&quot; //  可选，设置mapping文件，建议保持旧apk的proguard混淆方式</span><br><span class="line">        //applyResourceMapping = &quot;$&#123;bakPath&#125;/$&#123;appName&#125;/app-release-R.txt&quot; // 可选，设置R.txt文件，通过旧apk文件保持ResId的分配</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>权限配置以及activity配置。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;uses-permission android:name=&quot;android.permission.READ_PHONE_STATE&quot; /&gt;</span><br><span class="line">&lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt;</span><br><span class="line">&lt;uses-permission android:name=&quot;android.permission.ACCESS_NETWORK_STATE&quot; /&gt;</span><br><span class="line">&lt;uses-permission android:name=&quot;android.permission.ACCESS_WIFI_STATE&quot; /&gt;</span><br><span class="line">&lt;uses-permission android:name=&quot;android.permission.READ_LOGS&quot; /&gt;</span><br><span class="line">&lt;uses-permission android:name=&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot; /&gt;</span><br><span class="line">&lt;uses-permission android:name=&quot;android.permission.READ_EXTERNAL_STORAGE&quot;/&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;activity</span><br><span class="line">    android:name=&quot;com.tencent.bugly.beta.ui.BetaActivity&quot;</span><br><span class="line">    android:theme=&quot;@android:style/Theme.Translucent&quot; /&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>混淆配置</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">-dontwarn com.tencent.bugly.**</span><br><span class="line">-keep public <span class="class"><span class="keyword">class</span> <span class="title">com</span>.<span class="title">tencent</span>.<span class="title">bugly</span>.**</span>&#123;*;&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p><strong>本文转载自：<a href="https://www.dazhuanlan.com/2019/12/31/5e0b56c7943ed/" target="_blank" rel="noopener">https://www.dazhuanlan.com/2019/12/31/5e0b56c7943ed/</a></strong></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em>乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</em></p>
]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>Python DES EBC 加密解密代码示范</title>
    <url>/160.html</url>
    <content><![CDATA[<h2 id="Python-DES-EBC-加密解密代码示范"><a href="#Python-DES-EBC-加密解密代码示范" class="headerlink" title="Python DES EBC 加密解密代码示范"></a>Python DES EBC 加密解密代码示范</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pyDes <span class="keyword">import</span> des, ECB, PAD_PKCS5</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">des_encrypt</span><span class="params">(s)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    DES 加密</span></span><br><span class="line"><span class="string">    :param s: 原始字符串</span></span><br><span class="line"><span class="string">    :return: 加密后字符串，16进制</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    secret_key = <span class="string">'ucserver'</span>.encode()</span><br><span class="line"></span><br><span class="line">    k = des(secret_key, ECB, pad=<span class="literal">None</span>, padmode=PAD_PKCS5)</span><br><span class="line">    en = k.encrypt(s.encode(), padmode=PAD_PKCS5)</span><br><span class="line">    <span class="comment"># return binascii.b2a_hex(en)</span></span><br><span class="line">    <span class="keyword">return</span> base64.b64encode(en).decode()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">des_descrypt</span><span class="params">(s)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    DES 解密</span></span><br><span class="line"><span class="string">    :param s: 加密后的字符串，16进制</span></span><br><span class="line"><span class="string">    :return:  解密后的字符串</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    secret_key = <span class="string">'ucserver'</span>.encode()</span><br><span class="line"> </span><br><span class="line">    k = des(secret_key, ECB, pad=<span class="literal">None</span>, padmode=PAD_PKCS5)</span><br><span class="line">    de = k.decrypt(base64.b64decode(s), padmode=PAD_PKCS5)</span><br><span class="line">    <span class="keyword">return</span> de.decode()</span><br></pre></td></tr></table></figure>

<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p><strong>python中还有一个库Crypto 也是用于加密的, 但是加密的结果和java不一致, 这是个坑, 以下是Crypto加密的代码, 用于对比:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from Crypto.Cipher import DES</span><br><span class="line">import binascii</span><br><span class="line">import base64</span><br><span class="line"></span><br><span class="line"># data-&gt;被加密的字符串 key-&gt;密钥 同样传入字符串</span><br><span class="line">def des_decode(data, key):</span><br><span class="line">    b_data = base64.b64decode(data)</span><br><span class="line">    cipher = DES.new(key.encode(), DES.MODE_ECB)</span><br><span class="line">    decrypted = cipher.decrypt(b_data)</span><br><span class="line">    decrypted.rstrip(b&apos; &apos;)</span><br><span class="line">    return decrypted.decode()  # 解密完成后将加密时添加的多余字符&apos;\0&apos;删除</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># data-&gt;被加密的字符串 key-&gt;密钥 同样传入字符串</span><br><span class="line">def aes_encrypt(data, key):</span><br><span class="line">    # DES ECB模式 无需向量iv</span><br><span class="line">    cipher = DES.new(key.encode(), DES.MODE_ECB)</span><br><span class="line">    # 字符串转字节数组</span><br><span class="line">    b_data = data.encode()</span><br><span class="line">    # ------ 按照16位对其 不足的补空格 ----</span><br><span class="line">    block_size = DES.block_size</span><br><span class="line">    count = len(b_data)</span><br><span class="line">    # text不是16的倍数那就补足为16的倍数</span><br><span class="line">    add_count = block_size - (count % block_size)</span><br><span class="line">    s_plaintext = data + (&apos; &apos; * add_count)</span><br><span class="line">    # ------ 按照16位对其 不足的补空格 ----</span><br><span class="line">  </span><br><span class="line">    b_plaintext = s_plaintext.encode()</span><br><span class="line">    encrypted = cipher.encrypt(b_plaintext)  # des加密</span><br><span class="line"></span><br><span class="line">    return base64.b64encode(encrypted).decode()</span><br></pre></td></tr></table></figure>

<p><strong>本文为作者原创 转载时请注明出处 谢谢</strong></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em>乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</em></p>
]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Code Spring Boot Project With Kotlin by Android Studio</title>
    <url>/162.html</url>
    <content><![CDATA[<h2 id="Step-1"><a href="#Step-1" class="headerlink" title="Step 1"></a>Step 1</h2><h3 id="Modify-build-gradle"><a href="#Modify-build-gradle" class="headerlink" title="Modify build.gradle"></a>Modify build.gradle</h3><ol>
<li><strong>In Module Dir : apply plugin: ‘kotlin’  and add kotlin dependencies</strong></li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">apply plugin: <span class="string">'org.springframework.boot'</span></span><br><span class="line">apply plugin: <span class="string">'java'</span></span><br><span class="line">apply plugin: <span class="string">'kotlin'</span>//notice</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">    implementation fileTree(dir: <span class="string">"libs"</span>, include: [<span class="string">"*.jar"</span>])</span><br><span class="line">    compile <span class="string">'org.springframework.boot:spring-boot-starter:2.3.4.RELEASE'</span></span><br><span class="line">    compile <span class="string">'org.springframework.boot:spring-boot-starter-web:2.3.4.RELEASE'</span></span><br><span class="line">    compile   <span class="string">"org.jetbrains.kotlin:kotlin-stdlib-jdk8:1.3.72"</span>//notice</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><strong>Project Dir : add kotlin classpath</strong></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">buildscript &#123;</span><br><span class="line">    ext &#123;</span><br><span class="line">        springBootVersion = <span class="string">'1.5.9.RELEASE'</span></span><br><span class="line">    &#125;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        mavenLocal()</span><br><span class="line">        mavenCentral()</span><br><span class="line">    &#125;</span><br><span class="line">    dependencies &#123;</span><br><span class="line">        classpath <span class="string">"org.springframework.boot:spring-boot-gradle-plugin:$&#123;springBootVersion&#125;"</span></span><br><span class="line">        classpath <span class="string">"org.jetbrains.kotlin:kotlin-gradle-plugin:1.3.72"</span><span class="comment">//notice</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">allprojects &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        google()</span><br><span class="line">        jcenter()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">task <span class="title">clean</span><span class="params">(type: Delete)</span> </span>&#123;</span><br><span class="line">    delete rootProject.buildDir</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Step-2"><a href="#Step-2" class="headerlink" title="Step 2"></a>Step 2</h2><ol>
<li><p><strong>Code with kotlin</strong> </p>
<p><strong>tip</strong>: if you use pure kotlin, you may code in kotlin dir replace java </p>
</li>
</ol>
<h2 id="Step-3"><a href="#Step-3" class="headerlink" title="Step 3"></a>Step 3</h2><p><strong>Done!</strong></p>
<p><strong>本文为作者原创 转载时请注明出处 谢谢</strong></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em>乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</em></p>
]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>8086汇编语言之各个通用寄存器的作用</title>
    <url>/164.html</url>
    <content><![CDATA[<h2 id="在8086cpu通用寄存器"><a href="#在8086cpu通用寄存器" class="headerlink" title="在8086cpu通用寄存器"></a>在8086cpu通用寄存器</h2><ul>
<li><strong>寄存器AX</strong>: 用于存放数据 (源代码编写时不能以字母开头,可在开头补上0)<ul>
<li>比如 <code>mov ax, ffffh</code> 应该写成 <code>mov ax, 0ffffh</code> 否则编译报错</li>
</ul>
</li>
<li><strong>寄存器BX</strong>: 另外还用于存放数据段偏移地址  初始值为源代码大小</li>
<li><strong>寄存器CX</strong>: 另外还用于存放loop循环计数</li>
<li><strong>寄存器DX</strong>: 另外还用于存放累加结果</li>
<li><strong>寄存器EX</strong>:备用寄存器</li>
</ul>
<p>##　BX存在的意义</p>
<p>１.  asm编译器无法识别中括号,<code>mov ax,[0]</code>编译时会默认去除中括号.使用bx替代可以解决这个问题,如果在debug模式下使用-a命令输入中括号则没有问题,可以正常识别</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">;错误写法:编译器无法识别[0],会直接取值为0 而不是偏移地址0所对应的内容</span><br><span class="line">assumme cs:code</span><br><span class="line">code segment</span><br><span class="line">	mov ax,2000h</span><br><span class="line">	mov ds,ax</span><br><span class="line">	mov al,[0]</span><br><span class="line">	mov bl,[1]</span><br><span class="line">	mov cl,[2]</span><br><span class="line">	mov dl,[3]</span><br><span class="line">	</span><br><span class="line">	mov ax,4c00h</span><br><span class="line">	int 21h</span><br><span class="line">code ends</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<p>问题: 那如果非要以带中括号的方式进行编写可以吗? 答案是:需要带上段地址ds,如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">assumme cs:code</span><br><span class="line">code segment</span><br><span class="line">	mov ax,2000h</span><br><span class="line">	mov ds,ax</span><br><span class="line">	mov al,ds:[0] ;其中ds称作段前缀</span><br><span class="line">	mov bl,ds:[1]</span><br><span class="line">	mov cl,ds:[2]</span><br><span class="line">	mov dl,ds:[3]</span><br><span class="line">	</span><br><span class="line">	mov ax,4c00h</span><br><span class="line">	int 21h</span><br><span class="line">code ends</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<p><strong>本文为作者原创 转载时请注明出处 谢谢</strong></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em>乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</em></p>
]]></content>
      <tags>
        <tag>汇编</tag>
      </tags>
  </entry>
  <entry>
    <title>关于十六进制和二进制左移位右移位的问题</title>
    <url>/163.html</url>
    <content><![CDATA[<h2 id="Step-1"><a href="#Step-1" class="headerlink" title="Step 1"></a>Step 1</h2><h2 id="先聊十进制"><a href="#先聊十进制" class="headerlink" title="先聊十进制"></a>先聊十进制</h2><p><strong>以10举例</strong>:(满10进一位)</p>
<ul>
<li>10往左移一位变成100, 可以理解为是10乘以10得来的,100=10x10</li>
<li>10往右移一位变成1, 可以理解为是10除以10得来的,1=10/10</li>
</ul>
<h2 id="那么十六进制"><a href="#那么十六进制" class="headerlink" title="那么十六进制"></a>那么十六进制</h2><p><strong>以2F0举例</strong>:(满16进一位)</p>
<ul>
<li>2F0往左移一位变成2F00, 可以理解为是2F0乘以16得来的</li>
<li>2F0往右移一位变成2F, 可以理解为是2F0除以16得来的</li>
</ul>
<h2 id="二进制同理"><a href="#二进制同理" class="headerlink" title="二进制同理"></a>二进制同理</h2><p><strong>以1010举例</strong>:(满2进一位)</p>
<ul>
<li>1010往左移一位变成10100, 可以理解为是1010乘以2得来的,20=10x2(需要换算成十进制进行计算)</li>
<li>1010往右移一位变成101, 可以理解为是1010除以2得来的,5=10/2</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>向左移位低位进位补0,向右移位低位去0</li>
<li>十进制满10进位,十六进制满16进位,八进制满8进位,二进制满2进位</li>
<li>二进制每四位分割对应一个16进制,每三位分割对应一个八进制</li>
</ul>
<p><strong>本文为作者原创 转载时请注明出处 谢谢</strong></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em>乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</em></p>
]]></content>
      <tags>
        <tag>汇编</tag>
      </tags>
  </entry>
  <entry>
    <title>8086汇编语言之数据段和代码段以及栈段的理解</title>
    <url>/166.html</url>
    <content><![CDATA[<h2 id="数据段DS＋偏移地址段BX"><a href="#数据段DS＋偏移地址段BX" class="headerlink" title="数据段DS＋偏移地址段BX"></a>数据段DS＋偏移地址段BX</h2><p><strong>数据段可以通俗理解为数据容器指针</strong></p>
<p>比如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">MOV AX 0220H</span><br><span class="line">MOV DS AX</span><br><span class="line">MOV BX 0</span><br><span class="line">MOV AX [BX]</span><br><span class="line">;我们发现 DS数据段一直都是在给不同地址的容器赋值</span><br></pre></td></tr></table></figure>

<h2 id="代码段CS-偏移地址段IP"><a href="#代码段CS-偏移地址段IP" class="headerlink" title="代码段CS+偏移地址段IP"></a>代码段CS+偏移地址段IP</h2><p><strong>代码段可以通俗理解为汇编代码指针</strong></p>
<p>比如:</p>
<p>代码从 <code>MOV AX 0220H</code> 开始,那么代码段指向这行代码地址, 如果想要跳过这行代码的执行,那么进行代码段偏移</p>
<p><strong>在通过debug模式配合-u指令查看汇编代码时,可以根据CS进行范围查看:</strong></p>
<p>比如:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#以下模拟控制台输出</span><br><span class="line">-r</span><br><span class="line">AX=0000 BX=0000.....</span><br><span class="line">DS=13DB ES=13DB SS=13EB CS=13EB IP=0000</span><br><span class="line">-u 13eb:0</span><br><span class="line">13BE:0000 B8FFFF MOV   AX,FFFF</span><br></pre></td></tr></table></figure>

<h2 id="栈段SS-偏移地址段SP"><a href="#栈段SS-偏移地址段SP" class="headerlink" title="栈段SS+偏移地址段SP"></a>栈段SS+偏移地址段SP</h2><p><strong>栈段可以通俗理解为栈指针</strong></p>
<h2 id="什么是段"><a href="#什么是段" class="headerlink" title="什么是段"></a>什么是段</h2><p> 首先内存并没有分段，段的划分来自CPU，来自我们自己对内存的操作。由8086CPU</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">（段地址+偏移地址=“物理地址”）</span><br></pre></td></tr></table></figure>

<p>的方式给出内存单元的物理地址，使得我们用分段的方式管理内存</p>
<p>可以将段通俗理解为小区的一栋楼,偏移地址为这栋楼的住户门牌号.比如五号楼101房,那么形象比喻:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">五号楼----&gt;段地址  101房----&gt;偏移地址</span><br></pre></td></tr></table></figure>

<h2 id="为什么要这样划分"><a href="#为什么要这样划分" class="headerlink" title="为什么要这样划分?"></a>为什么要这样划分?</h2><p>直接使用一个物理地址岂不是更简单,何必拆分成段地址+物理地址?</p>
<p>这是由于8086cpu16位寄存器局限性造成的, 由于16位的寄存器最大只能存放0xFFFF 如果存放超过五位的地址比如0xFFFFA 则无法存放, 为了解决这个问题, cup设计者想出了 <strong>段地址*16+偏移地址</strong>的方法完美解决这个问题 </p>
<p><strong>物理地址</strong>=<strong>段地址*16+偏移地址</strong></p>
<p>一个物理地址可以有四种写法, 比如0xFFFFA:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0xFFFFA=0xFFFF0*16+0x000A</span><br><span class="line"></span><br><span class="line">0xFFFFA=0xFFF00*16+0x00FA</span><br><span class="line"></span><br><span class="line">0xFFFFA=0xFF000*16+0x0FFA</span><br><span class="line"></span><br><span class="line">0xFFFFA=0xF0000*16+0xFFFA</span><br></pre></td></tr></table></figure>

<h2 id="段的赋值"><a href="#段的赋值" class="headerlink" title="段的赋值"></a>段的赋值</h2><p><strong>代码段CS 数据段DS 栈段SS 不能直接赋值</strong>, 必须通过通用寄存器中转赋值</p>
<p>偏移地址可以直接赋值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mov ax ,2000H</span><br><span class="line">mov ss ,ax</span><br><span class="line">mov sp ,10H</span><br></pre></td></tr></table></figure>

<p><strong>本文为作者原创 转载时请注明出处 谢谢</strong></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em>乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</em></p>
]]></content>
      <tags>
        <tag>汇编</tag>
      </tags>
  </entry>
  <entry>
    <title>关于Android Studio设置代理的问题</title>
    <url>/17.html</url>
    <content><![CDATA[<h3 id="AndoridStudio报错-“Failed-to-parse-host-xxx-xxx”"><a href="#AndoridStudio报错-“Failed-to-parse-host-xxx-xxx”" class="headerlink" title="AndoridStudio报错 “Failed to parse host xxx.xxx”"></a>AndoridStudio报错 “Failed to parse host xxx.xxx”</h3><p> 你会发现, 单纯在 HTTP Proxy 里边 取消代理设置是不行的，依然报错 </p>
<p><strong>解决方法:</strong></p>
<p>找到你C盘用户 文件夹下的.gradle 下 ， 看看有没有一个叫gradle.properties 文件，修改里边的网络代理配置信息，或者直接把该文件夹删除。 </p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20200622115827.png" alt></p>
<p><strong>本文为作者原创 转载时请注明出处 谢谢</strong></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em>乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</em></p>
]]></content>
      <tags>
        <tag>问题集锦</tag>
      </tags>
  </entry>
  <entry>
    <title>汇编语言之debug模式常用指令介绍</title>
    <url>/165.html</url>
    <content><![CDATA[<blockquote>
<p> 在搭建好了8086汇编的开发环境后，接下来介绍8086的debug模式。执行debug.exe以进入debug调试模式，在dos中通过输入命令的方式进行交互 </p>
</blockquote>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20201101210639.png" alt></p>
<p>##　－Ｒ命令</p>
<p> <strong>R命令的作用是查看和修改debug模式下CPU中寄存器的值</strong> </p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20201101210624.png" alt></p>
<p>##　－Ｄ命令</p>
<p> <strong>D命令的作用是查看内存中的内容</strong> </p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20201101211009.png" alt></p>
<p> 上面为<strong>（段地址:偏移地址）</strong>查看方式。D命令默认会显示<strong>寻址地址开始的后128个内存单元</strong>的内容，以16进制的方式显示(每个内存单元8位，一行最多16个内存单元)，而最右边会将内存单元中的二进制数据<strong>以ascll码</strong>的形式翻译展示 </p>
<p>　　<strong>但有时</strong>，我们只想聚焦于某一部分内存地址的内容，而默认展示的内存视图不是很方便。</p>
<p>　　D命令提供了另外一种访问内存的方式（<strong>段地址:偏移起始地址 偏移终止地址</strong>），其能够展示（<strong>段地址:偏移起始地址 至 段地址:偏移终止地址</strong>）的内存信息，范围两端均为闭区间</p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20201101211514.png" alt></p>
<h2 id="－E命令"><a href="#－E命令" class="headerlink" title="－Ｅ命令"></a>－Ｅ命令</h2><p> <strong>E命令的作用是改变内存中的内容</strong>。 </p>
<p>　和对CPU中寄存器的查看，修改不同，对内存进行查看和修改较为复杂，为此debug设计了两个不同的命令分别进行控制(<strong>E命令修改内存、D命令查看内存</strong>)。</p>
<p>　　通过(<strong>E 起始地址 数据1 数据2 数据3…</strong>)命令可以修改内存中以起始地址开始，顺序的N个内存单元的值(N为实际参数传递的数量)</p>
<p> <img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20201101211543.png" alt> </p>
<p> 也可以和R命令修改CPU中寄存器值类似的，通过提示来修改特定内存单元的值。<strong>00.12</strong> <strong>00代表内存单元在修改前的值，12是我们手动输入的、需要修改的新值</strong> </p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20201101211618.png" alt></p>
<h2 id="－U命令"><a href="#－U命令" class="headerlink" title="－Ｕ命令"></a>－Ｕ命令</h2><p>  <strong>U命令的作用是将内存中的二进制数据转换为汇编指令展示(反汇编)</strong></p>
<p>D命令能够将内存中的数据以16进制或ascll码的形式展现出来，但有时我们需要观察的是内存中的机器指令时，D命令的视图过于抽象，不利于理解。debug提供了U命令来解决这个问题。</p>
<p>　　对于前面我们在1000:0处输入的机器指令，使用 U 1000:0 命令(u 内存地址)可以将内存中的数据以汇编语言指令的方式进行展示</p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20201101211814.png" alt></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20201102181847.png" alt></p>
<h2 id="－A命令"><a href="#－A命令" class="headerlink" title="－Ａ命令"></a>－Ａ命令</h2><p> <strong>A命令能够以汇编指令的形式向内存中写入内容</strong>  </p>
<p>对于内存操作，D命令可以查看内存中的内容，但如果想查看的是程序指令，显然U命令更加方便；E命令可以向内存中写入数据，但对于程序指令的写入，直接操作二进制机器码的方式过于硬核。为此，debug提供了A命令，我们可以通过A命令以汇编指令的形式向内存中写入内容。</p>
<p>　　通过A命令将(<strong>mov ax,0001，mov bx,0002，add ax,bx</strong>)三条指令写入内存1000:0处：</p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20201101211916.png" alt></p>
<p>通过A命令进行指令的写入，和E命令达到的效果一样，但使用起来却更加便捷。A命令能够自动识别所输入汇编指令的长度，正确的在内存中写入程序指令。</p>
<p>　　<strong>debug提供了D、E两种命令用于对内存进行通用的操作(纯二进制、十六进制数据的读、写)。</strong></p>
<p>　　<strong>对于程序指令，debug提供了U、A两种命令以更人性化的方式来读写内存中的指令内容</strong></p>
<h2 id="－T命令"><a href="#－T命令" class="headerlink" title="－Ｔ命令"></a>－Ｔ命令</h2><p> 　<strong>T命令的作用是进行单步机器指令的调试</strong> </p>
<h2 id="－G命令"><a href="#－G命令" class="headerlink" title="－G命令"></a>－G命令</h2><p> 　<strong>G命令的作用是进行Debug程序断点调试</strong> </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-g 代码地址(cs+ip)地址</span><br></pre></td></tr></table></figure>

<h2 id="－p命令"><a href="#－p命令" class="headerlink" title="－p命令"></a>－p命令</h2><p>　<strong>p命令的作用是断点跳过执行 ,可用于循环调试</strong> </p>
<p><strong>本文为作者原创 转载时请注明出处 谢谢</strong></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em>乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</em></p>
]]></content>
      <tags>
        <tag>汇编</tag>
      </tags>
  </entry>
  <entry>
    <title>二进制与十六进制和八进制的快速转换</title>
    <url>/167.html</url>
    <content><![CDATA[<blockquote>
<p> 进制转换属于计算机基础,虽然是基础,但是想要熟练计算,需要花点时间</p>
</blockquote>
<h2 id="二进制举例"><a href="#二进制举例" class="headerlink" title="二进制举例"></a>二进制举例</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0101001001001101    //转成十进制值是2^0+2^2+2^3+2^6+2^9+2^12+2^14=21069</span><br></pre></td></tr></table></figure>

<h2 id="二进制转十六进制"><a href="#二进制转十六进制" class="headerlink" title="二进制转十六进制"></a>二进制转十六进制</h2><p>从低到高每四位进行分割,也就是:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0101 0010 0100 1101   //结果 524D</span><br></pre></td></tr></table></figure>

<h2 id="二进制转八进制"><a href="#二进制转八进制" class="headerlink" title="二进制转八进制"></a>二进制转八进制</h2><p>从低到高每三位进行分割,也就是:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0 101 001 001 001 101</span><br></pre></td></tr></table></figure>

<p>不足三位的补0, 也就是:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">000 101 001 001 001 101 结果051115</span><br></pre></td></tr></table></figure>

<h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>二进制<strong>每四位(1111)</strong>最大值是15, 按照四位分割转成十六进制</p>
<p>二进制<strong>每三位(111)</strong>最大值是7,按照三位分割转八进制</p>
<p><strong>那么延伸</strong>:</p>
<p>二进制<strong>每两位(11)</strong>最大值是3,按照两位分割转成四进制</p>
<p>二进制<strong>每五位(11111</strong>)最大值是31,按照五位分割转成三十二进制</p>
<p>二进制<strong>每六位(111111)</strong>最大值是63,按照六位分割转成六十四进制</p>
<p>二进制<strong>每七位(1111111)</strong>最大值是127,按照七位分割转成一百二十八进制</p>
<p>……..</p>
<h2 id="如果快速转换"><a href="#如果快速转换" class="headerlink" title="如果快速转换"></a>如果快速转换</h2><p>十六进制和二进制一一对应关系表:</p>
<table>
<thead>
<tr>
<th align="center">十六进制</th>
<th align="center">二进制</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">0001</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">0010</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">0011</td>
</tr>
<tr>
<td align="center">4</td>
<td align="center">0100</td>
</tr>
<tr>
<td align="center">5</td>
<td align="center">0101</td>
</tr>
<tr>
<td align="center">6</td>
<td align="center">0110</td>
</tr>
<tr>
<td align="center">7</td>
<td align="center">0111</td>
</tr>
<tr>
<td align="center">8</td>
<td align="center">1000</td>
</tr>
<tr>
<td align="center">9</td>
<td align="center">1001</td>
</tr>
<tr>
<td align="center">A</td>
<td align="center">1010</td>
</tr>
<tr>
<td align="center">B</td>
<td align="center">1011</td>
</tr>
<tr>
<td align="center">C</td>
<td align="center">1100</td>
</tr>
<tr>
<td align="center">D</td>
<td align="center">1101</td>
</tr>
<tr>
<td align="center">E</td>
<td align="center">1110</td>
</tr>
<tr>
<td align="center">F</td>
<td align="center">1111</td>
</tr>
</tbody></table>
<p><strong>本文为作者原创 转载时请注明出处 谢谢</strong></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em>乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</em></p>
]]></content>
      <tags>
        <tag>编程基础</tag>
      </tags>
  </entry>
  <entry>
    <title>8086语言之申请栈空间的方法</title>
    <url>/168.html</url>
    <content><![CDATA[<h2 id="第一种"><a href="#第一种" class="headerlink" title="第一种"></a>第一种</h2><p>使用<code>dw</code>或者<code>db</code>直接申请</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">assume cs:cscode</span><br><span class="line">cscode segment</span><br><span class="line">	dw 0,0,0,0,0,0,0,0 ;定义8个字型数据,在程序加载后,将取得8个字的内存空间,可当做栈空间使用</span><br><span class="line">start:mov ax,cs</span><br><span class="line">	...</span><br><span class="line">cscode ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>

<p><strong>本文为作者原创 转载时请注明出处 谢谢</strong></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em>乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</em></p>
]]></content>
      <tags>
        <tag>汇编</tag>
      </tags>
  </entry>
  <entry>
    <title>java和smali语言互转流程图</title>
    <url>/170.html</url>
    <content><![CDATA[<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/%E6%97%A0%E6%A0%87%E9%A2%98.png" alt></p>
<h2 id="baksmali和smali-jar工具下载"><a href="#baksmali和smali-jar工具下载" class="headerlink" title="baksmali和smali.jar工具下载"></a>baksmali和smali.jar工具下载</h2><p><a href="https://bitbucket.org/JesusFreke/smali/downloads/" target="_blank" rel="noopener">https://bitbucket.org/JesusFreke/smali/downloads/</a></p>
<p><a href="https://bitbucket.org/JesusFreke/smali/downloads/" target="_blank" rel="noopener">点此下载</a></p>
<h2 id="class转dex指令"><a href="#class转dex指令" class="headerlink" title=".class转dex指令"></a>.class转dex指令</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dx.bat --dex --output=./aa.dex Test.class</span><br></pre></td></tr></table></figure>

<h2 id="dex转smali指令"><a href="#dex转smali指令" class="headerlink" title="dex转smali指令"></a>dex转smali指令</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java -jar baksmali-2.4.0.jar d test.dex</span><br></pre></td></tr></table></figure>

<h2 id="smali转dex指令"><a href="#smali转dex指令" class="headerlink" title="smali转dex指令"></a>smali转dex指令</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java -jar smali-2.4.0.jar a smali文件或目录 -o 输出目录/xxx.dex</span><br></pre></td></tr></table></figure>

<h2 id="dex转class指令"><a href="#dex转class指令" class="headerlink" title="dex转class指令"></a>dex转class指令</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">d2j-dex2jar.bat xxx.dex</span><br></pre></td></tr></table></figure>

<h2 id="class转java"><a href="#class转java" class="headerlink" title="class转java"></a>class转java</h2><ol>
<li>直接使用jad-gui或者jadx</li>
<li>使用javap -p xxx.class查看</li>
</ol>
<h2 id="另外"><a href="#另外" class="headerlink" title="另外"></a>另外</h2><ol>
<li><p>如果你嫌麻烦 可以直接使用dex2jar内部的工具 里面进行了相应的封装</p>
</li>
<li><p>android studio自带的.class转smali就非常好用,如图:</p>
</li>
</ol>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20201104143153.png" alt></p>
<p><strong>本文为作者原创 转载时请注明出处 谢谢</strong></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em>乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</em></p>
]]></content>
      <tags>
        <tag>smali</tag>
      </tags>
  </entry>
  <entry>
    <title>smali语言之locals和registers的区别</title>
    <url>/171.html</url>
    <content><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>  对于dalviks字节码寄存器<strong>都是32位</strong>的，它能够表示任何类型，2个寄存器用于表示64位的类型(Long and Double)。  </p>
<h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><p>声明于方法内部(必须)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">.<span class="function">method <span class="keyword">public</span> <span class="title">getName</span><span class="params">()</span>V</span></span><br><span class="line"><span class="function">    .registers 6 </span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">	return-<span class="keyword">void</span></span></span><br><span class="line"><span class="function">.end method</span></span><br></pre></td></tr></table></figure>

<h2 id="registers和locals基本区别"><a href="#registers和locals基本区别" class="headerlink" title=".registers和locals基本区别"></a>.registers和locals基本区别</h2><p>在一个方法（method）中有两中方式指定有多少个可用的寄存器。指令.registers指令指定了在这个方法中有多少个可用的寄存器，</p>
<p>指令.locals指明了在这个方法中非参（non-parameter）寄存器的数量。然而寄存器的总数也包括保存方法参数的寄存器。</p>
<h2 id="参数是如何传递的？"><a href="#参数是如何传递的？" class="headerlink" title="参数是如何传递的？"></a>参数是如何传递的？</h2><h4 id="1-如果是非静态方法"><a href="#1-如果是非静态方法" class="headerlink" title="1.如果是非静态方法"></a>1.如果是非静态方法</h4><p>例如，你写了一个非静态方法<code>LMyObject;-&gt;callMe(II)V</code>。这个方法有2个int参数，但在这两个整型参数前面还有一个隐藏的参数<code>LMyObject</code>；也就是当前对象的引用，所以这个方法总共有3个参数。<br>假如在一个方法中包含了五个寄存器(V0-V4)，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">.<span class="function">method <span class="keyword">public</span> <span class="title">callMe</span><span class="params">(II)</span>V</span></span><br><span class="line"><span class="function"> 	<span class="keyword">const</span>-string v0,"1"</span></span><br><span class="line"><span class="function">    <span class="keyword">const</span>-string v1,"1"</span></span><br><span class="line"><span class="function"> </span></span><br><span class="line"><span class="function">   return-<span class="keyword">void</span></span></span><br><span class="line"><span class="function">.end method</span></span><br></pre></td></tr></table></figure>

<p>那么只需用.register指令指定5个，或者使用.locals指令指定2个（2个local寄存器+3个参数寄存器）。如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">.<span class="function">method <span class="keyword">public</span> <span class="title">callMe</span><span class="params">(II)</span>V</span></span><br><span class="line"><span class="function">    .registers 5</span></span><br><span class="line"><span class="function"> 	<span class="keyword">const</span>-string v0,"1"</span></span><br><span class="line"><span class="function">    <span class="keyword">const</span>-string v1,"1"</span></span><br><span class="line"><span class="function">    v3</span>==&gt;p0</span><br><span class="line">    V4==&gt;P1</span><br><span class="line">    V5==&gt;P2</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">return</span>-<span class="keyword">void</span></span><br><span class="line">.end method</span><br><span class="line"></span><br><span class="line">或者</span><br><span class="line">.<span class="function">method <span class="keyword">public</span> <span class="title">callMe</span><span class="params">(II)</span>V</span></span><br><span class="line"><span class="function">    .locals 2</span></span><br><span class="line"><span class="function"> 	<span class="keyword">const</span>-string v0,"1"</span></span><br><span class="line"><span class="function">    <span class="keyword">const</span>-string v1,"1"</span></span><br><span class="line"><span class="function">   return-<span class="keyword">void</span></span></span><br><span class="line"><span class="function">.end method</span></span><br></pre></td></tr></table></figure>

<p><strong>该方法被调用的时候，调用方法的对象（即this引用）会保存在V2中，第一个参数在V3中，第二个参数在v4中。</strong></p>
<h4 id="2-如果是静态方法"><a href="#2-如果是静态方法" class="headerlink" title="2.如果是静态方法"></a>2.如果是静态方法</h4><p>那么参数少了对象引用，除此之外和非静态原理相同，<strong>registers为4 locals依然是2</strong></p>
<h2 id="关于寄存器命名规则"><a href="#关于寄存器命名规则" class="headerlink" title="关于寄存器命名规则"></a>关于寄存器命名规则</h2><h4 id="v命名法"><a href="#v命名法" class="headerlink" title="v命名法"></a>v命名法</h4><p>上面的例子中我们使用的是<strong>v命名法</strong>，也就是在本地寄存器后面依次添加参数寄存器，</p>
<p><strong>但是这种命名方式存在一种问题</strong>：假如我后期想要修改方法体的内容，涉及到增加或者删除寄存器，由于<strong>v命名法需要排序</strong>的局限性，那么会造成大量代码的改动，有没有一种办法让我们只改动registers或者locals的值就可以了呢， 答案是：有的</p>
<p>除<strong>v命名法</strong>之外，还有一种命名法叫做<strong>p命名法</strong></p>
<h4 id="p命名法"><a href="#p命名法" class="headerlink" title="p命名法"></a>p命名法</h4><p>p命名法只能给方法参数命名，不能给本地变量命名</p>
<p>假如有一个非静态方法如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.method public print(Ljava/lang/String;Ljava/lang/String;I)V</span><br></pre></td></tr></table></figure>

<p>以下是p命名法参数对应表：</p>
<table>
<thead>
<tr>
<th>p0</th>
<th>this</th>
</tr>
</thead>
<tbody><tr>
<td>p1</td>
<td>第一个参数Ljava/lang/String;</td>
</tr>
<tr>
<td>p2</td>
<td>第二个参数Ljava/lang/String;</td>
</tr>
<tr>
<td>p3</td>
<td>第三个参数I</td>
</tr>
</tbody></table>
<p>如前面提到的，long和double类型都是64位，需要2个寄存器。当你引用参数的时候一定要记住，例如：你有一个非静态方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">LMyObject;-&gt;MyMethod(IJZ)V</span><br></pre></td></tr></table></figure>

<p>方法的参数为int、long、bool。所以这个方法的所有参数需要5个寄存器。 </p>
<table>
<thead>
<tr>
<th>p0</th>
<th>this</th>
</tr>
</thead>
<tbody><tr>
<td>p1</td>
<td>I</td>
</tr>
<tr>
<td>p2, p3</td>
<td>J</td>
</tr>
<tr>
<td>p4</td>
<td>Z</td>
</tr>
</tbody></table>
<p>另外当你调用方法后，你必须在寄存器列表，调用指令中指明，两个寄存器保存了double-wide宽度的参数。</p>
<p>注意：在默认的baksmali中，参数寄存器将使用P命名方式，如果出于某种原因你要禁用P命名方式，而要强制使用V命名方式，应当使用-p/–no-parameter-registers选项。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li><strong>locals和registers都可以表示寄存器数量</strong>，locals指定本地局部变量寄存器个数，registers是locals和参数寄存器数量的总数，两者使用任选其一</li>
<li>同时，寄存器命名一共分两种，一种是v命名法，另一种是p命名法</li>
</ul>
<table>
<thead>
<tr>
<th>v0</th>
<th></th>
<th>the first local register</th>
</tr>
</thead>
<tbody><tr>
<td>v1</td>
<td></td>
<td>the second local register</td>
</tr>
<tr>
<td>v2</td>
<td>p0</td>
<td>the first parameter register</td>
</tr>
<tr>
<td>v3</td>
<td>p1</td>
<td>the second parameter register</td>
</tr>
<tr>
<td>v4</td>
<td>p2</td>
<td>the third parameter register</td>
</tr>
</tbody></table>
]]></content>
      <tags>
        <tag>smali</tag>
      </tags>
  </entry>
  <entry>
    <title>Android逆向开发之smali语言的学习</title>
    <url>/169.html</url>
    <content><![CDATA[<h2 id="smali和java基本数据类型对比"><a href="#smali和java基本数据类型对比" class="headerlink" title="smali和java基本数据类型对比"></a>smali和java基本数据类型对比</h2><table>
<thead>
<tr>
<th align="center">smali</th>
<th align="center">java</th>
</tr>
</thead>
<tbody><tr>
<td align="center">B</td>
<td align="center">byte</td>
</tr>
<tr>
<td align="center">S</td>
<td align="center">short</td>
</tr>
<tr>
<td align="center">I</td>
<td align="center">int</td>
</tr>
<tr>
<td align="center">J</td>
<td align="center">long</td>
</tr>
<tr>
<td align="center">F</td>
<td align="center">float</td>
</tr>
<tr>
<td align="center">D</td>
<td align="center">double</td>
</tr>
<tr>
<td align="center">C</td>
<td align="center">char</td>
</tr>
<tr>
<td align="center">Z</td>
<td align="center">boolean</td>
</tr>
<tr>
<td align="center">V</td>
<td align="center">void</td>
</tr>
<tr>
<td align="center">[</td>
<td align="center">数组</td>
</tr>
<tr>
<td align="center">L+全类名路径用/分割</td>
<td align="center">object</td>
</tr>
</tbody></table>
<h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><p>在smali语言中注释使用<code>#</code>表示</p>
<figure class="highlight smali"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 我是注释</span></span><br></pre></td></tr></table></figure>

<h2 id="类声明"><a href="#类声明" class="headerlink" title="类声明"></a>类声明</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.class +权限修饰符 +类名;</span><br></pre></td></tr></table></figure>

<p>比如以下java代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Test</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用smali代码表示为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.class public LTest;#声明类 （必须）</span><br><span class="line">.super Ljava/lang/Object;#声明父类 默认继承Object （必须）</span><br><span class="line">.implements Ljava/lang/CharSequence; #如果实现了接口 则添加接口代码</span><br><span class="line">.source &quot;Test.java&quot; # 源码文件 （非必须）</span><br></pre></td></tr></table></figure>

<h2 id="关于分号"><a href="#关于分号" class="headerlink" title="关于分号;"></a>关于分号;</h2><p>凡是L开头全包名路径结尾都需要加分号</p>
<h2 id="字段声明（成员-全局变量）"><a href="#字段声明（成员-全局变量）" class="headerlink" title="字段声明（成员/全局变量）"></a>字段声明（成员/全局变量）</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.field 权限修饰符+静态修饰符 +变量名:变量全类名路径;</span><br></pre></td></tr></table></figure>

<p>比如以下java代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Test</span><br><span class="line">&#123;</span><br><span class="line">	private static String a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用smali代码表示为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.class public LTest;#声明类 （必须）</span><br><span class="line">.super Ljava/lang/Object;#声明父类 默认继承Object （必须）</span><br><span class="line">.source &quot;Test.java&quot; # 源码文件 （非必须）</span><br><span class="line"></span><br><span class="line"># 如果是非静态，只需将static去掉即可</span><br><span class="line">.field private static a:Ljava/lang/String;</span><br></pre></td></tr></table></figure>

<p><strong>补充:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">基本数据类型示例：</span><br><span class="line">.<span class="function">method <span class="keyword">public</span> <span class="keyword">final</span> <span class="title">pubFinalMethod</span><span class="params">()</span>V <span class="comment">//返回值</span></span></span><br><span class="line"><span class="function">.field <span class="keyword">private</span> boType:Z    <span class="comment">// boolean</span></span></span><br><span class="line"><span class="function">.field <span class="keyword">private</span> byteType:B  <span class="comment">// byte</span></span></span><br><span class="line"><span class="function">.field <span class="keyword">private</span> shortType:S <span class="comment">// short</span></span></span><br><span class="line"><span class="function">.field <span class="keyword">private</span> charType:C  <span class="comment">// char</span></span></span><br><span class="line"><span class="function">.field <span class="keyword">private</span> intType:I   <span class="comment">// int</span></span></span><br><span class="line"><span class="function">.field <span class="keyword">private</span> longType:J  <span class="comment">//long</span></span></span><br><span class="line"><span class="function">.field <span class="keyword">private</span> floatType:F <span class="comment">// float</span></span></span><br><span class="line"><span class="function">.field <span class="keyword">private</span> doubleType:D <span class="comment">// double</span></span></span><br></pre></td></tr></table></figure>

<h2 id="常量声明"><a href="#常量声明" class="headerlink" title="常量声明"></a>常量声明</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.field 权限修饰符+静态修饰符 +final+变量名:变量全类名路径;=常量值</span><br></pre></td></tr></table></figure>

<p>比如以下java代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Test</span><br><span class="line">&#123;</span><br><span class="line">	private static final String a=”hello“;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用smali代码表示为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.class public LTest;#声明类 （必须）</span><br><span class="line">.super Ljava/lang/Object;#声明父类 默认继承Object （必须）</span><br><span class="line"></span><br><span class="line">.field public static final a:Ljava/lang/String; = &quot;hello&quot;</span><br></pre></td></tr></table></figure>

<h2 id="成员方法-函数声明"><a href="#成员方法-函数声明" class="headerlink" title="成员方法/函数声明"></a>成员方法/函数声明</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.method 权限修饰符+静态修饰符 +方法名(参数类型)返回值类型</span><br><span class="line">#方法体</span><br><span class="line">.end method #方法结尾标志</span><br></pre></td></tr></table></figure>

<p>比如以下java代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">public class Test</span><br><span class="line">&#123;</span><br><span class="line">	public static void getName()&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用smali代码表示为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.class public LTest;#声明类 （必须）</span><br><span class="line">.super Ljava/lang/Object;#声明父类 默认继承Object （必须）</span><br><span class="line"></span><br><span class="line"># 如果是非静态，只需将static去掉即可</span><br><span class="line">.method public static getName()V</span><br><span class="line"> </span><br><span class="line">    return-void</span><br><span class="line">.end method</span><br></pre></td></tr></table></figure>

<h4 id="如果是带参并且带有返回值的方法"><a href="#如果是带参并且带有返回值的方法" class="headerlink" title="如果是带参并且带有返回值的方法"></a>如果是带参并且带有返回值的方法</h4><p>比如以下java代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Test</span><br><span class="line">&#123;</span><br><span class="line">    public  String getName(String p)&#123;</span><br><span class="line">        return &quot;hello&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用smali代码表示为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.method public getName(Ljava/lang/String;)Ljava/lang/String;</span><br><span class="line"></span><br><span class="line">    const-string v0, &quot;hello&quot;</span><br><span class="line"></span><br><span class="line">    return-object v0</span><br><span class="line">.end method</span><br></pre></td></tr></table></figure>

<h2 id="关于方法返回关键字"><a href="#关于方法返回关键字" class="headerlink" title="关于方法返回关键字"></a>关于方法返回关键字</h2><h4 id="主要有以下四种"><a href="#主要有以下四种" class="headerlink" title="主要有以下四种"></a>主要有以下四种</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span>-<span class="keyword">void</span></span><br><span class="line"><span class="keyword">return</span>-object</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"><span class="keyword">return</span>-wide</span><br></pre></td></tr></table></figure>

<h4 id="数据类型对应关系表如下"><a href="#数据类型对应关系表如下" class="headerlink" title="数据类型对应关系表如下:"></a>数据类型对应关系表如下:</h4><table>
<thead>
<tr>
<th align="center">smali方法返回关键字</th>
<th align="center">java</th>
</tr>
</thead>
<tbody><tr>
<td align="center">return</td>
<td align="center">byte</td>
</tr>
<tr>
<td align="center">return</td>
<td align="center">short</td>
</tr>
<tr>
<td align="center">return</td>
<td align="center">int</td>
</tr>
<tr>
<td align="center">return-wide</td>
<td align="center">long</td>
</tr>
<tr>
<td align="center">return</td>
<td align="center">float</td>
</tr>
<tr>
<td align="center">return-wide</td>
<td align="center">double</td>
</tr>
<tr>
<td align="center">return</td>
<td align="center">char</td>
</tr>
<tr>
<td align="center">return</td>
<td align="center">boolean</td>
</tr>
<tr>
<td align="center">return-void</td>
<td align="center">void</td>
</tr>
<tr>
<td align="center">return-object</td>
<td align="center">数组</td>
</tr>
<tr>
<td align="center">return-object</td>
<td align="center">object</td>
</tr>
</tbody></table>
<h2 id="构造方法-构造函数声明"><a href="#构造方法-构造函数声明" class="headerlink" title="构造方法/构造函数声明"></a>构造方法/构造函数声明</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.method 权限修饰符 +constructor &lt;init&gt;(参数类型)返回值类型</span><br><span class="line">#方法体</span><br><span class="line">.end method #方法结尾标志</span><br></pre></td></tr></table></figure>

<p>比如以下java代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Test</span><br><span class="line">&#123;</span><br><span class="line">   public Test(String a)&#123;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用smali代码表示为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.class public LTest;#声明类 （必须）</span><br><span class="line">.super Ljava/lang/Object;#声明父类 默认继承Object （必须）</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">.method public constructor &lt;init&gt;(Ljava/lang/String;)V</span><br><span class="line">  </span><br><span class="line">    invoke-direct &#123;p0&#125;, Ljava/lang/Object;-&gt;&lt;init&gt;()V #调用父类构造方法 </span><br><span class="line"></span><br><span class="line">    return-void</span><br><span class="line">.end method</span><br></pre></td></tr></table></figure>

<h2 id="静态代码块的声明"><a href="#静态代码块的声明" class="headerlink" title="静态代码块的声明"></a>静态代码块的声明</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.method static +constructor &lt;clinit&gt;()V</span><br><span class="line">#方法体</span><br><span class="line">.end method #方法结尾标志</span><br></pre></td></tr></table></figure>

<p>比如以下java代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Test</span><br><span class="line">&#123;</span><br><span class="line">	public static String a=&quot;a&quot;;</span><br><span class="line"></span><br><span class="line">   static&#123;</span><br><span class="line">   </span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用smali代码表示为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.class public LTest;#声明类 （必须）</span><br><span class="line">.super Ljava/lang/Object;#声明父类 默认继承Object （必须）</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">.method public static constructor &lt;clinit&gt;()V</span><br><span class="line">  </span><br><span class="line"> </span><br><span class="line">    return-void</span><br><span class="line">.end method</span><br></pre></td></tr></table></figure>

<h2 id><a href="#" class="headerlink" title></a></h2><h2 id="方法调用"><a href="#方法调用" class="headerlink" title="方法调用"></a>方法调用</h2><h4 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">invoke-virtual //用于非私有实例方法的调用</span><br><span class="line">invoke-direct //用于构造方法以及私有方法的调用</span><br><span class="line">invoke-static //调用静态方法</span><br><span class="line">invoke-super //调用父类的方法</span><br><span class="line">invoke-interface //调用接口方法</span><br></pre></td></tr></table></figure>

<h4 id="非私有实例方法的调用"><a href="#非私有实例方法的调用" class="headerlink" title="非私有实例方法的调用"></a>非私有实例方法的调用</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">invoke-virtual &#123;参数&#125;, 方法所属类名;-&gt;方法名(参数类型)返回值类型;</span><br></pre></td></tr></table></figure>

<p>比如以下java代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Test</span><br><span class="line">&#123;</span><br><span class="line">  public Test(String a)&#123;</span><br><span class="line">    getName();</span><br><span class="line">   &#125;</span><br><span class="line">  public String getName()&#123;</span><br><span class="line">    return &quot;hello&quot;;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用smali代码表示为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.class public LTest;#声明类 （必须）</span><br><span class="line">.super Ljava/lang/Object;#声明父类 默认继承Object （必须）</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">.method public constructor &lt;init&gt;( Ljava/lang/String;)V</span><br><span class="line"> </span><br><span class="line">    invoke-direct &#123;p0&#125;, Ljava/lang/Object;-&gt;&lt;init&gt;()V #调用父类构造方法 </span><br><span class="line">	invoke-virtual &#123;p0&#125;, LTest;-&gt;getName()Ljava/lang/String;# 调用普通成员getName方法</span><br><span class="line"></span><br><span class="line">    return-void</span><br><span class="line">.end method</span><br><span class="line"></span><br><span class="line">#声明getName方法</span><br><span class="line">.method public getName()Ljava/lang/String;</span><br><span class="line">  </span><br><span class="line">    const-string v0, &quot;hello&quot;# 定义局部字符串常量</span><br><span class="line">    </span><br><span class="line">    return-object v0 # 返回常量</span><br><span class="line">.end method</span><br></pre></td></tr></table></figure>

<h4 id="私有方法或者构造方法的调用"><a href="#私有方法或者构造方法的调用" class="headerlink" title="私有方法或者构造方法的调用"></a>私有方法或者构造方法的调用</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">invoke-direct &#123;参数&#125;, 方法所属类名;-&gt;方法名(参数类型)返回值类型;</span><br></pre></td></tr></table></figure>

<p><strong>私有方法调用：</strong></p>
<p>比如以下java代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Test</span><br><span class="line">&#123;</span><br><span class="line">  public Test(String a)&#123;</span><br><span class="line">    getName();</span><br><span class="line">   &#125;</span><br><span class="line">   //私有方法</span><br><span class="line">  private String getName()&#123;</span><br><span class="line">    return &quot;hello&quot;;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用smali代码表示为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.class public LTest;#声明类 （必须）</span><br><span class="line">.super Ljava/lang/Object;#声明父类 默认继承Object （必须）</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">.method public constructor &lt;init&gt;(Ljava/lang/String;)V</span><br><span class="line">  </span><br><span class="line">    invoke-direct &#123;p0&#125;, Ljava/lang/Object;-&gt;&lt;init&gt;()V #调用父类构造方法 </span><br><span class="line">	invoke-direct &#123;p0&#125;, LTest;-&gt;getName()Ljava/lang/String;# 调用私有getName方法</span><br><span class="line"></span><br><span class="line">    return-void</span><br><span class="line">.end method</span><br><span class="line"></span><br><span class="line">#声明getName方法</span><br><span class="line">.method private getName()Ljava/lang/String;</span><br><span class="line">  </span><br><span class="line">    const-string v0, &quot;hello&quot;# 定义局部字符串常量</span><br><span class="line">    </span><br><span class="line">    return-object v0 # 返回常量</span><br><span class="line">.end method</span><br></pre></td></tr></table></figure>

<p><strong>构造方法调用：</strong></p>
<p>比如以下java代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Test</span><br><span class="line">&#123;</span><br><span class="line">  public Test(String a)&#123;</span><br><span class="line">    new Test2(&quot;hello&quot;); </span><br><span class="line">   &#125;</span><br><span class="line">    public class Test2</span><br><span class="line">    &#123;</span><br><span class="line">      public Test2(String a)&#123;    </span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用smali代码表示为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.class public LTest;#声明类 （必须）</span><br><span class="line">.super Ljava/lang/Object;#声明父类 默认继承Object （必须）</span><br><span class="line"></span><br><span class="line"># 匿名内部类的声明</span><br><span class="line">.annotation system Ldalvik/annotation/MemberClasses;</span><br><span class="line">    value = &#123;</span><br><span class="line">        LTest$Test2;</span><br><span class="line">    &#125;</span><br><span class="line">.end annotation</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 构造方法</span><br><span class="line">.method public constructor &lt;init&gt;(Ljava/lang/String;)V</span><br><span class="line">	# 初始化父类构造方法</span><br><span class="line">    invoke-direct &#123;p0&#125;, Ljava/lang/Object;-&gt;&lt;init&gt;()V</span><br><span class="line">	# 创建对象</span><br><span class="line">    new-instance v0, LTest$Test2;</span><br><span class="line">	# 定义常量</span><br><span class="line">    const-string v1, &quot;hello&quot;</span><br><span class="line">	# 调用构造方法</span><br><span class="line">    invoke-direct &#123;v0, p0, v1&#125;, LTest$Test2;-&gt;&lt;init&gt;(LTest;Ljava/lang/String;)V</span><br><span class="line"></span><br><span class="line">    return-void</span><br><span class="line">.end method</span><br></pre></td></tr></table></figure>

<h4 id="静态方法的调用并获取返回值-不区分私有公有-静态优先"><a href="#静态方法的调用并获取返回值-不区分私有公有-静态优先" class="headerlink" title="静态方法的调用并获取返回值(不区分私有公有 静态优先)"></a>静态方法的调用并获取返回值(不区分私有公有 静态优先)</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">invoke-static &#123;参数&#125;, 方法所属类名;-&gt;方法名(参数类型)返回值类型;</span><br></pre></td></tr></table></figure>

<p>比如以下java代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Test</span><br><span class="line">&#123;</span><br><span class="line">  public Test(String a)&#123;</span><br><span class="line">     String b=getName();</span><br><span class="line">     System.out.print(b);</span><br><span class="line">   &#125;</span><br><span class="line">  private static String getName()&#123;</span><br><span class="line">    return &quot;hello&quot;;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用smali代码表示为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.class public LTest;#声明类 （必须）</span><br><span class="line">.super Ljava/lang/Object;#声明父类 默认继承Object （必须）</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">.method public constructor &lt;init&gt;(Ljava/lang/String;)V</span><br><span class="line">  </span><br><span class="line">    invoke-direct &#123;p0&#125;, Ljava/lang/Object;-&gt;&lt;init&gt;()V #调用父类构造方法 </span><br><span class="line">	invoke-static &#123;p0&#125;, LTest;-&gt;getName()Ljava/lang/String;# 调用普通成员getName方法</span><br><span class="line">	move-result-object v0 #将返回值赋给v0</span><br><span class="line">    return-void</span><br><span class="line">.end method</span><br><span class="line"></span><br><span class="line">#声明getName方法</span><br><span class="line">.method public getName()Ljava/lang/String;</span><br><span class="line">  </span><br><span class="line">    const-string v0, &quot;hello&quot;# 定义局部字符串常量</span><br><span class="line">    </span><br><span class="line">    return-object v0 # 返回常量</span><br><span class="line">.end method</span><br></pre></td></tr></table></figure>

<h4 id="父类成员的方法调用"><a href="#父类成员的方法调用" class="headerlink" title="父类成员的方法调用"></a>父类成员的方法调用</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">invoke-super</span><br></pre></td></tr></table></figure>

<p>比如以下java代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">	super.onCreate(savedInstanceState);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用smali代码表示为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.method protected onCreate(Landroid/os/Bundle;)V</span><br><span class="line">    .registers 2</span><br><span class="line"> </span><br><span class="line">    invoke-super &#123;p0, p1&#125;, Landroid/app/Activity;-&gt;onCreate(Landroid/os/Bundle;)V</span><br><span class="line">    return-void</span><br><span class="line">.end method</span><br></pre></td></tr></table></figure>

<h4 id="接口的调用"><a href="#接口的调用" class="headerlink" title="接口的调用"></a>接口的调用</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">invoke-interface  &#123;参数&#125;, 方法所属类名;-&gt;方法名(参数类型)返回值类型;</span><br></pre></td></tr></table></figure>

<p>比如以下java代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Test</span><br><span class="line">&#123;</span><br><span class="line">    private  InterTest a=new Test2();</span><br><span class="line">    public Test(String a)&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    public void setAa()&#123;</span><br><span class="line">       InterTest aa=a;</span><br><span class="line">       # 调用接口方法</span><br><span class="line">        aa.est2();</span><br><span class="line">   &#125;</span><br><span class="line">  public class Test2 implements InterTest</span><br><span class="line">  &#123;</span><br><span class="line">        public Test2()&#123;&#125;</span><br><span class="line">            </span><br><span class="line">  		public void est2()&#123;&#125;</span><br><span class="line">   &#125;</span><br><span class="line">  interface InterTest</span><br><span class="line">  &#123;</span><br><span class="line">      public void est2();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用smali代码表示为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.class public LTest;#声明类 （必须）</span><br><span class="line">.super Ljava/lang/Object;#声明父类 默认继承Object （必须）</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">.method public constructor &lt;init&gt;(Ljava/lang/String;)V</span><br><span class="line">  </span><br><span class="line">    invoke-direct &#123;p0&#125;, Ljava/lang/Object;-&gt;&lt;init&gt;()V #调用父类构造方法 </span><br><span class="line">	invoke-static &#123;p0&#125;, LTest;-&gt;getName()Ljava/lang/String;# 调用普通成员getName方法</span><br><span class="line"></span><br><span class="line">    return-void</span><br><span class="line">.end method</span><br><span class="line"></span><br><span class="line">#声明setAagetName方法</span><br><span class="line">.method public setAa()V</span><br><span class="line">    .registers 2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    iget-object v0, p0, LTest;-&gt;a:LTest$InterTest;</span><br><span class="line">	# 调用接口方法</span><br><span class="line">    invoke-interface &#123;v0&#125;, LTest$InterTest;-&gt;est2()V</span><br><span class="line"></span><br><span class="line">    return-void</span><br><span class="line">.end method</span><br></pre></td></tr></table></figure>

<h2 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h2><p><strong>对象的创建分多步进行：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 声明实例</span><br><span class="line">new-instance +变量名, 对象全包名路径;</span><br><span class="line"># 调用构造方法 (如果构造方法内还定义了成员变量，那么在调用之前需要提前声明，然后在invoke的时候当作参数一并传入)</span><br><span class="line">invoke-direct &#123;变量名&#125;, 对象全包名路径;-&gt;&lt;init&gt;(参数)返回类型</span><br></pre></td></tr></table></figure>

<h5 id="数组的创建"><a href="#数组的创建" class="headerlink" title="数组的创建"></a>数组的创建</h5><pre><code>const/4 v0, 0x4
new-array v0, v0, [I

fill-array-data v0, :array_a

  :array_a
    .array-data 4 # 表示占用四个字节
        0x0
        0x1
        0x2
        0x3
    .end array-data</code></pre><h2 id="数据的定义"><a href="#数据的定义" class="headerlink" title="数据的定义"></a>数据的定义</h2><h4 id="分三大类"><a href="#分三大类" class="headerlink" title="分三大类"></a>分三大类</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">字符串类型数据</span><br><span class="line">字节码数据</span><br><span class="line">数值型数据</span><br></pre></td></tr></table></figure>

<h4 id="数值类型数据拆分"><a href="#数值类型数据拆分" class="headerlink" title="数值类型数据拆分"></a>数值类型数据拆分</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第一种 const开头 占用一个容器(寄存器) 32位/容器</span><br><span class="line">const v0,30</span><br><span class="line">  * const/4 最大只允许存放4位数值(4个二进制位) 1 111 7</span><br><span class="line">  * const/16 最大值允许存放16位数值 第一位默认为符号位 所以计算后15位的数值</span><br><span class="line">  * const 32位 最大32位</span><br><span class="line">  * const/high16 v0,0xFF7f0000</span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">第二种 const-wide 占用两个容器 64位</span><br><span class="line">const-wide v0,30 #占用v0和v1</span><br></pre></td></tr></table></figure>

<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const-string  v0 , &quot;hello&quot;# 定义字符串 将字符串hello赋值给v0</span><br><span class="line"></span><br><span class="line">const-class v0,LGoActivity; # 定义字节码对象 将GoActivity.class对象赋值给v0</span><br><span class="line"></span><br><span class="line"># 以下数据定义高位默认为符号位</span><br><span class="line">const/4 v0,0x2 # 定义一个容器 最大只允许存放半字节4位数据 取值范围为 -8 and 7</span><br><span class="line">const/16 v0 , 0xABCD # 定义定义一个容器 最大只允许存放16位数据 比如short类型数据 取值范围为-32768~32767</span><br><span class="line">const v0 , 0xA# 定义一个容器 最大只允许存放32位数据,比如int类型数据 将数字10赋值给v0 取值范围-2147483647~2147483647</span><br><span class="line">const/high16 #定义一个容器 最大只允许存放高16位数值 比如0xFFFF0000末四位补0 存入高四位0XFFFF</span><br><span class="line"></span><br><span class="line"># const-wide 占用两个寄存器vx和vx+1, 数值必须以L结尾 否则编译不通过</span><br><span class="line">const-wide/16 # 定义两个相连容器 最大只允许存放16位数据</span><br><span class="line">const-wide/32 # 定义两个相连容器 最大只允许存放32位数据</span><br><span class="line">const-wide # 定义两个相连容器 最大只允许存放64位数据</span><br><span class="line">const-wide/high16 # 定义两个相连容器 只允许存放高16位数据</span><br></pre></td></tr></table></figure>

<h2 id="数据取值范围算法"><a href="#数据取值范围算法" class="headerlink" title="数据取值范围算法"></a>数据取值范围算法</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1000 → -8；</span><br><span class="line">1001 → -7； </span><br><span class="line">1010 → -6； </span><br><span class="line">1011 → -5； </span><br><span class="line">1100 → -4； </span><br><span class="line">1101 → -3；</span><br><span class="line">1110 → -2； </span><br><span class="line">1111 → -1； </span><br><span class="line"></span><br><span class="line">0000 → 0； </span><br><span class="line">0001 → 1； </span><br><span class="line">0010 → 2； </span><br><span class="line">0011 → 3；</span><br><span class="line">0100 → 4； </span><br><span class="line">0101 → 5； </span><br><span class="line">0110 → 6； </span><br><span class="line">0111 → 7。</span><br></pre></td></tr></table></figure>

<p>算法：正数的符号位是0，负数的符号位是1。正数的反码、补码与原码一样。负数的反码是让符号位不变，数据位按位取反；补码是将反码加1。</p>
<h2 id="静态字段赋值"><a href="#静态字段赋值" class="headerlink" title="静态字段赋值"></a>静态字段赋值</h2><p><strong>分多步进行 关键代码：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sput-object # s代指static</span><br></pre></td></tr></table></figure>

<p>比如以下java代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Test</span><br><span class="line">&#123;</span><br><span class="line">	private static String a=”hello“;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用smali代码表示为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.class public LTest;#声明类 （必须）</span><br><span class="line">.super Ljava/lang/Object;#声明父类 默认继承Object （必须）</span><br><span class="line">.source &quot;Test.java&quot; # 源码文件 （非必须）</span><br><span class="line"></span><br><span class="line"># 声明静态字段</span><br><span class="line">.field private static a:Ljava/lang/String;</span><br><span class="line"></span><br><span class="line">#类初始化方法 被jvm执行 优先于构造方法</span><br><span class="line">.method static constructor &lt;clinit&gt;()V</span><br><span class="line"></span><br><span class="line">    const-string v0, &quot;hello&quot;# 定义常量值</span><br><span class="line"></span><br><span class="line">    sput-object v0, LTest;-&gt;a:Ljava/lang/String;#常量赋值</span><br><span class="line"></span><br><span class="line">    return-void</span><br><span class="line">.end method</span><br></pre></td></tr></table></figure>

<h2 id="类非静态字段赋值"><a href="#类非静态字段赋值" class="headerlink" title="类非静态字段赋值"></a>类非静态字段赋值</h2><p><strong>分多步进行 关键代码：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">iput-object  # i代表instance</span><br></pre></td></tr></table></figure>

<p>比如以下java代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Test</span><br><span class="line">&#123;</span><br><span class="line">    private  String a=&quot;g&quot;;</span><br><span class="line">    public Test(String a)&#123;</span><br><span class="line">       </span><br><span class="line">    &#125;</span><br><span class="line">    public void setAa()&#123;</span><br><span class="line">        a=&quot;b&quot;; </span><br><span class="line">   &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用smali代码表示为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.class public LTest;#声明类 （必须）</span><br><span class="line">.super Ljava/lang/Object;#声明父类 默认继承Object （必须）</span><br><span class="line">.source &quot;Test.java&quot; # 源码文件 （非必须）</span><br><span class="line"></span><br><span class="line"># 声明字段</span><br><span class="line">.field private a:Ljava/lang/String;</span><br><span class="line"></span><br><span class="line"># 构造方法初始化值a=&quot;g&quot;</span><br><span class="line">.method public constructor &lt;init&gt;(Ljava/lang/String;)V</span><br><span class="line">    .registers 3</span><br><span class="line">	# 初始化父类构造方法</span><br><span class="line">    invoke-direct &#123;p0&#125;, Ljava/lang/Object;-&gt;&lt;init&gt;()V</span><br><span class="line">    # 声明字符串内容</span><br><span class="line">    const-string v0, &quot;g&quot;</span><br><span class="line">	# 赋值</span><br><span class="line">    iput-object v0, p0, LTest;-&gt;a:Ljava/lang/String;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">    return-void</span><br><span class="line">.end method</span><br><span class="line"></span><br><span class="line"># 成员方法修改变量a=&quot;b&quot;</span><br><span class="line">.method public setAa()V</span><br><span class="line">    .registers 2</span><br><span class="line"></span><br><span class="line">    .prologue</span><br><span class="line"></span><br><span class="line">    const-string v0, &quot;b&quot;</span><br><span class="line"></span><br><span class="line">    iput-object v0, p0, LTest;-&gt;a:Ljava/lang/String;</span><br><span class="line"></span><br><span class="line">    return-void</span><br><span class="line">.end method</span><br></pre></td></tr></table></figure>

<h2 id="静态字段取值"><a href="#静态字段取值" class="headerlink" title="静态字段取值"></a>静态字段取值</h2><p><strong>关键代码</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sget-object # s代指static</span><br></pre></td></tr></table></figure>

<p>比如以下java代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Test</span><br><span class="line">&#123;</span><br><span class="line">    private  static  String a=&quot;hello&quot;;</span><br><span class="line">    public Test(String a)&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    public void getA()&#123;</span><br><span class="line">       String aa=a;</span><br><span class="line">   &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用smali代码表示为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.class public LTest;#声明类 （必须）</span><br><span class="line">.super Ljava/lang/Object;#声明父类 默认继承Object （必须）</span><br><span class="line">.source &quot;Test.java&quot; # 源码文件 （非必须）</span><br><span class="line"></span><br><span class="line"># 声明静态字段</span><br><span class="line">.field private static a:Ljava/lang/String;</span><br><span class="line"></span><br><span class="line">#类初始化方法 被jvm执行 优先于构造方法</span><br><span class="line">.method static constructor &lt;clinit&gt;()V</span><br><span class="line"></span><br><span class="line">    const-string v0, &quot;hello&quot;# 定义常量值</span><br><span class="line"></span><br><span class="line">    sput-object v0, LTest;-&gt;a:Ljava/lang/String;#常量赋值</span><br><span class="line"></span><br><span class="line">    return-void</span><br><span class="line">.end method</span><br><span class="line"></span><br><span class="line"># 取值方法</span><br><span class="line">.method public getA()V</span><br><span class="line">    .registers 2</span><br><span class="line"></span><br><span class="line">	# 静态字段取值</span><br><span class="line">    sget-object v0, LTest;-&gt;a:Ljava/lang/String;</span><br><span class="line"></span><br><span class="line">    return-void</span><br><span class="line">.end method</span><br></pre></td></tr></table></figure>

<h2 id="类非静态字段取值"><a href="#类非静态字段取值" class="headerlink" title="类非静态字段取值"></a>类非静态字段取值</h2><p><strong>关键代码：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">iget-object  # i代表instance</span><br></pre></td></tr></table></figure>

<p>比如以下java代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Test</span><br><span class="line">&#123;</span><br><span class="line">    private  String a=&quot;hello&quot;;</span><br><span class="line">    public Test(String a)&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    public void getA()&#123;</span><br><span class="line">       String aa=a;</span><br><span class="line">   &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用smali代码表示为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.class public LTest;#声明类 （必须）</span><br><span class="line">.super Ljava/lang/Object;#声明父类 默认继承Object （必须）</span><br><span class="line">.source &quot;Test.java&quot; # 源码文件 （非必须）</span><br><span class="line"></span><br><span class="line"># 声明静态字段</span><br><span class="line">.field private static a:Ljava/lang/String;</span><br><span class="line"></span><br><span class="line">#构造方法</span><br><span class="line">.method public constructor &lt;init&gt;(Ljava/lang/String;)V</span><br><span class="line">    .registers 3</span><br><span class="line"></span><br><span class="line">    .prologue</span><br><span class="line"></span><br><span class="line">    invoke-direct &#123;p0&#125;, Ljava/lang/Object;-&gt;&lt;init&gt;()V</span><br><span class="line"></span><br><span class="line">    const-string v0, &quot;hello&quot;</span><br><span class="line">	# 初始化成员变量</span><br><span class="line">    iput-object v0, p0, LTest;-&gt;a:Ljava/lang/String;</span><br><span class="line"></span><br><span class="line">    return-void</span><br><span class="line">.end method</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 取值方法</span><br><span class="line">.method public getA()V</span><br><span class="line">    .registers 2</span><br><span class="line"></span><br><span class="line">	# 类非静态字段取值</span><br><span class="line">    iget-object v0, LTest;-&gt;a:Ljava/lang/String;</span><br><span class="line"></span><br><span class="line">    return-void</span><br><span class="line">.end method</span><br></pre></td></tr></table></figure>

<h4 id="注意：以上取值赋值方法都是以String对象举例，如果是基本数据类型，那么按照如下表处理："><a href="#注意：以上取值赋值方法都是以String对象举例，如果是基本数据类型，那么按照如下表处理：" class="headerlink" title="注意：以上取值赋值方法都是以String对象举例，如果是基本数据类型，那么按照如下表处理："></a>注意：以上取值赋值方法都是以String对象举例，如果是基本数据类型，那么按照如下表处理：</h4><p>值定义</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const/4 v0, 0x1 # 实例变量值内容定义 值皆为十六进制</span><br></pre></td></tr></table></figure>

<p>取值：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">iget #实例变量int型取值</span><br><span class="line">sget #静态变量int型取值</span><br></pre></td></tr></table></figure>

<p>赋值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">iput #实例变量int型赋值</span><br><span class="line">sput #静态变量int型赋值</span><br></pre></td></tr></table></figure>

<p>下表以实例变量举例：</p>
<table>
<thead>
<tr>
<th align="center">smali取值赋值和值定义关键字</th>
<th align="center">java</th>
</tr>
</thead>
<tbody><tr>
<td align="center">iget-byte <br>iput-byte<br>const/4</td>
<td align="center">byte</td>
</tr>
<tr>
<td align="center">iget-short <br>iput-short<br>const/4</td>
<td align="center">short</td>
</tr>
<tr>
<td align="center">iget <br>iput<br>const/4</td>
<td align="center">int</td>
</tr>
<tr>
<td align="center">iget-wide<br>iput-wide<br>const-wide/16</td>
<td align="center">long</td>
</tr>
<tr>
<td align="center">iget-<br>iput<br>const/high16</td>
<td align="center">float</td>
</tr>
<tr>
<td align="center">iget-wide-<br>iput-wide<br>const/high16</td>
<td align="center">double</td>
</tr>
<tr>
<td align="center">iget-char-<br>iput-char<br>const/16</td>
<td align="center">char</td>
</tr>
<tr>
<td align="center">iget-boolean-<br>iput-boolean<br>const/4</td>
<td align="center">boolean</td>
</tr>
<tr>
<td align="center">#### 如果是基本数据类型，那么按照如下表处理:</td>
<td align="center"></td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="center">smali取值赋值和值定义关键字</th>
<th align="center">java</th>
</tr>
</thead>
<tbody><tr>
<td align="center">iget-object-<br>iput-object<br>new-array v0, v0, [数据类型签名<br><br>    fill-array-data v0, :array_c</td>
<td align="center">数组</td>
</tr>
<tr>
<td align="center">iget-object-<br>iput-object<br><br>以下两步为类对象定义<br>new-instance v0, 全包名类路径;<br><br>    invoke-direct #调用构造方法</td>
<td align="center">类和接口</td>
</tr>
<tr>
<td align="center">iget-object-<br>iput-object<br>sget-object</td>
<td align="center">枚举</td>
</tr>
<tr>
<td align="center">iget-object-<br>iput-object<br>const-string</td>
<td align="center">String</td>
</tr>
</tbody></table>
<p>以上表结果示例java代码如下，可自行试验：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Test</span><br><span class="line">&#123;</span><br><span class="line">     private  Test2 a=Test2.a;</span><br><span class="line">    public Test(String a)&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    public void setAa()&#123;</span><br><span class="line">       Test2 aa=a;</span><br><span class="line">   &#125;</span><br><span class="line">      public enum Test2</span><br><span class="line">        &#123;</span><br><span class="line">            a,b;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>$$</p>
<p>$$</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Test</span><br><span class="line">&#123;</span><br><span class="line">    private  String a=&quot;a&quot;;</span><br><span class="line">    public Test(String a)&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    public void setAa()&#123;</span><br><span class="line">       String aa=a;</span><br><span class="line">   &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="逻辑语句之条件跳转分支"><a href="#逻辑语句之条件跳转分支" class="headerlink" title="逻辑语句之条件跳转分支"></a>逻辑语句之条件跳转分支</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;if-eq vA, vB, :cond_**&quot;  如果vA等于vB则跳转到:cond_** #equal</span><br><span class="line"></span><br><span class="line">&quot;if-ne vA, vB, :cond_**&quot;  如果vA不等于vB则跳转到:cond_**  # not  equal</span><br><span class="line"></span><br><span class="line">&quot;if-lt vA, vB, :cond_**&quot;  如果vA小于vB则跳转到:cond_**    #less than</span><br><span class="line"></span><br><span class="line">&quot;if-ge vA, vB, :cond_**&quot;  如果vA大于等于vB则跳转到:cond_**  # greater equal</span><br><span class="line"></span><br><span class="line">&quot;if-gt vA, vB, :cond_**&quot;  如果vA大于vB则跳转到:cond_**  # greater than</span><br><span class="line"></span><br><span class="line">&quot;if-le vA, vB, :cond_**&quot;  如果vA小于等于vB则跳转到:cond_** # less equal</span><br><span class="line"></span><br><span class="line">&quot;if-eqz vA, :cond_**&quot;  如果vA等于0则跳转到:cond_** #zero</span><br><span class="line">&quot;if-nez vA, :cond_**&quot;  如果vA不等于0则跳转到:cond_**</span><br><span class="line">&quot;if-ltz vA, :cond_**&quot;  如果vA小于0则跳转到:cond_**</span><br><span class="line">&quot;if-gez vA, :cond_**&quot;  如果vA大于等于0则跳转到:cond_**</span><br><span class="line">&quot;if-gtz vA, :cond_**&quot;  如果vA大于0则跳转到:cond_**</span><br><span class="line">&quot;if-lez vA, :cond_**&quot;  如果vA小于等于0则跳转到:cond_**</span><br></pre></td></tr></table></figure>

<h2 id="逻辑语句之循环"><a href="#逻辑语句之循环" class="headerlink" title="逻辑语句之循环"></a>逻辑语句之循环</h2><p>比如以下java代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">   </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">3</span>;i++)&#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对应的smali代码为:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">.<span class="function">method <span class="keyword">public</span> <span class="keyword">static</span> <span class="title">main</span><span class="params">([Ljava/lang/String;)</span>V</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    <span class="keyword">const</span>/4 v0, 0x0</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    :goto_1</span></span><br><span class="line"><span class="function">    <span class="keyword">const</span>/4 v1, 0x3</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    <span class="keyword">if</span>-ge v0, v1, :cond_7</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    add-<span class="keyword">int</span>/lit8 v0, v0, 0x1 # 加法运算符 v0</span>=v0+<span class="number">0x1</span></span><br><span class="line"></span><br><span class="line">    goto :goto_1</span><br><span class="line"></span><br><span class="line">    :cond_7</span><br><span class="line">    <span class="keyword">return</span>-<span class="keyword">void</span></span><br><span class="line">.end method</span><br></pre></td></tr></table></figure>

<p>如果将int改成long, 结果又不一样,这里使用到了比较运算符cmp(comparable)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">.<span class="function">method <span class="keyword">public</span> <span class="keyword">static</span> <span class="title">main</span><span class="params">([Ljava/lang/String;)</span>V</span></span><br><span class="line"><span class="function">    .registers 5</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    .prologue</span></span><br><span class="line"><span class="function">    .line 4</span></span><br><span class="line"><span class="function">    <span class="keyword">const</span>-wide/16 v0, 0x0</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    :goto_2</span></span><br><span class="line"><span class="function">    <span class="keyword">const</span>-wide/16 v2, 0x3</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    cmp-<span class="keyword">long</span> v2, v0, v2 # cmp-<span class="keyword">long</span>为固定写法 如果v0大于v2 则返回1 赋值给v2  等于为0 小于则为-1</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    <span class="keyword">if</span>-gez v2, :cond_c</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    <span class="keyword">const</span>-wide/16 v2, 0x1</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    add-<span class="keyword">long</span>/2addr v0, v2</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    goto :goto_2</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    .line 6</span></span><br><span class="line"><span class="function">    :cond_c</span></span><br><span class="line"><span class="function">    return-<span class="keyword">void</span></span></span><br><span class="line"><span class="function">.end method</span></span><br></pre></td></tr></table></figure>

<h2 id="smali语法关键字"><a href="#smali语法关键字" class="headerlink" title="smali语法关键字"></a>smali语法关键字</h2><h4 id="line"><a href="#line" class="headerlink" title=".line"></a>.line</h4><p>表示与java源文件代码的映射关系，比如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.line 3  # 代表以下代码还原成java代码在源文件第三行 </span><br><span class="line">const/4 v0, 0x1</span><br><span class="line"></span><br><span class="line">iput v0, p0, LTest;-&gt;a:I</span><br></pre></td></tr></table></figure>

<p><strong>删除该关键字不影响程序执行，该关键字在反编译时能很好地帮助我们阅读smali代码，以该关键字当作代码块的分割线，方便快速阅读执行内容</strong></p>
<h4 id="cond-0"><a href="#cond-0" class="headerlink" title=":cond_0"></a>:cond_0</h4><p>条件分支，配合if使用</p>
<h4 id="prologue"><a href="#prologue" class="headerlink" title=".prologue"></a>.prologue</h4><p>表示程序的开始 可省略</p>
<h4 id="goto-0"><a href="#goto-0" class="headerlink" title=":goto_0"></a>:goto_0</h4><p>goto跳转分支，配合goto关键字使用</p>
<h4 id="local"><a href="#local" class="headerlink" title=".local"></a>.local</h4><p>显示局部变量别名信息,作用等同.line</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">move-result-object v0 # 调用方法后结果储存在v0中</span><br><span class="line">.local v0, &quot;b&quot;:Ljava/lang/String;  # 局部变量v0别名为b 是一个String类型 也就是 String b=v0</span><br></pre></td></tr></table></figure>

<h4 id="locals-N"><a href="#locals-N" class="headerlink" title=".locals N"></a>.locals N</h4><p>注意这个和上面local的区别多加了一个s</p>
<p> 标明了你<strong>在这个函数中最少要用到的本地寄存器的个数</strong> 也即是指明了在这个方法中非参（non-parameter）寄存器的数量</p>
<p>locals和registers具体区别参见:<a href="https://code.newban.cn/171.html">点击跳转</a></p>
<h4 id="registers-N"><a href="#registers-N" class="headerlink" title=".registers N"></a>.registers N</h4><p>在Smali中，如果需要存储变量，必须先声明足够数量的寄存器，1个寄存器可以存储32位长度的类型，比如Int，而两个寄存器可以存储64位长度类型的数据，比如Long或Double</p>
<p>声明可使用的寄存器数量的方式为：<code>.registers N</code>，N代表需要的寄存器的总个数</p>
<p>示例：</p>
<figure class="highlight smali"><table><tr><td class="code"><pre><span class="line"><span class="keyword">.method</span><span class="keyword"> private</span> test(I)V</span><br><span class="line"><span class="keyword">    .registers</span> 4  <span class="comment"># 声明总共需要使用4个寄存器</span></span><br><span class="line"></span><br><span class="line">   <span class="built_in"> const-string </span>v0, <span class="string">"LOG"</span>  <span class="comment"># 将v0寄存器赋值为字符串常量"LOG"</span></span><br><span class="line"></span><br><span class="line">   <span class="built_in"> move </span>v1, p1  <span class="comment"># 将int型参数的值赋给v1寄存器</span></span><br><span class="line"></span><br><span class="line">    return-void</span><br><span class="line"><span class="keyword">.end method</span></span><br></pre></td></tr></table></figure>

<p><strong>那么，如何确定需要使用的寄存器的个数？</strong></p>
<p>由于非static方法，需要占用一个寄存器以保存this指针，那么这类方法的寄存器个数，最低就为1，如果还需要处理传入的参数，则需要再次叠加，此时还需要考虑Double和Float这种需要占用两个寄存器的参数类型，举例来看：</p>
<p>如果一个Java方法声明如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">myMethod(<span class="keyword">int</span> p1, <span class="keyword">float</span> p2, <span class="keyword">boolean</span> p3)<span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>那么对应的Smali则为：</p>
<figure class="highlight smali"><table><tr><td class="code"><pre><span class="line">method <span class="class">LMyObject;</span>-&gt;myMethod(IJZ)V1</span><br></pre></td></tr></table></figure>

<p>此时，寄存器的对应情况如下：</p>
<table>
<thead>
<tr>
<th>寄存器名称</th>
<th>对应的引用</th>
</tr>
</thead>
<tbody><tr>
<td>p0</td>
<td>this</td>
</tr>
<tr>
<td>p1</td>
<td>int型的p1参数</td>
</tr>
<tr>
<td>p2, p3</td>
<td>float型的p2参数</td>
</tr>
<tr>
<td>p4</td>
<td>boolean型的p3参数</td>
</tr>
</tbody></table>
<p>那么最少需要的寄存器个数则为：5</p>
<p>如果方法体内含有常量、变量等定义，则需要根据情况增加寄存器个数，数量只要满足需求，保证需要获取的值不被后面的赋值冲掉即可，方法有：存入类中的字段中（存入后，寄存器可被重新赋值），或者长期占用一个寄存器</p>
<p><strong>寄存器数量只能多不能少</strong></p>
<h3 id="Dalvik指令集"><a href="#Dalvik指令集" class="headerlink" title="Dalvik指令集"></a>Dalvik指令集</h3><p>如果需要使用Smali编写程序，还需要掌握常用的Dalvik虚拟机指令，其合集称为Dalvik指令集。这些指令有点类似x86汇编的指令，但指令更多，使用也非常简单方便。最详尽的介绍，可以参考Android官方的Dalvik相关文档：</p>
<p><a href="https://source.android.com/devices/tech/dalvik/dalvik-bytecode#instructions" target="_blank" rel="noopener">https://source.android.com/devices/tech/dalvik/dalvik-bytecode#instructions</a></p>
<p>一般的指令格式为：<code>[op]-[type](可选)/[位宽，默认4位] [目标寄存器],[源寄存器](可选)</code>，比如：<code>move v1,v2</code>，<code>move-wide/from16 v1,v2</code></p>
<p>这里也列举一些常用的指令，并结合Smali进行说明：</p>
<ul>
<li>移位操作：</li>
</ul>
<p>此类操作常用于赋值</p>
<table>
<thead>
<tr>
<th>指令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>move v1,v2</td>
<td>将v2中的值移入到v1寄存器中（4位，支持int型）</td>
</tr>
<tr>
<td>move/from16 v1,v2</td>
<td>将16位的v2寄存器中的值移入到8位的v1寄存器中</td>
</tr>
<tr>
<td>move/16 v1,v2</td>
<td>将16位的v2寄存器中的值移入到16位的v1寄存器中</td>
</tr>
<tr>
<td>move-wide v1,v2</td>
<td>将寄存器对（一组，用于支持双字型）v2中的值移入到v1寄存器对中（4位，猜测支持float、double型）</td>
</tr>
<tr>
<td>move-wide/from16 v1,v2</td>
<td>将16位的v2寄存器对（一组）中的值移入到8位的v1寄存器中</td>
</tr>
<tr>
<td>move-wide/16 v1,v2</td>
<td>将16位的v2寄存器对（一组）中的值移入到16位的v1寄存器中</td>
</tr>
<tr>
<td>move-object v1,v2</td>
<td>将v2中的对象指针移入到v1寄存器中</td>
</tr>
<tr>
<td>move-object/from16 v1,v2</td>
<td>将16位的v2寄存器中的对象指针移入到v1（8位）寄存器中</td>
</tr>
<tr>
<td>move-object/16 v1,v2</td>
<td>将16位的v2寄存器中的对象指针移入到v1（16位）寄存器中</td>
</tr>
<tr>
<td>move-result v1</td>
<td>将这个指令的上一条指令计算结果，移入到v1寄存器中（需要配合invoke-static、invoke-virtual等指令使用）</td>
</tr>
<tr>
<td>move-result-object v1</td>
<td>将上条计算结果的对象指针移入v1寄存器</td>
</tr>
<tr>
<td>move-result-wide v1</td>
<td>将上条计算结果（双字）的对象指针移入v1寄存器</td>
</tr>
<tr>
<td>move-exception v1</td>
<td>将异常移入v1寄存器，用于捕获try-catch语句中的异常</td>
</tr>
</tbody></table>
<ul>
<li>返回操作：</li>
</ul>
<p>用于返回值，对应Java中的return语句</p>
<table>
<thead>
<tr>
<th>指令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>return-void</td>
<td>返回void，即直接返回</td>
</tr>
<tr>
<td>return v1</td>
<td>返回v1寄存器中的值</td>
</tr>
<tr>
<td>return-object v1</td>
<td>返回v1寄存器中的对象指针</td>
</tr>
<tr>
<td>return-wide v1</td>
<td>返回双字型结果给v1寄存器</td>
</tr>
</tbody></table>
<h2 id="另外"><a href="#另外" class="headerlink" title="另外"></a>另外</h2><p>android studio自带的.class转smali就非常好用,如图:</p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20201104143153.png" alt></p>
<h2 id="从错误总学习"><a href="#从错误总学习" class="headerlink" title="从错误总学习"></a>从错误总学习</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SLog.smali[24,4] Invalid register: v-1. Must be between v0 and v15, inclusive.</span><br></pre></td></tr></table></figure>

<p><strong>寄存器命名从v0-v15 一共15个</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SLog.smali[17,0] A .registers or .locals directive must be present for a non-abstract/non-final method</span><br></pre></td></tr></table></figure>

<p><strong>.registers或者.locals必须存在, 除非是抽象方法或者final方法</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java.lang.VerifyError: Rejecting class com.pangshu.SLog because it failed compile-time verification (declaration of &apos;com.pangshu.SLog&apos; appears in /sdcard/ex.dex)</span><br><span class="line">        at com.pangshu.HelloTest.main(HelloTest.java)</span><br></pre></td></tr></table></figure>

<p>这种错误一般很难定位，因为没有提示具体原因或者具体的行数，有可能是静态方法调用你写成了虚方法的调用，或者是构造函数调用没有加<strong>尖括号</strong>， 甚至是寄存器数量过少 等等</p>
<h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>为什么方法中包括参数在内需要3个寄存器，但是在定义的时候只写了两个却也不报错呢？</p>
<p>如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.method public static print(Ljava/lang/String;)V</span><br><span class="line">	.registers 2 #不报错</span><br><span class="line">	.prologue</span><br><span class="line">	</span><br><span class="line">	invoke-static &#123;p0&#125;,Lcom/pangshu/SLog;-&gt;wrapTag(Ljava/lang/String;)Ljava/lang/String;</span><br><span class="line">	move-result-object v1 #如果这个地方改成v2以上那么报错</span><br><span class="line"></span><br><span class="line">	# log---System.out.print()</span><br><span class="line">	sget-object v0,Ljava/lang/System;-&gt;out:Ljava/io/PrintStream;</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">	# 方法调用</span><br><span class="line">	invoke-virtual &#123;v0,v1&#125;,Ljava/io/PrintStream;-&gt;print(Ljava/lang/String;)V</span><br><span class="line">	</span><br><span class="line">return-void</span><br><span class="line">.end method</span><br></pre></td></tr></table></figure>

<p>答案是：系统会更具最大寄存器的位置进行判断，从v0到vN，数量必须大于N，</p>
<p><strong>本文为作者原创 转载时请注明出处 谢谢</strong></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em>乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</em></p>
]]></content>
      <tags>
        <tag>smali</tag>
      </tags>
  </entry>
  <entry>
    <title>smali基本语法</title>
    <url>/173.html</url>
    <content><![CDATA[<h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="类声明"><a href="#类声明" class="headerlink" title="类声明"></a>类声明</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="方法声明"><a href="#方法声明" class="headerlink" title="方法声明"></a>方法声明</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="字段声明"><a href="#字段声明" class="headerlink" title="字段声明"></a>字段声明</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="字段取值赋值"><a href="#字段取值赋值" class="headerlink" title="字段取值赋值"></a>字段取值赋值</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="方法调用"><a href="#方法调用" class="headerlink" title="方法调用"></a>方法调用</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="方法取值"><a href="#方法取值" class="headerlink" title="方法取值"></a>方法取值</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>smali</tag>
      </tags>
  </entry>
  <entry>
    <title>smali语言之const const/4 const/16 const/high16</title>
    <url>/172.html</url>
    <content><![CDATA[<h2 id="数据的定义"><a href="#数据的定义" class="headerlink" title="数据的定义"></a>数据的定义</h2><h4 id="分三大类"><a href="#分三大类" class="headerlink" title="分三大类"></a>分三大类</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">字符串类型数据</span><br><span class="line">字节码数据</span><br><span class="line">数值型数据</span><br></pre></td></tr></table></figure>

<h4 id="数值类型数据拆分"><a href="#数值类型数据拆分" class="headerlink" title="数值类型数据拆分"></a>数值类型数据拆分</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第一种 const开头 占用一个容器(寄存器) 32位/容器</span><br><span class="line">const v0,30</span><br><span class="line">  * const/4 最大只允许存放4位数值(4个二进制位) 1 111 7</span><br><span class="line">  * const/16 最大值允许存放16位数值 第一位默认为符号位 所以计算后15位的数值</span><br><span class="line">  * const 32位 最大32位</span><br><span class="line">  * const/high16 v0,0xFF7f0000</span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">第二种 const-wide 占用两个容器 64位</span><br><span class="line">const-wide v0,30 #占用v0和v1</span><br></pre></td></tr></table></figure>

<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const-string  v0 , &quot;hello&quot;# 定义字符串 将字符串hello赋值给v0</span><br><span class="line"></span><br><span class="line">const-class v0,LGoActivity; # 定义字节码对象 将GoActivity.class对象赋值给v0</span><br><span class="line"></span><br><span class="line"># 以下数据定义高位默认为符号位</span><br><span class="line">const/4 v0,0x2 # 定义一个容器 最大只允许存放半字节4位数据 取值范围为 -8 and 7</span><br><span class="line">const/16 v0 , 0xABCD # 定义定义一个容器 最大只允许存放16位数据 比如short类型数据 取值范围为-32768~32767</span><br><span class="line">const v0 , 0xA# 定义一个容器 最大只允许存放32位数据,比如int类型数据 将数字10赋值给v0 取值范围-2147483647~2147483647</span><br><span class="line">const/high16 #定义一个容器 最大只允许存放高16位数值 比如0xFFFF0000末四位补0 存入高四位0XFFFF</span><br><span class="line"></span><br><span class="line"># const-wide 占用两个寄存器vx和vx+1, 数值必须以L结尾 否则编译不通过</span><br><span class="line">const-wide/16 # 定义两个相连容器 最大只允许存放16位数据</span><br><span class="line">const-wide/32 # 定义两个相连容器 最大只允许存放32位数据</span><br><span class="line">const-wide # 定义两个相连容器 最大只允许存放64位数据</span><br><span class="line">const-wide/high16 # 定义两个相连容器 只允许存放高16位数据</span><br></pre></td></tr></table></figure>

<h2 id><a href="#" class="headerlink" title></a></h2><p>详情参考:<a href="https://code.newban.cn/169.html">Android逆向开发之smali语言的学习</a></p>
<p><strong>本文为作者原创 转载时请注明出处 谢谢</strong></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em>乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</em></p>
]]></content>
      <tags>
        <tag>smali</tag>
      </tags>
  </entry>
  <entry>
    <title>关于Git版本回退的几种方法</title>
    <url>/175.html</url>
    <content><![CDATA[<h2 id="如果已经commit-想要回退"><a href="#如果已经commit-想要回退" class="headerlink" title="如果已经commit  想要回退"></a>如果已经commit  想要回退</h2><h4 id="版本回退"><a href="#版本回退" class="headerlink" title="版本回退"></a>版本回退</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git reset --hard HEAD^   //一个^代表一个版本 如果回退两个版本那就HEAD^^ 以此类推</span><br></pre></td></tr></table></figure>

<h4 id="指定版本-版本穿梭"><a href="#指定版本-版本穿梭" class="headerlink" title="指定版本/版本穿梭"></a>指定版本/版本穿梭</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git reset --hard 8383f01   //一个^代表一个版本 如果回退两个版本那就HEAD^^ 以此类推</span><br></pre></td></tr></table></figure>

<h2 id="如果还没有commit"><a href="#如果还没有commit" class="headerlink" title="如果还没有commit"></a>如果还没有commit</h2><h4 id="第一种-使用reset回退到当前版本初始状态"><a href="#第一种-使用reset回退到当前版本初始状态" class="headerlink" title="第一种 使用reset回退到当前版本初始状态"></a>第一种 使用reset回退到当前版本初始状态</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git reset --hard HEAD</span><br></pre></td></tr></table></figure>

<h4 id="第二种-使用checkout"><a href="#第二种-使用checkout" class="headerlink" title="第二种 使用checkout"></a>第二种 使用checkout</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git reset checkout . //放弃所有文件的修改</span><br><span class="line">git reset checkout 指定相应文件</span><br></pre></td></tr></table></figure>

<h4 id="第三种-使用stash"><a href="#第三种-使用stash" class="headerlink" title="第三种 使用stash"></a>第三种 使用stash</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git stash  //暂存当前修改的代码</span><br></pre></td></tr></table></figure>

<h4 id="第四种-使用revert重做"><a href="#第四种-使用revert重做" class="headerlink" title="第四种 使用revert重做"></a>第四种 使用revert重做</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git revert -n 版本号</span><br></pre></td></tr></table></figure>

<p><strong>本文为作者原创 转载时请注明出处 谢谢</strong></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em>乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</em></p>
]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>关于Git打标签Tag分支</title>
    <url>/176.html</url>
    <content><![CDATA[<h2 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h2><h4 id="查看当前标签"><a href="#查看当前标签" class="headerlink" title="查看当前标签"></a>查看当前标签</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git tag</span><br></pre></td></tr></table></figure>

<h4 id="在本地代码仓库给项目打上一个标签"><a href="#在本地代码仓库给项目打上一个标签" class="headerlink" title="在本地代码仓库给项目打上一个标签"></a>在本地代码仓库给项目打上一个标签</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git tag -a v1.0 -m &quot;version 1.0&quot;</span><br></pre></td></tr></table></figure>

<h4 id="将标签推送到远程仓库"><a href="#将标签推送到远程仓库" class="headerlink" title="将标签推送到远程仓库"></a>将标签推送到远程仓库</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git push origin v1.0</span><br></pre></td></tr></table></figure>

<h4 id="检出v1-0标签"><a href="#检出v1-0标签" class="headerlink" title="检出v1.0标签"></a>检出v1.0标签</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git checkout origin v1.0</span><br></pre></td></tr></table></figure>

<h4 id="从检出状态创建v1-0bugfix分支"><a href="#从检出状态创建v1-0bugfix分支" class="headerlink" title="从检出状态创建v1.0bugfix分支"></a>从检出状态创建v1.0bugfix分支</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git checkout -b bugfix1.0</span><br></pre></td></tr></table></figure>

<h4 id="查看远程分支"><a href="#查看远程分支" class="headerlink" title="查看远程分支"></a>查看远程分支</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git branch -r</span><br></pre></td></tr></table></figure>

<h4 id="删除远程分支"><a href="#删除远程分支" class="headerlink" title="删除远程分支"></a>删除远程分支</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git branch -r -d origin/bugfix1.0</span><br></pre></td></tr></table></figure>

<p><strong>本文为作者原创 转载时请注明出处 谢谢</strong></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em>乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</em></p>
]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>包名和签名</title>
    <url>/174.html</url>
    <content><![CDATA[<h2 id="包名作用"><a href="#包名作用" class="headerlink" title="包名作用?"></a>包名作用?</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">唯一标识</span><br></pre></td></tr></table></figure>

<h2 id="一台机器能否同时运行两个相同包名的不同应用"><a href="#一台机器能否同时运行两个相同包名的不同应用" class="headerlink" title="一台机器能否同时运行两个相同包名的不同应用?"></a>一台机器能否同时运行两个相同包名的不同应用?</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">不可以</span><br><span class="line">原因: 一个包名代表一个应用, 相同包名系统认为是同一个应用, 会进行覆盖安装</span><br><span class="line">原理: 签名不一致</span><br></pre></td></tr></table></figure>

<h2 id="一台机器能否同时运行两个相同签名的不同应用"><a href="#一台机器能否同时运行两个相同签名的不同应用" class="headerlink" title="一台机器能否同时运行两个相同签名的不同应用?"></a>一台机器能否同时运行两个相同签名的不同应用?</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">可以</span><br></pre></td></tr></table></figure>

<h2 id="历史问题-反编译为什么必须要修改包名"><a href="#历史问题-反编译为什么必须要修改包名" class="headerlink" title="历史问题:反编译为什么必须要修改包名?"></a>历史问题:反编译为什么必须要修改包名?</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">成为一款独立的应用, 方便用户下载安装</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>android基础</tag>
      </tags>
  </entry>
  <entry>
    <title>python金融量化交易</title>
    <url>/177.html</url>
    <content><![CDATA[<blockquote>
<p>量化投资绝对是一个趋势</p>
</blockquote>
<h2 id="免费数据回测平台"><a href="#免费数据回测平台" class="headerlink" title="免费数据回测平台"></a>免费数据回测平台</h2><ul>
<li>米筐 <a href="http://www.ricequant.com" target="_blank" rel="noopener">www.ricequant.com</a></li>
<li>聚宽  <a href="https://www.joinquant.com/" target="_blank" rel="noopener">https://www.joinquant.com/</a> </li>
</ul>
<h2 id="相关代码"><a href="#相关代码" class="headerlink" title="相关代码"></a>相关代码</h2><p>以米筐api为例:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"> <span class="comment">#需求: 获得市盈率大于50且小于65, 营业总收入前10的股票</span></span><br><span class="line"> <span class="comment"># 每日调仓 </span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">init</span><span class="params">(context)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 沪深300</span></span><br><span class="line">    context.hs300_list=index_components(<span class="string">"000300.XSHG"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 在context中保存全局变量</span></span><br><span class="line">    context.s1 = <span class="string">"000001.XSHE"</span></span><br><span class="line">    <span class="comment"># 实时打印日志</span></span><br><span class="line">    logger.info(<span class="string">"RunInfo: &#123;&#125;"</span>.format(context.run_info))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 开启定时器 按月调仓</span></span><br><span class="line">    <span class="comment"># scheduler.run_monthly(getdata,tradingday=1)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getdata</span><span class="params">(context, bar_dict)</span>:</span></span><br><span class="line">    <span class="comment"># 在一号的时候 先执行before_trading 然后执行getdata定时任务方法 最后执行handle_bar</span></span><br><span class="line">    q=query(        fundamentals.eod_derivative_indicator.pe_ratio,fundamentals.income_statement.revenue).filter(</span><br><span class="line">        fundamentals.eod_derivative_indicator.pe_ratio&gt;<span class="number">50</span></span><br><span class="line">    ).filter(</span><br><span class="line">        fundamentals.eod_derivative_indicator.pe_ratio&gt;<span class="number">65</span></span><br><span class="line"></span><br><span class="line">    ).order_by(</span><br><span class="line">        fundamentals.income_statement.revenue.desc()</span><br><span class="line"></span><br><span class="line">    ).filter(</span><br><span class="line">        <span class="comment"># 在指定的股票池当中选择</span></span><br><span class="line">        fundamentals.stockcode.in_(context.hs300_list)</span><br><span class="line"></span><br><span class="line">    ).limit(<span class="number">10</span>)</span><br><span class="line">    found=get_fundamentals(q)</span><br><span class="line">    <span class="comment"># 格式化显示</span></span><br><span class="line">    logger.info(found.T)</span><br><span class="line">    <span class="comment"># 将第一列股票代码 放候选表中</span></span><br><span class="line">    context.stock_list=found.T.index</span><br><span class="line"></span><br><span class="line"><span class="comment"># before_trading此函数会在每天策略交易开始前被调用，当天只会被调用一次</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">before_trading</span><span class="params">(context)</span>:</span></span><br><span class="line">    <span class="comment"># 选股 获得市盈率大于50且小于65, 营业总收入前10的股票</span></span><br><span class="line">    q=query(        fundamentals.eod_derivative_indicator.pe_ratio,fundamentals.income_statement.revenue).filter(</span><br><span class="line">        fundamentals.eod_derivative_indicator.pe_ratio&gt;<span class="number">50</span></span><br><span class="line">    ).filter(</span><br><span class="line">        fundamentals.eod_derivative_indicator.pe_ratio&gt;<span class="number">65</span></span><br><span class="line"></span><br><span class="line">    ).order_by(</span><br><span class="line">        fundamentals.income_statement.revenue.desc()</span><br><span class="line"></span><br><span class="line">    ).limit(<span class="number">10</span>)</span><br><span class="line">    found=get_fundamentals(q)</span><br><span class="line">    <span class="comment"># 格式化显示</span></span><br><span class="line">    logger.info(found.T)</span><br><span class="line">    <span class="comment"># 将第一列股票代码 放候选表中</span></span><br><span class="line">    context.stock_list=found.T.index</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 你选择的证券的数据更新将会触发此段逻辑，例如日或分钟历史数据切片或者是实时数据切片更新</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">handle_bar</span><span class="params">(context, bar_dict)</span>:</span></span><br><span class="line">    <span class="comment"># 先判断仓位是否有股票 如果有,卖出不符合条件的股票</span></span><br><span class="line">    <span class="keyword">if</span> len(context.portfolio.positions.keys())!=<span class="number">0</span>:</span><br><span class="line">        <span class="keyword">for</span> stock <span class="keyword">in</span> context.portfolio.positions.keys():</span><br><span class="line">            <span class="keyword">if</span> stock <span class="keyword">not</span> <span class="keyword">in</span> context.stock_list:</span><br><span class="line">                <span class="comment">#如果持有的股票不在新股票池中, 卖出</span></span><br><span class="line">                order_target_percent(stock,<span class="number">0</span>)</span><br><span class="line">    <span class="comment"># 买入最新股票池中的10只股票 等比买入</span></span><br><span class="line">    <span class="keyword">for</span> new_stock <span class="keyword">in</span> context.stock_list:</span><br><span class="line">        order_target_percent(new_stock,<span class="number">1</span>/len(context.stock_list))</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line"><span class="comment"># after_trading函数会在每天交易结束后被调用，当天只会被调用一次</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">after_trading</span><span class="params">(context)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>

<p><strong>本文为作者原创 转载时请注明出处 谢谢</strong></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em>乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</em></p>
]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>短视频拍摄手法大致有哪些</title>
    <url>/178.html</url>
    <content><![CDATA[<h2 id="推"><a href="#推" class="headerlink" title="推"></a>推</h2><p>说明: 视频拍摄中常用的手法之一, 是指把手机或相机慢慢想拍摄主体推进, 常用于烘托氛围或者强调某个人/事/物</p>
<h2 id="拉"><a href="#拉" class="headerlink" title="拉"></a>拉</h2><p>说明: 是指把手机或者相机慢慢向后拉, 使拍摄主体在画面中慢慢变小, 常用于向观众张氏拍摄主体所处的环境</p>
<h2 id="摇"><a href="#摇" class="headerlink" title="摇"></a>摇</h2><p>说明: 是只拍摄者拍摄机位不懂(站在原地), 通过摇动手机臂带动手机/相机呈弧线运动</p>
<h2 id="移"><a href="#移" class="headerlink" title="移"></a>移</h2><p>说明: 通常是指在水平方向, 按一定运动轨迹进行运动拍摄, 是一种侧面跟拍人物的表现手法</p>
<h2 id="跟"><a href="#跟" class="headerlink" title="跟"></a>跟</h2><p>说明: 通常是指在物体后方一直跟着拍摄主体进行拍摄</p>
<h2 id="升"><a href="#升" class="headerlink" title="升"></a>升</h2><p>说明: 通常是指在手机由下往上进行拍摄, 这种拍摄方式是展现拍摄氛围的绝佳手段</p>
<h2 id="降"><a href="#降" class="headerlink" title="降"></a>降</h2><p>说明: 通常是指在手机由上往下进行拍摄, 这种拍摄方式是拍摄光晕的首选</p>
<h2 id="旋转"><a href="#旋转" class="headerlink" title="旋转"></a>旋转</h2><p>说明: 通常是指被拍摄物是圆形的中心点, 手机按一定半径围绕圆心点进行旋转</p>
<h2 id="静"><a href="#静" class="headerlink" title="静"></a>静</h2><p>说明: 镜头固定 适合知识类型讲解的画面</p>
<p><strong>本文为作者原创 转载时请注明出处 谢谢</strong></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em>乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</em></p>
]]></content>
      <tags>
        <tag>短视频运营</tag>
      </tags>
  </entry>
  <entry>
    <title>8086学习之jump指令</title>
    <url>/180.html</url>
    <content><![CDATA[<h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><p>用于更改CS:IP的值</p>
<p>由于在8086cpu中更改段寄存器CS和指针寄存器IP的值不能直接使用mov赋值, 比如:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mov CS,3000H</span><br><span class="line"></span><br><span class="line">mov IP, 0001H</span><br></pre></td></tr></table></figure>

<p><strong>以上写法不允许</strong></p>
<p>那么, 如果我们需要给其赋值时, 其中一种替代方案就是使用jump指令,比如:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">jump 3000H:0001H # 跳转到该代码段物理地址</span><br></pre></td></tr></table></figure>

<p>如果段地址保持不变, 只是更改偏移地址, 那么需要借助通用寄存器, 如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mov ax,0002H</span><br><span class="line">jump 3000H:0001H </span><br><span class="line">jump ax #等同于jump 3000H:0002H</span><br></pre></td></tr></table></figure>

<p>则只需<code>jump+保存偏移地址的寄存器</code> 这种写法即可</p>
<p>注意不能直接<code>jump 0002H</code>  这样是不允许的</p>
]]></content>
      <tags>
        <tag>汇编</tag>
      </tags>
  </entry>
  <entry>
    <title>Charles抓取Https请求的相关配置Windows篇</title>
    <url>/179.html</url>
    <content><![CDATA[<h2 id="第一步添加SSL代理配置"><a href="#第一步添加SSL代理配置" class="headerlink" title="第一步添加SSL代理配置"></a>第一步添加SSL代理配置</h2><p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20201117233257.png" alt></p>
<p><strong>添加代理主机</strong></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20201117233433.png" alt></p>
<h2 id="第二步-添加根证书"><a href="#第二步-添加根证书" class="headerlink" title="第二步 添加根证书"></a>第二步 添加根证书</h2><p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20201117233616.png" alt></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20201117233701.png" alt></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20201117233918.png" alt></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20201117233947.png" alt></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20201117234024.png" alt></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20201117234100.png" alt></p>
<p>最后重启Charles即可抓包</p>
<h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><h4 id="1-Charles-Map-rRemote"><a href="#1-Charles-Map-rRemote" class="headerlink" title="1.Charles Map rRemote"></a>1.Charles Map rRemote</h4><p>关于<code>https</code>的抓包, 我们在使用<code>charles</code>工具时还可以使用它的路径映射功能, 也就是自动将<code>https</code>替换成<code>http</code>协议</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20220805142316685.png" alt="image-20220805142316685"></p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20220805142357260.png" alt="image-20220805142357260"></p>
<h4 id="2-反编译全局替换"><a href="#2-反编译全局替换" class="headerlink" title="2.反编译全局替换"></a>2.反编译全局替换</h4><p>另外, 如果你是为了给<code>App</code>抓包, 刚好在反编译该<code>App</code>, 在条件允许的情况下, 可以在反编译<code>smali</code>后,批量对源码中的<code>https</code>进行替换 然后重新打包, 效果也不错</p>
<h4 id="3-使用模拟器抓包"><a href="#3-使用模拟器抓包" class="headerlink" title="3.使用模拟器抓包"></a>3.使用模拟器抓包</h4><p>有些网站在手机上可以访问但是在电脑浏览器无法访问 大家懂的, 此时我们若通想通过浏览器控台提取相应的资源无法实现, 而且真机上的浏览器默认屏蔽了一部分<code>https</code>抓包功能 尤其是Android7.0以上版本机器</p>
<p>此时 我们可以考虑使用模拟器 比如网易模拟器 默认配备了<code>Android6.0</code>的系统, 低版本的系统相对来说限制要少很多</p>
<p><strong>本文为作者原创 转载时请注明出处 谢谢</strong></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em>乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</em></p>
]]></content>
      <tags>
        <tag>抓包</tag>
      </tags>
  </entry>
  <entry>
    <title>关于linux指令sed的使用</title>
    <url>/18.html</url>
    <content><![CDATA[<p><strong>sed -i</strong> 主要作用就是操作文本 如下:</p>
<p><strong>去掉 “行首” 带“@”的首字母@</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sed -i &apos;s/^@//&apos; file</span><br></pre></td></tr></table></figure>



<p><strong>特定字符串的行前插入新行</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sed -i &apos;/特定字符串/i 新行字符串&apos; file</span><br></pre></td></tr></table></figure>



<p><strong>特定字符串的行后插入新行</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sed -i &apos;/特定字符串/a 新行字符串&apos; file</span><br></pre></td></tr></table></figure>



<p><strong>特定字符串的删除</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sed -i &apos;/字符串/d&apos; file</span><br></pre></td></tr></table></figure>

<p><strong>提示: 以上斜杠可以换成~ 一样实现相同功能</strong></p>
<h4 id="问题场景："><a href="#问题场景：" class="headerlink" title="问题场景："></a>问题场景：</h4><p>在mac上，使用sed命令把当前目录的test.sql文件内容中的a替换为b，使用命令：sed -i “s/a/b/g” test.sql</p>
<p>遇到报错：sed: 1: “grep …”: extra characters at the end of g command</p>
<p><strong>解决：</strong></p>
<p>在mac中使用sed命令在-i参数后面需要带一对双引号””，正确格式如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sed -i &quot;&quot; &quot;s/a/b/g&quot; test.sql</span><br></pre></td></tr></table></figure>

<p><strong>原因</strong></p>
<p>sed -i 后面的双引号中可写任意字符串或者为空，含义是用于生成源文件的备份文件的文件名。比如上面的例子：sed -i “_tmp” “s/a/b/g” test.sql，在替换test.sql的同时，还会生成test.sql_tmp的备份文件</p>
<p><strong>本文为作者原创 转载时请注明出处 谢谢</strong></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em>乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</em></p>
]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>8086学习之关于数据段的取值和赋值</title>
    <url>/181.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>数据段存在的意义是为了告诉cpu, 该段物理地址存放的是数据而不是指令</p>
<p>那么既然里面存放的是数据, 势必会有取值和赋值</p>
<h2 id="取值"><a href="#取值" class="headerlink" title="取值"></a>取值</h2><p>将20001H物理地址中的数据取值然后填入通用寄存器中, 如下:</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">mov ax ,<span class="number">2000</span>H</span><br><span class="line">mov ds ,ax</span><br><span class="line">mov ax,[1] #[1]等同于 2000H:1H</span><br></pre></td></tr></table></figure>

<p><strong>以上有几个关键的地方需要记忆</strong></p>
<ul>
<li>[]内数字表示偏移地址, 默认将DS设为基地址</li>
<li>必须先声明段地址 也就是必须先给ds赋值</li>
<li>通用寄存器相当于临时变量ax,bx,cx,dx…..  任选 ,只要避免冲突即可</li>
</ul>
<h2 id="赋值"><a href="#赋值" class="headerlink" title="赋值"></a>赋值</h2><p>将BH中的数据赋值给数据物理地址20001H中, 如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mov bh,30H</span><br><span class="line">mov ax ,2000H</span><br><span class="line">mov ds ,ax</span><br><span class="line">mov [1] ,bh</span><br></pre></td></tr></table></figure>

<p>和取值类似, 反过来即可</p>
<h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><ol>
<li>在代码段CS:IP中, cpu读取的内存地址宽度是更具代码所占的字节数据而定, 那么在数据段DS中,如何确定读取多少个字节的数据呢?</li>
</ol>
<p>以取值代码为例:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mov ax ,2000H</span><br><span class="line">mov ds ,ax</span><br><span class="line">mov ax,[1]</span><br></pre></td></tr></table></figure>

<p>如果物理地址和数据一一对应关系如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">20001H-----&gt;23</span><br><span class="line">20002H-----&gt;11</span><br><span class="line">20003H-----&gt;53</span><br><span class="line">20004H-----&gt;71</span><br></pre></td></tr></table></figure>

<p>那么ax中的值是多少呢? </p>
<p><strong>答案是1123 而不是23, 为什么?</strong></p>
<p>这是<strong>根据寄存器容器大小决定的</strong>, 容器大装得多, 容器小装的小, 因为ax是16位容器,那么则获取16位也就是两个字节的数据,即1123, 如果是ah或者al接收的话则获取8位也就是一个字节的数据,即23</p>
<ol start="2">
<li>mov 内存单元:内存单元是不允许的, 比如mov [0],[1]</li>
</ol>
]]></content>
      <tags>
        <tag>汇编</tag>
      </tags>
  </entry>
  <entry>
    <title>汇编学习之大小端模式</title>
    <url>/182.html</url>
    <content><![CDATA[<h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><ul>
<li>大端模式: 是指数据的高字节保存在内存中的低地址中, 而数据的低字节保存在内存的高地址中(高低/低高)(Big Endian)</li>
<li>小端模式: 是指数据的高字节保存在内存中的高地址中, 而数据的低字节保存在内存的低地址中(高高/低低)(Little Endian)</li>
</ul>
<p>ARM既可以工作在大端,也可工作在小端模式</p>
]]></content>
      <tags>
        <tag>汇编</tag>
      </tags>
  </entry>
  <entry>
    <title>如何执行smali代码</title>
    <url>/183.html</url>
    <content><![CDATA[<blockquote>
<p>java代码的执行需要编译成字节码文件然后借助java虚拟机JVM执行, 那么smali代码的执行同样需要借助虚拟机, 只不过是安卓虚拟机DalvikVM, 但是由于Dalvik虚拟机默认识别dex文件, 因此需要将smali文件封装成dex文件</p>
</blockquote>
<h4 id="1-创建smali文件"><a href="#1-创建smali文件" class="headerlink" title="1.创建smali文件"></a>1.创建smali文件</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.class public LTest;</span><br><span class="line">.super Ljava/lang/Object;</span><br><span class="line"></span><br><span class="line">.method public constructor &lt;init&gt;()V</span><br><span class="line">    .registers 1</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line">    invoke-direct &#123;p0&#125;, Ljava/lang/Object;-&gt;&lt;init&gt;()V</span><br><span class="line"></span><br><span class="line">    return-void</span><br><span class="line">.end method</span><br><span class="line"></span><br><span class="line">.method public static main([Ljava/lang/String;)V</span><br><span class="line">    .registers 3</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    sget-object v0, Ljava/lang/System;-&gt;out:Ljava/io/PrintStream;</span><br><span class="line"></span><br><span class="line">    const-string v1, &quot;Hello Pangshu!&quot;</span><br><span class="line"></span><br><span class="line">    invoke-virtual &#123;v0, v1&#125;, Ljava/io/PrintStream;-&gt;println(Ljava/lang/String;)V</span><br><span class="line"></span><br><span class="line">    return-void</span><br><span class="line">.end method</span><br></pre></td></tr></table></figure>

<h4 id="2-smali文件转dex-或者打包成Apk也一样"><a href="#2-smali文件转dex-或者打包成Apk也一样" class="headerlink" title="2.smali文件转dex(或者打包成Apk也一样)"></a>2.smali文件转dex(或者打包成Apk也一样)</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java -jar smali-2.4.0.jar a smali文件或目录 -o 输出目录/xxx.dex</span><br></pre></td></tr></table></figure>

<h4 id="3-将dex传至android设备中-真机或者模拟器"><a href="#3-将dex传至android设备中-真机或者模拟器" class="headerlink" title="3.将dex传至android设备中(真机或者模拟器)"></a>3.将dex传至android设备中(真机或者模拟器)</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">adb push test.dex /sdcard/</span><br></pre></td></tr></table></figure>

<h4 id="4-调用Dalvik-VM执行代码"><a href="#4-调用Dalvik-VM执行代码" class="headerlink" title="4.调用Dalvik VM执行代码"></a>4.调用Dalvik VM执行代码</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">adb shell</span><br><span class="line"></span><br><span class="line">dalvikvm -cp /sdcard/test.dex Test</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em>乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</em></p>
]]></content>
      <tags>
        <tag>smali</tag>
      </tags>
  </entry>
  <entry>
    <title>8086汇编学习之关于栈段相关知识</title>
    <url>/184.html</url>
    <content><![CDATA[<h2 id="Push和Pop"><a href="#Push和Pop" class="headerlink" title="Push和Pop"></a>Push和Pop</h2><p><strong>Push(入栈)</strong>:是修改栈内的数据, 并且将sp指针往低地址偏移</p>
<p><strong>Pop(出栈)</strong>:是读取栈顶数据, 并且将sp指针往高地址偏移</p>
<p><strong>注: Pop指令并未删除栈内原有的数据, 仅仅是读取而已</strong></p>
<h2 id="关于栈底指针位置"><a href="#关于栈底指针位置" class="headerlink" title="关于栈底指针位置"></a>关于栈底指针位置</h2><p>如果是一个空栈, 那么<strong>ss:sp指向栈空间最高地址单元的一个单元</strong></p>
<h2 id="数据宽度"><a href="#数据宽度" class="headerlink" title="数据宽度"></a>数据宽度</h2><p>在8086十六位CPU中, Push和Pop操作的数据都是两个字节的, 也就是说无论是</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">push ax ;将ax里数据写入栈顶 两个字节</span><br><span class="line"></span><br><span class="line">pop ax  ;读取栈顶数据赋值给ax 两个字节</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">pop al ;读取栈顶数据赋值给al 读取两个字节 al接收低八位数据</span><br></pre></td></tr></table></figure>

<p>统统操作两个字节数据</p>
]]></content>
      <tags>
        <tag>汇编</tag>
      </tags>
  </entry>
  <entry>
    <title>8086语言之Loop</title>
    <url>/185.html</url>
    <content><![CDATA[<h2 id="LOOP指令"><a href="#LOOP指令" class="headerlink" title="LOOP指令"></a>LOOP指令</h2><p>Loop指令和cx寄存器配合使用, 用于循环操作,类似于高级语言中的do while循环</p>
<h2 id="使用格式"><a href="#使用格式" class="headerlink" title="使用格式"></a>使用格式</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">	mov cx,循环次数</span><br><span class="line">标号:</span><br><span class="line">	循环执行的程序代码</span><br><span class="line">	loop 标号</span><br></pre></td></tr></table></figure>

<p>标号的名称可以自定义</p>
<h2 id="执行流程"><a href="#执行流程" class="headerlink" title="执行流程"></a>执行流程</h2><ul>
<li><strong>第一步:不管cx中值是否大于0, 先执行一遍循环体</strong>(因为程序还未执行到<code>loop 标号</code>位置时,程序不知道是个循环体, 当做正常流程代码执行)</li>
<li><strong>第二步: 执行到<code>loop 标号</code>位置,确认是个循环体后, 先将cx减1,也就是cx=cx-1</strong></li>
<li><strong>第三步:减1后结果如果大于1,则重复执行循环体, 否则跳过循环体代码,继续执行<code>loop 标号</code>后面的代码</strong></li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>因此,从代码层面上看cx的值代表了循环次数, 事实上只循环了cx-1次 只不过判断之前会先执行一遍循环体, 类似于do while </p>
<h2 id="特殊案例"><a href="#特殊案例" class="headerlink" title="特殊案例"></a>特殊案例</h2><p>根据以上结论, 如果cx的值为0, 减1后为-1, 那程序会怎么执行呢?</p>
<p>答案是会进入死循环 , 8086cpu是16位 的会循环执行65535次  </p>
<p><strong>为什么?</strong></p>
<p>因为-1在计算机里面对应的十六进制为FFFF, 二进制第一位为符号位</p>
<h2 id="小练习"><a href="#小练习" class="headerlink" title="小练习"></a>小练习</h2><p>题目: 取出以下内存地址中的值并且相加取和</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">FFFF0H-----&gt;20h  #每个内存单元存放一个字节数据</span><br><span class="line"></span><br><span class="line">FFFF1H-----&gt;ach</span><br><span class="line"></span><br><span class="line">FFFF2H-----&gt;FFh</span><br></pre></td></tr></table></figure>

<p>正常思维是使用八位寄存器取出对应地址的值,比如:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">mov ax,ffffh</span><br><span class="line">mov ds,ax</span><br><span class="line">mov al,[<span class="number">0</span>]</span><br><span class="line">add al,[<span class="number">1</span>]</span><br><span class="line">add al,[<span class="number">2</span>]</span><br></pre></td></tr></table></figure>

<p>但是这里面存在一个问题, ach+ffh明显超出一个字节, 如果使用al寄存器接收势必数据保存不全,此时,需要再借助一个寄存器,代码修改后如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">mov ax,ffffh</span><br><span class="line">mov ds,ax</span><br><span class="line">mov dx <span class="number">0</span>h ;确保数据为<span class="number">0</span>  避免系统脏数据</span><br><span class="line">    </span><br><span class="line">mov al,[<span class="number">0</span>]</span><br><span class="line">mov ah,<span class="number">0</span>h</span><br><span class="line">add dx,ax</span><br><span class="line">    </span><br><span class="line">mov al,[<span class="number">1</span>]</span><br><span class="line">mov ah,<span class="number">0</span>h</span><br><span class="line">add dx,ax</span><br><span class="line">    </span><br><span class="line">mov al,[<span class="number">2</span>]</span><br><span class="line">mov ah,<span class="number">0</span>h</span><br><span class="line">add dx,ax</span><br></pre></td></tr></table></figure>

<p>这种方式保证了数据超出后自动进位, 最后结合loop循环优化代码,如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">mov ax,ffffh</span><br><span class="line">mov ds,ax</span><br><span class="line">mov dx <span class="number">0</span>h ;确保数据为<span class="number">0</span>  避免系统脏数据</span><br><span class="line">mov bx <span class="number">0</span>h</span><br><span class="line">    mov cx,<span class="number">3</span>h</span><br><span class="line">s:  mov al,[bx]</span><br><span class="line">    mov ah,<span class="number">0</span>h</span><br><span class="line">    add dx,ax</span><br><span class="line">    add,bx,<span class="number">1</span>H</span><br><span class="line">    loop s</span><br></pre></td></tr></table></figure>

<h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p>获取数据, 除了通过ds来获取数据之外, 还可以利用其它段地址来获取, 比如:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mov ax,ds:[0]</span><br><span class="line">mov ax,cs:[0]</span><br><span class="line">mov ax,ss:[0]</span><br><span class="line">mov ax,es:[0]</span><br></pre></td></tr></table></figure>

<p><strong>本文为作者原创 转载时请注明出处 谢谢</strong></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em>乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</em></p>
]]></content>
      <tags>
        <tag>汇编</tag>
      </tags>
  </entry>
  <entry>
    <title>汇编语言知识总结</title>
    <url>/186.html</url>
    <content><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>汇编是<strong>一类</strong>编程语言,每种cpu对应一种cpu语言,这些语言语法大同小异,指令集有所不同,</p>
<p>那么这些cpu语言统称为汇编语言,与java,c++,python等高级语言无异, 只不过汇编更加接近硬件,代码执行效率高</p>
<p>二进制&gt;汇编&gt;c&gt;java</p>
<p>所有编程语言都有相应语法,汇编也不例外, 语法是人定的,只是一套公共协议,目的是方便程序员进行程序开发</p>
<h2 id="为什么要学汇编"><a href="#为什么要学汇编" class="headerlink" title="为什么要学汇编"></a>为什么要学汇编</h2><ul>
<li>了解程序的本质, 利于日常开发</li>
<li>从事硬件相关开发工作</li>
<li>进行反编译逆向</li>
<li>装X</li>
</ul>
<h2 id="常见的cpu架构"><a href="#常见的cpu架构" class="headerlink" title="常见的cpu架构"></a>常见的cpu架构</h2><ul>
<li><p>x86 架构 : PC 端主流  高性能高功耗</p>
</li>
<li><p>ARM  架构: 移动端主流 体积小低功耗 </p>
</li>
<li><p>MIPS  架构:  龙芯3号 国产cpu</p>
</li>
</ul>
<p>不同架构使用的指令集也不一样,  X86使用了CISC复杂指令集 ARM采用了RISC精简指令集 </p>
<blockquote>
<p> RISC可以说是从CISC中取其精华去其糟粕，简化指令功能，让指令的平均执行周期减少，达到提升计算机工作主频的目的，同时引入大量通用寄存器减少不必要的读写过程，提高子程序执行速度，这样一来程序运行时间缩短并且减少了寻址，提高了编译效率，最终达到高性能目的 </p>
</blockquote>
<p><strong>不同cpu架构所对应的汇编语法大致相同, 只是指令集不同</strong></p>
<h2 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h2><p>顾名思义, 寄存器可以理解为是寄生在cpu上存放数据的容器, 在计算机当中,用于存放数据的容器有很多,比如内存条,硬盘等等, 那寄存器有什么不一样呢?</p>
<ul>
<li>寄存器靠近cpu,读写数据速度远大于内存</li>
<li>进行数据的临时存储 </li>
</ul>
<blockquote>
<p>当然 cpu内部除了有寄存器之外,还有运算器和控制器, 对于我们程序员来讲,只需要学习寄存器即可</p>
</blockquote>
<h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><p>寄存器和缓存是两个概念, 由于cpu执行速度太快, 而内存读写数据远远跟不上, 这时需要借助缓存进行数据缓冲,相当于是寄存器和内存之间的中间桥梁, 这样cpu在执行指令的时候能够有源源不断的数据供给</p>
<blockquote>
<p>了解:寄存器–&gt;一级缓存–&gt;二级缓存–&gt;三级缓存–&gt;内存</p>
</blockquote>
<blockquote>
<p>拓展: 如果内存条的读写性能过差, 那么cpu再强悍也使不上劲,巧妇难为无米之炊, 因此平常我们再自己组装电脑时,除了内存条的容量之外,还需要考虑到内存条的品质, 否则影响cpu性能,硬盘同理</p>
</blockquote>
<h2 id="为什么要了解寄存器"><a href="#为什么要了解寄存器" class="headerlink" title="为什么要了解寄存器"></a>为什么要了解寄存器</h2><p>因为程序员如果想要操控cpu或者修改内存, 不能直接操控, 需要借助寄存器, 更改寄存器当中的数据间接地操控cpu和内存</p>
<h2 id="寄存器的数量"><a href="#寄存器的数量" class="headerlink" title="寄存器的数量"></a>寄存器的数量</h2><p>在高级语言中如果要对两个变量进行数据交换,我们通常的做法是使用一个temp临时变量,比如:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int a=1;</span><br><span class="line">int b=2;</span><br><span class="line">int temp;</span><br><span class="line">//数据交换</span><br><span class="line">temp=a;</span><br><span class="line">a=b;</span><br><span class="line">b=temp;</span><br></pre></td></tr></table></figure>

<p><strong>寄存器是一个存储容器,也可以通俗理解为是一个变量</strong>, 那么cpu在进行数据交换时明显一个寄存器是不够的, 在8086cpu中,通用寄存器有好几个,比如ax,bx,cx,dx  这些名称是固定的, 根据cpu的不同名称也各不相同, <strong>咱们只需知道每种cpu都有相应的通用寄存器, 寄存器数量越多,自然运算效率越高</strong></p>
<h2 id="寄存器的分类"><a href="#寄存器的分类" class="headerlink" title="寄存器的分类"></a>寄存器的分类</h2><ul>
<li>通用寄存器 (通用): 用于存放临时数据, 可以简单理解为高级语言中的临时变量</li>
<li>段寄存器 (特有): 内存分段管理 x86架构中分为数据段,代码段和栈段  ARM架构中没有段寄存器</li>
<li>浮点寄存器 (特有): 专用于浮点数的运算</li>
<li>向量寄存器 (特有): 专用于向量运算</li>
<li>标志寄存器  </li>
<li>状态寄存器</li>
<li>……….</li>
</ul>
<h2 id="通用寄存器的命名"><a href="#通用寄存器的命名" class="headerlink" title="通用寄存器的命名"></a>通用寄存器的命名</h2><blockquote>
<p>在x86架构中 , 一共有四个通用寄存器,以16位x86为例, 分别取名为ax,bx,cx,dx 最大只能装16位的数据</p>
<p>在ARM架构中, 一共有31个通用寄存器,以64位arm为例 从x0到x30</p>
<p>在MIPS架构中,, 一共有32个通用寄存器 ,从$0到$31</p>
</blockquote>
<p><strong>在x86架构中,不同精度cpu 通用寄存器名称有所区分:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">;在x86架构中,不同精度cpu 通用寄存器名称有所区分:</span><br><span class="line">0x1122334455667788</span><br><span class="line">  ================ rax (64 bits)  ;字母r开头表示64位寄存器 r是registers的意思</span><br><span class="line">          ======== eax (32 bits)  ;e开头表示32位寄存器 e是扩展的意思 extend</span><br><span class="line">              ====  ax (16 bits)  ;默认ax表示16位寄存器 </span><br><span class="line">              ==    ah (8 bits)</span><br><span class="line">                ==  al (8 bits)</span><br></pre></td></tr></table></figure>

<blockquote>
<p> e是扩展的意思，在386以前，CPU的寄存器的16位的，用AX，BX等表示，<br>386及以后的CPU，它们的寄存器的32位的，所以就用多一个E来表示 </p>
</blockquote>
<p><strong>在ARM架构中,不同精度cpu 通用寄存器名称同样有所区分:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0x1122334455667788</span><br><span class="line">  ================ xN (64 bits)  ;x开头表示64位寄存器 从x0到x30  </span><br><span class="line">  		  ======== WN (64 bits)  ;WN表示64位寄存器中的低32位 64位cpu中才有 32位中没有W这种命名</span><br><span class="line">  		  </span><br><span class="line">          ======== RN (32 bits)  ;字母R开头表示32位寄存器     不一定是大写也有小写</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在64位cpu中WN是XN的低32位, 属于xN的一部分, WN数据改了,xN也会跟着一块改, 也就是说WN无法独立存在, 同时ARM中并没有提供16位和8位寄存器的访问和使用</p>
</blockquote>
<h2 id="汇编代码初探"><a href="#汇编代码初探" class="headerlink" title="汇编代码初探"></a>汇编代码初探</h2><p>工具: <a href="https://godbolt.org/" target="_blank" rel="noopener">https://godbolt.org/</a></p>
<h2 id="进制转换基础"><a href="#进制转换基础" class="headerlink" title="进制转换基础"></a>进制转换基础</h2><ol>
<li>计算机只识别二进制, 汇编中一般使用十六进制表示数据, 使用十六进制是为了方便程序员阅读和开发</li>
<li>二进制和十六进制转换</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">0101</span> <span class="number">1100</span> <span class="number">1001</span> <span class="number">0010</span>  <span class="comment">//二进制</span></span><br><span class="line"> </span><br><span class="line"> <span class="number">5</span>    C    <span class="number">9</span>    <span class="number">2</span>    <span class="comment">//每四位二进制数对应一位十六进制数</span></span><br></pre></td></tr></table></figure>

<p>在x86汇编代码中,十六进制写法为如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mov ax,2000H  ;h结尾表示十六进制, h不区分大小写</span><br></pre></td></tr></table></figure>

<p>在ARM汇编代码中,十六进制写法为如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mov R0,#0x2020202A ;使用0x开头表示  #是固定写法,暂不用理会</span><br></pre></td></tr></table></figure>

<h3 id="数据单位"><a href="#数据单位" class="headerlink" title="数据单位"></a>数据单位</h3><ul>
<li>位 :一个二进制位</li>
<li>字节 :8个二进制位表示一个字节</li>
</ul>
<p>由于八个二进制位转换成十六进制后是两位十六进制数, 所以两个十六进制数占用一个字节:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0x20   ;占用一个字节</span><br><span class="line">或者 </span><br><span class="line">20H    ;占用一个字节</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在计算机中最小的数据单位是位,但在内存中,最小的数据单位是字节,一个内存单元占用一个字节, 内存单元就是一个存放数据的容器,可以比喻为一栋公寓里面的小单间, 每个单间住着一对夫妻</p>
</blockquote>
<h2 id="内存单元和地址"><a href="#内存单元和地址" class="headerlink" title="内存单元和地址"></a>内存单元和地址</h2><p>内存单元相当于一栋公寓里的小单间, 每个单间里面住着一个字节(一对夫妻) , 一对夫妻是两个人, 形容两个十六进制数</p>
<p>地址就相当于这个房间的门牌号, 通常使用十六进制表示(也叫物理地址)</p>
<blockquote>
<p>cpu想要读写内存中的数据, 需要通过地址来需要对应的内存单元,也叫寻址</p>
</blockquote>
<p>那么问题来了, 一栋公寓里一共有多少个单间呢, 或者说单间的数量跟什么有关呢?</p>
<ul>
<li>内存条容量: 既然每个内存单元占的空间是固定的, 那么内存容量越大,房间自然就越多</li>
</ul>
<h4 id="给房间贴门牌号"><a href="#给房间贴门牌号" class="headerlink" title="给房间贴门牌号"></a>给房间贴门牌号</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">0x1</span></span><br><span class="line"><span class="number">0x2</span></span><br><span class="line"><span class="number">0x3</span></span><br><span class="line">...</span><br><span class="line"><span class="number">0x10</span></span><br><span class="line"><span class="number">0x20</span></span><br><span class="line">...</span><br><span class="line"><span class="number">0x100</span></span><br><span class="line"><span class="number">0x200</span>   </span><br><span class="line">...</span><br><span class="line"><span class="number">0x1000</span></span><br><span class="line"><span class="number">0x2000</span></span><br><span class="line">...</span><br><span class="line">    </span><br><span class="line"><span class="number">0xFFFF</span> <span class="number">65535</span></span><br><span class="line">    <span class="number">0xFFFFA</span></span><br></pre></td></tr></table></figure>

<h4 id="现实中门牌编号最大值和什么有关"><a href="#现实中门牌编号最大值和什么有关" class="headerlink" title="现实中门牌编号最大值和什么有关?"></a>现实中门牌编号最大值和什么有关?</h4><ul>
<li><p>装修师傅的计算能力</p>
</li>
<li><p>门牌金属板的宽度(字体大小不变的前提)</p>
</li>
</ul>
<h4 id="在计算机的世界中"><a href="#在计算机的世界中" class="headerlink" title="在计算机的世界中"></a>在计算机的世界中</h4><ul>
<li><p>装修师傅的计算能力—–&gt;cpu运算能力</p>
</li>
<li><p>门牌金属板的宽度——-&gt;地址总线宽度(地址总线数量)</p>
</li>
</ul>
<p>如果对应的cpu是16位的, 同时地址总线也是16位,那么最大只能运算表示16位数也就是<code>0xFFFF</code> , </p>
<p>如果对应的cpu是32位的, 同时地址总线也是32位,那么最大只能表示32位数也就是<code>0xFFFFFFFF</code> </p>
<p>如果对应的cpu是64位的, 同时地址总线也是64位,那么最大只能表示64位数也就是<code>0xFFFFFFFFFFFFFFFF</code> </p>
<blockquote>
<p>在8086cpu中 cpu是16位 但是地址总线却是20位, 本来最大只能表示16位地址值, cpu设计者为了让其能表示20位地址,使用了段地址*16+偏移地址的形式来表示20位地址</p>
</blockquote>
<p><strong>物理地址</strong>=<strong>段地址*16+偏移地址</strong></p>
<p>如果要表示一个20位物理地址0xFFFFA,可以有一下四种写法:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0xFFFFA=0xFFFF*16+0x000A //FFFF0   10*10=100   </span><br><span class="line"></span><br><span class="line">0xFFFFA=0xFFF0*16+0x00FA</span><br><span class="line"></span><br><span class="line">0xFFFFA=0xFF00*16+0x0FFA</span><br><span class="line"></span><br><span class="line">0xFFFFA=0xF000*16+0xFFFA</span><br></pre></td></tr></table></figure>

<blockquote>
<p>因此计算机的寻址能力不单单和cpu有关还和地址总线有关, 32位操作系统对应32位地址总线, 这也就是为什么即便你用的是64位cpu,如果只装了32位操作系统,无法完全发挥cpu和内存的性能</p>
</blockquote>
<h2 id="栈和队列"><a href="#栈和队列" class="headerlink" title="栈和队列"></a>栈和队列</h2><p>栈和队列都是数据存储结构,数据结构大致包含以下几种存储结构：</p>
<ol>
<li><strong>线性表</strong>，还可细分为顺序表,链表、栈和队列；</li>
</ol>
<ul>
<li><strong>树结构</strong>，包括普通树,二叉树,线索二叉树；</li>
<li><strong>图存储结构</strong></li>
</ul>
<ul>
<li>队列结构 :先进先出, 和排队一样</li>
<li>栈存储结构 : 先进后出, 类似于往往杯子里放饼干, 第一个放的最后一个取出</li>
</ul>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20201218154435.png" alt></p>
<p>栈作用 : </p>
<ul>
<li>用于存储临时数据, </li>
<li>对数据进行暂时性保护,不被复写</li>
<li>寄存器不够用时,使用栈临时代替中转</li>
</ul>
<blockquote>
<p>寄存器和栈同样用于存放临时数据, 那么它们两者有什么区别呢?</p>
<p>寄存器类似于全局变量,是个公共容器,可以被所有函数读写,寄存器中的数据容易被覆盖, 常用于短周期使用</p>
<p>栈空间是累加型结构: 如果想要复写第一个放入的数据,必须先将后面存放的数据丢弃, 类似于递归, 适合嵌套数据,这也是为什么函数和函数中的局部变量都存放在栈中的原因</p>
</blockquote>
<h2 id="总线"><a href="#总线" class="headerlink" title="总线"></a>总线</h2><p>存在的意义, 内存中的数据不能直接运算,必须将其读取到寄存器中进行处理, cpu运算完毕后,将其保存至内存中, 那么这一系列过程中,涉及到数据传输, 那么这三条线就是干这个用的</p>
<h2 id="x86汇编语法"><a href="#x86汇编语法" class="headerlink" title="x86汇编语法"></a>x86汇编语法</h2><ol>
<li><strong>注释</strong></li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">;我是注释</span><br></pre></td></tr></table></figure>

<blockquote>
<p>了解: arm汇编注释同为;  而mips汇编注释为#</p>
</blockquote>
<ol start="2">
<li><strong>变量取值和赋值(传送指令)</strong></li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">;赋值</span><br><span class="line">mov ax,2000H ;将十六进制2000赋值给十六位寄存器ax  相当于ax=2000H</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">;取值</span><br><span class="line">mov bx,ax ;将ax中的值取出赋值给bx  相当于bx=ax</span><br></pre></td></tr></table></figure>

<blockquote>
<p>无论是x86还是arm传送指令都是mov</p>
<p>存放的数据大小根据使用的寄存器而定, 比如ax是16位寄存器,最大只能存放16位数据,也就是4位十六进制数据</p>
</blockquote>
<ol start="3">
<li><strong>函数声明</strong></li>
</ol>
<p>结构如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">函数名:</span><br><span class="line">	函数体</span><br><span class="line">	ret   ;结尾标记</span><br></pre></td></tr></table></figure>

<p>示例:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">print:	;函数名</span><br><span class="line">		mov dx,offset str</span><br><span class="line">		mov ah 9ch </span><br><span class="line">		int 21h</span><br><span class="line">		</span><br><span class="line">		ret ;函数结尾标记</span><br></pre></td></tr></table></figure>

<ol start="4">
<li><strong>函数调用</strong></li>
</ol>
<p>x86架构中使用关键指令<code>call</code>, ARM架构中使用关键指令<code>bl</code></p>
<p>x86架构汇编示例:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">		call print ;调用print函数</span><br><span class="line">		</span><br><span class="line">		;退出程序</span><br><span class="line">		mov ah 4ch </span><br><span class="line">		int 21h</span><br><span class="line">		</span><br><span class="line">print:	;函数名</span><br><span class="line">		mov dx,offset str;获取别名对应数据的偏移地址</span><br><span class="line">		mov ah 9ch ;9h表示调用显存 从dx总读取偏移地址对应的数据</span><br><span class="line">		int 21h</span><br><span class="line">		ret</span><br></pre></td></tr></table></figure>

<p>ARM架构汇编代码示例:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.text </span><br><span class="line">.global _A,_B ;定义两个全局函数 A和B</span><br><span class="line"></span><br><span class="line">_A:</span><br><span class="line">	mov x0 ,#0xa0 ;arm汇编中数据用#开头</span><br><span class="line">	bl _B ;调用函数B</span><br><span class="line">	mov x1 ,#0x00</span><br><span class="line">	add x1 ,x0,#0x14 ;x1=x0+0x14</span><br><span class="line">	ret  </span><br><span class="line">	</span><br><span class="line">_B:</span><br><span class="line">	add x0, x0,#0x10</span><br><span class="line">	ret ;返回到bl指令所对应的下一条指令</span><br></pre></td></tr></table></figure>

<h2 id="C语言内嵌汇编代码-GCC内联汇编"><a href="#C语言内嵌汇编代码-GCC内联汇编" class="headerlink" title="C语言内嵌汇编代码(GCC内联汇编)"></a>C语言内嵌汇编代码(GCC内联汇编)</h2><p><strong>格式</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">asm volatile(   ;asm也可写成 __asm__ 或者__asm</span><br><span class="line">&quot;汇编指令&quot;</span><br><span class="line">:&quot;=限制符&quot;(输出参数) ,&quot;=限制符&quot;(输出参数)</span><br><span class="line">:&quot;限制符&quot;(输入参数)</span><br><span class="line">:保留列表</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">;volatile是可选关键字,表示禁止编译器对汇编代码进行优化</span><br><span class="line">;汇编指令之间使用\n进行分隔</span><br><span class="line">;限制符用于和c语言交互,属于可选,多个参数使用逗号进行分隔</span><br></pre></td></tr></table></figure>

<p><strong>代码示例:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//将input的值赋值给result </span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int result = 0;</span><br><span class="line">    int input = 1;</span><br><span class="line">  asm volatile (</span><br><span class="line">        &quot;movl %1, %0\n&quot; // 通过占位符指定交互的变量  %1赋值给%0</span><br><span class="line">        : &quot;=r&quot;(result)      // 输出变量，与汇编交互</span><br><span class="line">        : &quot;r&quot;(input)            // 输入变量，与汇编交互</span><br><span class="line">// 这里的r指示编译器自动将通用寄存器关联到变量</span><br><span class="line">        );</span><br><span class="line">     printf(&quot;result = %d\n&quot;, result);</span><br><span class="line">    printf(&quot;input = %d\n&quot;, input);</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>我们看到，movl指令的操作数（operand）中，出现了%1、%0，这往往让新手摸不着头脑。其实只要知道下面的规则就不会产生疑惑了：</p>
<p>在内联汇编中，操作数通常用数字来引用，具体的编号规则为：若命令共涉及n个操作数，则第1个输出操作数（the first output operand）被编号为0，第2个output operand编号为1，依次类推，最后1个输入操作数（the last input operand）则被编号为n-1。</p>
<p>具体到上面的示例代码中，根据上下文，涉及到2个操作数变量a、b，这段汇编代码的作用是将a的值赋给b，可见，a是input operand，而b是output operand，那么根据操作数的引用规则，不难推出，a应该用%1来引用，b应该用%0来引用。</p>
</blockquote>
<p><strong>常用限制符参照:</strong></p>
<table>
<thead>
<tr>
<th>限制符</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>r</td>
<td>通用寄存器</td>
</tr>
<tr>
<td>a</td>
<td>eax,ax,al</td>
</tr>
<tr>
<td>b</td>
<td>ebx,bx,bl</td>
</tr>
<tr>
<td>c</td>
<td>ecx,cx,cl</td>
</tr>
<tr>
<td>d</td>
<td>edx,dx,dl</td>
</tr>
<tr>
<td>S</td>
<td>esi,si</td>
</tr>
<tr>
<td>D</td>
<td>edi,di</td>
</tr>
<tr>
<td>q</td>
<td>寄存器a,b,c,d</td>
</tr>
<tr>
<td>m</td>
<td>使用合法的内存代表参数</td>
</tr>
<tr>
<td>g</td>
<td>任意寄存器,内存,立即数</td>
</tr>
</tbody></table>
<h4 id="为什么有些汇编语法不一致"><a href="#为什么有些汇编语法不一致" class="headerlink" title="为什么有些汇编语法不一致"></a>为什么有些汇编语法不一致</h4><p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20201219152638.png" alt></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20201219152550.png" alt></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20201219152733.png" alt></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20201219152718.png" alt></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20201219152750.png" alt></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20201219152815.png" alt></p>
<h3 id="C语言外链汇编"><a href="#C语言外链汇编" class="headerlink" title="C语言外链汇编"></a>C语言外链汇编</h3><p>新建一个汇编原文件, linux平台.s结尾 ,windows平台.asm结尾</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">;外链汇编</span><br><span class="line">;以下使用的是AT&amp;T的汇编语法</span><br><span class="line"></span><br><span class="line">.text ;声明为代码段</span><br><span class="line">.global _sum  ;定义为全局函数, 否则无法被外界访问</span><br><span class="line">_sum:  ;函数名称必须_开头</span><br><span class="line">    movq %rdi,%rax  ;方法参数存放在di和di寄存器中</span><br><span class="line">    addq %rsi,%rax</span><br><span class="line">    retq</span><br></pre></td></tr></table></figure>

<p>然后在C中进行相应调用即可</p>
<p><strong>本文为作者原创 转载时请注明出处 谢谢</strong></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em>乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</em></p>
]]></content>
      <tags>
        <tag>汇编</tag>
      </tags>
  </entry>
  <entry>
    <title>ida工具的使用</title>
    <url>/188.html</url>
    <content><![CDATA[<blockquote>
<p>这里以ida7.0版本为例  ida理论上支持各种文件的查看包括exe，dll ， so等等</p>
</blockquote>
<h3 id="主要界面了解"><a href="#主要界面了解" class="headerlink" title="主要界面了解"></a>主要界面了解</h3><p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20201211161923.png" alt></p>
<h3 id="汇编界面转源代码界面"><a href="#汇编界面转源代码界面" class="headerlink" title="汇编界面转源代码界面"></a>汇编界面转源代码界面</h3><p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20201211162340.png" alt></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20201211162115.png" alt></p>
<p><strong>使用F5快捷键进入</strong></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20201211162600.png" alt></p>
<p><strong>右键选择hide casts后界面好看多了</strong></p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20201211162721409.png" alt></p>
<p><strong>668是什么鬼？继续优化</strong></p>
<p>选中env变量名右键选择se lvar type 或者使用快捷键Y ,然后填入JNIEnv*</p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20201211163143.png" alt></p>
<p><strong>这时,代码舒爽多了</strong></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20201211163431.png" alt></p>
<h3 id="快速查看当前文件所包含的字符串"><a href="#快速查看当前文件所包含的字符串" class="headerlink" title="快速查看当前文件所包含的字符串"></a>快速查看当前文件所包含的字符串</h3><p>使用shift+F12快捷键</p>
<p><strong>本文为作者原创 转载时请注明出处 谢谢</strong></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em>乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</em></p>
]]></content>
      <tags>
        <tag>android反编译</tag>
      </tags>
  </entry>
  <entry>
    <title>android反编译之jni接口数据的获取的几种方法</title>
    <url>/187.html</url>
    <content><![CDATA[<h2 id="如果没有签名校验"><a href="#如果没有签名校验" class="headerlink" title="如果没有签名校验"></a>如果没有签名校验</h2><ol>
<li><p><strong>通过加壳的形式或者log插桩获取</strong></p>
</li>
<li><p><strong>直接抽取so文件 然后构建一个新app</strong></p>
</li>
</ol>
<h2 id="如果app或者so库有签名校验"><a href="#如果app或者so库有签名校验" class="headerlink" title="如果app或者so库有签名校验"></a>如果app或者so库有签名校验</h2><ol>
<li><p><strong>使用ida工具静态分析so库</strong> </p>
</li>
<li><p><strong>使用xposed工具动态获取</strong></p>
<p>原料:</p>
<ul>
<li><p>一台root设备, 推荐使用模拟器</p>
<ul>
<li>xposed框架安装包</li>
<li>编写hook插件 （关键）</li>
</ul>
</li>
</ul>
</li>
</ol>
<h2 id="xposed工具简单介绍"><a href="#xposed工具简单介绍" class="headerlink" title="xposed工具简单介绍"></a>xposed工具简单介绍</h2><p>xposed是一个第三方的app, 用于hook代码, 可以简单理解为代码拦截, </p>
<p>该app存在的作用:</p>
<ul>
<li>内部集成了相应的hook环境包</li>
<li>方便管理多个插件</li>
</ul>
<h4 id="插件hook的原理"><a href="#插件hook的原理" class="headerlink" title="插件hook的原理"></a>插件hook的原理</h4><p>插件其实就是一个独立的app, 只不过该app内部自定义了一些标识能够被xposed框架app识别, xposed框架将我们编写好的带有标识的app当成插件进行管理, 插件利用xposed框架中集成好的hook环境实现hook操作</p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/11111111.png" alt></p>
<p><strong>本文为作者原创 转载时请注明出处 谢谢</strong></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em>乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</em></p>
]]></content>
      <tags>
        <tag>android反编译</tag>
      </tags>
  </entry>
  <entry>
    <title>8086汇编语言之代码分段</title>
    <url>/189.html</url>
    <content><![CDATA[<p>##　场景</p>
<p>当我们需要在内存中申请一块空间，可以使用伪指令<strong>db</strong>和<strong>dw</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">db--&gt;define <span class="keyword">byte</span>  定义字节</span><br><span class="line">dw--&gt;define word  定义字</span><br></pre></td></tr></table></figure>

<p>如果按照以下写法:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">	db 1,2,3,4,5</span><br><span class="line">	db &apos;hello&apos;</span><br><span class="line">	db &quot;pangshu&quot;</span><br><span class="line">	</span><br><span class="line">	mov al ,cs:[0] ;取出预先定义好的数据 ip默认从0开始</span><br><span class="line">	;退出程序</span><br><span class="line">	mov ah 4ch</span><br><span class="line">	int 21h</span><br><span class="line">code ends</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<p>以上代码存在一个问题, 由于数据是在代码段中定义, cpu默认将数据识别为代码, 将导致数据不可用,那么解决办法为,增加入口标记:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">	db 1,2,3,4,5</span><br><span class="line">	db &apos;hello&apos;</span><br><span class="line">	db &quot;pangshu&quot;</span><br><span class="line">	</span><br><span class="line">start:	mov al ,cs:[0] ;取出预先定义好的数据 ip默认从0开始</span><br><span class="line">		;退出程序</span><br><span class="line">		mov ah 4ch</span><br><span class="line">		int 21h</span><br><span class="line">code ends</span><br><span class="line">end start ;标记名称可自定义</span><br></pre></td></tr></table></figure>

<p>标记是为了告诉编译器代码段入口位置, 这样就能保证db数据不被识别为指令</p>
<h2 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h2><ol>
<li>如果我想定义20个0数据,有一种快捷的语法:</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment	</span><br><span class="line">	db 20 dup(0) ;申请20个字节的空间 然后存放0</span><br><span class="line">	</span><br><span class="line">start:	mov al ,cs:[0] ;取出预先定义好的数据 ip默认从0开始</span><br><span class="line">		;退出程序</span><br><span class="line">		mov ah 4ch</span><br><span class="line">		int 21h</span><br><span class="line">code ends</span><br><span class="line">end start ;标记名称可自定义</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>数据段和栈段的定义</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment	</span><br><span class="line">	db 20 dup(0) ;可存数据也可当作栈</span><br><span class="line">	db 20 dup(0) ;可存数据也可当作栈</span><br><span class="line">start:	;将数据所在的物理基地址交由ds段寄存器进行存放管理</span><br><span class="line">		mov dx,cs</span><br><span class="line">		mov ds,dx</span><br><span class="line">		mov ax,1122h</span><br><span class="line">		mov [0],ax</span><br><span class="line">		</span><br><span class="line">		;定义栈段 将栈空间所在的物理基地址交由ss栈段进行保存管理</span><br><span class="line">		mov ss,ds</span><br><span class="line">		mov sp,40 ;从高字节往低字节存放</span><br><span class="line">		push ax</span><br><span class="line">		</span><br><span class="line">		;退出程序</span><br><span class="line">		mov ah 4ch</span><br><span class="line">		int 21h</span><br><span class="line">code ends</span><br><span class="line">end start ;标记名称可自定义</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>分段定义</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">assume cs:code,ds:data,ss:stack</span><br><span class="line"></span><br><span class="line">;数据段 代码段可直接获取数据段中数据, 相当于高级语言中的局部变量</span><br><span class="line">stack segment</span><br><span class="line">	db 20 dup(0) ;定义数据相当于是定义了段地址</span><br><span class="line">stack ends</span><br><span class="line"></span><br><span class="line">;数据段 代码段可直接获取数据段中数据, 相当于高级语言中的全局变量</span><br><span class="line">data segment</span><br><span class="line">	db 20 dup(0) ;定义数据相当于是定义了段地址</span><br><span class="line">	age dw 20h ;给数据取个别名为age</span><br><span class="line">	</span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line">code segment	</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">start:	</span><br><span class="line">		mov ax,1122h</span><br><span class="line">		mov age,ax ; 相当于[14h],ax</span><br><span class="line">		</span><br><span class="line">		;退出程序</span><br><span class="line">		mov ah 4ch</span><br><span class="line">		int 21h</span><br><span class="line">code ends</span><br><span class="line">end start ;标记名称可自定义</span><br></pre></td></tr></table></figure>

<h2 id="额外思考"><a href="#额外思考" class="headerlink" title="额外思考"></a>额外思考</h2><p>事实上我们使用的段其实是一个逻辑概念，即是我们自己定义的，</p>
<p>再说白了，我定义一个段，我说它是数据段那它就是数据段，我说它是代码段那么它就是代码段，</p>
<p>它们其实都是一块连续的内存而已，至于为什么要区分为数据段和代码段，</p>
<p>很明显，是用来给我们编程提供方便的，即我们在自己的思想上或者说是编码习惯上规定，</p>
<p>数据放数据段中，代码放代码段中 。而我们在使用数据段的时候，为了方便或者说是代码的编写方便起见，</p>
<p>我们一般把数据段的段地址放在 DS 寄存器中，当然，如果你硬要觉得 DS 不顺眼，那你可以换个 ES 也是一样的，但是换成CS则不行，因为CS指向的数据都被当成指令进行处理，如果换成SS呢，可行，但是读取数据需要使用pop，修改数据需要使用push，如果是用DS或者ES ，可以直接使用DS:[0]这种形式进行内存数据的读写</p>
<p>被DS和ES指向的内存空间的数据被cpu当作数据处理，被SS指向的内存空间的数据被cpu当作是栈空间，被CS指向的内存空间的数据被cpu当作指令进行执行</p>
<p>看注释说明:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">assume cs:code,ds:data,ss:stack</span><br><span class="line"></span><br><span class="line">;开辟了一块栈空间 同时生成了与之对应的物理地址</span><br><span class="line">stack segment</span><br><span class="line">	db 20 dup(0) ;定义数据相当于是定义了段地址</span><br><span class="line">stack ends</span><br><span class="line"></span><br><span class="line">;开辟了一块数据空间 同时生成了与之对应的物理地址</span><br><span class="line">data segment</span><br><span class="line">	db 20 dup(0) ;定义数据相当于是定义了段地址</span><br><span class="line">	age dw 20h ;给数据取个别名为age</span><br><span class="line">	</span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line">;开辟了一块代码空间 如果没有入口标记 那么里面无论存放什么, cpu都把它当成指令</span><br><span class="line">code segment	</span><br><span class="line">start:	</span><br><span class="line">		;程序开始</span><br><span class="line">		</span><br><span class="line">		;获取栈空间基地址 存放在ss寄存器中</span><br><span class="line">		mov ax ,stack</span><br><span class="line">		mov ss ,ax</span><br><span class="line">		;获取数据空间基地址 存放在ds寄存器中</span><br><span class="line">		mov ax,data</span><br><span class="line">		mov ds ,ax</span><br><span class="line">		</span><br><span class="line">		;如果有别名 可以直接使用别名访问数据,而不需要另外借助段地址</span><br><span class="line">		mov age,ax ; 相当于[14h],ax</span><br><span class="line">		</span><br><span class="line">		;退出程序</span><br><span class="line">		mov ah 4ch</span><br><span class="line">		int 21h</span><br><span class="line">code ends</span><br><span class="line">end start ;标记名称可自定义</span><br></pre></td></tr></table></figure>

<p><strong>本文为作者原创 转载时请注明出处 谢谢</strong></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em>乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</em></p>
]]></content>
      <tags>
        <tag>汇编</tag>
      </tags>
  </entry>
  <entry>
    <title>8086汇编语言之Call和ret指令</title>
    <url>/191.html</url>
    <content><![CDATA[<h2 id="call"><a href="#call" class="headerlink" title="call"></a>call</h2><p><strong>可以理解为高级语言中函数的调用</strong></p>
<p>使用格式为:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">call  标号/地址</span><br></pre></td></tr></table></figure>

<p>执行流程:</p>
<pre><code>* 先将下一条指令的偏移地址入栈
* 然后跳转到定位的标号地址执行指令</code></pre><h2 id="ret"><a href="#ret" class="headerlink" title="ret"></a>ret</h2><p><strong>可以理解为高级语言中的return</strong></p>
<p>官方解释:</p>
<p>ret指令就是讲栈顶的值Pop给IP</p>
<h2 id="栈平衡"><a href="#栈平衡" class="headerlink" title="栈平衡"></a>栈平衡</h2><p>编译器为了保证ret之后执行调用栈中预先通过call入栈的下一条指令, 需要将临时push进栈中的局部变量 和参数等进行pop, 从而保持栈sp值恢复原样, 也就是所谓的栈平衡</p>
<p><strong>特点</strong>: ip突然上升,而后ip突然恢复  </p>
<p><strong>本文为作者原创 转载时请注明出处 谢谢</strong></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em>乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</em></p>
]]></content>
      <tags>
        <tag>汇编</tag>
      </tags>
  </entry>
  <entry>
    <title>8086汇编语言之dos打印hello world</title>
    <url>/190.html</url>
    <content><![CDATA[<h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">assume cs:code,ds:data,ss:stack</span><br><span class="line"></span><br><span class="line">;数据段 代码段可直接获取数据段中数据, 相当于高级语言中的局部变量</span><br><span class="line">stack segment</span><br><span class="line">	db 20 dup(0) ;定义数据相当于是定义了段地址</span><br><span class="line">stack ends</span><br><span class="line"></span><br><span class="line">;数据段 代码段可直接获取数据段中数据, 相当于高级语言中的全局变量</span><br><span class="line">data segment</span><br><span class="line">	db 20 dup(0) ;定义数据相当于是定义了段地址</span><br><span class="line">	db &apos;hello world!$&apos; ;$ 表示结尾标记</span><br><span class="line">	</span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line">code segment	</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">start:	</span><br><span class="line">		;设置ds和ss</span><br><span class="line">		mov ax,data</span><br><span class="line">		mov ds,ax</span><br><span class="line">		mov ax stack</span><br><span class="line">		mov ss,ax</span><br><span class="line">		</span><br><span class="line">		;业务逻辑代码</span><br><span class="line">		mov dx,14h</span><br><span class="line">		mov ah 9h ;9h表示调用显存 从dx总读取偏移地址对应的数据</span><br><span class="line">		int 21h</span><br><span class="line">		</span><br><span class="line">		;退出程序</span><br><span class="line">		mov ah 4ch </span><br><span class="line">		int 21h</span><br><span class="line">code ends</span><br><span class="line">end start ;标记名称可自定义</span><br></pre></td></tr></table></figure>

<p><strong>使用数据别名优化代码</strong></p>
<p>第一种:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">assume cs:code,ds:data,ss:stack</span><br><span class="line"></span><br><span class="line">;数据段 代码段可直接获取数据段中数据, 相当于高级语言中的局部变量</span><br><span class="line">stack segment</span><br><span class="line">	db 20 dup(0) ;定义数据相当于是定义了段地址</span><br><span class="line">stack ends</span><br><span class="line"></span><br><span class="line">;数据段 代码段可直接获取数据段中数据, 相当于高级语言中的全局变量</span><br><span class="line">data segment</span><br><span class="line">	db 20 dup(0) ;定义数据相当于是定义了段地址</span><br><span class="line">	str: db &apos;hello world!$&apos; ;$ 表示结尾标记 str:表示指向该数据的地址</span><br><span class="line">	</span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line">code segment	</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">start:	</span><br><span class="line">		;设置ds和ss</span><br><span class="line">		mov ax,data</span><br><span class="line">		mov ds,ax</span><br><span class="line">		mov ax stack</span><br><span class="line">		mov ss,ax</span><br><span class="line">		</span><br><span class="line">		;业务逻辑代码</span><br><span class="line">		mov dx,str</span><br><span class="line">		mov ah,9h ;9h表示调用显存 从dx总读取偏移地址对应的数据</span><br><span class="line">		int 21h</span><br><span class="line">		</span><br><span class="line">		;退出程序</span><br><span class="line">		mov ah 4ch </span><br><span class="line">		int 21h</span><br><span class="line">code ends</span><br><span class="line">end start ;标记名称可自定义</span><br></pre></td></tr></table></figure>

<p>第二种:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">assume cs:code,ds:data,ss:stack</span><br><span class="line"></span><br><span class="line">;数据段 代码段可直接获取数据段中数据, 相当于高级语言中的局部变量</span><br><span class="line">stack segment</span><br><span class="line">	db 20 dup(0) ;定义数据相当于是定义了段地址</span><br><span class="line">stack ends</span><br><span class="line"></span><br><span class="line">;数据段 代码段可直接获取数据段中数据, 相当于高级语言中的全局变量</span><br><span class="line">data segment</span><br><span class="line">	db 20 dup(0) ;定义数据相当于是定义了段地址</span><br><span class="line">	str db &apos;hello world!$&apos; ;$ 表示结尾标记</span><br><span class="line">	</span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line">code segment	</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">start:	</span><br><span class="line">		;设置ds和ss</span><br><span class="line">		mov ax,data</span><br><span class="line">		mov ds,ax</span><br><span class="line">		mov ax,stack</span><br><span class="line">		mov ss,ax</span><br><span class="line">		</span><br><span class="line">		;业务逻辑代码</span><br><span class="line">		mov dx,offset str;获取别名对应数据的偏移地址</span><br><span class="line">		mov ah, 9h ;9h表示调用显存 从dx总读取偏移地址对应的数据</span><br><span class="line">		int 21h</span><br><span class="line">		</span><br><span class="line">		;退出程序</span><br><span class="line">		mov ah, 4ch </span><br><span class="line">		int 21h</span><br><span class="line">code ends</span><br><span class="line">end start ;标记名称可自定义</span><br></pre></td></tr></table></figure>

<p>知识点:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第一种 方案使用str:</span><br><span class="line">str: db &apos;hello world!$&apos; ; str:表示指向该数据的地址</span><br><span class="line">;业务逻辑代码</span><br><span class="line">mov dx, str</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">第二种 方案使用offset</span><br><span class="line">str db &apos;hello world!$&apos; ;$ 表示结尾标记 str表示指向该数据的内容</span><br><span class="line">;业务逻辑代码</span><br><span class="line">mov dx,offset str;获取别名对应数据的偏移地址 如果直接使用str表示将hello world!中的h赋值给dx</span><br></pre></td></tr></table></figure>

<p><strong>本文为作者原创 转载时请注明出处 谢谢</strong></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em>乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</em></p>
]]></content>
      <tags>
        <tag>汇编</tag>
      </tags>
  </entry>
  <entry>
    <title>关于mv 移动文件时出现Argument list too long的解决方案</title>
    <url>/19.html</url>
    <content><![CDATA[<h4 id="移动所有文件到指定目录"><a href="#移动所有文件到指定目录" class="headerlink" title="移动所有文件到指定目录"></a>移动所有文件到指定目录</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mv 需要移动的目录/* 目标目录/</span><br></pre></td></tr></table></figure>

<p>当出现文件过多时报错:<code>Argument list too long</code></p>
<h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案:"></a>解决方案:</h4><p>移动文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">find sourcePath/ -name &quot;*.txt&quot;  -exec mv &#123;&#125; targetPath/  \;</span><br></pre></td></tr></table></figure>

<p>or:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">find sourcePath/ -type f  -exec mv &#123;&#125; targetPath/  \;</span><br></pre></td></tr></table></figure>

<p>查看所有行目录下所有txt文件的行：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">find sourcePath/ -name &quot;*.txt&quot; |xargs cat |wc -l</span><br></pre></td></tr></table></figure>

<h3 id="只移动前5个文件"><a href="#只移动前5个文件" class="headerlink" title="只移动前5个文件"></a>只移动前5个文件</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mv `ls |sed -n 1,5p  /post</span><br></pre></td></tr></table></figure>

<h3 id="只拷贝前5个文件"><a href="#只拷贝前5个文件" class="headerlink" title="只拷贝前5个文件"></a>只拷贝前5个文件</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cp -R `ls |sed -n 1,5p /post</span><br></pre></td></tr></table></figure>

<p><strong>本文为作者原创 转载时请注明出处 谢谢</strong></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em>乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</em></p>
]]></content>
      <tags>
        <tag>linux指令</tag>
      </tags>
  </entry>
  <entry>
    <title>8086汇编语言之函数的声明和调用</title>
    <url>/192.html</url>
    <content><![CDATA[<h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">assume cs:code,ds:data,ss:stack</span><br><span class="line"></span><br><span class="line">;数据段</span><br><span class="line">stack segment</span><br><span class="line">	db 20 dup(0) ;定义数据相当于是定义了段地址</span><br><span class="line">stack ends</span><br><span class="line"></span><br><span class="line">;数据段</span><br><span class="line">data segment</span><br><span class="line">	db 20 dup(0) ;定义数据相当于是定义了段地址</span><br><span class="line">	str db &apos;hello world!$&apos; ;$ 表示结尾标记</span><br><span class="line">	</span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line">code segment	</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">start:	</span><br><span class="line">		;设置ds和ss</span><br><span class="line">		mov ax,data</span><br><span class="line">		mov ds,ax</span><br><span class="line">		mov ax stack</span><br><span class="line">		mov ss,ax</span><br><span class="line">		</span><br><span class="line">		;业务逻辑代码</span><br><span class="line">		mov dx,offset str;获取别名对应数据的偏移地址</span><br><span class="line">		mov ah 9ch ;9h表示调用显存 从dx总读取偏移地址对应的数据</span><br><span class="line">		int 21h</span><br><span class="line">		</span><br><span class="line">		;退出程序</span><br><span class="line">		mov ah 4ch </span><br><span class="line">		int 21h</span><br><span class="line">code ends</span><br><span class="line">end start ;标记名称可自定义</span><br></pre></td></tr></table></figure>

<h2 id="需求-将打印Hello-world-封装成一个函数"><a href="#需求-将打印Hello-world-封装成一个函数" class="headerlink" title="需求: 将打印Hello world!封装成一个函数"></a>需求: 将打印Hello world!封装成一个函数</h2><p>使用标号即可:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">assume cs:code,ds:data,ss:stack</span><br><span class="line"></span><br><span class="line">;数据段 </span><br><span class="line">stack segment</span><br><span class="line">	db 20 dup(0) ;定义数据相当于是定义了段地址</span><br><span class="line">stack ends</span><br><span class="line"></span><br><span class="line">;数据段 </span><br><span class="line">data segment</span><br><span class="line">	db 20 dup(0) ;定义数据相当于是定义了段地址</span><br><span class="line">	str db &apos;hello world!$&apos; ;$ 表示结尾标记</span><br><span class="line">	</span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line">code segment	</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">start:	</span><br><span class="line">		;设置ds和ss</span><br><span class="line">		mov ax,data</span><br><span class="line">		mov ds,ax</span><br><span class="line">		mov ax stack</span><br><span class="line">		mov ss,ax</span><br><span class="line">		</span><br><span class="line">print:	;函数名</span><br><span class="line">		;业务逻辑代码</span><br><span class="line">		mov dx,offset str;获取别名对应数据的偏移地址</span><br><span class="line">		mov ah 9ch ;9h表示调用显存 从dx总读取偏移地址对应的数据</span><br><span class="line">		int 21h</span><br><span class="line">		</span><br><span class="line">		;退出程序</span><br><span class="line">		mov ah 4ch </span><br><span class="line">		int 21h</span><br><span class="line">code ends</span><br><span class="line">end start ;标记名称可自定义</span><br></pre></td></tr></table></figure>

<p><strong>由于print函数默认执行,为了保证在call时才执行, 咱们将print函数代码移至中断后:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">assume cs:code,ds:data,ss:stack</span><br><span class="line"></span><br><span class="line">;数据段 </span><br><span class="line">stack segment</span><br><span class="line">	db 20 dup(0) ;定义数据相当于是定义了段地址</span><br><span class="line">stack ends</span><br><span class="line"></span><br><span class="line">;数据段 </span><br><span class="line">data segment</span><br><span class="line">	db 20 dup(0) ;定义数据相当于是定义了段地址</span><br><span class="line">	str db &apos;hello world!$&apos; ;$ 表示结尾标记</span><br><span class="line">	</span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line">code segment	</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">start:	</span><br><span class="line">		;设置ds和ss</span><br><span class="line">		mov ax,data</span><br><span class="line">		mov ds,ax</span><br><span class="line">		mov ax stack</span><br><span class="line">		mov ss,ax</span><br><span class="line">		</span><br><span class="line">		;业务逻辑代码</span><br><span class="line">		call print ;调用print函数</span><br><span class="line">		</span><br><span class="line">		;退出程序</span><br><span class="line">		mov ah 4ch </span><br><span class="line">		int 21h</span><br><span class="line">		</span><br><span class="line">print:	;函数名</span><br><span class="line">		mov dx,offset str;获取别名对应数据的偏移地址</span><br><span class="line">		mov ah 9ch ;9h表示调用显存 从dx总读取偏移地址对应的数据</span><br><span class="line">		int 21h</span><br><span class="line">code ends</span><br><span class="line">end start ;标记名称可自定义</span><br></pre></td></tr></table></figure>

<p>该代码存在一个问题,就是调用print函数后程序无法终止, 此时加上ret优化 ,最终代码为:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">assume cs:code,ds:data,ss:stack</span><br><span class="line"></span><br><span class="line">;数据段 </span><br><span class="line">stack segment</span><br><span class="line">	db 20 dup(0) ;定义数据相当于是定义了段地址</span><br><span class="line">stack ends</span><br><span class="line"></span><br><span class="line">;数据段 </span><br><span class="line">data segment</span><br><span class="line">	db 20 dup(0) ;定义数据相当于是定义了段地址</span><br><span class="line">	str db &apos;hello world!$&apos; ;$ 表示结尾标记</span><br><span class="line">	</span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line">code segment	</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">start:	</span><br><span class="line">		;设置ds和ss</span><br><span class="line">		mov ax,data</span><br><span class="line">		mov ds,ax</span><br><span class="line">		mov ax stack</span><br><span class="line">		mov ss,ax</span><br><span class="line">		</span><br><span class="line">		;业务逻辑代码</span><br><span class="line">		call print ;调用print函数</span><br><span class="line">		</span><br><span class="line">		;退出程序</span><br><span class="line">		mov ah 4ch </span><br><span class="line">		int 21h</span><br><span class="line">		</span><br><span class="line">print:	;函数名</span><br><span class="line">		mov dx,offset str;获取别名对应数据的偏移地址</span><br><span class="line">		mov ah 9ch ;9h表示调用显存 从dx总读取偏移地址对应的数据</span><br><span class="line">		int 21h</span><br><span class="line">		ret</span><br><span class="line">code ends</span><br><span class="line">end start ;标记名称可自定义</span><br></pre></td></tr></table></figure>

<p><strong>本文为作者原创 转载时请注明出处 谢谢</strong></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em>乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</em></p>
]]></content>
      <tags>
        <tag>汇编</tag>
      </tags>
  </entry>
  <entry>
    <title>Android系统目前支持CPU架构都有哪些</title>
    <url>/193.html</url>
    <content><![CDATA[<h2 id="7种CPU架构"><a href="#7种CPU架构" class="headerlink" title="7种CPU架构"></a>7种CPU架构</h2><ul>
<li><strong>armeabi (ARM v5)</strong>:32位cpu 属于 第5代、第6代早期的ARM处理器 </li>
<li><strong>armeabi-v7a (ARM v7)</strong>:32位cpu 属于 第7代的 ARM 处理器   从2010年起 </li>
<li><strong>arm64-v8a (ARM v8):</strong> 第8代、64位ARM处理器 </li>
<li><strong>x86</strong> : 32位处理器  从2011年起 </li>
<li><strong>x86_64</strong> : 64位处理器  从2014年起 </li>
<li><strong>MIPS  :</strong> 32位处理器  从2012年起 </li>
<li><strong>MIPS64</strong> : 64位处理器  从2014年起 </li>
</ul>
<h1 id="兼容和文件读取顺序"><a href="#兼容和文件读取顺序" class="headerlink" title="兼容和文件读取顺序"></a>兼容和文件读取顺序</h1><p>arm64-v8a是可以向下兼容的，其下有armeabi-v7a，armeabi<br>armeabi-v7a向下兼容armeabi</p>
<p>对于一个cpu是arm64-v8a架构的手机，它运行app时，进入jnilibs去读取库文件时，先看有没有arm64-v8a文件夹：</p>
<p>如果没有该文件夹，去找armeabi-v7a文件夹，如果没有，再去找armeabi文件夹，如果连这个文件夹也没有，就抛出异常<br>如果有arm64-v8a文件夹，那么就去找特定名称的.so文件，<strong>注意：如果没有找到，不会再往下（armeabi-v7a文件夹）找了，而是直接抛出异常</strong></p>
<blockquote>
<p>由于向下兼容的特性 高版本的设备可以使用低版本armeabi的so库, 但是低版本不支持高版本库, 这也就是为什么很多开发商包括微信只保留了armeabi的so库,从而兼容市面上所有的设备</p>
</blockquote>
<h2 id="只保留armeabi存在的问题"><a href="#只保留armeabi存在的问题" class="headerlink" title="只保留armeabi存在的问题"></a>只保留armeabi存在的问题</h2><p> <strong>所有的x86/x86_64/armeabi-v7a/arm64-v8a设备都支持armeabi架构的.so文件</strong>，因此似乎移除其他ABIs的.so文件是一个减少APK大小的好技巧。但事实上并不是：这不只影响到函数库的性能和兼容性 </p>
<p> 64位设备（arm64-v8a, x86_64, mips64）能够运行32位的函数库，但是以32位模式运行，在64位平台上运行32位版本的ART和Android组件，将丢失专为64位优化过的性能（ART，webview，media等等） </p>
<p><strong>本文为作者原创 转载时请注明出处 谢谢</strong></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em>乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</em></p>
]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>汇编语言之ARM64汇编</title>
    <url>/194.html</url>
    <content><![CDATA[<h3 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h3><p>CPU除了有控制器、运算器还有寄存器。其中寄存器的作用就是进行数据的临时存储。</p>
<blockquote>
<p>CPU的运算速度是非常快的，为了性能CPU在内部开辟一小块临时存储区域，并在进行运算时先将数据从内存复制到这一小块临时存储区域中，运算时就在这一小快临时存储区域内进行。我们称这一小块临时存储区域为寄存器。</p>
</blockquote>
<p>对于arm64系的CPU来说， 如果寄存器以x开头则表明的是一个64位的寄存器，如果以w开头则表明是一个32位的寄存器，在系统中没有提供16位和8位的寄存器供访问和使用。其中32位的寄存器是64位寄存器的低32位部分并不是独立存在的。</p>
<h3 id="高速缓存"><a href="#高速缓存" class="headerlink" title="高速缓存"></a>高速缓存</h3><p>iPhoneX上搭载的ARM处理器A11它的1级缓存的容量是64KB，2级缓存的容量8M.</p>
<blockquote>
<p>CPU每执行一条指令前都需要从内存中将指令读取到CPU内并执行。而寄存器的运行速度相比内存读写要快很多,为了性能,CPU还集成了一个<strong>高速缓存存储区域</strong>.当程序在运行时，先将要执行的指令代码以及数据复制到高速缓存中去(由操作系统完成).CPU直接从高速缓存依次读取指令来执行.</p>
</blockquote>
<h3 id="通用寄存器"><a href="#通用寄存器" class="headerlink" title="通用寄存器"></a>通用寄存器</h3><ul>
<li>ARM64拥有有31个64位的通用寄存器 x0 到 x30,这些寄存器通常用来存放一般性的数据，称为通用寄存器（有时也有特定用途） <ul>
<li>那么w0 到 w28 这些是32位的. 因为64位CPU可以兼容32位.所以可以只使用64位寄存器的低32位.</li>
<li>比如 w0 就是 x0的低32位!</li>
</ul>
</li>
</ul>
<h3 id="数据地址寄存器"><a href="#数据地址寄存器" class="headerlink" title="数据地址寄存器"></a>数据地址寄存器</h3><p>数据地址寄存器通常用来做数据计算的临时存储、做累加、计数、地址保存等功能。定义这些寄存器的作用主要是用于在CPU指令中保存操作数，在CPU中当做一些常规变量来使用。<br> <strong>ARM64中</strong></p>
<ul>
<li>64位: X0-X30, XZR(零寄存器 ,里面存放数据0)</li>
<li>32位: W0-W30, WZR(零寄存器)</li>
</ul>
<blockquote>
<p>注意:<br> 有一种特殊的寄存器段寄存器:CS,DS,SS,ES四个寄存器来保存这些段的基地址,这个属于Intel架构CPU中.在ARM中并没有</p>
</blockquote>
<h3 id="浮点和向量寄存器"><a href="#浮点和向量寄存器" class="headerlink" title="浮点和向量寄存器"></a>浮点和向量寄存器</h3><p>因为浮点数的存储以及其运算的特殊性,CPU中专门提供浮点数寄存器来处理浮点数</p>
<ul>
<li>浮点寄存器 64位: D0 - D31  32位: S0 - S31</li>
</ul>
<p>现在的CPU支持向量运算.(向量运算在图形处理相关的领域用得非常的多)为了支持向量计算系统了也提供了众多的向量寄存器.</p>
<ul>
<li>向量寄存器 128位:V0-V31</li>
</ul>
<h3 id="PC寄存器-program-counter"><a href="#PC寄存器-program-counter" class="headerlink" title="PC寄存器(program counter)"></a>PC寄存器(program counter)</h3><p>为指令指针寄存器, 它指示了CPU当前要读取指令的地址, 类似于x86汇编种的cs+ip</p>
<h3 id="SP和FP寄存器"><a href="#SP和FP寄存器" class="headerlink" title="SP和FP寄存器"></a>SP和FP寄存器</h3><ul>
<li>sp寄存器在任意时刻会保存我们栈顶的地址.</li>
<li>fp寄存器也称为x29寄存器属于通用寄存器,但是在某些时刻我们利用它保存栈底的地址!()</li>
</ul>
<blockquote>
<p>注意:ARM64开始,取消32位的 LDM,STM,PUSH,POP指令! 取而代之的是ldr\ldp  str\stp<br> ARM64里面 对栈的操作是16字节对齐的!!</p>
</blockquote>
<h3 id="关于内存读写指令"><a href="#关于内存读写指令" class="headerlink" title="关于内存读写指令"></a>关于内存读写指令</h3><blockquote>
<p>注意:读/写 数据是都是往高地址读/写  也就是sp指针是从高地址往低地址移动但是指向的数据是往高地址读写，堆指针是从低往高地址移动，堆和栈各占一头，两个指针相撞则抛出堆栈内存溢出</p>
</blockquote>
<p><strong>str(store register)指令</strong></p>
<p>将数据从寄存器中读出来,存到内存中.</p>
<p><strong>ldr(load register)指令</strong></p>
<p>将数据从内存中读出来,存到寄存器中 </p>
<p>此ldr 和 str 的变种ldp(pair) 和 stp(pair) 还可以操作2个寄存器.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">;利用栈进行数据交换</span><br><span class="line">.text</span><br><span class="line">.global _A</span><br><span class="line">_A:</span><br><span class="line">	sub sp,sp,#0x20 ;sp=sp-0x20 开辟一个32字节的占空间</span><br><span class="line">	stp x0,x1,[sp,#0x10] ;然后将x0和x1中的数据存入sp+0x10所指向的栈空间 []相当于是获取指定地址的空间,不会改变sp原来的值,如果想改变sp的值只需在末尾加上!  也就是[sp,#0x10]! 即可</span><br><span class="line">	ldp x1,x0,[sp,#0x10] ;读取sp+0x10这块栈空间中的数据存放至x1，x0寄存器中</span><br><span class="line">	add sp,sp,#0x20 ；栈平衡， 释放内存空间</span><br><span class="line">	ret ;返回至调用指令下一行</span><br></pre></td></tr></table></figure>

<blockquote>
<p>stur指令:  偏移量为减时使用 . stur  w0, [x29, #0x8]  偏移量为负的  将寄存器w0的值存入x29 - 0x8 的内存地址 </p>
<p>[sp]: sp保存栈空间的地址值, [sp]表示取值,获取所对应的空间 和8086中的[bx]是类似的</p>
</blockquote>
<h4 id="另外-汇编简写"><a href="#另外-汇编简写" class="headerlink" title="另外 汇编简写"></a>另外 汇编简写</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">stp x29,x30,[sp,#-0x10]! ;尾部多了一个!号</span><br><span class="line"></span><br><span class="line">;相当于一下两行代码</span><br><span class="line">sub sp,sp,#0x10</span><br><span class="line">stp x29,x30,[sp]</span><br><span class="line">;或者直接理解为加了!号的sp值会发生改变</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ldp x29,x30 ,[sp],#x010</span><br><span class="line">;相当于以下两行代码</span><br><span class="line">ldp x29,x30,[sp]</span><br><span class="line">add sp,#0x10</span><br></pre></td></tr></table></figure>

<h3 id="bl指令"><a href="#bl指令" class="headerlink" title="bl指令"></a>bl指令</h3><ul>
<li>CPU从何处执行指令是由pc中的内容决定的，我们可以通过改变pc的内容来控制CPU执行目标指令</li>
<li>ARM64提供了一个mov指令（传送指令），可以用来修改大部分寄存器的值，比如<ul>
<li>mov x0,#10、mov x1,#20</li>
</ul>
</li>
<li>但是，mov指令不能用于设置pc的值，ARM64没有提供这样的功能</li>
<li>ARM64提供了另外的指令来修改PC的值，这些指令统称为转移指令，最简单的是bl指令</li>
</ul>
<p>类似于x86汇编中的, call</p>
<h4 id="bl标号"><a href="#bl标号" class="headerlink" title="bl标号"></a>bl标号</h4><ul>
<li>将下一条指令的地址放入lr(x30)寄存器</li>
<li>转到标号处执行指令</li>
</ul>
<h4 id="ret"><a href="#ret" class="headerlink" title="ret"></a>ret</h4><ul>
<li>默认使用lr(x30)寄存器的值,通过底层指令提示CPU此处作为下条指令地址!</li>
</ul>
<blockquote>
<p>ARM64平台的特色指令,它面向硬件做了优化处理的</p>
</blockquote>
<h4 id="x30寄存器"><a href="#x30寄存器" class="headerlink" title="x30寄存器"></a>x30寄存器</h4><p>x30寄存器存放的是函数的返回地址.当ret指令执行时刻,会寻找x30寄存器保存的地址值!</p>
<blockquote>
<p>注意:在函数嵌套调用之前的时候.需要将x30入栈!</p>
</blockquote>
<h4 id="arm代码示例"><a href="#arm代码示例" class="headerlink" title="arm代码示例"></a>arm代码示例</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.text ;代码段</span><br><span class="line">.global _A,_B ;定义两个全局函数 A和B</span><br><span class="line"></span><br><span class="line">_A:</span><br><span class="line">	mov x0 ,#0xa0 ;arm汇编中数据用#开头</span><br><span class="line">	mov x1 ,#0x00</span><br><span class="line">	add x1 ,x0,#0x14 ;x1=x0+0x14</span><br><span class="line">	ret  ;返回到bl指令所对应的下一条指令</span><br><span class="line">	</span><br><span class="line">_B:</span><br><span class="line">	add x0, x0,#0x10</span><br><span class="line">	ret</span><br></pre></td></tr></table></figure>

<h4 id="寄存器和栈"><a href="#寄存器和栈" class="headerlink" title="寄存器和栈"></a>寄存器和栈</h4><p>寄存器是全局容器,所有函数共用,但是栈不一样,一个函数占用独有的栈空间, 在各个函数嵌套调用时,寄存器很容易被覆盖读写,这个时候为了保持寄存器的数据不被改变,通常结合栈临时保存寄存器中的值,然后函数ret之前将数据恢复,这样就能确保上一个函数的数据不被改变,也就是实现了将寄存器当做局部变量使用</p>
<h2 id="栈的对齐"><a href="#栈的对齐" class="headerlink" title="栈的对齐"></a>栈的对齐</h2><p>ARM64里面 对栈的操作是16字节对齐的, 也就是一次开辟栈空间至少是16字节, 或者是16的倍数, 如果不是这个值会报错</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.text ;代码段</span><br><span class="line">.global _A,_B ;定义两个全局函数 A和B</span><br><span class="line"></span><br><span class="line">_A:</span><br><span class="line">	mov x0 ,#0xaaaa ;arm汇编中数据用#开头</span><br><span class="line">	str x30,[sp,#-0x10]! ;在调用下一个函数之前临时保存lr寄存器中的地址, lr保存bl _A的下一条指令地址</span><br><span class="line">	bl _B</span><br><span class="line">	mov x0,#0xcccc</span><br><span class="line">	ldr x30,[sp],#0x10 ;lr恢复</span><br><span class="line">	ret  ;返回到bl指令所对应的下一条指令</span><br><span class="line">	</span><br><span class="line">_B:</span><br><span class="line">	add x0, x0,#0x10</span><br><span class="line">	ret</span><br></pre></td></tr></table></figure>

<p>既然sp一次最少拉伸16个字节, 那么以下函数需要拉伸多少空间:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> c=<span class="number">3</span>;</span><br><span class="line">    <span class="keyword">int</span> c=<span class="number">4</span>;</span><br><span class="line">    <span class="keyword">int</span> c=<span class="number">5</span>;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于int类型的数据占用4个字节空间, 这里一共有5个int,那么需要占用5*4=20个字节的空间, 那么sp一次性拉伸0x20也就是32字节的栈空间</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">16</span>位寄存器--&gt;最大装<span class="number">2</span>个字节数据--&gt;<span class="number">0xFFFF</span></span><br><span class="line"><span class="number">32</span>位寄存器--&gt;最大装<span class="number">4</span>个字节数据--&gt;<span class="number">0xFFFFFFFF</span></span><br><span class="line"><span class="number">64</span>位寄存器--&gt;最大装<span class="number">8</span>个字节数据--&gt;<span class="number">0XFFFFFFFFFFFFFFFF</span></span><br></pre></td></tr></table></figure>

<p>如果函数里面又调用了函数,那么sp拉伸多少呢?</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> c=<span class="number">3</span>;</span><br><span class="line">    <span class="keyword">int</span> c=<span class="number">4</span>;</span><br><span class="line">    <span class="keyword">int</span> c=sumb(a,b);</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于bl调用函数之前会复写x30(lr)寄存器中的值, 所以需要将x29和x30寄存器进行临时保护, 这两个寄存器占用16个字节, 加上sum函数的局部变量和参数所占的16个字节,一共是32个字节</p>
<h2 id="叶子函数"><a href="#叶子函数" class="headerlink" title="叶子函数"></a>叶子函数</h2><p>函数体中没有调用其他函数的函数称之为叶子函数,又称为末尾函数</p>
<p>这种函数在编写汇编代码时可以省略使用栈空间, 栈空间是为了临时保护数据不被下一个函数污染, 叶子函数不存在这种风险,所以不需要进行保护处理,直接使用寄存器即可</p>
<h2 id="ARM64方法返回值"><a href="#ARM64方法返回值" class="headerlink" title="ARM64方法返回值"></a>ARM64方法返回值</h2><p> ARM64下,<strong>函数的参数</strong>通常情况下是存放在X0到X7(W0到W7)这8个寄存器里面的.如果超过8个参数,就会入栈.(一是跟参数个数有关,另外还更数据结构有关,指针占用8个字节刚好一个64位寄存器, 如果仓鼠类型超出8个字节,即存放到其他地方,比如栈空间)<br><strong>函数的返回值</strong>通常情况下是放在X0 寄存器里面的. </p>
<h2 id="orr指令"><a href="#orr指令" class="headerlink" title="orr指令"></a>orr指令</h2><p>称为或指令, 进行或运算, <a href="https://blog.csdn.net/qq_39416311/article/details/102762635" target="_blank" rel="noopener">https://blog.csdn.net/qq_39416311/article/details/102762635</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">orr w8,wzr,#0x1  ;将立即数0x1和0进行或运算, 然后复制给w8</span><br></pre></td></tr></table></figure>

<h3 id="函数嵌套复用"><a href="#函数嵌套复用" class="headerlink" title="函数嵌套复用"></a>函数嵌套复用</h3><p>假如有两个函数A和B,它们的调用链为:A–&gt;B–&gt;A</p>
<p>在高级语言中,A函数进行了复用,但是在汇编当中并没有复用的概念,每调用一个函数便开辟一次栈空间, 因此哪怕是调用同一个函数,如果递归嵌套次数过多,就会造成内存溢出</p>
<h2 id="状态寄存器-标记寄存器"><a href="#状态寄存器-标记寄存器" class="headerlink" title="状态寄存器(标记寄存器)"></a>状态寄存器(标记寄存器)</h2><p>cpsr(current program status registers)寄存器</p>
<p>CPSR和其他寄存器不一样,其他寄存器是用来存放数据的,都是整个寄存器具有一个含义.而CPSR寄存器是按位起作用的,也就是说,它的每一位都有专门的含义,记录特定的信息.</p>
<p>要想在算数运算是影响标记寄存器的值,必须在指令后面加上s,比如:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">add---&gt;adds</span><br><span class="line">sub---&gt;subs</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注:CPSR寄存器是32位的</p>
</blockquote>
<ul>
<li>CPSR的低8位（包括I、F、T和M[4：0]）称为控制位，程序无法修改,除非CPU运行于特权模式下,程序才能修改控制位!</li>
<li>N、Z、C、V均为条件码标志位。它们的内容可被算术或逻辑运算的结果所改变，并且可以决定某条指令是否被执行!意义重大!</li>
</ul>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20201221150846.png" alt></p>
<h3 id="N（Negative）标志"><a href="#N（Negative）标志" class="headerlink" title="N（Negative）标志"></a>N（Negative）标志</h3><blockquote>
<p>CPSR的第31位是 N，符号标志位。它记录相关指令执行后,其结果是否为负.如果为负 N = 1,如果是非负数 N = 0.</p>
</blockquote>
<p>   <strong>注意</strong>,在ARM64的指令集中,有的指令的执行时影响状态寄存器的,比如add\sub\or等,他们大都是运算指令(进行逻辑或算数运算)；</p>
<h3 id="Z-Zero-标志"><a href="#Z-Zero-标志" class="headerlink" title="Z(Zero)标志"></a>Z(Zero)标志</h3><blockquote>
<p>CPSR的第30位是Z，0标志位。它记录相关指令执行后,其结果是否为0.如果结果为0.那么Z = 1.如果结果不为0,那么Z = 0.</p>
</blockquote>
<p>   对于Z的值,我们可以这样来看,Z标记相关指令的计算结果是否为0,如果为0,则N要记录下”是0”这样的肯定信息.在计算机中1表示逻辑真,表示肯定.所以当结果为0的时候Z = 1,表示”结果是0”.如果结果不为0,则Z要记录下”不是0”这样的否定信息.在计算机中0表示逻辑假,表示否定,所以当结果不为0的时候Z = 0,表示”结果不为0”。</p>
<h3 id="C-Carry-标志"><a href="#C-Carry-标志" class="headerlink" title="C(Carry)标志"></a>C(Carry)标志</h3><blockquote>
<p>CPSR的第29位是C，进位标志位。一般情况下,进行<strong>无符号数</strong>的运算。<br> 加法运算：当运算结果产生了进位时（无符号数溢出），C=1，否则C=0。<br> 减法运算（包括CMP）：当运算时产生了借位时（无符号数溢出），C=0，否则C=1。</p>
</blockquote>
<p>   对于位数为N的无符号数来说，其对应的二进制信息的最高位，即第N - 1位，就是它的最高有效位，而假想存在的第N位，就是相对于最高有效位的更高位。如下图所示：</p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20201222145318.png" alt></p>
<h3 id="进位"><a href="#进位" class="headerlink" title="进位"></a>进位</h3><p>   我们知道，当两个数据相加的时候，有可能产生从最高有效位想更高位的进位。比如两个32位数据：0xaaaaaaaa + 0xaaaaaaaa,将产生进位。由于这个进位值在32位中无法保存，我们就只是简单的说这个进位值丢失了。其实CPU在运算的时候，并不丢弃这个进位制，而是记录在一个特殊的寄存器的某一位上。ARM下就用C位来记录这个进位值。比如，下面的指令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mov w0,<span class="comment">#0xaaaaaaaa；0xa 的二进制是 1010</span></span><br><span class="line">adds w0,w0,w0； 执行后 相当于 1010 &lt;&lt; 1 进位1（无符号溢出） 所以C标记 为 1</span><br><span class="line">adds w0,w0,w0； 执行后 相当于 0101 &lt;&lt; 1 进位0（无符号没溢出） 所以C标记 为 0</span><br><span class="line">adds w0,w0,w0； 重复上面操作</span><br><span class="line">adds w0,w0,w0</span><br></pre></td></tr></table></figure>

<h3 id="借位"><a href="#借位" class="headerlink" title="借位"></a>借位</h3><p>   当两个数据做减法的时候，有可能向更高位借位。再比如，两个32位数据：0x00000000 - 0x000000ff,将产生借位，借位后，相当于计算0x100000000 - 0x000000ff。得到0xffffff01 这个值。由于借了一位，所以C位 用来标记借位。C = 0.比如下面指令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mov w0,<span class="comment">#0x0</span></span><br><span class="line">subs w0,w0,<span class="comment">#0xff ;</span></span><br><span class="line">subs w0,w0,<span class="comment">#0xff</span></span><br><span class="line">subs w0,w0,<span class="comment">#0xff</span></span><br></pre></td></tr></table></figure>

<h3 id="V-Overflow-溢出标志"><a href="#V-Overflow-溢出标志" class="headerlink" title="V(Overflow)溢出标志"></a>V(Overflow)溢出标志</h3><blockquote>
<p>CPSR的第28位是V，溢出标志位。在进行有符号数运算的时候，如果超过了机器所能标识的范围，称为溢出。</p>
</blockquote>
<ul>
<li>正数 +  正数  为负数  溢出</li>
<li>负数 +  负数  为正数  溢出</li>
<li>正数 +  负数  不可能溢出</li>
</ul>
<h2 id="adrp指令"><a href="#adrp指令" class="headerlink" title="adrp指令"></a>adrp指令</h2><p><code>adrp</code>(address page):地址页,用于计算指定数据所在物理地址和当前pc地址之间的偏移量, 也就是说通过该指令计算出常量的物理地址</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">adrp x0,1</span><br><span class="line">;1.将1的值左移12位, 1 0000 0000 0000 ==0x1000</span><br><span class="line">;2.将pc寄存器的低12位清零</span><br><span class="line">;3.清零之后的值加上0x1000 然后将最后结果赋值给x0寄存器</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">;adrp指令后边的数值1为十六进制</span><br></pre></td></tr></table></figure>

<h3 id="内存分区"><a href="#内存分区" class="headerlink" title="内存分区"></a>内存分区</h3><ul>
<li>代码区:可读可写可执行</li>
<li>栈区: 可读可写</li>
<li>堆区:动态申请, 可读可写</li>
<li>全局变量区:可读可写</li>
<li>常量区:只读</li>
</ul>
<p><strong>本文为作者原创 转载时请注明出处 谢谢</strong></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em>乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</em></p>
]]></content>
      <tags>
        <tag>汇编</tag>
      </tags>
  </entry>
  <entry>
    <title>x86汇编语言之大小写快速转换</title>
    <url>/197.html</url>
    <content><![CDATA[<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>大写字母 abcd对应的ascii码以及二进制:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">A  41H  0100 0001B</span><br><span class="line">B  42H  0100 0010B</span><br><span class="line">C  43H  0100 0011B</span><br><span class="line">D  44H  0100 0100B</span><br></pre></td></tr></table></figure>

<p>小写字母 abcd对应的ascii码以及二进制:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a  61H  0110 0001B</span><br><span class="line">b  62H  0110 0010B</span><br><span class="line">c  63H  0110 0011B</span><br><span class="line">d  64H  0110 0100B</span><br></pre></td></tr></table></figure>

<h3 id="发现规律"><a href="#发现规律" class="headerlink" title="发现规律"></a>发现规律</h3><p>大写转小写,只需二进制和0010 0000B进行或运算即可:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">or 0010 0000B ;大写变成小写, 小写依然还是小写</span><br></pre></td></tr></table></figure>

<p>小写转大写,只需二进制和1101 1111B进行与运算即可:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">and 1101 1111B ;小写变成大写, 大写依然还是大写</span><br></pre></td></tr></table></figure>

<h4 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">assume cs:code ,ds:data</span><br><span class="line"></span><br><span class="line">data segment</span><br><span class="line">	db &apos;ABcDEF&apos;</span><br><span class="line">	db &apos;abCdef&apos;</span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line"></span><br><span class="line">	start:</span><br><span class="line">		mov ax ,data</span><br><span class="line">		mov ds,ax</span><br><span class="line">		mov bx,0</span><br><span class="line">		</span><br><span class="line">		mov ax,data</span><br><span class="line">		mov es,ax</span><br><span class="line">		</span><br><span class="line">		mov cx,6</span><br><span class="line">		</span><br><span class="line">downLetter:		;大写转小写</span><br><span class="line">		mov dl,ds:[bx]</span><br><span class="line">		or dl,00100000B</span><br><span class="line">		mov es:[bx],dl</span><br><span class="line">		inc bx</span><br><span class="line">		loop downLetter</span><br><span class="line">		</span><br><span class="line">	</span><br><span class="line">		mov cx,6</span><br><span class="line">		mov bx,6</span><br><span class="line">upLetter:		;小写转大写</span><br><span class="line">		mov dl,ds:[bx]</span><br><span class="line">		and dl,11011111B</span><br><span class="line">		mov es:[bx],dl</span><br><span class="line">		inc bx</span><br><span class="line">		loop upLetter</span><br><span class="line">		</span><br><span class="line">		mov ah,4ch</span><br><span class="line">		int 21h</span><br><span class="line">		</span><br><span class="line">	</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>

<p>以上代码可使用偏移地址组合方式[bx+x]进行优化,结果为:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">assume cs:code ,ds:data</span><br><span class="line"></span><br><span class="line">data segment</span><br><span class="line">	db &apos;ABcDEF&apos;</span><br><span class="line">	db &apos;abCdef&apos;</span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line"></span><br><span class="line">	start:</span><br><span class="line">		mov ax ,data</span><br><span class="line">		mov ds,ax</span><br><span class="line">		mov bx,0</span><br><span class="line">		</span><br><span class="line">		mov ax,data</span><br><span class="line">		mov es,ax</span><br><span class="line">		</span><br><span class="line">		mov cx,6</span><br><span class="line">		</span><br><span class="line">changeLetter:		</span><br><span class="line">		;大写转小写</span><br><span class="line">		mov dl,ds:[bx]</span><br><span class="line">		or dl,00100000B</span><br><span class="line">		mov es:[bx],dl</span><br><span class="line">		;小写转大写</span><br><span class="line">		mov dl,ds:[bx+6]</span><br><span class="line">		and dl,11011111B</span><br><span class="line">		mov es:[bx+6],dl</span><br><span class="line">		inc bx</span><br><span class="line">		loop changeLetter</span><br><span class="line">		</span><br><span class="line">	</span><br><span class="line">		mov ah,4ch</span><br><span class="line">		int 21h</span><br><span class="line">		</span><br><span class="line">	</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>

<p><strong>本文为作者原创 转载时请注明出处 谢谢</strong></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em>乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</em></p>
]]></content>
      <tags>
        <tag>汇编</tag>
      </tags>
  </entry>
  <entry>
    <title>x86汇编语言之and和or指令以及ascii码</title>
    <url>/196.html</url>
    <content><![CDATA[<h2 id="And指令"><a href="#And指令" class="headerlink" title="And指令"></a>And指令</h2><p>是逻辑运算指令, 按位进行与运算, 也就是需要转成二进制进行运算, 1代表真, 0代表假</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mov al,1111 1111B ;或者写成十六进制FFH的形式也可</span><br><span class="line">and al,0000 1111B ;将al中的值和0000 1111B进行与运算, 然后将结果赋值给al</span><br><span class="line"></span><br><span class="line">;结果为 0000 1111B</span><br></pre></td></tr></table></figure>

<h2 id="or指令"><a href="#or指令" class="headerlink" title="or指令"></a>or指令</h2><p>按位进行或运算</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mov al,1111 1111B </span><br><span class="line">or al,0000 1111B </span><br><span class="line"></span><br><span class="line">;结果为1111 1111B</span><br></pre></td></tr></table></figure>

<h2 id="ascii码"><a href="#ascii码" class="headerlink" title="ascii码"></a>ascii码</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mov al &apos;a&apos; ;该行代码将字符a所对应的ascii码传入al寄存器中</span><br></pre></td></tr></table></figure>

<p><strong>本文为作者原创 转载时请注明出处 谢谢</strong></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em>乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</em></p>
]]></content>
      <tags>
        <tag>汇编</tag>
      </tags>
  </entry>
  <entry>
    <title>使用docker部署redis</title>
    <url>/2.html</url>
    <content><![CDATA[<h2 id="部署Redis"><a href="#部署Redis" class="headerlink" title="部署Redis"></a>部署Redis</h2><ol>
<li>搜索redis镜像</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker search redis</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>拉取redis镜像</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker pull redis</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>创建容器 设置端口映射</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run -id --name=c_redis -p 6379:6379 redis:5.0</span><br></pre></td></tr></table></figure>

<p> 使用外部机器连接redis</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.redis-cli.exe -h 192.168.149.135 -p 6379</span><br></pre></td></tr></table></figure>

<p><strong>本文为作者原创 转载时请注明出处 谢谢</strong></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em>乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</em></p>
]]></content>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>x86汇编语言之段空间大小的对齐</title>
    <url>/199.html</url>
    <content><![CDATA[<h3 id="段所占空间大小和特点"><a href="#段所占空间大小和特点" class="headerlink" title="段所占空间大小和特点"></a>段所占空间大小和特点</h3><p>以8086为例,假如声明一个段,不论是数据段,栈段还是代码段, 一旦段里面有内容,那么会<strong>从一个新的段地址开始开辟空间</strong>,如果代码进行了分段处理,那么就会形成<strong>16字节对齐</strong>的<strong>现象</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">assume ds:data</span><br><span class="line">;场景一</span><br><span class="line">data segment</span><br><span class="line">	;如果没有内容,则不开辟空间, 被编译器忽略	</span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line">;场景二</span><br><span class="line">data segment</span><br><span class="line">	dw 55FFH,55FFH ;后面的数据用0补足16个字节</span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line">;场景三</span><br><span class="line">data segment</span><br><span class="line">	dw 55FFH,55FFH </span><br><span class="line">	db &apos;hello&apos;  ;以上占用连续的内存空间 55FFH 55FFH hello</span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line">;场景四</span><br><span class="line">data segment</span><br><span class="line">	dw 55FFH,55FFH,55FFH,55FFH,55FFH,55FFH,55FFH,55FFH,55FFH,55FFH,55FFH,55FFH;超过16个字节,那么开辟16的倍数也就是32个字节的空间, 以此类推</span><br><span class="line">data ends</span><br></pre></td></tr></table></figure>

<h5 id="段空间占用计算公式"><a href="#段空间占用计算公式" class="headerlink" title="段空间占用计算公式:"></a>段空间占用计算公式:</h5><p>如果段中的数据占用N个字节,则程序加载后,该段实际占用空间为:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(N/16+1)*16</span><br></pre></td></tr></table></figure>

<h4 id="为什么说是现象呢"><a href="#为什么说是现象呢" class="headerlink" title="为什么说是现象呢"></a>为什么说是现象呢</h4><p>本质并不是因为段固定占用n<em>16字节,而是因为段必须从一个新的地址段开始开辟空间,这就导致了我们认为*</em>段一次最少拉升16字节的内存空间,必须为16的倍数**, 原因看如下代码:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">data segment</span><br><span class="line">	db &apos;hello&apos;</span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line">start:</span><br><span class="line">    call print</span><br><span class="line">    mov ax,2000H</span><br><span class="line">    </span><br><span class="line">print: </span><br><span class="line">    mov bx,3000H</span><br><span class="line">    mov cx,4000H    </span><br><span class="line">    ret</span><br><span class="line"></span><br><span class="line">          </span><br><span class="line"> end start</span><br></pre></td></tr></table></figure>

<p>内存分布如下:</p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20201225164204.png" alt></p>
<p>我们发现data段并没有独占16个字节空间,而是让数据从一个新的16字节地址开始存入,段的作用是让数据在内存中的排列按照一定的布局进行排列,方便我们进行计算读取, 但是使用段的话明显会占用更多的内存空间</p>
<h3 id="各个段之间内存排列分布"><a href="#各个段之间内存排列分布" class="headerlink" title="各个段之间内存排列分布"></a>各个段之间内存排列分布</h3><p>数据段,栈段,代码段 他们在内存中开辟的空间是根据代码由上到下依次分布的:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">assume ds:data,cs:code,ss:stack</span><br><span class="line"></span><br><span class="line">data segment</span><br><span class="line">	dw 66FF</span><br><span class="line">data ends</span><br><span class="line">;假如数据段的段地址是2000H 那么栈段的段地址为2001H, 代码段的段地址为:2002H 依次排列</span><br><span class="line"></span><br><span class="line">stack segment</span><br><span class="line">	dw 77FF</span><br><span class="line">stack ends</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">		mov ax,data</span><br><span class="line">		mov ds,ax</span><br><span class="line">		</span><br><span class="line">		mov ax,stack</span><br><span class="line">		mov ss,ax</span><br><span class="line">		</span><br><span class="line">code ends</span><br><span class="line"></span><br><span class="line">;数据段---&gt;栈段---&gt;代码段</span><br></pre></td></tr></table></figure>

<p>假如数据段的段地址是2000H 那么栈段的段地址为2001H, 代码段的段地址为:2002H 依次排列</p>
<p>如果我将各个段的代码位置调整一下,那么所在内存的位置也会跟着发生改变:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">assume ds:data,cs:code,ss:stack</span><br><span class="line"></span><br><span class="line">;假如栈段的段地址是2000H 那么代码段的段地址为2001H, 数据段的段地址为:2002H 依次排列</span><br><span class="line"></span><br><span class="line">stack segment</span><br><span class="line">	dw 77FF</span><br><span class="line">stack ends</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">		mov ax,data</span><br><span class="line">		mov ds,ax</span><br><span class="line">		</span><br><span class="line">		mov ax,stack</span><br><span class="line">		mov ss,ax</span><br><span class="line">		</span><br><span class="line">code ends</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">data segment</span><br><span class="line">	dw 66FF</span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line">;栈段---&gt;代码段---&gt;数据段</span><br></pre></td></tr></table></figure>

<p>也就是说各个段的内存分布不是固定的, 和代码的编写有关系</p>
<p>如果不加start标记的话,汇编代码默认由上往下执行,cs+ip从上往下,所过之处,全部被当做代码处理, 因此即便你在数据段中存放指令,甚至打入代码起始标签也没有问题:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">assume cs:code,ds:data</span><br><span class="line"></span><br><span class="line">data segment</span><br><span class="line">	mov ax,2000H   ;第一步 执行</span><br><span class="line">data ends</span><br><span class="line">;由于一个段所占空间为16的倍数,后面空位补0,被当做为指令对待,因此当在数据段中执行16个字节代码后,由于段与段之间内存是连续分布的,如果ip的值刚好指向了代码段,那么紧接着执行代码段中的内容,如果ip没有指向代码段,则不执行, 这个情况是不可控的</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">	mov ax,3000H  ;ip偏移16个字节后 执行</span><br><span class="line">code ends</span><br></pre></td></tr></table></figure>

<p>如果在数据段中加上代码起始标记:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">assume cs:code,ds:data</span><br><span class="line"></span><br><span class="line">data segment</span><br><span class="line">	dw 55FFH</span><br><span class="line">	start:</span><br><span class="line">		mov ax,2000H  ;第一步 先执行 如果没有标记,则从dw开始当做代码执行</span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">	mov ax,3000H  ;ip偏移16个字节后 执行</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>

<h3 id="段和段地址之间的关系"><a href="#段和段地址之间的关系" class="headerlink" title="段和段地址之间的关系"></a>段和段地址之间的关系</h3><p>每个段会独占一个栈地址</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">assume cs:code,ds:data</span><br><span class="line">                         </span><br><span class="line"> mov ax,3000H  ;占用三个字节空间</span><br><span class="line"> </span><br><span class="line"> data segment                 </span><br><span class="line"> 	age dw &apos;hello&apos;     </span><br><span class="line"> data ends</span><br></pre></td></tr></table></figure>

<p>内存分布如下:</p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20201224143113.png" alt></p>
<p>咱们会发现数据段,并不是从0100:0003开始开辟16个字节的空间,而是新起一个段地址从0101:0000开始开辟, 也就是说<strong>一个段占用独立的一个栈地址</strong></p>
<p>假如把段去掉:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">assume cs:code,ds:data</span><br><span class="line">                         </span><br><span class="line"> mov ax,3000H  ;占用三个字节空间</span><br><span class="line">              </span><br><span class="line"> age dw &apos;hello&apos;</span><br></pre></td></tr></table></figure>

<p>则内存分布如下:</p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20201224143454.png" alt></p>
<p>那么代码会依次连续进行累加填充</p>
<p><strong>本文为作者原创 转载时请注明出处 谢谢</strong></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em>乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</em></p>
]]></content>
      <tags>
        <tag>汇编</tag>
      </tags>
  </entry>
  <entry>
    <title>关于MySQL数据库基础备份</title>
    <url>/20.html</url>
    <content><![CDATA[<p><strong>mysqldump备份</strong></p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/u=63179589,2229917185&fm=173&app=25&f=JPEG.jpeg" alt="img"></p>
<h2 id="备份命令"><a href="#备份命令" class="headerlink" title="备份命令"></a>备份命令</h2><p>格式：<code>mysqldump -u用户名 -p密码  数据库名 &gt; 文件名.sql</code></p>
<p>例如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysqldump -uroot -ppassword  cmdb &gt; /data/backup/cmdb.sql</span><br></pre></td></tr></table></figure>

<h2 id="备份压缩"><a href="#备份压缩" class="headerlink" title="备份压缩"></a>备份压缩</h2><p>导出的数据有可能比较大，不好备份到远程，这时候就需要进行压缩</p>
<p>格式：<code>mysqldump --u用户名 -p密码 --database 数据库名 | gzip &gt; 文件名.sql.gz</code></p>
<p>例如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysqldump  -uroot -ppassword  cmdb | gzip &gt; /data/backup/cmdb.sql.gz</span><br></pre></td></tr></table></figure>

<h2 id="备份同个库多个表"><a href="#备份同个库多个表" class="headerlink" title="备份同个库多个表"></a>备份同个库多个表</h2><p>格式：<code>mysqldump -u用户名 -p密码 --database 数据库名 表1 表2 .... &gt; 文件名.sql</code></p>
<p>例如 :</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysqldump -uroot -ppassword cmdb t1 t2 &gt; /data/backup/cmdb_t1_t2.sql</span><br></pre></td></tr></table></figure>

<h2 id="同时备份多个库"><a href="#同时备份多个库" class="headerlink" title="同时备份多个库"></a>同时备份多个库</h2><p>格式：<code>mysqldump -u用户名 -p密码 --databases 数据库名1 数据库名2 数据库名3 &gt; 文件名.sql</code></p>
<p>例如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysqldump  -uroot -ppassword --databases cmdb bbs blog &gt; /data/backup/mutil_db.sql</span><br></pre></td></tr></table></figure>

<h2 id="备份实例上所有的数据库"><a href="#备份实例上所有的数据库" class="headerlink" title="备份实例上所有的数据库"></a>备份实例上所有的数据库</h2><p>格式：<code>mysqldump -u用户名 -p密码 --all-databases &gt; 文件名.sql</code></p>
<p>例如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysqldump -uroot -ppassword --all-databases &gt; /data/backup/all_db.sql</span><br></pre></td></tr></table></figure>

<h2 id="备份数据出带删除数据库或者表的sql备份"><a href="#备份数据出带删除数据库或者表的sql备份" class="headerlink" title="备份数据出带删除数据库或者表的sql备份"></a>备份数据出带删除数据库或者表的sql备份</h2><p>格式：<code>mysqldump -u用户名 -p密码 --add-drop-table --add-drop-database 数据库名 &gt; 文件名.sql</code></p>
<p>例如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysqldump -uroot -ppassword --add-drop-table --add-drop-database cmdb &gt; /data/backup/all_db.sql</span><br></pre></td></tr></table></figure>

<h2 id="备份数据库结构，不备份数据"><a href="#备份数据库结构，不备份数据" class="headerlink" title="备份数据库结构，不备份数据"></a>备份数据库结构，不备份数据</h2><p>格式：<code>mysqldump  -u用户名 -p密码 --no-data 数据库名1 数据库名2 数据库名3 &gt; 文件名.sql</code></p>
<p>例如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysqldump --no-data –databases db1 db2 cmdb &gt; /data/backup/structure.sql</span><br></pre></td></tr></table></figure>

<p><strong>本文为作者原创 转载时请注明出处 谢谢</strong></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em>乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</em></p>
]]></content>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>x86汇编语言之8086语法和指令集</title>
    <url>/198.html</url>
    <content><![CDATA[<h2 id="x86汇编语法"><a href="#x86汇编语法" class="headerlink" title="x86汇编语法"></a>x86汇编语法</h2><ol>
<li><strong>注释</strong></li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">;我是注释</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><strong>变量取值和赋值(传送指令)</strong></li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">;赋值</span><br><span class="line">mov ax,2000H ;将十六进制2000赋值给十六位寄存器ax  相当于ax=2000H</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">;取值</span><br><span class="line">mov bx,ax ;将ax中的值取出赋值给bx  相当于bx=ax</span><br></pre></td></tr></table></figure>

<blockquote>
<p>存放的数据大小根据使用的寄存器而定, 比如ax是16位寄存器,最大只能存放16位数据,也就是4位十六进制数据</p>
<p>十六进制数据不能以字母开头, 前面需加上0 否则编译报错</p>
</blockquote>
<ol start="3">
<li><strong>函数声明</strong></li>
</ol>
<p>结构如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">函数名:</span><br><span class="line">	函数体</span><br><span class="line">	ret   ;结尾标记</span><br></pre></td></tr></table></figure>

<p>示例:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">print:	;函数名</span><br><span class="line">		mov dx,offset str</span><br><span class="line">		mov ah, 9ch </span><br><span class="line">		int 21h</span><br><span class="line">		</span><br><span class="line">		ret ;函数结尾标记</span><br></pre></td></tr></table></figure>

<ol start="4">
<li><strong>函数调用</strong></li>
</ol>
<p>x86架构中使用关键指令<code>call</code></p>
<p>x86架构汇编示例:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">		call print ;调用print函数</span><br><span class="line">		</span><br><span class="line">		;退出程序</span><br><span class="line">		mov ah, 4ch </span><br><span class="line">		int 21h</span><br><span class="line">		</span><br><span class="line">print:	;函数名</span><br><span class="line">		mov dx,offset str;获取别名对应数据的偏移地址</span><br><span class="line">		mov ah, 9ch ;9h表示调用显存 从dx总读取偏移地址对应的数据</span><br><span class="line">		int 21h</span><br><span class="line">		ret</span><br></pre></td></tr></table></figure>

<ol start="5">
<li><p><strong>字符串的定义</strong></p>
<p><strong>起因</strong>：如果直接将字符串赋值给通用寄存器，会出现以下两个问题：</p>
<ul>
<li>字符顺序是反着的</li>
<li>最多只能存放两个字符</li>
<li>无法获取到数据地址，不能堆字符串进行修改</li>
</ul>
<p>为了解决这个问题，需要使用另外一种方式，定义字符串</p>
<p><strong>首先</strong>:需要先在内存中申请一块空间，可以使用伪指令<strong>db</strong>和<strong>dw</strong></p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">db--&gt;define <span class="keyword">byte</span>  定义字节 读写一个数据，偏移量加<span class="number">1</span></span><br><span class="line">dw--&gt;define word  定义字   读写一个数据，偏移量加<span class="number">2</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">dd--&gt;define <span class="keyword">double</span> word 定义双字， 读写一个数据 偏移量加<span class="number">4</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>示例</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">db &apos;hello&apos;  ;占用五个字节的内存空间</span><br><span class="line">dw &apos;hello&apos;  ;占用六个字节的内存空间  跟偏移量有关系</span><br></pre></td></tr></table></figure>

</li>
</ul>
<blockquote>
<p>如果定义数字,使用dw每个数字占用两个字节的空间, 字符串比较特殊,并不是每个字符占用两个字节,而是总长度必须是2的倍数</p>
</blockquote>
</li>
</ol>
<ol start="6">
<li><p><strong>字符串的获取</strong></p>
<p>获取字符串的数据,首先要获取到数据所对应的内存地址</p>
<p>那怎么获取已经定义好的地址呢?</p>
<p><strong>第一步尝试: 给数据添加别名</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">str db &apos;hello&apos;</span><br><span class="line"></span><br><span class="line">start:</span><br><span class="line">	mov bx,str ;别名中存放的是偏移地址</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">end start</span><br></pre></td></tr></table></figure>

<p>别名中存放的是偏移地址,但是光有偏移地址还不行,还需要段地址, <strong>段地址+偏移地址=实际物理地址</strong>,别名默认从ds寄存器中读取段地址, 但是我们并没有给ds寄存器赋过值, 这就导致我们无法获取正确的数据,因为我们不知道正确的段地址是多少?</p>
<p>那字符串段地址从哪里获取呢?</p>
<ul>
<li><p>方法一: 直接从内存中找(仅限于调试,实际开发肯定不行)</p>
</li>
<li><p>方法二:使用段进行包裹, 段能给我们提供一个段地址(正解)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">data segment</span><br><span class="line">	str db &apos;hello&apos;</span><br><span class="line">data ends</span><br><span class="line">	;使用段进行包裹, 可以借助段名称获取段地址</span><br><span class="line">start:</span><br><span class="line">	mov ax,data</span><br><span class="line">	mov ds,ax</span><br><span class="line">	mov bx,str </span><br><span class="line"></span><br><span class="line">end start</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p><strong>对内存中的数据进行读写</strong></p>
<p>从内存中一次读取数据的多少,取决于寄存器的容器大小</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  data segment</span><br><span class="line">  	str dw &apos;hello&apos;  ;如果定义多个数据 使用逗号进行分隔</span><br><span class="line">data ends</span><br><span class="line">  </span><br><span class="line">  start:</span><br><span class="line">  	mov ax,data</span><br><span class="line">  	mov ds,ax</span><br><span class="line">  	mov ax,str  ;如果从内存中读取数据,是根据寄存器大小来读取,16位寄存器则一次性读取16位数据,8位al则一次性读取八位数据</span><br><span class="line">  </span><br><span class="line">  end start</span><br></pre></td></tr></table></figure>


</li>
</ol>
<p>   <strong>思考</strong>:为什么以下写法报错:</p>
   <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">;报错1</span><br><span class="line">data segment</span><br><span class="line">	str db &apos;hello &apos; ;改成dw则不报错</span><br><span class="line">data ends</span><br><span class="line">start:</span><br><span class="line">mov ax,data</span><br><span class="line">	mov ds,ax</span><br><span class="line">	mov ax,str  ;</span><br><span class="line"></span><br><span class="line">end start</span><br><span class="line"></span><br><span class="line">;报错2</span><br><span class="line">data segment</span><br><span class="line">	str dw &apos;hello &apos; </span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line">start:</span><br><span class="line">	mov ax,data</span><br><span class="line">	mov ds,ax</span><br><span class="line">	mov al,str  ; ;改成mov ax,str 或者mov al,b.str 则不报错</span><br><span class="line"></span><br><span class="line">end start</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">;报错3</span><br><span class="line">mov ax,bl   ;宽度不匹配  以上两个也是同样的问题</span><br></pre></td></tr></table></figure>


<p>   <strong>内存数据的读写是从低往高进行读写</strong></p>
<p>   上面使用db或者dw定义数据的方式,定义数据的同时就已经定义好了数据所在的物理地址, <strong>如果我们想要从指定的内存地址中写入或者读取数据的话,需要借助段寄存器来实现</strong> 在8086中给我们提供了DS SS CS ES四个寄存器,理论上你使用哪一个都行,但是由于系统默认读取DS寄存器中的数据当做段地址,所以我们一般使用DS进行数据的段地址管理</p>
<ul>
<li><p>如何从指定内存中读取数据</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">;假设我们需要从0710:0000这个物理地址中读取数据,然后存放到寄存器中</span><br><span class="line"></span><br><span class="line">;错误写法1:</span><br><span class="line">start:</span><br><span class="line">	mov ax,0710H:0000H  ;没有这种语法</span><br><span class="line">end start</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">;错误写法2:</span><br><span class="line">start:</span><br><span class="line">	mov ds,0710H   ;段寄存器不能直接赋值,必须借助通用寄存器</span><br><span class="line">	mov ax,ds:[0]</span><br><span class="line">end start</span><br><span class="line"></span><br><span class="line">;正确写法:</span><br><span class="line">start:</span><br><span class="line">	mov ax,0710H</span><br><span class="line">	mov ds,ax</span><br><span class="line">	mov ax,ds:[0]  ;实际物理地址 段地址+偏移地址 ===&gt;ds:[xxx] 表示从该地址取数据</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>


</li>
</ul>
<ul>
<li><p>如何往指定内存中写入数据</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">;假设我们需要将数据写入0710:0000这个物理地址中</span><br><span class="line"></span><br><span class="line">;错误写法1:</span><br><span class="line">  start:</span><br><span class="line">  	mov ax,3333H</span><br><span class="line">  	mov 0710:0000,ax  ;没有这种语法</span><br><span class="line">  end start</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  ;错误写法2:</span><br><span class="line">  data segment</span><br><span class="line">  	str dw &apos;he&apos;</span><br><span class="line">  data ends</span><br><span class="line"></span><br><span class="line">  start:</span><br><span class="line">  	mov ax,data</span><br><span class="line">  	mov ds,ax   </span><br><span class="line">  	mov ds:[0],ds:str ;必须借助通用寄存器进行赋值</span><br><span class="line">  end start</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">  ;正确写法1:</span><br><span class="line">  data segment</span><br><span class="line">  	str dw &apos;he&apos;</span><br><span class="line">  data ends</span><br><span class="line"></span><br><span class="line">  start:</span><br><span class="line">  	mov ax,data</span><br><span class="line">  	mov ds,ax   </span><br><span class="line">  	mov ax,ds:str ;str-==&gt;[xx] ds:[xxx]</span><br><span class="line">  	mov ds:[0],ax </span><br><span class="line">  end start</span><br><span class="line"></span><br><span class="line">  ;正确写法2:</span><br><span class="line">  start:</span><br><span class="line">  	mov ax,0710H </span><br><span class="line">  	mov ds,ax;指定需要写入数据的段地址</span><br><span class="line">  	</span><br><span class="line">  	mov ax,3333H ;将3333H当做数据</span><br><span class="line">  	mov ds:[0],ax  </span><br><span class="line">  end start</span><br><span class="line">  </span><br><span class="line">;正确写法3:</span><br><span class="line">  start:</span><br><span class="line">  	mov ax,0710H </span><br><span class="line">  	mov ds,ax;指定需要写入数据的段地址</span><br><span class="line">  	</span><br><span class="line">  	mov ds:[0],3333H  ;可以直接将数据写入 最多写入十六位的数据</span><br><span class="line">  end start</span><br></pre></td></tr></table></figure>




</li>
</ul>
<blockquote>
<p>补充:往内存中写入数据是字节宽度还是字型宽度取决于寄存器的宽度也就是 <code>mov ds:[0],ax</code> 或者数据的大小:<code>mov ds:[0] 30H</code></p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">; 以下是指定数据占用空间的大小 可以实现8位数据占用16个字节的空间的目的</span><br><span class="line"></span><br><span class="line"> mov byte ptr ds:[0],1 ;前面加上byte ptr关键字 表示往指定内存中写入字节型数据1</span><br><span class="line"> </span><br><span class="line"> mov word ptr ds:[0],1 ;往指定内存中写入字型数据1 也就是在内存中占用两个字节空间</span><br></pre></td></tr></table></figure>

<p>​<br>8. <strong>字符串修改和替换</strong></p>
   <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">;需求1 : 将内存中he修改为wo</span><br><span class="line"></span><br><span class="line">data segment</span><br><span class="line">	str dw &apos;he&apos;</span><br><span class="line">	newstr dw &apos;wo&apos;</span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">start:</span><br><span class="line">	mov ax,data</span><br><span class="line">	mov ds,ax   </span><br><span class="line"></span><br><span class="line">	mov ax,ds:str</span><br><span class="line">	mov ds:newstr,ax </span><br><span class="line"></span><br><span class="line">end start</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">;需求2 : 将内存中hello 修改为wowowo</span><br><span class="line"></span><br><span class="line">data segment</span><br><span class="line">	str dw &apos;hello &apos;</span><br><span class="line">	newstr dw &apos;wowowo&apos;</span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">start:</span><br><span class="line">	mov ax,data</span><br><span class="line">	mov ds,ax   </span><br><span class="line"></span><br><span class="line">	mov ax,ds:str</span><br><span class="line">	mov ds:newstr,ax </span><br><span class="line">	</span><br><span class="line">	mov ax,ds:str+2</span><br><span class="line">	mov ds:newstr+2,ax</span><br><span class="line"></span><br><span class="line">	mov ax,ds:str+4</span><br><span class="line">	mov ds:newstr+4,ax</span><br><span class="line"></span><br><span class="line">end start</span><br></pre></td></tr></table></figure>

<p>   分段写法:</p>
   <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">data segment</span><br><span class="line">	str dw &apos;he&apos;</span><br><span class="line">	</span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line">newData segment</span><br><span class="line">     newstr dw &apos;wo&apos;</span><br><span class="line">newData ends</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">start:</span><br><span class="line">	mov ax,data</span><br><span class="line">	mov ds,ax   </span><br><span class="line">	mov ax,newData</span><br><span class="line">	mov es,ax</span><br><span class="line">	</span><br><span class="line">	mov ax,ds:str</span><br><span class="line">	mov es:newstr,ax </span><br><span class="line">	</span><br><span class="line">code ends</span><br><span class="line"></span><br><span class="line">end start</span><br></pre></td></tr></table></figure>

<ol start="9">
<li><p><strong>Loop循环指令</strong></p>
<p>类似于高级语言中的while循环, 系统默认从cx寄存器中读取数据作为循环的条件,当cx中的值cx-1大于零时循环执行一次代码</p>
<p>示例:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">;需求 : 将内存中wowowo修改为hello </span><br><span class="line"></span><br><span class="line">data segment</span><br><span class="line">	str dw &apos;hello &apos;</span><br><span class="line">	newstr dw &apos;wowowo&apos;</span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">start:</span><br><span class="line">	mov ax,data</span><br><span class="line">	mov ds,ax   </span><br><span class="line">	</span><br><span class="line">	mov bx,0 </span><br><span class="line">	mov cx,3</span><br><span class="line">replace:	</span><br><span class="line">	mov ax,ds:[bx]</span><br><span class="line">	mov ds:[bx+6],ax </span><br><span class="line">	add bx,2</span><br><span class="line">	loop replace</span><br><span class="line"></span><br><span class="line">end start</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">;需求 : 将内存中wowowo修改为hello </span><br><span class="line"></span><br><span class="line">data segment</span><br><span class="line">	dw &apos;aaa&apos;</span><br><span class="line">	str dw &apos;hello &apos;</span><br><span class="line">	newstr dw &apos;wowowo&apos;</span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">start:</span><br><span class="line">	mov ax,data</span><br><span class="line">	mov ds,ax   </span><br><span class="line">	</span><br><span class="line">	mov bx,offset str </span><br><span class="line">	mov cx,3</span><br><span class="line">replace:	</span><br><span class="line">	mov ax,ds:[bx]</span><br><span class="line">	mov ds:[bx+6],ax </span><br><span class="line">	add bx,2</span><br><span class="line">	loop replace</span><br><span class="line"></span><br><span class="line">end start</span><br></pre></td></tr></table></figure>

<p><strong>加减运算指令add和sub</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">add ax,2 ;ax=ax+2</span><br><span class="line">sub ax,2 ;ax=ax-2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sub/add 通用寄存器,数值  ;add/sub ax,2</span><br><span class="line">sub/add 通用寄存器,通用寄存器 ;add/sub ax,bx</span><br><span class="line">sub/add 内存地址,通用寄存器 ;add/sub ds:[0],bx</span><br><span class="line">sub/add 通用寄存器,内存地址 ;add/sub ax,ds:[0]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">;错误写法</span><br><span class="line">sub/add 内存地址,内存地址 ;;add/sub ds:[0],ds:[3]  不允许这样写</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="10">
<li><p><strong>中断</strong></p>
<p>顾名思义,程序运行到一半暂时断开,官方一点说就是,由于软件或者硬件信号,使得cpu暂停当前任务,转而执行另一段子程序</p>
<blockquote>
<p>可以形象理解为游戏中暂时搁置主线任务临时去完成支线任务</p>
</blockquote>
<p>中断的分类:</p>
<ul>
<li><p><strong>外中断 (硬中断):</strong>由外部设备(比如网卡,或者硬盘 键盘 鼠标)引发的中断,比如当网卡收到数据包的时候,就会发出一个中断</p>
</li>
<li><p><strong>内中断(软中断):</strong>由执行的中断指令产生的,可以通过程序控制触发</p>
</li>
</ul>
<p>我们接下来要学习的是内中断知识,如果我们想要通过代码发出一个中断,那么需要使用中断指令<code>int</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int 21h ;执行中断码为21H的中断指令</span><br></pre></td></tr></table></figure>

<p>cpu接收到中断信号后,暂停当前正在执行的指令,临时去执行中断码对应的内容</p>
<p>中断码不止一个,每个码代表着不同的含义,部分中断码列表如下:</p>
<table>
<thead>
<tr>
<th>中断</th>
<th>功能</th>
<th>入口参数</th>
<th>出口参数</th>
</tr>
</thead>
<tbody><tr>
<td>INT16</td>
<td>键盘输入</td>
<td>AH=0H读键盘  AH=10读扩展键盘</td>
<td>AH=键盘扫描码 AL=字符ascii码</td>
</tr>
<tr>
<td>INT20</td>
<td>程序正常退出</td>
<td>CS=PSP段地址</td>
<td></td>
</tr>
<tr>
<td>INT21</td>
<td>系统功能调用</td>
<td>AH=功能号</td>
<td></td>
</tr>
<tr>
<td>INT22</td>
<td>程序结束处理</td>
<td></td>
<td></td>
</tr>
<tr>
<td>INT23</td>
<td>Ctrl-Break处理</td>
<td></td>
<td>AL=0(忽略)</td>
</tr>
<tr>
<td>INT24</td>
<td>严重错误处理</td>
<td>AL=驱动器号</td>
<td>AL=1(重试)AL=2(通过INT 23H终止)Cy=1出错</td>
</tr>
<tr>
<td>INT25</td>
<td>绝对磁盘读</td>
<td>CX=读入扇区数DX=起始逻辑扇区数DS:BX=缓冲区地址AL=驱动器号</td>
<td>Cy=0正确</td>
</tr>
<tr>
<td>INT26</td>
<td>绝对磁盘写</td>
<td>CX=写盘扇区数DX=起始逻辑扇区数DS:BX=缓冲区地址</td>
<td></td>
</tr>
<tr>
<td>INT27</td>
<td>驻留退出</td>
<td>CS=PSP段地址DX=程序末地址+1</td>
<td></td>
</tr>
</tbody></table>
</li>
</ol>
<pre><code>**二、DOS功能调用**

**功能号在AH中,并设好其余的入口参数,向DOS发出INT21H命令,最后获得出口参数。**

| 调用号 | 功能                                                         | 入口参数                                                     | 出口参数                                                     |
| ------ | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 00H    | 程序终止                                                     | CS=PSP段地址                                                 |                                                              |
| 01H    | 键盘输入字符                                                 |                                                              | AL=输入的字符                                                |
| 02H    | 显示输出                                                     | DL=显示的字符                                                |                                                              |
| 03H    | 串行设备输入                                                 |                                                              | AL=输入的字符                                                |
| 04H    | 串行设备输出                                                 | DL=输出的字符                                                |                                                              |
| 05H    | 打印输出                                                     | DL=输出的字符                                                |                                                              |
| 06H    | 直接控制台I/O                                                | DL=0FFH(输入请求)DL=字符(输出请求)                           | AL=输入的字符                                                |
| 07H    | 直接控制台I/O(不显示输入)                                    |                                                              | AL=输入的字符                                                |
| 08H    | 键盘输入字符(无回显)                                         |                                                              | AL=输入的字符                                                |
| 09H    | 显示字符串                                                   | DS:DX=缓冲区首址                                             |                                                              |
| 0AH    | 输入字符串                                                   | DS:DX=缓冲区首址                                             |                                                              |
| 0BH    | 检查标准输入状态                                             |                                                              | AL=00无按键AL=0FFH有按键                                     |
| 0CH    | 清除输入缓冲区并执行指定的标准输入功能                       | AL=功能号(01/06/07/08/0AH)DS:DX=缓冲区(0AH功能)              | AL=输入的数据(功能01/06/07/08)                               |
| 0DH    | 初始化磁盘状态                                               |                                                              |                                                              |
| 0EH    | 选择缺省的驱动器                                             | DL=驱动器号(0=A,1=B..)                                       | AL=逻辑驱动器数                                              |
| 0FH    | 打开文件                                                     | DS:DX=未打开的FCB首址                                        | AL=00成功,0FFH失败                                           |
| 10H    | 关闭文件                                                     | DS:DX=打开的FCB首址                                          | AL=00成功,0FFH失败                                           |
| 11H    | 查找第一匹配目录                                             | DS:DX=未打开的FCB首址                                        | AL=00成功,0FFH失败                                           |
| 12H    | 查找下一匹配目录                                             | DS:DX=未打开的FCB首址                                        | AL=00成功,0FFH失败                                           |
| 13H    | 删除文件                                                     | DS:DX=未打开的FCB首址                                        | AL=00成功,0FFH失败                                           |
| 14H    | 顺序读                                                       | DS:DX=打开的FCB首址                                          | AL=00成功,01文件结束02缓冲区太小03缓冲区不满                 |
| 15H    | 顺序写                                                       | DS:DX=打开的FCB首址                                          | AL=00成功,01盘满02缓冲区太小                                 |
| 16H    | 创建文件                                                     | DS:DX=未打开的FCB首址                                        | AL=00成功0FFH目录区满                                        |
| 17H    | 文件换名                                                     | DS:DX=被修改的FCB首址                                        | AL=00成功,0FFH未找到目录项或文件重名                         |
| *18H   | 保留未用                                                     |                                                              |                                                              |
| 19H    | 取缺省驱动器号                                               |                                                              | AL=驱动器号(0=A,1=B..)                                       |
| 1AH    | 设置磁盘缓冲区DTA                                            | DS:DX=磁盘缓冲区首址                                         |                                                              |
| *1BH   | 取缺省驱动器的磁盘格式信息                                   |                                                              | AL=每簇的扇区数CX=每扇区的字节数DX=数据区总簇数-1DS:BX=介质描述字节 |
| *1CH   | 取指定驱动器的磁盘格式信息                                   | DL=驱动器号(0=缺省,1=A..)                                    | AL=每簇的扇区数CX=每扇区的字节数DX=数据区总簇数-1DS:BX=介质描述字节 |
| *1DH   | 保留未用                                                     |                                                              |                                                              |
| *1EH   | 保留未用                                                     |                                                              |                                                              |
| *1FH   | 取缺省驱动器的DPB                                            |                                                              | DS:BX=DPB首址                                                |
| *20H   | 保留未用                                                     |                                                              |                                                              |
| 21H    | 随机读一个记录                                               | DS:DX=打开的FCB首址                                          | AL=00成功,01文件结束02缓冲区太小03缓冲区不满                 |
| 22H    | 随机写一个记录                                               | DS:DX=打开的FCB首址                                          | AL=00成功,01盘满02缓冲区太小                                 |
| 23H    | 取文件大小                                                   | DS:DX=未打开的FCB首址                                        | AL=00成功,0FFH失败                                           |
| 24H    | 设置随机记录号                                               | DS:DX=打开的FCB首址                                          |                                                              |
| 25H    | 设置中断向量                                                 | AL=中断号DS:DX=中断程序入口                                  |                                                              |
| *26H   | 创建新的PSP                                                  | DS:DX=新的PSP段地址                                          |                                                              |
| 27H    | 随机读若干记录                                               | DS:DX=打开的FCB首址CX=要读入的记录数                         | AL=00成功,01文件结束AL=02缓冲区太小AL=03缓冲区不满CX=读入的块数 |
| 28H    | 随机写若干记录                                               | DS:DX=打开的FCB首址CX=要写入的记录数                         | AL=00成功,01盘满AL=02缓冲区太小AL=03缓冲区不满CX=已写的块数  |
| 29H    | 分析文件名                                                   | AL=分析控制标记DS:SI=要分析的字符串ES:DI=未打开的FCB首址     | AL=00未通配符01有通配符0FFH驱动器字母无效ES:DI=未打开的FCB   |
| 2AH    | 取系统日期                                                   |                                                              | CX=年(1980-2099)DH=月,DL=日,AL=星期(0=星期日)                |
| 2BH    | 置系统日期                                                   | CX=年,DH=月,DL=日                                            | AL=00成功,0FFH失败                                           |
| 2CH    | 取系统时间                                                   |                                                              | CH=时(0-23),CL=分,DH=秒,DL=百分之几秒                        |
| 2DH    | 置系统时间                                                   | CX=时,分DX=秒,百分秒                                         | AL=00成功,0FFH失败                                           |
| 2EH    | 设置/复位校验开关                                            | AL=0关闭,1打开                                               |                                                              |
| 2FH    | 取磁盘传输地址DTA                                            |                                                              | ES:BX=DTA首地址                                              |
| 30H    | 取DOS版本                                                    |                                                              | AL,AH=DOS主、次版本                                          |
| 31H    | 结束并驻留                                                   | AL=返回码,DX=内存大小                                        |                                                              |
| *32H   | 取指定驱动器的DPB                                            |                                                              | DS:BX=DPB首址                                                |
| 33H    | 取或置Ctrl-Break标志                                         | AL=0:取,1:置,DL=标志                                         | DL=标志(取功能)0:关1:开                                      |
| *34H   | 取DOS中断标志                                                |                                                              | ES:BX=DOS中断标志                                            |
| 35H    | 取中断向量地址                                               | AL=中断号                                                    | ES:BX=中断程序入口                                           |
| 36H    | 取磁盘的自由空间                                             | DL=驱动器号(0=缺省,1=A                                       | AX=FF驱动器无效其它每簇扇区数BX=自由簇数CX=每扇区字节数BX=文件区所占簇数 |
| *37H   | 取/置参数分隔符取/置设备名许可标记                           | AL=0:取分隔符,1:置分隔符,DL=分隔符2:取许可标记3:置许可标记,DL=许可标记 | DL=分隔符(功能0)DL=许可标记(功能2)                           |
| 38H    | 取国家信息                                                   | AL=0,DS:DX=缓冲区首址                                        |                                                              |
| 39H    | 创建子目录                                                   | DS:DX=路径字符串                                             | CF=0成功,1失败,AX=错误码                                     |
| 3AH    | 删除子目录                                                   | DS:DX=路径字符串                                             | CF=0成功,1失败,AX=错误码                                     |
| 3BH    | 设置子目录                                                   | DS:DX=路径字符串                                             | CF=0成功,1失败,AX=错误码                                     |
| 3CH    | 创建文件                                                     | DS:DX=带路径的文件名CX=属性1-只读2-隐蔽4-系统                | CF=0成功,AX=文件号CF=1失败,AX=错误码                         |
| 3DH    | 打开文件                                                     | DS:DX=带路径的文件名AL=方式0-读1-写2-读写                    | CF=0成功,AX=文件号CF=1失败,AX=错误码                         |
| 3EH    | 关闭文件                                                     | BX=文件号                                                    | CF=0成功CF=1失败,AX=错误码                                   |
| 3FH    | 读文件或设备                                                 | BX=文件号CX=字节数                                           | CF=0成功DX:AX=新的指针位置                                   |
| 40H    | 写文件或设备                                                 | DS:DX=缓冲区首址                                             | CF=1失败,AX=错误码                                           |
| 41H    | 删除文件                                                     | DS:DX=带路径的文件名                                         | CF=0成功,1失败,AX=错误码                                     |
| 42H    | 移动文件指针                                                 | AL=方式0-正向1-相对2-反向BX=文件号,CX:DX=移动的位移量        | CF=0成功,DX:AX=新的文件指针CF=1失败,AX=错误码                |
| 43H    | 取/置文件属性                                                | AL=0:取1:置,CX=新属性DS:DX=带路径的文件名                    | CX=属性(功能0)1-只读2-隐蔽4-系统20H-归档                     |
| 44H    | 设备输入/输出控制:设置/取得与打开设备的句柄相关联信息,或发送/接收控制字符串至设备句柄 | AL=0/1取/置设备信息2/3读/写设备控制通道4/5同功能2/36/7取输入/输出状态BX=句柄(功能0-3,6-7)BL=驱动器号(功能4-5)CX=字节数(功能2-5)DS:DX=缓冲区(功能2-5) | CF=0成功DX=设备信息(功能0)AL=状态(功能6/7)0未准备,1准备AX=传送的字节数(功能2-5) |
| 45H    | 复制文件号(对于一个打开的文件返回一个新的文件号)             | BX=文件号                                                    | CF=0成功,AX=新文件号CF=1失败,AX=错误码                       |
| 46H    | 强行复制文件号                                               | BX=现存的文件号,CX=第2文件号                                 | CF=0成功,1失败AX=错误码                                      |
| 47H    | 取当前目录                                                   | DL=驱动器号DS:SI=缓冲区首址                                  | CF=0成功,1失败AX=错误码                                      |
| 48H    | 分配内存                                                     | BX=所需的内存节数                                            | CF=0成功,AX=分配的段数,CF=1失败,AX=错误码BX=最大可用块大小   |
| 49H    | 释放内存                                                     | ES=释放块的段值                                              | CF=1失败,AX=错误码                                           |
| 4AH    | 修改分配内存                                                 | ES=修改块的段值BX=新长度(以节为单位)                         | CF=1失败,AX=错误码BX=最大可用块大小                          |
| 4BH    | 装载程序运行程序                                             | AL=0装载并运行1获得执行信息3装载但不运行DS:DX=带路径的文件名ES:BX=装载用的参数块 | CF=1失败,AX=错误码                                           |
| 4CH    | 带返回码的结束                                               | AL=进程返回码                                                |                                                              |
| 4DH    | 取由31H/4CH带回的返回码                                      |                                                              | AL=进程返回码AH=类型码,0-正常结束1-由Ctrl-Break结束2-由严重设备错误而结束3-由调用31H而结束 |
| 4EH    | 查找第一个匹配项                                             | DS:DX=带路径的文件名CX=属性                                  | CF=1失败,AX=错误码                                           |
| 4FH    | 查找下一个匹配项                                             |                                                              | CF=1失败,AX=错误码                                           |
| *50H   | 建立当前的PSP段地址                                          | BX=PSP段地址                                                 |                                                              |
| *51H   | 读当前的PSP段地址                                            |                                                              | BX=PSP段地址                                                 |
| *52H   | 取DOS系统数据区首址                                          |                                                              | ES:BX=DOS数据区首址                                          |
| *53H   | 为块设备建立DPB                                              | DS:SI=BPB,ES:DI=DPB                                          |                                                              |
| 54H    | 取校验开关设定值                                             |                                                              | AL=标志值(0:关,1:开)                                         |
| *55H   | 由当前PSP建立新PSP                                           | DX=PSP段地址                                                 |                                                              |
| 56H    | 文件换名                                                     | DS:DX=带路径的旧文件名ES:DI=带路径的新文件名                 | CF=1失败,AX=错误码                                           |
| 57H    | 取/置文件时间及日期                                          | AL=0/1取/置,BX=文件号CX=时间,DX=日期                         | CF=0成功,CX=时间,DX=日期                                     |</code></pre><ol start="11">
<li><p><strong>打印字符串</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">data segment</span><br><span class="line">	str db &apos;hello pangshu!$&apos; ;$ 表示结尾标记</span><br><span class="line">	</span><br><span class="line">data ends</span><br><span class="line">code segment	</span><br><span class="line"></span><br><span class="line">start:	</span><br><span class="line">		mov ax,data</span><br><span class="line">		mov ds,ax</span><br><span class="line">		</span><br><span class="line">		;业务逻辑代码</span><br><span class="line">		mov dx,offset str;获取别名对应数据的偏移地址</span><br><span class="line">		mov ah, 9h ;9h表示调用显存 从dx总读取偏移地址对应的数据</span><br><span class="line">		int 21h</span><br><span class="line">		</span><br><span class="line">		;退出程序</span><br><span class="line">		mov ah, 4ch </span><br><span class="line">		int 21h</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="12">
<li><p><strong>除法指令div</strong></p>
<p>格式:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">div 寄存器  ;div bx   该寄存器表示除数</span><br></pre></td></tr></table></figure>

<blockquote>
<p> 公式是<em>被除数<em>÷</em>除数</em>=商……余数 </p>
</blockquote>
</li>
</ol>
<p>被除数需要预先存放在ax寄存器中，相除后商存放在ax寄存器中，余数存放在dx寄存器中</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mov ax,2000 ;定义被除数</span><br><span class="line">mov bx,300   ;定义除数</span><br><span class="line">div bx      ; 进行除法运算</span><br><span class="line"></span><br><span class="line">mov ds:[0],ax ;将商存放至内存中</span><br><span class="line">mov ds:[2],dx ;将余数存放至内存中</span><br></pre></td></tr></table></figure>

<p>因为ax和dx需要存放被除数和余数， 因此除数一般放在bx，cx，或者内存中</p>
<p>由于16位寄存器最多只能存放16位数据，假如被除数数值超过十六位，那么被除数低16位存放在ax寄存器中，高十六位存放在dx寄存器中</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mov dx,20   ;定义被除数高16位</span><br><span class="line">mov ax,2000 ;定义被除数低16位  就是1407D0H</span><br><span class="line">mov bx,300   ;定义除数</span><br><span class="line">div bx      ; 进行除法运算</span><br><span class="line"></span><br><span class="line">mov ds:[0],ax ;将商存放至内存中</span><br><span class="line">mov ds:[2],dx ;将余数存放至内存中</span><br></pre></td></tr></table></figure>

<ol start="13">
<li><p>乘法指令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mov ax,100</span><br><span class="line">mov bx,1000</span><br><span class="line">mul bx    ;相乘</span><br><span class="line"></span><br><span class="line">mov ds:[0],ax ;将积低16位存放至内存中</span><br><span class="line">mov ds:[2],dx ;将积高16位存放至内存中</span><br></pre></td></tr></table></figure>





</li>
</ol>
<h2 id="段寄存器"><a href="#段寄存器" class="headerlink" title="段寄存器"></a>段寄存器</h2><ol>
<li><strong>数据和指令的区别</strong></li>
</ol>
<p>内存中存放的数据都是十六进制的数据，如果这些十六进制数据被标记为数据，那么cpu在读取的时候，读到多少就是多少，如果被标记为了指令，那么cpu会将这些十六进制转成指令进行执行</p>
<p>cpu只是个无情的计算机器，它无法自动区分数据和指令，标记需要我们告诉cpu</p>
<p>那么 如何给数据进行标记呢？</p>
<ol start="2">
<li><strong>段寄存器的种类</strong></li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DS----&gt;data segment</span><br><span class="line">SS----&gt;stack segment </span><br><span class="line">CS----&gt;code segement </span><br><span class="line">ES----&gt;extra segement</span><br></pre></td></tr></table></figure>

<p>都是用于存放段地址的</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">实际物理地址=段地址*16:偏移地址 10*10=100  </span><br><span class="line">71001	  =	0710*16:0001</span><br></pre></td></tr></table></figure>

<p><strong>DS寄存器用于存放数据的段地址</strong>，那么数据所对应的偏移地址可以使用bx寄存器进行存放，<strong>使用DS寄存操作的内存数据都被当成是纯数据</strong>，里面存的是什么，读出来的就是什么</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mov ax,3000H  ;这行代码会转成16进制的数据存放到内存中 这些数据所对应的段地址默认放在ds寄存器中 ，使用ds进行读取的时候 读取的是该指令对应的16进制数据， 而不是被还原成了指令进行执行</span><br></pre></td></tr></table></figure>

<p><strong>CS寄存器用于存放指令所在的段地址</strong>，IP寄存器存放的是当前正在执行的指令所对应的偏移地址，<strong>所有使用CS:IP进行操作的内存数据都被当成是指令对待</strong>，读取的时候会将16进制数据转成对应的指令并执行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mov bx,3333H ;假如这条这条指令数据所对应的物理地址为0710:0000</span><br><span class="line">mov ax,2000H ;假如这条这条指令数据所对应的物理地址为0710:0003</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">;如果我想跳过第一条指令 直接执行第二条指令 那么直接修改CS:IP的值为0710:0003即可</span><br></pre></td></tr></table></figure>

<p><strong>SS寄存器用于存放栈空间对应的段地址</strong>，所有被SS操作的内存空间都被当成栈空间进行对待，你想让哪部分内存空间当作栈空间，完全取决于开发者，sp寄存器存放栈空间偏移量，ss和sp配合使用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mov ax,0710H</span><br><span class="line">mov ss,ax </span><br><span class="line">mov sp,20 ;将0710:0000~0710:0014H 这20个字节的内存空间定义为栈空间</span><br></pre></td></tr></table></figure>

<p><strong>ES寄存器一般用于DS的替补</strong>,DS被占用无法使用时,临时使用ES替代,用法和DS一致</p>
<h2 id="栈空间的操作"><a href="#栈空间的操作" class="headerlink" title="栈空间的操作"></a>栈空间的操作</h2><p>栈段里面存放也是数据和数据段无异,只不过数据排列的方式不一样,正常的排列方式是数据从低地址往高地址进行偏移存放,读取数据也是从低到高,而栈则是写入数据从高到低进行偏移,读取数据从低地址到高地址</p>
<p>由于这个特性,所以我们在定义一块空间作为栈空间使用时,都会先往高地址偏移一段空间</p>
<p><strong>栈存储特点:</strong></p>
<ul>
<li><p>一次读写两个字节的数据</p>
</li>
<li><p>数据高地址往低地址逆序偏移存放</p>
</li>
</ul>
<ol>
<li><p><strong>栈空间的声明</strong></p>
<p>前面提到过，使用ss寄存器进行标记的空间为栈空间</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">data segment</span><br><span class="line">	db 0,0,0,0,0,0,0,0 ;定义数据相当于是开辟了一块未标记内存空间，这块空间可以当作是数据空间也可以栈或者指令空间，却决于该段地址是由哪个段寄存器进行管理的</span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">	start:</span><br><span class="line">		mov ax，data</span><br><span class="line">		mov ss，ax ;该空间被ss指向，因此被当作是栈空间 如果是被CS指向则被当成指令空间，里面存放的数据都会被当成指令进行执行</span><br><span class="line">		mov sp,8</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>往栈空间中写入数据</strong></p>
<p>使用push指令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">data segment</span><br><span class="line">	db 0,0,0,0,0,0,0,0 </span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">	start:</span><br><span class="line">		mov ax，data</span><br><span class="line">		mov ss，ax </span><br><span class="line">		mov sp,8</span><br><span class="line">		</span><br><span class="line">		mov ax,2000H</span><br><span class="line">		push ax  ;一次写入两个字节的数据,如果使用al编译报错</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>从栈空间读取数据</strong></p>
<p>使用pop指令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">data segment</span><br><span class="line">	db 0,0,0,0,0,0,0,0 </span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">	start:</span><br><span class="line">		mov ax，data</span><br><span class="line">		mov ss，ax </span><br><span class="line">		mov sp,8</span><br><span class="line">		</span><br><span class="line">		mov ax,2000H</span><br><span class="line">		push ax</span><br><span class="line">		</span><br><span class="line">		pop bx  ;一次读取两个字节的数据,如果使用bl编译报错</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>

<blockquote>
<p>思考:栈空间和数据段空间,里面存放的都是数据,那么是否可以使用SS来存放数据段的段地址呢,答案是可以的, 当SS充当数据段的时候,读写操作和DS一样,SS:[N],如果充当栈段的时候,读写操作时候时候pop和push,</p>
<p>由于pop和push默认以SS寄存器中的数据当做栈段地址,因此不能使用其他段寄存器充当栈段寄存器</p>
</blockquote>
</li>
</ol>
<h2 id="操控显存输出字符串"><a href="#操控显存输出字符串" class="headerlink" title="操控显存输出字符串"></a>操控显存输出字符串</h2><p>前面咱们介绍过使用中断的方式输出字符串, 今天我们学习一种不使用中断的方式实现字符串的打印</p>
<p> 在8086的内存地址结构中，<code>B8000H~BFFFFH</code>这部分的内存区域为显存区域，一旦向这个地址空间写入数据，<strong>cpu会从0号偏移地址开始读取数据然后显示输出</strong>, (每写入一次数据就从0开始读取一次)</p>
<p>代码尝试:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">start:</span><br><span class="line">	   mov ax,0B800H</span><br><span class="line">	   mov ds,ax</span><br><span class="line">  </span><br><span class="line">	 </span><br><span class="line">	   mov dl,&apos;a&apos;           </span><br><span class="line">	   mov ds:[0],dl</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>

<p>在这块区域中,每个字符固定占用两个字节的空间,也就是<code>ds:[0]</code>和<code>ds:[1]</code>存放一个字符的信息,前者存放字符具体的内容,后者存放字符对应的颜色</p>
<p>比如:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">start:</span><br><span class="line">	   mov ax,0B800H</span><br><span class="line">	   mov ds,ax</span><br><span class="line">  </span><br><span class="line">	 </span><br><span class="line">	   mov dl,&apos;a&apos;           </span><br><span class="line">	   mov ds:[0],dl</span><br><span class="line">	   </span><br><span class="line">	   mov dl,00000100B ;让字符以红色显示          </span><br><span class="line">	   mov ds:[1],dl</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>

<p> <strong>字符颜色的设置规则:</strong> </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0 0 0 0 0 0 0 0  ;用8个二进制位表示字符属性</span><br></pre></td></tr></table></figure>

<p>从高往低数,第一个二进制位表示是否显示闪烁痕迹</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">start:</span><br><span class="line">	   mov ax,0B800H</span><br><span class="line">	   mov ds,ax</span><br><span class="line">  </span><br><span class="line">	 </span><br><span class="line">	   mov dl,&apos;a&apos;           </span><br><span class="line">	   mov ds:[0],dl</span><br><span class="line">	   </span><br><span class="line">	   mov dl,10000000B ;保留字符闪烁痕迹       </span><br><span class="line">	   mov ds:[1],dl</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>

<p>第234个二进制位表示字符背景颜色 分别代表：RGB，即red、green、blue </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">start:</span><br><span class="line">	   mov ax,0B800H</span><br><span class="line">	   mov ds,ax</span><br><span class="line">  </span><br><span class="line">	 </span><br><span class="line">	   mov dl,&apos;a&apos;           </span><br><span class="line">	   mov ds:[0],dl</span><br><span class="line">	   </span><br><span class="line">	   mov dl,01000000B ;背景颜色设为红色       </span><br><span class="line">	   mov ds:[1],dl</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>

<p>第5个二进制位表示字符是否高亮</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">start:</span><br><span class="line">	   mov ax,0B800H</span><br><span class="line">	   mov ds,ax</span><br><span class="line">  </span><br><span class="line">	 </span><br><span class="line">	   mov dl,&apos;a&apos;           </span><br><span class="line">	   mov ds:[0],dl</span><br><span class="line">	   </span><br><span class="line">	   mov dl,00001100B ;字符颜色设置为红色 并且高亮显示 </span><br><span class="line">	   mov ds:[1],dl</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>

<p>第678个二进制位表示字符本身的颜色 分别代表：RGB，即red、green、blue </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">start:</span><br><span class="line">	   mov ax,0B800H</span><br><span class="line">	   mov ds,ax</span><br><span class="line">  </span><br><span class="line">	 </span><br><span class="line">	   mov dl,&apos;a&apos;           </span><br><span class="line">	   mov ds:[0],dl</span><br><span class="line">	   </span><br><span class="line">	   mov dl,00000111B ;背景颜色设为白色  系统默认颜色是白色  </span><br><span class="line">	   mov ds:[1],dl</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>

<p>由于cpu会从0号偏移地址开始读取数据然后显示输出,因此假如你直接在6号偏移地址写入字符数据, 那么前面三个数据会以占位形式存在</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">start:</span><br><span class="line">	   mov ax,0B800H</span><br><span class="line">	   mov ds,ax</span><br><span class="line">  </span><br><span class="line">	 </span><br><span class="line">	   mov dl,&apos;a&apos;           </span><br><span class="line">	   mov ds:[0],dl</span><br><span class="line">	   </span><br><span class="line">	   mov dl,00000111B  </span><br><span class="line">	   mov ds:[6],dl ;输出结果为&quot;   a&quot;</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>

<p><strong>字符串打印</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">data segment</span><br><span class="line">	str db &apos;hello pangshu&apos;</span><br><span class="line">	endstr db &apos;&apos;</span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line"></span><br><span class="line">    start:                  </span><br><span class="line">    </span><br><span class="line">           mov ax,data</span><br><span class="line">           mov ds,ax</span><br><span class="line">           mov ax,0B800H</span><br><span class="line">           mov es,ax</span><br><span class="line"></span><br><span class="line">		   mov cx ,offset endstr-str</span><br><span class="line">		   mov bx,0 </span><br><span class="line">		   mov si,0      </span><br><span class="line">		   </span><br><span class="line">    print:</span><br><span class="line">           mov dl,ds:[si]           </span><br><span class="line">           mov es:[bx],dl</span><br><span class="line"></span><br><span class="line">           mov dl,00000111B ;背景颜色设为白色  系统默认颜色是白色  </span><br><span class="line">           mov es:[bx+1],dl  </span><br><span class="line">           inc si</span><br><span class="line">           add bx,2</span><br><span class="line">           loop print</span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>

<p>借助字符不断刷新显示的特性,可用让字符动画显示</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">;让字符从左往右移动</span><br><span class="line">code segment</span><br><span class="line"></span><br><span class="line">    start:                        </span><br><span class="line">           mov ax,0B800H</span><br><span class="line">           mov es,ax</span><br><span class="line">           </span><br><span class="line">		   mov bx,0 </span><br><span class="line">   		   mov cx,30</span><br><span class="line">    print:     </span><br><span class="line">           mov es:[bx],&apos; &apos; </span><br><span class="line">           mov dl,&apos;a&apos;        </span><br><span class="line">           mov es:[bx+2],dl        </span><br><span class="line">           add bx,2    </span><br><span class="line">           loop print</span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>

<p>屏幕默认显示80x25个字符,全屏显示106x38个字符,那么可以根据这个特性,让字符上下移动</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">;让字符从上往下移动</span><br><span class="line">code segment</span><br><span class="line"></span><br><span class="line">    start:                        </span><br><span class="line">           mov ax,0B800H</span><br><span class="line">           mov es,ax</span><br><span class="line">           </span><br><span class="line">		   mov bx,0 </span><br><span class="line">   		   mov cx,25</span><br><span class="line">    print:     </span><br><span class="line">           mov es:[bx],&apos;a&apos; </span><br><span class="line">           mov dl,&apos; &apos;        </span><br><span class="line">           mov es:[bx-160],dl        </span><br><span class="line">           add bx,160   ;为什么是160而不是80 以内一个字符占两个字节的空间, 80个字符总共偏移了160</span><br><span class="line">           loop print</span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line">end start</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">;让字符从下往上移动</span><br><span class="line">code segment</span><br><span class="line"></span><br><span class="line">    start:                        </span><br><span class="line">           mov ax,0B800H</span><br><span class="line">           mov es,ax</span><br><span class="line">           </span><br><span class="line">		   mov bx,160*24 </span><br><span class="line">   		   mov cx,25</span><br><span class="line">    print:     </span><br><span class="line">           mov es:[bx],&apos;a&apos; </span><br><span class="line">           mov dl,&apos; &apos;        </span><br><span class="line">           mov es:[bx+160],dl        </span><br><span class="line">           sub bx,160   ;为什么是160而不是80 以内一个字符占两个字节的空间, 80个字符总共偏移了160</span><br><span class="line">           loop print</span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>

<p>另外, 让字符斜着移动</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">;让让字符斜着移动</span><br><span class="line">code segment</span><br><span class="line"></span><br><span class="line">    start:                        </span><br><span class="line">           mov ax,0B800H</span><br><span class="line">           mov es,ax</span><br><span class="line">           </span><br><span class="line">		   mov bx,0 </span><br><span class="line">   		   mov cx,25</span><br><span class="line">    print:     </span><br><span class="line">           mov es:[bx],&apos;a&apos; </span><br><span class="line">           mov dl,&apos; &apos;        </span><br><span class="line">           mov es:[bx-161],dl        </span><br><span class="line">           add bx,161   ;向右斜加偏移量 向左斜减偏移量</span><br><span class="line">           loop print</span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>

<p>补充: 在8086中系统提供了一个显示服务(Video Service)中断供我们使用,使用10H这个中断码也可以打印带有颜色属性的字符串</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">;示例1:</span><br><span class="line">mov ah,2 ;放置光标</span><br><span class="line">mov bh,0 ;第0页</span><br><span class="line">mov dh,5 ;行号</span><br><span class="line">mod dl,12 ;列号</span><br><span class="line">int 10H</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">;示例2:</span><br><span class="line">mov ah,9 ;在光标的位置显示字符</span><br><span class="line">mov al,&apos;a&apos; ;字符</span><br><span class="line">mov bl,11001010B ;颜色</span><br><span class="line">mov bh,0 ;第0页</span><br><span class="line">mov cx,3 ;重复显示3次</span><br><span class="line">int 10H</span><br></pre></td></tr></table></figure>

<h2 id="使用键盘输入控制字符移动"><a href="#使用键盘输入控制字符移动" class="headerlink" title="使用键盘输入控制字符移动"></a>使用键盘输入控制字符移动</h2><p>使用16号中断码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">;使用键盘控制字符移动</span><br><span class="line">code segment</span><br><span class="line"></span><br><span class="line">    start:                        </span><br><span class="line">           mov ax,0B800H</span><br><span class="line">           mov es,ax</span><br><span class="line">		   mov bx,0 </span><br><span class="line">   		   mov cx,30    </span><br><span class="line">   		      </span><br><span class="line">   		scan:   </span><br><span class="line">   		   mov ah, 00H</span><br><span class="line">   		   int 16H       </span><br><span class="line">   		   cmp al,61H ;判断两个值是否相等</span><br><span class="line">   		   jne scan2  ;jmp not equal 如果两者不相等 则跳转到scan2 否则往下执行</span><br><span class="line">   		   call  left </span><br><span class="line">   		   jmp scan    </span><br><span class="line">   	    scan2:	     </span><br><span class="line">   		   cmp al,64H</span><br><span class="line">   		   jne scan3    </span><br><span class="line">   		   call  right</span><br><span class="line">   		   jmp scan    </span><br><span class="line">   	    scan3:	   </span><br><span class="line">   		   cmp al,77H</span><br><span class="line">   		   jne scan4 </span><br><span class="line">   		   call top</span><br><span class="line">   		   jmp scan   </span><br><span class="line">   	    scan4:	   </span><br><span class="line">   		   </span><br><span class="line">   		   cmp al,73H</span><br><span class="line">   		   jne scan </span><br><span class="line">   		   </span><br><span class="line">   		   call  down</span><br><span class="line">   		   jmp scan    </span><br><span class="line">   		   </span><br><span class="line">    right:     </span><br><span class="line">           mov es:[bx],&apos; &apos; </span><br><span class="line">           mov dl,&apos;a&apos;        </span><br><span class="line">           mov es:[bx+2],dl        </span><br><span class="line">           add bx,2    </span><br><span class="line">          ret   </span><br><span class="line">     </span><br><span class="line">   		   </span><br><span class="line">    left:     </span><br><span class="line">           mov es:[bx],&apos; &apos; </span><br><span class="line">           mov dl,&apos;a&apos;        </span><br><span class="line">           mov es:[bx-2],dl        </span><br><span class="line">           sub bx,2    </span><br><span class="line">          ret  </span><br><span class="line">           </span><br><span class="line">    top:     </span><br><span class="line">           mov es:[bx],&apos; &apos; </span><br><span class="line">           mov dl,&apos;a&apos;        </span><br><span class="line">           mov es:[bx-160],dl        </span><br><span class="line">           sub bx,160    </span><br><span class="line">          ret  </span><br><span class="line">           </span><br><span class="line">     </span><br><span class="line">   		   </span><br><span class="line">    down:     </span><br><span class="line">           mov es:[bx],&apos; &apos; </span><br><span class="line">           mov dl,&apos;a&apos;        </span><br><span class="line">           mov es:[bx+160],dl        </span><br><span class="line">           add bx,160    </span><br><span class="line">          ret     </span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>

<h3 id="内存读写的另外一种简便方法"><a href="#内存读写的另外一种简便方法" class="headerlink" title="内存读写的另外一种简便方法"></a>内存读写的另外一种简便方法</h3><p>直接使用<code>别名+[偏移量]</code>的形式获取或者修改已经定义好的数据,比如:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">;需求:将第二个字符串最后一个o替换成第一个字符串中的e</span><br><span class="line">data segment</span><br><span class="line">	str dw &apos;hello &apos;</span><br><span class="line">	newstr dw &apos;wowowo&apos;</span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">;以前的写法:</span><br><span class="line">code segment</span><br><span class="line">start:</span><br><span class="line">	mov ax,data</span><br><span class="line">	mov ds,ax   </span><br><span class="line">    mov al,ds:b.str+1    </span><br><span class="line">    mov ds:b.newstr+5,al</span><br><span class="line">code ends</span><br><span class="line">end start</span><br><span class="line"></span><br><span class="line">;更加简便的写法:</span><br><span class="line">code segment</span><br><span class="line">start:</span><br><span class="line">	mov ax,data</span><br><span class="line">	mov ds,ax   </span><br><span class="line">    mov al ,b.str[1]   ;使用b.或者直接定义db数据 实现对单个字符进行控制 </span><br><span class="line">    mov b.newstr[5],al</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>

<p>  <code>mov ax ,str</code> 中的<code>str</code>相当于是<code>str[0]</code>,这也是为什么咱们能够直接通过别名来获取第一个字符的原因 </p>
<blockquote>
<p>前面我们只介绍了b.str[0],表示读取一个字节的数据,另外一种w.str[0]表示读取一个字的数据</p>
<p>别名str中存放的数据量更db和dw有关, 如果是db那么别名默认取一个字节数据,如果dw 别名默认取两个字节数据, 可以使用b.和w.进行数据量的调节</p>
</blockquote>
<h2 id="一维数组的定义"><a href="#一维数组的定义" class="headerlink" title="一维数组的定义"></a>一维数组的定义</h2><p>数组本质上就是多个数据的集合,在内存中按照一定顺序排列,角标即为每个数据的偏移值,如果使用<code>db</code>进行数据的定义那么两个数据之间的偏移值为1个字节,如果使用<code>dw</code>指令定义数据,则偏移值为2个字节</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">data segment</span><br><span class="line">	db 3 dup(1) ;批量定义三个连续的数据 每个数据的偏移量为1  在内存中的排列为 111</span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line">data segment</span><br><span class="line">	db 3 dup(1,2,3) ;批量定义三个连续的数据 每个数据的偏移量为1  在内存中的排列为 123123123</span><br><span class="line">data ends</span><br></pre></td></tr></table></figure>

<p><strong>数组的打印</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">data segment</span><br><span class="line">	array db 128 dup(0)</span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">	start:</span><br><span class="line">		mov ax,data</span><br><span class="line">		mov ds,ax</span><br><span class="line">		</span><br><span class="line">		mov array[0],1   </span><br><span class="line">		mov array[1],2</span><br><span class="line">		mov array[2],3    </span><br><span class="line">		</span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>

<h2 id="外中断"><a href="#外中断" class="headerlink" title="外中断"></a>外中断</h2><p><strong>外中断 (硬中断):</strong>由外部设备(比如网卡,或者硬盘 键盘 鼠标)引发的中断,比如当网卡收到数据包的时候,就会发出一个中断</p>
<p><strong>中断屏蔽:</strong></p>
<p>cpu监听到外部中断时,第一步需要先判断IF标志位的值,如果为1则执行,如果为0则屏蔽</p>
<p>为什么还有中断屏蔽这么一说? 因为有些重复的外部中断并不需要响应,或者cpu正在在执行非常重要的一段指令,这些指令不能中断,一旦中途调开可能会造成系统崩溃,那么在这种情况下需要先将IF标志位置为0,屏蔽所有可屏蔽的外部信号,等这段指令执行完后,再讲IF还原回1, 这个IF标志位相当于是一个监听外部信号的开关</p>
<p>为了方便IF标志位的修改,8086提供了相应的指令方面我们使用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cli  ;相当于IF=0</span><br><span class="line"></span><br><span class="line">sti  ;相当于IF=1</span><br></pre></td></tr></table></figure>

<h4 id="键盘中断"><a href="#键盘中断" class="headerlink" title="键盘中断"></a>键盘中断</h4><p>当我们按下键盘中的一个键,那么键盘会向cpu发出一个中断信号,cpu接收到信号后判断标志位IF是否为1,如果为1,则执行这个中断</p>
<p>当松开按键时,同样会发出一个中断信号,也就是说点击一个键实际产生了两个中断信号</p>
<p><strong>以上这一系列过程涉及到几个问题</strong>:</p>
<p>​    1. 键盘是一个外部设备,电信号发出时,cpu怎么知道这个信号是来自键盘而不是鼠标的呢?</p>
<p>​    2. cpu又如何知道你按下的是哪一个键?</p>
<p><strong>解答1</strong>:</p>
<p>​    cpu除了可以对寄存器 和内存进行数据读写之外,还可以读写端口的数据,电脑上一共有65535个端口,每个端口相当于是一个数据通道,当外部键盘借助USB接口接入电脑被驱动识别后,势必有一个端口与其相连进行数据通信, 在8086中这个端口号为60H</p>
<p>那么如何使用汇编读写端口中的数据呢?</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">in al,60H ; 使用in指令 从60h这个端口读取一个字节到al寄存器中去</span><br><span class="line"></span><br><span class="line">out 60h,al ; 使用out指令 al寄存器中的数据写入60H端口</span><br></pre></td></tr></table></figure>

<p><strong>从端口读写数据必须使用ax或者al寄存器进行交互</strong></p>
<p><strong>解答2:</strong></p>
<p>​    键盘每个键位所对应的字符都有与之对应的扫描码一一映射,不同厂商键盘硬件对应的扫描码可能不一致,它们最终都会转成相应的ascii码</p>
<p>键位扫描码参考表如下:</p>
<table>
<thead>
<tr>
<th><strong>key</strong></th>
<th><strong>mark（Hex）按下</strong></th>
<th><strong>break（Hex）松开</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td>NumLock</td>
<td>45</td>
<td>c5</td>
<td>break = mark + 0x80</td>
</tr>
<tr>
<td>/</td>
<td>e0 35</td>
<td>e0 b5</td>
<td>由 e0 引导出 extend scan code</td>
</tr>
<tr>
<td>*</td>
<td>37</td>
<td>b7</td>
<td>break = mark + 0x80</td>
</tr>
<tr>
<td>-</td>
<td>4a</td>
<td>ca</td>
<td>同上</td>
</tr>
<tr>
<td>7/Home</td>
<td>47</td>
<td>c7</td>
<td>同上</td>
</tr>
<tr>
<td>8/Up</td>
<td>48</td>
<td>c8</td>
<td>同上</td>
</tr>
<tr>
<td>9/PgUp</td>
<td>49</td>
<td>c9</td>
<td>同上</td>
</tr>
<tr>
<td>4/Left</td>
<td>4b</td>
<td>cb</td>
<td>同上</td>
</tr>
<tr>
<td>5</td>
<td>4c</td>
<td>cc</td>
<td>同上</td>
</tr>
<tr>
<td>6/Right</td>
<td>4d</td>
<td>cd</td>
<td>同上</td>
</tr>
<tr>
<td>1/End</td>
<td>4f</td>
<td>cf</td>
<td>同上</td>
</tr>
<tr>
<td>2/Down</td>
<td>50</td>
<td>d0</td>
<td>同上</td>
</tr>
<tr>
<td>3/PgDn</td>
<td>51</td>
<td>d1</td>
<td>同上</td>
</tr>
<tr>
<td>0/Ins</td>
<td>52</td>
<td>d2</td>
<td>同上</td>
</tr>
<tr>
<td>./Del</td>
<td>53</td>
<td>d3</td>
<td>同上</td>
</tr>
<tr>
<td>+</td>
<td>4e</td>
<td>ce</td>
<td>同上</td>
</tr>
<tr>
<td>Enter</td>
<td>e0 1c</td>
<td>e0 9c</td>
<td></td>
</tr>
<tr>
<td>Scroll Lock</td>
<td>46</td>
<td>c6</td>
<td>同上</td>
</tr>
<tr>
<td>Pause/Break</td>
<td>e1 1d 45 e1 9d c5</td>
<td>*</td>
<td>同上</td>
</tr>
<tr>
<td>Insert</td>
<td>e0 52</td>
<td>e0 d2</td>
<td>同上</td>
</tr>
<tr>
<td>Home</td>
<td>e0 47</td>
<td>e0 c7</td>
<td>同上</td>
</tr>
<tr>
<td>Page Up</td>
<td>e0 49</td>
<td>e0 c9</td>
<td>同上</td>
</tr>
<tr>
<td>Delete</td>
<td>e0 53</td>
<td>e0 d3</td>
<td>同上</td>
</tr>
<tr>
<td>End</td>
<td>e0 4f</td>
<td>e0 cf</td>
<td>同上</td>
</tr>
<tr>
<td>Page Down</td>
<td>e0 51</td>
<td>e0 d1</td>
<td>同上</td>
</tr>
<tr>
<td>left</td>
<td>e0 46</td>
<td>e0 c6</td>
<td>同上</td>
</tr>
<tr>
<td>right</td>
<td>e0 4d</td>
<td>e0 cd</td>
<td>同上</td>
</tr>
<tr>
<td>up</td>
<td>e0 48</td>
<td>e0 c8</td>
<td>同上</td>
</tr>
<tr>
<td>down</td>
<td>e0 50</td>
<td>e0 d0</td>
<td>同上</td>
</tr>
<tr>
<td><esc></esc></td>
<td>01</td>
<td>81</td>
<td>scan code</td>
</tr>
<tr>
<td>F1</td>
<td>3b</td>
<td>bb</td>
<td>同上</td>
</tr>
<tr>
<td>F2</td>
<td>3c</td>
<td>bc</td>
<td>同上</td>
</tr>
<tr>
<td>F3</td>
<td>3d</td>
<td>bd</td>
<td>同上</td>
</tr>
<tr>
<td>F4</td>
<td>3e</td>
<td>be</td>
<td>同上</td>
</tr>
<tr>
<td>F5</td>
<td>3f</td>
<td>bf</td>
<td>同上</td>
</tr>
<tr>
<td>F6</td>
<td>40</td>
<td>c0</td>
<td>同上</td>
</tr>
<tr>
<td>F7</td>
<td>41</td>
<td>c1</td>
<td>同上</td>
</tr>
<tr>
<td>F8</td>
<td>42</td>
<td>c2</td>
<td>同上</td>
</tr>
<tr>
<td>F9</td>
<td>43</td>
<td>c3</td>
<td>同上</td>
</tr>
<tr>
<td>F10</td>
<td>44</td>
<td>c4</td>
<td>同上</td>
</tr>
<tr>
<td>F11</td>
<td>57</td>
<td>d7</td>
<td>同上</td>
</tr>
<tr>
<td>F12</td>
<td>58</td>
<td>d8</td>
<td>同上</td>
</tr>
<tr>
<td>~/·</td>
<td>29</td>
<td>a9</td>
<td></td>
</tr>
<tr>
<td><tab></tab></td>
<td>0f</td>
<td>8f</td>
<td></td>
</tr>
<tr>
<td><scapslock></scapslock></td>
<td>3a</td>
<td>ba</td>
<td></td>
</tr>
<tr>
<td><l-shift></l-shift></td>
<td>2a</td>
<td>aa</td>
<td></td>
</tr>
<tr>
<td>!/1</td>
<td>02</td>
<td>82</td>
<td></td>
</tr>
<tr>
<td>q</td>
<td>10</td>
<td>90</td>
<td></td>
</tr>
<tr>
<td>a</td>
<td>1e</td>
<td>9e</td>
<td></td>
</tr>
<tr>
<td>z</td>
<td>2c</td>
<td>ac</td>
<td></td>
</tr>
<tr>
<td>@/2</td>
<td>03</td>
<td>83</td>
<td></td>
</tr>
<tr>
<td>w</td>
<td>11</td>
<td>91</td>
<td></td>
</tr>
<tr>
<td>s</td>
<td>1f</td>
<td>9f</td>
<td></td>
</tr>
<tr>
<td>x</td>
<td>2d</td>
<td>ad</td>
<td></td>
</tr>
<tr>
<td>#/3</td>
<td>04</td>
<td>84</td>
<td></td>
</tr>
<tr>
<td>e</td>
<td>12</td>
<td>12</td>
<td></td>
</tr>
<tr>
<td>d</td>
<td>20</td>
<td>a0</td>
<td></td>
</tr>
<tr>
<td>c</td>
<td>2e</td>
<td>ae</td>
<td></td>
</tr>
<tr>
<td>$/4</td>
<td>05</td>
<td>85</td>
<td></td>
</tr>
<tr>
<td>r</td>
<td>13</td>
<td>93</td>
<td></td>
</tr>
<tr>
<td>f</td>
<td>21</td>
<td>a1</td>
<td></td>
</tr>
<tr>
<td>v</td>
<td>2f</td>
<td>af</td>
<td></td>
</tr>
<tr>
<td>%/5</td>
<td>06</td>
<td>86</td>
<td></td>
</tr>
<tr>
<td>t</td>
<td>14</td>
<td>94</td>
<td></td>
</tr>
<tr>
<td>g</td>
<td>22</td>
<td>a2</td>
<td></td>
</tr>
<tr>
<td>b</td>
<td>30</td>
<td>b0</td>
<td></td>
</tr>
<tr>
<td>^/6</td>
<td>07</td>
<td>87</td>
<td></td>
</tr>
<tr>
<td>y</td>
<td>15</td>
<td>95</td>
<td></td>
</tr>
<tr>
<td>h</td>
<td>23</td>
<td>a3</td>
<td></td>
</tr>
<tr>
<td>n</td>
<td>31</td>
<td>b1</td>
<td></td>
</tr>
<tr>
<td>&amp;/7</td>
<td>08</td>
<td>88</td>
<td></td>
</tr>
<tr>
<td>u</td>
<td>16</td>
<td>96</td>
<td></td>
</tr>
<tr>
<td>j</td>
<td>24</td>
<td>a4</td>
<td></td>
</tr>
<tr>
<td>m</td>
<td>32</td>
<td>b2</td>
<td></td>
</tr>
<tr>
<td>*/8</td>
<td>09</td>
<td>89</td>
<td></td>
</tr>
<tr>
<td>i</td>
<td>17</td>
<td>97</td>
<td></td>
</tr>
<tr>
<td>k</td>
<td>25</td>
<td>a5</td>
<td></td>
</tr>
<tr>
<td>&lt;/,</td>
<td>33</td>
<td>b3</td>
<td></td>
</tr>
<tr>
<td>(/9</td>
<td>0a</td>
<td>8a</td>
<td></td>
</tr>
<tr>
<td>o</td>
<td>18</td>
<td>98</td>
<td></td>
</tr>
<tr>
<td>l</td>
<td>26</td>
<td>a6</td>
<td></td>
</tr>
<tr>
<td>&gt;/.</td>
<td>34</td>
<td>b4</td>
<td></td>
</tr>
<tr>
<td>)/0</td>
<td>0b</td>
<td>8b</td>
<td></td>
</tr>
<tr>
<td>p</td>
<td>19</td>
<td>99</td>
<td></td>
</tr>
<tr>
<td>:/;</td>
<td>27</td>
<td>a7</td>
<td></td>
</tr>
<tr>
<td>?//</td>
<td>35</td>
<td>b5</td>
<td></td>
</tr>
<tr>
<td></td>
<td>_/-</td>
<td>0c</td>
<td>8c</td>
</tr>
<tr>
<td>{/[</td>
<td>1a</td>
<td>9a</td>
<td></td>
</tr>
<tr>
<td>“/‘</td>
<td>28</td>
<td>a8</td>
<td></td>
</tr>
<tr>
<td><r-shift></r-shift></td>
<td>36</td>
<td>b6</td>
<td></td>
</tr>
<tr>
<td></td>
<td>+/=</td>
<td>0d</td>
<td>8d</td>
</tr>
<tr>
<td>}/]</td>
<td>1b</td>
<td>9b</td>
<td></td>
</tr>
<tr>
<td><enter></enter></td>
<td>1c</td>
<td>9c</td>
<td></td>
</tr>
<tr>
<td><l-ctrl></l-ctrl></td>
<td>1d</td>
<td>9d</td>
<td></td>
</tr>
<tr>
<td>|/\</td>
<td>2b</td>
<td>ab</td>
<td></td>
</tr>
<tr>
<td><l-alt></l-alt></td>
<td>38</td>
<td>b8</td>
<td></td>
</tr>
<tr>
<td><backspace></backspace></td>
<td>0e</td>
<td>8e</td>
<td></td>
</tr>
<tr>
<td><space></space></td>
<td>39</td>
<td>b9</td>
<td></td>
</tr>
</tbody></table>
<blockquote>
<p>如果是控制键ctrl shift 则将其转变成状态字节, 记录到0040:0017这个内存空间中,也就是说当我们按下控制键 这个位置的数据会发生相应的改变</p>
</blockquote>
<h2 id="磁盘读写"><a href="#磁盘读写" class="headerlink" title="磁盘读写"></a>磁盘读写</h2><ol>
<li>概念</li>
</ol>
<p>磁盘构造:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">一面=80个磁道</span><br><span class="line"></span><br><span class="line">一个磁道=18个扇区</span><br><span class="line"></span><br><span class="line">一个扇区=512byte</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>中断</p>
<p><strong>使用13H号中断</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">;读取磁盘中的数据到0:200H这个内存中</span><br><span class="line">mov ax,0</span><br><span class="line">mov es,ax</span><br><span class="line">mov bx,200h</span><br><span class="line"></span><br><span class="line">mov al,1 ;读取的扇区数</span><br><span class="line">mov ch,0 ;磁道号</span><br><span class="line">mov cl,1 ;扇区号</span><br><span class="line">mov dl,0 ;驱动器号 软驱a, b</span><br><span class="line">mov dh,2 ;面号</span><br><span class="line">mov ah,2 ;2表示读取 3表示写入</span><br><span class="line">int 13H</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">;将0:200H这个内存中数据写入软盘</span><br><span class="line">mov ax,0</span><br><span class="line">mov es,ax</span><br><span class="line">mov bx,200h</span><br><span class="line"></span><br><span class="line">mov al,1 ;读取的扇区数</span><br><span class="line">mov ch,0 ;磁道号</span><br><span class="line">mov cl,1 ;扇区号</span><br><span class="line">mov dl,0 ;驱动器号 软驱a, b</span><br><span class="line">mov dh,2 ;面号</span><br><span class="line">mov ah,3 ;写入</span><br><span class="line">int 13H</span><br></pre></td></tr></table></figure>









</li>
</ol>
<h2 id="转移指令jmp-jcxz和retf"><a href="#转移指令jmp-jcxz和retf" class="headerlink" title="转移指令jmp ,jcxz和retf"></a>转移指令jmp ,jcxz和retf</h2><p>如果我们想要实现以下效果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mov bx,3333H ;假如这条这条指令数据所对应的物理地址为0710:0000</span><br><span class="line">mov ax,2000H ;假如这条这条指令数据所对应的物理地址为0710:0003</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">;如果我想跳过第一条指令 直接执行第二条指令 那么直接修改CS:IP的值为0710:0003即可</span><br></pre></td></tr></table></figure>

<p>修改方法：</p>
<ul>
<li><p>调试器直接修改</p>
</li>
<li><p>使用<code>jmp</code>指令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">jmp 0100h:8H</span><br><span class="line">mov bx,3333H </span><br><span class="line">mov ax,2000H </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">;如果在同一个段中 可以直接使用jmp+偏移地址的形式</span><br><span class="line">jmp 8H</span><br><span class="line">mov bx,3333H </span><br><span class="line">mov ax,2000H</span><br></pre></td></tr></table></figure>

<p>或者使用标记</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">jmp me</span><br><span class="line">mov bx,3333H </span><br><span class="line">me:</span><br><span class="line">	mov ax,2000H</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用<code>jcxz</code>指令</p>
<p><code>jcxz</code> （jmp cx zero）:条件转移指令，功能和jmp一样，只是需要满足条件，也就是当cx寄存器中的值为0时，进行跳转</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mov cx,0</span><br><span class="line">jcxz me</span><br><span class="line">mov bx,3333H </span><br><span class="line">me:</span><br><span class="line">	mov ax,2000H</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用<code>retf</code>指令</p>
<p><code>retf</code>需要配合栈进行使用，当程序执行到<code>retf</code>这条指令时，会连续从栈中<code>pop</code>两次数据，第一次的数据赋值给<code>CS</code>，第二次的数据赋值给IP，那么如果我们想要跳转到指定的指令，需要将该指令的段地址和偏移地址分别<code>push</code>进栈中</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">stack segment</span><br><span class="line">	db 128 dup(0)</span><br><span class="line">stack ends</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">	start:</span><br><span class="line">		mov ax,stack</span><br><span class="line">		mov ss,ax</span><br><span class="line">		mov sp,128</span><br><span class="line">		</span><br><span class="line">		mov ax,0710H ;指定段地址</span><br><span class="line">		push ax</span><br><span class="line">		mov ax,0003H ;指定偏移地址</span><br><span class="line">		push ax</span><br><span class="line">		</span><br><span class="line">		retf ;程序跳转到0710:0003H这个位置</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>



</li>
</ul>
<h2 id="Call和Ret进阶"><a href="#Call和Ret进阶" class="headerlink" title="Call和Ret进阶"></a>Call和Ret进阶</h2><p><code>call</code>在执行时会先将下一条指令所对应的<code>ip</code>地址入栈，然后修改<code>ip</code>的值实现跳转, <code>ret</code>指令执行的时候，将<code>ip</code>地址<code>pop</code>出来进行跳转</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">call s ;标号里面存放的是ip偏移地址 如果写成call 3H  那么意思就是跳转到CS:0003h这个位置</span><br></pre></td></tr></table></figure>

<p><code>call Far ptr</code> 执行时会将下一条指令做对应的<code>cs</code>和<code>ip</code>都入栈，<code>retf</code>指令执行的时候，将<code>ip</code>和<code>cs</code>值pop出来进行跳转</p>
<blockquote>
<p>ret和call配套使用，retf和call Far ptr 配套使用</p>
<p>可以通过标号(函数名称)之间数值相减计算函数体代码所占用的内存空间大小</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">code segment          </span><br><span class="line">    mov ax,func1 </span><br><span class="line">    mov bx, func2</span><br><span class="line">    sub bx,ax ;计算函数func1占用的内存空间大小</span><br><span class="line"> </span><br><span class="line">  func1: </span><br><span class="line">    mov ax,3333H </span><br><span class="line">    ret             </span><br><span class="line">  func2:       </span><br><span class="line">    mov bx,4444H</span><br><span class="line">    ret</span><br><span class="line">code ends</span><br></pre></td></tr></table></figure>

<p><strong>直接从内存中获取ip地址然后跳转</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">call word ptr ds:[0] ;ds:[0]存放ip值</span><br></pre></td></tr></table></figure>

<p><strong>直接从内存中获取cs和ip地址然后跳转</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">call dword ptr ds:[0] ;ds:[0]存放的是ip值， ds:[2]存放的是cs值</span><br><span class="line"></span><br><span class="line">;这种方式同样会将cs和ip入栈 可以配合retf使用</span><br></pre></td></tr></table></figure>

<blockquote>
<p>以上两种直接从内存中获取cs：ip的方式对于jmp指令同样有效</p>
</blockquote>
<p><strong><code>call</code>指令和<code>jmp</code>指令的区别</strong></p>
<ul>
<li><code>jmp</code>指令仅仅只是修改了<code>cs：ip</code>的值</li>
<li><code>call</code>指令除了修改<code>cs：ip</code>的值之外，还将下一条指令的<code>ip</code>值入栈，方便<code>ret</code>指令跳转调用</li>
</ul>
<p><strong>iret指令:</strong></p>
<p><code>iret</code>指令执行,将<code>ip</code>和<code>cs</code>值pop出来进行跳转，同时还执行了<code>popf</code>，相当于执行了以下三步操作</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pop ip</span><br><span class="line">pop cs</span><br><span class="line">popf</span><br></pre></td></tr></table></figure>

<h2 id="内中断进阶"><a href="#内中断进阶" class="headerlink" title="内中断进阶"></a>内中断进阶</h2><p>我们利用中断码段可以调用系统的功能,也就是被系统封装好的子程序</p>
<p>中断既然能够引导<code>cpu</code>临时去执行子程序，那么势必是更改了<code>cs:ip</code>的值，也就是在内存中存放了这个子程序的入口指令地址，通过<code>int</code>关键字找出来并跳转。<strong>这里有两个先决条件，一个是子程序必须提前编写好存放在内存中，二是将入口地址存放在内存的某个位置</strong></p>
<p>当程序执行到<code>int</code>指令时，根据中断码计算出程序入口所在的物理地址，然后然后取出来赋值给<code>cs：ip</code></p>
<p>那么怎么通过中断码计算呢？</p>
<p>比如 <code>int 0h</code>  会从<code>0000：0000</code>这个地址开始找出四个字节数据，由高地址往低地址分别为段地址和偏移地址</p>
<p>由于每个中断码需要占用四个字节空间，因此<code>int 2H</code> 从<code>0000：0004</code>开始找，以此类推</p>
<p>公式为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">IP=中断码*4</span><br><span class="line">CS=中断码*4+2</span><br></pre></td></tr></table></figure>

<p>配合咱们之前学的<code>call</code>指令  <code>int 9h</code> 可以用以下指令替代:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int 9h </span><br><span class="line"></span><br><span class="line">;相当于一下三行代码</span><br><span class="line">mov ax,0000H</span><br><span class="line">mov ds,ax</span><br><span class="line">call dword ptr ds:[9h*4]</span><br></pre></td></tr></table></figure>

<h4 id="编写自定义中断"><a href="#编写自定义中断" class="headerlink" title="编写自定义中断"></a>编写自定义中断</h4><ol>
<li><p>编写子程序</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">child:</span><br><span class="line">	mov ax,3322H</span><br><span class="line">	retf</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="2">
<li><p>将子程序入口地址值存放到中断码对应的内存位置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">code segment</span><br><span class="line">start:</span><br><span class="line">	call write</span><br><span class="line">	</span><br><span class="line">	mov ah,4cH</span><br><span class="line">	int 21h</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">    ;=======子程序======</span><br><span class="line">    child:</span><br><span class="line">        mov ax,3322H</span><br><span class="line">        retf</span><br><span class="line">    endd: nop</span><br><span class="line">    ;=======子程序======</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    ;=======将子程序入口地址写入内存======</span><br><span class="line">    write:</span><br><span class="line">    	</span><br><span class="line">    	;子程序所在的段地址</span><br><span class="line">    	mov ax,cs</span><br><span class="line">    	;子程序所在的偏移地址</span><br><span class="line">    	mov bx,child</span><br><span class="line">    </span><br><span class="line">    	mov cx,0000H</span><br><span class="line">    	mov es,cx</span><br><span class="line">    	mov es:[9h*4],bx</span><br><span class="line">    	mov es:[9h*4+2],ax</span><br><span class="line">    	ret</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用中断码调用子程序</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">code segment</span><br><span class="line">start:</span><br><span class="line">	call write</span><br><span class="line">	</span><br><span class="line">	;测试中断</span><br><span class="line">	int 9H</span><br><span class="line">	</span><br><span class="line">	mov ah,4cH</span><br><span class="line">	int 21h</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">    ;=======子程序======</span><br><span class="line">    child:</span><br><span class="line">        mov ax,3322H</span><br><span class="line">        retf</span><br><span class="line">    endd: nop</span><br><span class="line">    ;=======子程序======</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    ;=======将子程序入口地址写入内存======</span><br><span class="line">    write:</span><br><span class="line">    	</span><br><span class="line">    	;子程序所在的段地址</span><br><span class="line">    	mov ax,cs</span><br><span class="line">    	;子程序所在的偏移地址</span><br><span class="line">    	mov bx,child</span><br><span class="line">    </span><br><span class="line">    	mov cx,0000H</span><br><span class="line">    	mov es,cx</span><br><span class="line">    	mov es:[9h*4],bx</span><br><span class="line">    	mov es:[9h*4+2],ax</span><br><span class="line">    	ret</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>



</li>
</ol>
<h2 id="音乐播放"><a href="#音乐播放" class="headerlink" title="音乐播放"></a>音乐播放</h2><p>声音由震动产生,不同频率对应不同的声音,也就是<strong>音高</strong></p>
<p>单个音高的声音不能叫音乐,只能叫音频,</p>
<p>而音乐是由<strong>不同时长</strong>的<strong>不同音高</strong>组合而成,比如100Hz的声音持续1秒紧接着200Hz的声音持续半秒,如此反复循环,那么在听感上就是一首音乐</p>
<p>在音乐演奏的世界里,为了表示音高,一般采用记谱的方式来代替频率,从而方便音乐家们交流,但是对于计算机而言,计算机不能识别简谱也不能识别五线谱</p>
<h4 id="计算机的发声原理"><a href="#计算机的发声原理" class="headerlink" title="计算机的发声原理"></a>计算机的发声原理</h4><p>电信号—–&gt;驱动——-&gt;扬声器</p>
<h4 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">data segment</span><br><span class="line">	;音高</span><br><span class="line">	freq dw 262,262,262,196</span><br><span class="line">		 dw 330,330,330,262</span><br><span class="line">		 dw 262,330,392,392</span><br><span class="line">		 dw 349,330,294</span><br><span class="line">		 dw 294,330,349,349</span><br><span class="line">		 dw 330,294,330,262</span><br><span class="line">		 dw 262,330,294,196</span><br><span class="line">		 dw 247,294,262,-1</span><br><span class="line">	 ;时长</span><br><span class="line">	 time dw 3 dup(12,12,25,25),12,12,50</span><br><span class="line">	      dw 3 dup(12,12,25,25),12,12,50</span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line">stack segment</span><br><span class="line">	db 100H dup(0)</span><br><span class="line">stack ends</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">	start:</span><br><span class="line">		;主程序</span><br><span class="line">		mov ax,stack</span><br><span class="line">		mov ss,ax</span><br><span class="line">		mov sp,100H</span><br><span class="line">		mov ax,data</span><br><span class="line">		mov ds,ax</span><br><span class="line">		</span><br><span class="line">		lea si,freq</span><br><span class="line">		lea di,time</span><br><span class="line">		</span><br><span class="line">	play:</span><br><span class="line">		mov dx,[si]</span><br><span class="line">		cmp dx,-1</span><br><span class="line">		je end_play</span><br><span class="line">		call sound</span><br><span class="line">		add si,2</span><br><span class="line">		add di,2</span><br><span class="line">		jmp play</span><br><span class="line">		</span><br><span class="line">	end_play:</span><br><span class="line">		mov ah,4cH</span><br><span class="line">		int 21H</span><br><span class="line">	sound:</span><br><span class="line">    	push ax</span><br><span class="line">    	push dx</span><br><span class="line">    	push cx</span><br><span class="line">    	;定时器的设置</span><br><span class="line">    	mov al,0b6h</span><br><span class="line">    	out 43H,al</span><br><span class="line">    	mov dx,12H</span><br><span class="line">    	mov ax,34dcH</span><br><span class="line">    	div word ptr[si]</span><br><span class="line">    	out 42h,al</span><br><span class="line">    	mov al,ah</span><br><span class="line">    	out 42h,al</span><br><span class="line">    	;设置8255芯片,控制扬声器开关</span><br><span class="line">    	in al,61h</span><br><span class="line">    	mov ah,al</span><br><span class="line">    	or al ,3</span><br><span class="line">    	out 61h,al</span><br><span class="line">    	;延时一定的时长</span><br><span class="line">    	mov dx,[di]</span><br><span class="line">    wait1:</span><br><span class="line">    	mov cx,28000</span><br><span class="line">    delay:</span><br><span class="line">    	nop</span><br><span class="line">    	loop delay</span><br><span class="line">    	dec dx</span><br><span class="line">    	jnz wait1</span><br><span class="line">        ;恢复扬声器端口原值</span><br><span class="line">        mov al,ah</span><br><span class="line">        out 61h,al</span><br><span class="line">        pop cx</span><br><span class="line">        pop dx</span><br><span class="line">        pop ax</span><br><span class="line">        ret</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>

<p><strong>本文为作者原创 转载时请注明出处 谢谢</strong></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em>乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</em></p>
]]></content>
      <tags>
        <tag>汇编</tag>
      </tags>
  </entry>
  <entry>
    <title>x86汇编语言之DI和SI寄存器</title>
    <url>/200.html</url>
    <content><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p><strong>SI（source index）是源变址寄存器</strong><br><strong>DI（destination index）是目的变址寄存器</strong><br>它们和[bx]类似,用于存放偏移地址</p>
<h3 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">assume cs:code,ds:data</span><br><span class="line"></span><br><span class="line">;需求:字符串复制到...位置</span><br><span class="line">data segment</span><br><span class="line">	db &apos;welcome to masm!&apos;</span><br><span class="line">	db &apos;................&apos;</span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">	start:</span><br><span class="line">		mov ax,data</span><br><span class="line">		mov ds,ax</span><br><span class="line">		mov es,ax</span><br><span class="line">		</span><br><span class="line">		mov si,0</span><br><span class="line">		mov di,16</span><br><span class="line">		</span><br><span class="line">		mov cx, 8</span><br><span class="line">copydata:</span><br><span class="line">		mov dx,ds:[si]</span><br><span class="line">		mov es:[di],dx</span><br><span class="line">		add si,2</span><br><span class="line">		add di,2</span><br><span class="line">		loop copydata</span><br><span class="line">		</span><br><span class="line">code ends</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">end start</span><br></pre></td></tr></table></figure>

<p>改成栈复制:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">assume cs:code,ds:data</span><br><span class="line"></span><br><span class="line">;需求:字符串复制到...位置</span><br><span class="line">data segment</span><br><span class="line">	db &apos;welcome to masm!&apos;</span><br><span class="line">	db &apos;................&apos;</span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line">stack segment</span><br><span class="line">	db 32 dup(0)</span><br><span class="line">stack ends</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">	start:</span><br><span class="line">		mov ax,data</span><br><span class="line">		mov ds,ax</span><br><span class="line">		mov es,ax</span><br><span class="line">		</span><br><span class="line">		mov ax,stack</span><br><span class="line">		mov ss,ax</span><br><span class="line">		mov sp,32</span><br><span class="line">		</span><br><span class="line">		mov si,0</span><br><span class="line">		mov di,16</span><br><span class="line">		</span><br><span class="line">		mov cx, 8</span><br><span class="line">copydata:</span><br><span class="line">		push ds:[si]</span><br><span class="line">		pop es:[di]</span><br><span class="line">		add si,2</span><br><span class="line">		add di,2</span><br><span class="line">		loop copydata</span><br><span class="line">		</span><br><span class="line">code ends</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">end start</span><br></pre></td></tr></table></figure>

<h2 id="偏移地址组合"><a href="#偏移地址组合" class="headerlink" title="偏移地址组合"></a>偏移地址组合</h2><ol>
<li><p>ds:[bx+数字]</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ds:[bx+数字] ;如果写成[数字+bx],那么相当于[bx]+数字,两者意思不一样</span><br></pre></td></tr></table></figure>
</li>
<li><p>ds:[bx+si]和ds:[bx+si+数字]</p>
</li>
<li><p>ds:[bx+di]和ds:[bx+di+数字]</p>
</li>
</ol>
<h4 id="偏移地址组合实际应用"><a href="#偏移地址组合实际应用" class="headerlink" title="偏移地址组合实际应用"></a>偏移地址组合实际应用</h4><ol>
<li>需求:首字母变成大写</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">assume cs:code ,ds:data</span><br><span class="line">; 需求:首字母变成大写</span><br><span class="line">data segment</span><br><span class="line">	db &apos;1. file         &apos;</span><br><span class="line">	db &apos;2. edit         &apos;</span><br><span class="line">	db &apos;3. search       &apos;</span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">	start:</span><br><span class="line">		mov ax,data</span><br><span class="line">		mov ds,ax</span><br><span class="line">		mov es,ax</span><br><span class="line">		</span><br><span class="line">		mov bx,0</span><br><span class="line">		mov si,3</span><br><span class="line">		</span><br><span class="line">		mov cx,3</span><br><span class="line">upLetter:</span><br><span class="line">		mov dl,ds:[bx+si]</span><br><span class="line">		and dl,11011111B</span><br><span class="line">		mov es:[bx+si],dl</span><br><span class="line">		add bx,16</span><br><span class="line">		loop upLetter</span><br><span class="line">		</span><br><span class="line">code ends</span><br><span class="line"></span><br><span class="line">end start</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>需求:所有字母变成大写</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">assume cs:code ,ds:data，ss:stack</span><br><span class="line">; 需求:所有字母变成大写</span><br><span class="line">data segment</span><br><span class="line">	db &apos;1. file         &apos;</span><br><span class="line">	db &apos;2. edit         &apos;</span><br><span class="line">	db &apos;3. sear         &apos;</span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line">stack segment</span><br><span class="line">	db 32 dup(0)</span><br><span class="line">stack ends</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">	start:</span><br><span class="line">		mov ax,data</span><br><span class="line">		mov ds,ax</span><br><span class="line">		mov es,ax</span><br><span class="line">		</span><br><span class="line">		mov ax,stack</span><br><span class="line">		mov ss,ax</span><br><span class="line">		mov sp,32</span><br><span class="line">		</span><br><span class="line">		mov bx,0</span><br><span class="line">		mov si,3</span><br><span class="line">		</span><br><span class="line">		mov cx,3</span><br><span class="line">upRow: ;使用两层循环， 因为内循环需要用到cx和si寄存器，避免数据被覆盖，使用栈临时保护</span><br><span class="line">		push cx</span><br><span class="line">		push si</span><br><span class="line">		</span><br><span class="line">		mov cx,4</span><br><span class="line">upLetter:</span><br><span class="line">		mov dl,ds:[bx+si]</span><br><span class="line">		and dl,11011111B</span><br><span class="line">		mov es:[bx+si],dl</span><br><span class="line">		inc si</span><br><span class="line">		loop upLetter</span><br><span class="line">		</span><br><span class="line">        add bx,16</span><br><span class="line">        pop si</span><br><span class="line">        pop cx</span><br><span class="line">        loop upRow</span><br><span class="line">		</span><br><span class="line">code ends</span><br><span class="line"></span><br><span class="line">end start</span><br></pre></td></tr></table></figure>

<p><strong>本文为作者原创 转载时请注明出处 谢谢</strong></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em>乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</em></p>
]]></content>
      <tags>
        <tag>汇编</tag>
      </tags>
  </entry>
  <entry>
    <title>关于字节和字长以及半字的关系</title>
    <url>/203.html</url>
    <content><![CDATA[<h2 id="关于字节"><a href="#关于字节" class="headerlink" title="关于字节"></a>关于字节</h2><p>一个字节是固定为8个二进制位</p>
<h2 id="关于字-word"><a href="#关于字-word" class="headerlink" title="关于字(word)"></a>关于字(word)</h2><p>字的长度是可变的,它和cpu一次性能操作的实际位数有关</p>
<p>比如16位的cpu一次能操作16位数,因次2个字节代表一个字</p>
<p>如果是32位cpu,那么32位也就是4个字节代表一个字的长度(word)</p>
<h2 id="关于半字"><a href="#关于半字" class="headerlink" title="关于半字"></a>关于半字</h2><p>半字即为字长的一半,在16位cpu中,半字即为一个字节,故在16位中没有半字这个说法,一半32位以上cpu环境中常用</p>
<p><strong>本文为作者原创 转载时请注明出处 谢谢</strong></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em>乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</em></p>
]]></content>
      <tags>
        <tag>汇编</tag>
      </tags>
  </entry>
  <entry>
    <title>android设备上如何运行C语言原生程序</title>
    <url>/201.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>咱们知道<code>android</code>设备可以直接运行<code>apk</code>,或者使用<code>dalvikvm</code>指令运行<code>dex</code>文件中的程序, 但是这两者本质上使用的语言都是<code>java</code>或者<code>smali</code>,</p>
<p>如果需要执行C语言程序,我们通常需要借助<code>NDK</code>编译成<code>so</code>库, 那有没有不使用<code>NDK</code>而直接编译c原生程序然后在安卓设备中运行的方式呢?</p>
<h2 id="交叉编译"><a href="#交叉编译" class="headerlink" title="交叉编译"></a>交叉编译</h2><p>C语言是一门跨平台的语言,<strong>语言跨平台,但是程序不跨平台</strong></p>
<p>也就是说在<code>windows</code>平台下编译的程序只能在<code>windows</code>平台上执行,<code>linux</code>亦是如此, 为什么会出现这种情况呢? </p>
<p>除了操作系统导致的文件格式不一致之外,本质上是因为不同平台<code>cpu</code>使用的架构不一致导致</p>
<p>目前主流的三大<code>cpu</code>架构<strong>x86,ARM,MIPS</strong>,每个架构都对应着属于自己的一套汇编指令集, 我们编写的程序,最终都会解码成汇编指令被<code>cpu</code>所执行,</p>
<p>那么在<code>windows</code>平台上进行本机编译的C语言代码,会根据当前平台的<code>cpu</code>架构和操作系统生成只能在当前平台运行的程序</p>
<p>如果我想在<code>windows</code>平台编译出能在<code>linux</code>系统或者在<code>ARM</code>设备中运行的程序, 那该怎么办呢?</p>
<p>这个时候我们就要使用交叉编译工具, 那这种<strong>编译的模式就不叫本机编译了,而叫做交叉编译</strong></p>
<h2 id="为什么需要交叉编译"><a href="#为什么需要交叉编译" class="headerlink" title="为什么需要交叉编译"></a>为什么需要交叉编译</h2><p>场景:</p>
<ul>
<li>你正在编译一款<code>linux</code>应用,但你手上只有一台<code>windows</code>电脑,这个时候交叉编译能帮上大忙</li>
<li>目标设备环境不允许,比如单片机, 内存和性能无法支持程序的编译</li>
<li>一款配备新硬件的机器问世, 需要借助交叉编译来编译它的系统和编译器等</li>
</ul>
<h2 id="交叉编译工具"><a href="#交叉编译工具" class="headerlink" title="交叉编译工具"></a>交叉编译工具</h2><p>目前主流的交叉编译工具有<code>GCC</code>和<code>Clang</code>, 接下来主要介绍<code>GCC</code>的使用方法:</p>
<p>首先</p>
<p>交叉编译工具链的命名规则为：<strong>arch [-vendor] [-os] [-(gnu)eabi]</strong></p>
<ul>
<li><strong>arch</strong> – 体系架构，如<code>ARM</code>，<code>MIPS</code></li>
<li><strong>vendor</strong> – 工具链提供商</li>
<li><strong>os</strong> – 目标操作系统</li>
<li><strong>eabi</strong> – 嵌入式应用二进制接口（Embedded Application Binary Interface）</li>
</ul>
<p>根据对操作系统的支持与否，<strong>ARM GCC可分为支持和不支持操作系统</strong>，</p>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><ul>
<li><strong>arm-none-eabi</strong>：这个是没有操作系统的,适用于<code>ARM</code>架构裸机,工具链提供商未知,嵌入式应用二进制接口,这个工具不支持那些跟操作系统关系密切的函数，比如fork(2)。他使用的是<code>newlib</code>这个专用于嵌入式系统的C库。</li>
<li><strong>arm-none-linux-eabi</strong>：用于<code>Linux</code>的，<code>ARM</code>架构,使用<code>Glibc</code></li>
</ul>
<blockquote>
<p>如果是裸机编译,由于没有操作系统进行文件识别翻译,因此编译出来的大部分是面向cpu内核的机器码文件</p>
<p>单片机编译后的文件就是如此</p>
</blockquote>
<h2 id="回到主题"><a href="#回到主题" class="headerlink" title="回到主题"></a>回到主题</h2><p>我需要用C语言编写一个能在安卓设备上运行的程序, 首先安卓设备大多采用的是<code>ARM</code>架构<code>cpu,</code> 系统采用的是<code>linux</code>系统, </p>
<p>如果我们想在安卓设备中进行本机编译的话,实现起来比较困难, 那么咱们可以借助交叉编译工具,实现在<code>windows</code>平台上编译出能够在<code>ARM+Linux</code>平台上的可执行程序</p>
<p>这里我们使用 <code>arm-none-linux-gnueabi-gcc</code> 这款交叉编译工具</p>
<p>工具下载:</p>
<p><a href="https://code.newban.cn/202.html">各个平台arm-none-linux-gnueabi交叉编译工具下载</a></p>
<p>或者</p>
<p><a href="https://sourcery.mentor.com/public/gnu_toolchain/arm-none-linux-gnueabi/arm-2009q1-203-arm-none-linux-gnueabi-i686-pc-linux-gnu.tar.bz2" target="_blank" rel="noopener">linux平台arm-none-linux-gnueabi工具直链下载</a></p>
<h4 id="第一步-源码编写"><a href="#第一步-源码编写" class="headerlink" title="第一步 源码编写"></a>第一步 源码编写</h4><p>新建<code>test.c</code>文件</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;  </span></span></span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Hello world!\n"</span>);  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="第二步-源码编译"><a href="#第二步-源码编译" class="headerlink" title="第二步 源码编译"></a>第二步 源码编译</h4><p>在命令窗口执行bin包下的<code>arm-none-linux-gnueabi-gcc</code>指令</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">arm-none-linux-gnueabi-gcc test.c -o test -<span class="keyword">static</span></span><br></pre></td></tr></table></figure>

<p> 因为<code>Android 的 Linux</code> 内核没有标准IO库函数，因此我们采用静态编译的方式进行编译 末尾<code>-static</code>必须要有</p>
<h4 id="第三步-将编译后的可执行文件传至安卓设备"><a href="#第三步-将编译后的可执行文件传至安卓设备" class="headerlink" title="第三步 将编译后的可执行文件传至安卓设备"></a>第三步 将编译后的可执行文件传至安卓设备</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">adb push test /data/</span><br></pre></td></tr></table></figure>

<h4 id="第四步-执行文件"><a href="#第四步-执行文件" class="headerlink" title="第四步 执行文件"></a>第四步 执行文件</h4><p>直接在控制台输入文件名即可执行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">./test</span><br></pre></td></tr></table></figure>

<p>如果提示权限拒绝,那么执行以下指令:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">chmod 777 test</span><br></pre></td></tr></table></figure>

<p>至此 程序正常运行 控台输出<code>Hello world!</code></p>
<p><strong>本文为作者原创 转载时请注明出处 谢谢</strong></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em>乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</em></p>
]]></content>
      <tags>
        <tag>汇编</tag>
      </tags>
  </entry>
  <entry>
    <title>硬件开发之基础知识(-)</title>
    <url>/206.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>随着智能家居的兴起,5G时代的到来, 智能硬件扮演者越来越关键的角色, 对于老百姓的我们而言,占据先机最好的办法的就是了解并掌握它, 因为知识是公平的</p>
<h2 id="基础物理知识"><a href="#基础物理知识" class="headerlink" title="基础物理知识"></a>基础物理知识</h2><p>这些我们在学生时代都学过,现在需要把它们都重新拾起来</p>
<h4 id="1-电压"><a href="#1-电压" class="headerlink" title="1. 电压"></a>1. 电压</h4><p>可以理解为电子移动的动力,压力即是动力,单位:V</p>
<h4 id="2-电流"><a href="#2-电流" class="headerlink" title="2. 电流"></a>2. 电流</h4><p> 电荷的定向流动 ,犹如水流</p>
<p>流动的电才能将电灯点亮</p>
<p>单位:A</p>
<h4 id="3-电的产生"><a href="#3-电的产生" class="headerlink" title="3.电的产生"></a>3.电的产生</h4><p>产生电的方式有很多种,摩擦生电,电解质生电,一般我们日常使用的电,是通过发电机发电,它的原理是:</p>
<p> 闭合电路的一部分导体在磁场里做切割磁感线的运动时，导体中就会产生电流</p>
<p>材料:</p>
<pre><code>1. 磁铁
 2. 线圈</code></pre><p>自制发电机:<a href="https://v.163.com/static/1/VYUIDVSRG.html" target="_blank" rel="noopener">https://v.163.com/static/1/VYUIDVSRG.html</a></p>
<h2 id="电子元器件"><a href="#电子元器件" class="headerlink" title="电子元器件"></a>电子元器件</h2><p>分类:</p>
<ul>
<li>元件:工厂在加工时没改变原材料分子成分的产品可称为元件。元件属于不需要能源的器件。它包括：电阻、电容、电感等</li>
<li>器件:工厂在生产加工时改变了原材料分子结构的产品称为器件。器件需要消耗能源,它包括双极性晶体三极管 场效应晶体管 可控硅 等</li>
</ul>
<h4 id="常见电子元器件"><a href="#常见电子元器件" class="headerlink" title="常见电子元器件"></a>常见电子元器件</h4><ol>
<li>电阻</li>
<li>电容</li>
<li>二极管</li>
<li>三极管</li>
<li>继电器</li>
<li>电容器</li>
<li>电位器</li>
<li>传感器</li>
<li></li>
</ol>
<h3 id="电流的的流向判断"><a href="#电流的的流向判断" class="headerlink" title="电流的的流向判断"></a>电流的的流向判断</h3><p><strong>第一步</strong>:判断是否有一条电路直接将正负极向连,如果有则短路,没有则进入第二步</p>
<p><strong>第二步</strong>:在电流分叉路口,判断是否有一条电路没有连接任何元器件,如果有则走这条路,其他路不通, 如果都连接了器件,那么都有电流通过</p>
<h2 id="串联和并联电路"><a href="#串联和并联电路" class="headerlink" title="串联和并联电路"></a>串联和并联电路</h2><p> 1.串联电路的特点：<br>（1）电流：文字表达：串联电路中各处电流都相等.<br>公式表达：I=I1=I2=I3=……=In<br>（2）电压：文字表达：串联电路中的总电压等于各部分电路电压之和.<br>公式表达：U=U1+U2+U3+……+Un<br>（3）电阻：文字表达：串联电路中的总电阻等于各部分电路的电阻之和.<br>公式表达：R=R1+R2+R3+……+Rn<br>（4）分压定律：文字表达：串联电路中各部分电路两端电压与其电阻成正比.<br>公式表达：U1/R1=U2/R2=U3/R3=.=Un/Rn<br>另种表达：U1：U2：U3：…：Un= R1：R2：R3：…：Rn<br>特例：U1/U2=R1/R2<br>2.并联电路的特点：<br>（1）电流：文字表达：并联电路中总电流等于各支路中的电流之和.<br>公式表达：I=I1+I2+I3+……+In<br>（2）电压：文字表达：并联电路中各支路两端的电压都相等.<br>公式表达：U=U1=U2=U3=……=Un<br>（3）电阻：文字表达：并联电路总电阻的倒数等于各支路电阻倒数之和.<br>公式表达：1/R=1/R1+1/R2+1/R3+……+1/Rn<br>（4）分流定律：文字表达：并联电路中,流过各支路的电流与其电阻成反比.<br>公式表达：I1R1=I2R2=I3R3= …=InRn<br>特例：I1/I2=R2/R1 </p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>在串联电路中</p>
<ul>
<li>电阻越大,截取的电压越大</li>
</ul>
<p>在并联电路中</p>
<ul>
<li>电阻越大, 截取的电流越小</li>
<li>分支电路越多,总电流越大</li>
</ul>
<p><strong>本文为作者原创 转载时请注明出处 谢谢</strong></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em>乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</em></p>
]]></content>
      <tags>
        <tag>硬件开发</tag>
      </tags>
  </entry>
  <entry>
    <title>硬件开发之个人PCB电路板制作</title>
    <url>/207.html</url>
    <content><![CDATA[<h2 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h2><h4 id="第一步-画电路原理图"><a href="#第一步-画电路原理图" class="headerlink" title="第一步 画电路原理图"></a>第一步 画电路原理图</h4><ol>
<li><p>工具</p>
<p><strong>Altium Designer 19</strong>: 中文官网：<a href="https://www.altium.com.cn/products/downloads" target="_blank" rel="noopener">https://www.altium.com.cn/products/downloads</a> </p>
</li>
</ol>
<h4 id="第二步-联系PCB厂家"><a href="#第二步-联系PCB厂家" class="headerlink" title="第二步 联系PCB厂家"></a>第二步 联系PCB厂家</h4><ol>
<li>廉价厂家推荐<ul>
<li><a href="https://www.jlc.com/" target="_blank" rel="noopener">嘉立创</a> :10x10cm的板子5张 只需5块钱</li>
<li><a href="https://www.jiepei.com" target="_blank" rel="noopener">捷配</a>  :10x10cm的板子5张 19块钱</li>
</ul>
</li>
</ol>
<h4 id="第三步-电子元器件采购"><a href="#第三步-电子元器件采购" class="headerlink" title="第三步 电子元器件采购"></a>第三步 电子元器件采购</h4><h4 id="第四步-电子元器件焊接"><a href="#第四步-电子元器件焊接" class="headerlink" title="第四步 电子元器件焊接"></a>第四步 电子元器件焊接</h4><h4 id="第四步-电路板测试"><a href="#第四步-电路板测试" class="headerlink" title="第四步 电路板测试"></a>第四步 电路板测试</h4><p><strong>本文为作者原创 转载时请注明出处 谢谢</strong></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em>乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</em></p>
]]></content>
      <tags>
        <tag>硬件开发</tag>
      </tags>
  </entry>
  <entry>
    <title>各个平台arm-none-linux-gnueabi交叉编译工具下载</title>
    <url>/202.html</url>
    <content><![CDATA[<p><strong>arm-none-linux-gnueabi-gcc</strong>是 Codesourcery 公司（目前已经被Mentor收购）基于GCC推出的的ARM交叉编译工具。可用于交叉编译ARM系统中所有环节的代码，包括裸机程序、u-boot、Linux kernel、filesystem和App应用程序。使用时，按照主机平台，可以下载以下任一版本中的一个，结果是一样的：</p>
<ul>
<li><strong>Linux解压版</strong>：在Linux主机（如Ubuntu、RedHat等）直接解压即可使用。<strong>推荐方式！</strong></li>
<li><strong>Linux安装版</strong>：在Linux主机下执行后按照提示安装后使用。</li>
<li><strong>Windows解压版</strong>：在Windows系统下解压后使用，但是需要MingW32。</li>
<li><strong>Windows安装版</strong>：在Windows系统下安装后使用。</li>
<li><strong>RPM安装版</strong>：RedHat系统安装包，新版本不提供该类安装包。</li>
<li><strong>源码版</strong>：交叉编译器源代码，一般很少用到。</li>
</ul>
<p>为方便国内用户下载使用，我们从Codesourcery（Mentor）官网下载了所有版本的arm-none-linux-gnueabi-gcc编译器，并放到国内云盘上提供下载。因为版本很多，可能难以选择，但是我们建议您使用最新版本，即有<em>最新~</em>标志的下载项。</p>
<h2 id="1-Linux解压版"><a href="#1-Linux解压版" class="headerlink" title="1 Linux解压版"></a>1 Linux解压版</h2><p>gnu-csl-arm-2005Q1B-arm-none-linux-gnueabi-i686-pc-linux-gnu.tar.bz2 —— <a href="http://pan.baidu.com/s/1dD7ZSbv" target="_blank" rel="noopener">下载</a><br>arm-2006q1-3-arm-none-linux-gnueabi-i686-pc-linux-gnu.tar.bz2 —— <a href="http://pan.baidu.com/s/1pJAxr1T" target="_blank" rel="noopener">下载</a><br>arm-2006q1-6-arm-none-linux-gnueabi-i686-pc-linux-gnu.tar.bz2 —— <a href="http://pan.baidu.com/s/1pJjsX0v" target="_blank" rel="noopener">下载</a><br>arm-2006q3-26-arm-none-linux-gnueabi-i686-pc-linux-gnu.tar.bz2 —— <a href="http://pan.baidu.com/s/1sj0PPwh" target="_blank" rel="noopener">下载</a><br>arm-2007q1-10-arm-none-linux-gnueabi-i686-pc-linux-gnu.tar.bz2 —— <a href="http://pan.baidu.com/s/1dDoxdIT" target="_blank" rel="noopener">下载</a><br>arm-2007q1-21-arm-none-linux-gnueabi-i686-pc-linux-gnu.tar.bz2 —— <a href="http://pan.baidu.com/s/1zs2PS" target="_blank" rel="noopener">下载</a><br>arm-2007q3-51-arm-none-linux-gnueabi-i686-pc-linux-gnu.tar.bz2 —— <a href="http://pan.baidu.com/s/1hqvc7uW" target="_blank" rel="noopener">下载</a><br>arm-2008q1-126-arm-none-linux-gnueabi-i686-pc-linux-gnu.tar.bz2 —— <a href="http://pan.baidu.com/s/1bn8JSBl" target="_blank" rel="noopener">下载</a><br>arm-2008q3-41-arm-none-linux-gnueabi-i686-pc-linux-gnu.tar.bz2 —— <a href="http://pan.baidu.com/s/1sj8Xr7B" target="_blank" rel="noopener">下载</a><br>arm-2008q3-72-arm-none-linux-gnueabi-i686-pc-linux-gnu.tar.bz2 —— <a href="http://pan.baidu.com/s/1sjDbdk5" target="_blank" rel="noopener">下载</a><br>arm-2009q1-176-arm-none-linux-gnueabi-i686-pc-linux-gnu.tar.bz2 —— <a href="http://pan.baidu.com/s/1eQDx5BW" target="_blank" rel="noopener">下载</a><br>arm-2009q1-203-arm-none-linux-gnueabi-i686-pc-linux-gnu.bz2 —— <a href="http://pan.baidu.com/s/1hq3jZ60" target="_blank" rel="noopener">下载</a><br>arm-2009q3-67-arm-none-linux-gnueabi-i686-pc-linux-gnu.tar.bz2 —— <a href="http://pan.baidu.com/s/1dDEf4nJ" target="_blank" rel="noopener">下载</a><br>arm-2010.09-50-arm-none-linux-gnueabi-i686-pc-linux-gnu.tar.bz2 —— <a href="http://pan.baidu.com/s/1ntv8p7N" target="_blank" rel="noopener">下载</a><br>arm-2010q1-202-arm-none-linux-gnueabi-i686-pc-linux-gnu.tar.bz2 —— <a href="http://pan.baidu.com/s/1jG9R9EA" target="_blank" rel="noopener">下载</a><br>arm-2011.03-41-arm-none-linux-gnueabi-i686-pc-linux-gnu.tar.bz2 —— <a href="http://pan.baidu.com/s/1dD7tU8p" target="_blank" rel="noopener">下载</a><br>arm-2012.09-64-arm-none-linux-gnueabi-i686-pc-linux-gnu.tar.bz2 —— <a href="http://pan.baidu.com/s/1ntA1wI9" target="_blank" rel="noopener">下载</a><br>arm-2013.05-24-arm-none-linux-gnueabi-i686-pc-linux-gnu.tar.bz2 —— <a href="http://pan.baidu.com/s/1i3gNttF" target="_blank" rel="noopener">下载</a><br>arm-2013.11-33-arm-none-linux-gnueabi-i686-pc-linux-gnu.tar.bz2 —— <a href="http://pan.baidu.com/s/1dDkZmoh" target="_blank" rel="noopener">下载</a><br><strong>arm-2014.05-29-arm-none-linux-gnueabi-i686-pc-linux-gnu.tar.bz2</strong> <em>最新~推荐！</em>—— <a href="http://pan.baidu.com/s/1mgyYfos" target="_blank" rel="noopener">下载</a></p>
<h2 id="2-Linux安装版"><a href="#2-Linux安装版" class="headerlink" title="2 Linux安装版"></a>2 Linux安装版</h2><p>arm-2006q3-26-arm-none-linux-gnueabi.bin —— <a href="http://pan.baidu.com/s/1hqKfaAw" target="_blank" rel="noopener">下载</a><br>arm-2007q1-10-arm-none-linux-gnueabi.bin —— <a href="http://pan.baidu.com/s/1bngZ90r" target="_blank" rel="noopener">下载</a><br>arm-2007q1-21-arm-none-linux-gnueabi.bin —— <a href="http://pan.baidu.com/s/1sjFcXUP" target="_blank" rel="noopener">下载</a><br>arm-2007q3-51-arm-none-linux-gnueabi.bin —— <a href="http://pan.baidu.com/s/1o6v6nWm" target="_blank" rel="noopener">下载</a><br>arm-2008q1-126-arm-none-linux-gnueabi.bin —— <a href="http://pan.baidu.com/s/1gd9XC1X" target="_blank" rel="noopener">下载</a><br>arm-2008q3-41-arm-none-linux-gnueabi.bin —— <a href="http://pan.baidu.com/s/1gdf53fP" target="_blank" rel="noopener">下载</a><br>arm-2008q3-72-arm-none-linux-gnueabi.bin —— <a href="http://pan.baidu.com/s/1dDf9BGX" target="_blank" rel="noopener">下载</a><br>arm-2009q1-176-arm-none-linux-gnueabi.bin —— <a href="http://pan.baidu.com/s/1mgqQCDM" target="_blank" rel="noopener">下载</a><br>arm-2009q1-203-arm-none-linux-gnueabi.bin —— <a href="http://pan.baidu.com/s/1c0H5ui0" target="_blank" rel="noopener">下载</a><br>arm-2009q3-67-arm-none-linux-gnueabi.bin —— <a href="http://pan.baidu.com/s/1lLsTo" target="_blank" rel="noopener">下载</a><br>arm-2010.09-50-arm-none-linux-gnueabi.bin —— <a href="http://pan.baidu.com/s/1eQf78KM" target="_blank" rel="noopener">下载</a><br>arm-2010q1-202-arm-none-linux-gnueabi.bin —— <a href="http://pan.baidu.com/s/1qW8tw1e" target="_blank" rel="noopener">下载</a><br>arm-2011.03-41-arm-none-linux-gnueabi.bin —— <a href="http://pan.baidu.com/s/1eQCbBcI" target="_blank" rel="noopener">下载</a><br>arm-2011.09-70-arm-none-linux-gnueabi.bin —— <a href="http://pan.baidu.com/s/1gdDv5rd" target="_blank" rel="noopener">下载</a><br>arm-2012.03-57-arm-none-linux-gnueabi.bin —— <a href="http://pan.baidu.com/s/1gd26ezT" target="_blank" rel="noopener">下载</a><br>arm-2012.09-64-arm-none-linux-gnueabi.bin —— <a href="http://pan.baidu.com/s/1jG2zYUq" target="_blank" rel="noopener">下载</a><br>arm-2013.05-24-arm-none-linux-gnueabi.bin —— <a href="http://pan.baidu.com/s/1eQ7rTmE" target="_blank" rel="noopener">下载</a><br>arm-2013.11-33-arm-none-linux-gnueabi.bin —— <a href="http://pan.baidu.com/s/1gvEt4" target="_blank" rel="noopener">下载</a><br>arm-2014.05-29-arm-none-linux-gnueabi.bin —— <em>最新~</em> <a href="http://pan.baidu.com/s/1o6JmOXG" target="_blank" rel="noopener">下载</a></p>
<h2 id="3-Windows-Mingw32-版"><a href="#3-Windows-Mingw32-版" class="headerlink" title="3 Windows Mingw32 版"></a>3 Windows Mingw32 版</h2><p>gnu-csl-arm-2005Q1B-arm-none-linux-gnueabi-i686-mingw32.tar.bz2 —— <a href="http://pan.baidu.com/s/1kTmOULx" target="_blank" rel="noopener">下载</a><br>arm-2006q3-26-arm-none-linux-gnueabi-i686-mingw32.tar.bz2 —— <a href="http://pan.baidu.com/s/1dDH3rdZ" target="_blank" rel="noopener">下载</a><br>arm-2007q1-10-arm-none-linux-gnueabi-i686-mingw32.tar.bz2 —— <a href="http://pan.baidu.com/s/1bn1YrRx" target="_blank" rel="noopener">下载</a><br>arm-2007q1-21-arm-none-linux-gnueabi-i686-mingw32.tar.bz2 —— <a href="http://pan.baidu.com/s/1pJuOqRT" target="_blank" rel="noopener">下载</a><br>arm-2007q3-51-arm-none-linux-gnueabi-i686-mingw32.tar.bz2 —— <a href="http://pan.baidu.com/s/1pJJQKeZ" target="_blank" rel="noopener">下载</a><br>arm-2008q1-126-arm-none-linux-gnueabi-i686-mingw32.tar.bz2 —— <a href="http://pan.baidu.com/s/1i3KcX6l" target="_blank" rel="noopener">下载</a><br>arm-2008q3-41-arm-none-linux-gnueabi-i686-mingw32.tar.bz2 —— <a href="http://pan.baidu.com/s/1qWLQ84O" target="_blank" rel="noopener">下载</a><br>arm-2008q3-72-arm-none-linux-gnueabi-i686-mingw32.tar.bz2 —— <a href="http://pan.baidu.com/s/1ntHnbXB" target="_blank" rel="noopener">下载</a><br>arm-2009q1-176-arm-none-linux-gnueabi-i686-mingw32.tar.bz2 —— <a href="http://pan.baidu.com/s/1o69d0gU" target="_blank" rel="noopener">下载</a><br>arm-2009q1-203-arm-none-linux-gnueabi-i686-mingw32.tar.bz2 —— <a href="http://pan.baidu.com/s/1eQ1Sjtw" target="_blank" rel="noopener">下载</a><br>arm-2009q3-67-arm-none-linux-gnueabi-i686-mingw32.tar.bz2 —— <a href="http://pan.baidu.com/s/1qWBHlne" target="_blank" rel="noopener">下载</a><br>arm-2010.09-50-arm-none-linux-gnueabi-i686-mingw32.tar.bz2 —— <a href="http://pan.baidu.com/s/1nt0XXNz" target="_blank" rel="noopener">下载</a><br>arm-2010q1-202-arm-none-linux-gnueabi-i686-mingw32.tar.bz2 —— <a href="http://pan.baidu.com/s/1jG85Bym" target="_blank" rel="noopener">下载</a><br>arm-2011.03-41-arm-none-linux-gnueabi-i686-mingw32.tar.bz2 —— <a href="http://pan.baidu.com/s/1jG9lDkE" target="_blank" rel="noopener">下载</a><br>arm-2011.09-70-arm-none-linux-gnueabi-i686-mingw32.tar.bz2 —— <a href="http://pan.baidu.com/s/1sj7B13B" target="_blank" rel="noopener">下载</a><br>arm-2012.03-57-arm-none-linux-gnueabi-i686-mingw32.tar.bz2 —— <a href="http://pan.baidu.com/s/1c0hD47Q" target="_blank" rel="noopener">下载</a><br>arm-2012.09-64-arm-none-linux-gnueabi-i686-mingw32.tar.bz2 —— <a href="http://pan.baidu.com/s/1i3va3wL" target="_blank" rel="noopener">下载</a><br>arm-2013.05-24-arm-none-linux-gnueabi-i686-mingw32.tar.bz2 —— <a href="http://pan.baidu.com/s/1bnCNEaz" target="_blank" rel="noopener">下载</a><br>arm-2013.11-33-arm-none-linux-gnueabi-i686-mingw32.tar.bz2 —— <a href="http://pan.baidu.com/s/1pJ0nUkj" target="_blank" rel="noopener">下载</a><br>arm-2014.05-29-arm-none-linux-gnueabi-i686-mingw32.tar.bz2 —— <em>最新~</em> <a href="http://pan.baidu.com/s/1sj4T7IH" target="_blank" rel="noopener">下载</a></p>
<h2 id="4-Windows安装版"><a href="#4-Windows安装版" class="headerlink" title="4 Windows安装版"></a>4 Windows安装版</h2><p>gnu-csl-arm-2005Q1B-arm-none-linux-gnueabi.exe —— <a href="http://pan.baidu.com/s/1gdxMxWZ" target="_blank" rel="noopener">下载</a><br>arm-2006q1-3-arm-none-linux-gnueabi.exe —— <a href="http://pan.baidu.com/s/1ntqO8MP" target="_blank" rel="noopener">下载</a><br>arm-2006q1-6-arm-none-linux-gnueabi.exe —— <a href="http://pan.baidu.com/s/1pJNo76F" target="_blank" rel="noopener">下载</a><br>arm-2006q3-26-arm-none-linux-gnueabi.exe —— <a href="http://pan.baidu.com/s/1c0vkFM4" target="_blank" rel="noopener">下载</a><br>arm-2007q1-10-arm-none-linux-gnueabi.exe —— <a href="http://pan.baidu.com/s/1mg9N1C8" target="_blank" rel="noopener">下载</a><br>arm-2007q1-21-arm-none-linux-gnueabi.exe —— <a href="http://pan.baidu.com/s/1eQ06tou" target="_blank" rel="noopener">下载</a><br>arm-2007q3-51-arm-none-linux-gnueabi.exe —— <a href="http://pan.baidu.com/s/1sjv0hB3" target="_blank" rel="noopener">下载</a><br>arm-2008q1-126-arm-none-linux-gnueabi.exe —— <a href="http://pan.baidu.com/s/1pJG2VYr" target="_blank" rel="noopener">下载</a><br>arm-2008q3-41-arm-none-linux-gnueabi.exe —— <a href="http://pan.baidu.com/s/1sjjUP9j" target="_blank" rel="noopener">下载</a><br>arm-2008q3-72-arm-none-linux-gnueabi.exe —— <a href="http://pan.baidu.com/s/1eQEd2ee" target="_blank" rel="noopener">下载</a><br>arm-2009q1-176-arm-none-linux-gnueabi.exe —— <a href="http://pan.baidu.com/s/1c07vWVA" target="_blank" rel="noopener">下载</a><br>arm-2009q1-203-arm-none-linux-gnueabi.exe —— <a href="http://pan.baidu.com/s/1gduyCoF" target="_blank" rel="noopener">下载</a><br>arm-2009q3-67-arm-none-linux-gnueabi.exe —— <a href="http://pan.baidu.com/s/1kTkNbpX" target="_blank" rel="noopener">下载</a><br>arm-2010.09-50-arm-none-linux-gnueabi.exe —— <a href="http://pan.baidu.com/s/1bn5whSb" target="_blank" rel="noopener">下载</a><br>arm-2010q1-202-arm-none-linux-gnueabi.exe —— <a href="http://pan.baidu.com/s/1qWHgRfu" target="_blank" rel="noopener">下载</a><br>arm-2011.03-41-arm-none-linux-gnueabi.exe —— <a href="http://pan.baidu.com/s/1o6iFcuu" target="_blank" rel="noopener">下载</a><br>arm-2011.09-70-arm-none-linux-gnueabi.exe —— <a href="http://pan.baidu.com/s/1mgoiMI8" target="_blank" rel="noopener">下载</a><br>arm-2012.03-57-arm-none-linux-gnueabi.exe —— <a href="http://pan.baidu.com/s/1jGBTxNC" target="_blank" rel="noopener">下载</a><br>arm-2012.09-64-arm-none-linux-gnueabi.exe —— <a href="http://pan.baidu.com/s/1jGC9wBs" target="_blank" rel="noopener">下载</a><br>arm-2013.05-24-arm-none-linux-gnueabi.exe —— <a href="http://pan.baidu.com/s/1c0Ilr2o" target="_blank" rel="noopener">下载</a><br>arm-2013.11-33-arm-none-linux-gnueabi.exe —— <a href="http://pan.baidu.com/s/1kTHrdDt" target="_blank" rel="noopener">下载</a><br>arm-2014.05-29-arm-none-linux-gnueabi.exe —— <em>最新~</em> <a href="http://pan.baidu.com/s/1dDviBkP" target="_blank" rel="noopener">下载</a></p>
<h2 id="5-PRM安装版"><a href="#5-PRM安装版" class="headerlink" title="5 PRM安装版"></a>5 PRM安装版</h2><p>arm-arm-none-linux-gnueabi-2007q3-51.i686.rpm —— <a href="http://pan.baidu.com/s/1pJCzoLH" target="_blank" rel="noopener">下载</a></p>
<h2 id="6-源码"><a href="#6-源码" class="headerlink" title="6 源码"></a>6 源码</h2><p>gnu-csl-arm-2005Q1B-arm-none-linux-gnueabi.src.tar.bz2 —— <a href="http://pan.baidu.com/s/1sjM43Dz" target="_blank" rel="noopener">下载</a><br>arm-2006q1-3-arm-none-linux-gnueabi.src.tar.bz2 —— <a href="http://pan.baidu.com/s/1pJDflpx" target="_blank" rel="noopener">下载</a><br>arm-2006q1-6-arm-none-linux-gnueabi.src.tar.bz2 —— <a href="http://pan.baidu.com/s/1o64tHYq" target="_blank" rel="noopener">下载</a><br>arm-2006q3-26-arm-none-linux-gnueabi.src.tar.bz2 —— <a href="http://pan.baidu.com/s/1eQxi2Ro" target="_blank" rel="noopener">下载</a><br>arm-2007q1-10-arm-none-linux-gnueabi.src.tar.bz2 —— <a href="http://pan.baidu.com/s/14ImMa" target="_blank" rel="noopener">下载</a><br>arm-2007q1-21-arm-none-linux-gnueabi.src.tar.bz2 —— <a href="http://pan.baidu.com/s/1nt5HE5b" target="_blank" rel="noopener">下载</a><br>arm-2007q3-51-arm-none-linux-gnueabi.src.tar.bz2 —— <a href="http://pan.baidu.com/s/1o6iFcvC" target="_blank" rel="noopener">下载</a><br>arm-2008q1-126-arm-none-linux-gnueabi.src.tar.bz2 —— <a href="http://pan.baidu.com/s/1sj6V0Jj" target="_blank" rel="noopener">下载</a><br>arm-2008q3-41-arm-none-linux-gnueabi.src.tar.bz2 —— <a href="http://pan.baidu.com/s/1o6Fjdfc" target="_blank" rel="noopener">下载</a><br>arm-2008q3-72-arm-none-linux-gnueabi.src.tar.bz2 —— <a href="http://pan.baidu.com/s/1ntmKPbr" target="_blank" rel="noopener">下载</a><br>arm-2009q1-176-arm-none-linux-gnueabi.src.tar.bz2 —— <a href="http://pan.baidu.com/s/1o69JwxG" target="_blank" rel="noopener">下载</a><br>arm-2009q1-203-arm-none-linux-gnueabi.src.tar.bz2.bz2 —— <a href="http://pan.baidu.com/s/1mgqQCFA" target="_blank" rel="noopener">下载</a><br>arm-2009q3-67-arm-none-linux-gnueabi.src.tar.bz2 —— <a href="http://pan.baidu.com/s/1i3JxaRV" target="_blank" rel="noopener">下载</a><br>arm-2010.09-50-arm-none-linux-gnueabi.src.tar.bz2 —— <a href="http://pan.baidu.com/s/1gd9rIs7" target="_blank" rel="noopener">下载</a><br>arm-2010q1-202-arm-none-linux-gnueabi.src.tar.bz2 —— <a href="http://pan.baidu.com/s/1gdkVlkR" target="_blank" rel="noopener">下载</a><br>arm-2011.03-41-arm-none-linux-gnueabi.src.tar.bz2 —— <a href="http://pan.baidu.com/s/1pJCzoLH" target="_blank" rel="noopener">下载</a><br>arm-2011.09-70-arm-none-linux-gnueabi.src.tar.bz2 —— <a href="http://pan.baidu.com/s/1ntqi9k9" target="_blank" rel="noopener">下载</a><br>arm-2012.03-57-arm-none-linux-gnueabi.src.tar.bz2 —— <a href="http://pan.baidu.com/s/1kT5LIaN" target="_blank" rel="noopener">下载</a><br>arm-2012.09-64-arm-none-linux-gnueabi.src.tar.bz2 —— <a href="http://pan.baidu.com/s/1gwTdG" target="_blank" rel="noopener">下载</a><br>arm-2013.05-24-arm-none-linux-gnueabi.src.tar.bz2 —— <a href="http://pan.baidu.com/s/1hqf4HnQ" target="_blank" rel="noopener">下载</a><br>arm-2013.11-33-arm-none-linux-gnueabi.src.tar.bz2 —— <a href="http://pan.baidu.com/s/1eQAaVh4" target="_blank" rel="noopener">下载</a><br>arm-2014.05-29-arm-none-linux-gnueabi.src.tar.bz2 —— <em>最新~</em> <a href="http://pan.baidu.com/s/1ntFmvjz" target="_blank" rel="noopener">下载</a></p>
<p>Mentor官方下载地址（需要注册，注册之后官方会发送一个下载地址到邮箱里面）：<a href="http://www.mentor.com/embedded-software/sourcery-tools/sourcery-codebench/evaluations/。" target="_blank" rel="noopener">http://www.mentor.com/embedded-software/sourcery-tools/sourcery-codebench/evaluations/。</a></p>
<p><strong>本文为作者原创 转载时请注明出处 谢谢</strong></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em>乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</em></p>
]]></content>
      <tags>
        <tag>交叉编译</tag>
      </tags>
  </entry>
  <entry>
    <title>ARM原生汇编与ARM GNU汇编的区分</title>
    <url>/205.html</url>
    <content><![CDATA[<h2 id="一、ARM汇编开发的两种的方式"><a href="#一、ARM汇编开发的两种的方式" class="headerlink" title="一、ARM汇编开发的两种的方式"></a>一、ARM汇编开发的两种的方式</h2><p>ARM汇编开发指用ARM提供的汇编指令，进行ARM程序的开发。</p>
<p>ARM汇编开发，有两种开发方式，一种是使用ARM汇编，一种是使用ARM GNU汇编。两种汇编开发，使用的汇编指令是完全一样的，区别是宏指令，伪指令，伪操作不一样。其实两种开发方式的区别在于所使用的编译工具不一样。</p>
<p>对于ARM汇编，使用的是ARM公司开发的编译器，而ARM GNU汇编，是使用GNU为ARM指令集开发的编译器，也就是arm-gcc。</p>
<h2 id="二、ARM的编译开发环境"><a href="#二、ARM的编译开发环境" class="headerlink" title="二、ARM的编译开发环境"></a>二、ARM的编译开发环境</h2><p>两种常用的ARM的编译开发环境</p>
<ul>
<li>DS5：ARM提供的集成开发软件。使用的是ARM提供的工具链进行程序编译</li>
<li>GNU开发环境： 由GNU的汇编器as，交叉编译器gcc，和链接器ld等组成</li>
</ul>
<h2 id="三、伪操作，宏指令，伪指令"><a href="#三、伪操作，宏指令，伪指令" class="headerlink" title="三、伪操作，宏指令，伪指令"></a>三、伪操作，宏指令，伪指令</h2><p>伪操作：ARM汇编语言程序里的一些特殊指令助记符，其作用主要是完成汇编程序做各种准备工作，在源程序进行汇编时由汇编程序处理，而不是在计算机运行期间由机器执行。如程序段的定义，就属于伪操作。</p>
<p>宏指令：一段独立的程序代码，可插在源程序中，通过伪操作来定义。</p>
<p>伪指令：ARM汇编语言程序里的一些特殊指令助记符，不在处理器运行期间执行，在汇编时，被合适的ARM的机器指令代替，从而实现真正的指令操作。</p>
<h2 id="四、ARM原生汇编伪操作"><a href="#四、ARM原生汇编伪操作" class="headerlink" title="四、ARM原生汇编伪操作"></a>四、ARM原生汇编伪操作</h2><table>
<thead>
<tr>
<th>伪操作</th>
<th>语法格式</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>GBLA</td>
<td>GBLA  Varible</td>
<td>声明一个全局的算术变量，并将其初始化为0</td>
</tr>
<tr>
<td>GBLL</td>
<td>GBLL  Varible</td>
<td>声明一个全局的逻辑变量，并将其初始化成{FALSE}</td>
</tr>
<tr>
<td>GBLS</td>
<td>GBLS  Varible</td>
<td>声明一个全局的字符串变量，并将其初始化成空串</td>
</tr>
<tr>
<td>LCLA</td>
<td>LCLA  Varible</td>
<td>声明一个局部的算术变量，并将其初始化为0</td>
</tr>
<tr>
<td>LCLL</td>
<td>LCLL  Varible</td>
<td>声明一个局部的逻辑变量，并将其初始化成{FALSE}</td>
</tr>
<tr>
<td>LCLS</td>
<td>LCLS  Varible</td>
<td>声明一个局部的字符串变量，并将其初始化成空串</td>
</tr>
<tr>
<td>SETA</td>
<td>SETA  Varible  expr</td>
<td>给一个全局或局部算术变量赋值</td>
</tr>
<tr>
<td>SETL</td>
<td>SETL  Varible  expr</td>
<td>给一个全局或局部逻辑变量赋值</td>
</tr>
<tr>
<td>SETS</td>
<td>SETS  Varible  expr</td>
<td>给一个全局或局部字符串变量赋值</td>
</tr>
<tr>
<td>RLIST</td>
<td>name LIST {list of registers}</td>
<td>为一个通用寄存器列表定义名称</td>
</tr>
<tr>
<td>CN</td>
<td>name CN expr</td>
<td>为一个协处理器的寄存器定义名称</td>
</tr>
<tr>
<td>CP</td>
<td>name CP expr</td>
<td>为一个协处理器定义名称</td>
</tr>
<tr>
<td>DN/SN</td>
<td>name DN/SN expr</td>
<td>DN/SN为一个双精度/单精度的VFP寄存器定义名称</td>
</tr>
<tr>
<td>FN</td>
<td>name FN  expr</td>
<td>为一个FPA浮点寄存器定义名称</td>
</tr>
<tr>
<td>LTORG</td>
<td>LTONG</td>
<td>声明一个数据缓冲池（文字池）的开始</td>
</tr>
<tr>
<td>MAP</td>
<td>MAP expr {, base-register}</td>
<td>定义一个结构化的内存表(storage map)的首地址</td>
</tr>
<tr>
<td>FIELD</td>
<td>{label}  FIELF  expr</td>
<td>定义一个结构化内存表中的数据域</td>
</tr>
<tr>
<td>SPACE</td>
<td>{label}  SPACE  expr</td>
<td>分配一块连续内存单元，并用0初始化</td>
</tr>
<tr>
<td>DCB</td>
<td>{label}  DCB  expr {,expr}..</td>
<td>分配一块字节内存单元，并用expr初始化</td>
</tr>
<tr>
<td>DCD/ DCDU</td>
<td>{label} DCD/DCDU expr {,expr}…</td>
<td>分配一块字内存单元， 并用expr初始化</td>
</tr>
<tr>
<td>DCDO</td>
<td>{label}  DCDO  expr {,expr}…</td>
<td>分配一块字对齐的字内存单元， 并用expr初始化</td>
</tr>
<tr>
<td>DCFD/DCFDU</td>
<td>{label}  DCFD{U}  fpliteral ,{,fpliteral}…</td>
<td>为双精度的浮点数分配字对齐的内存单元</td>
</tr>
<tr>
<td>DCFS/DCFSU</td>
<td>{label}   DCFS{U}  fpliteral,{,fpliteral}…</td>
<td>为单精度的浮点数分配字对齐的内存单元</td>
</tr>
<tr>
<td>DCI</td>
<td>{label} DCI expr, {expr}…</td>
<td>ARM代码分配一段字对齐的内存单元，填充expr（二进制指令码），THUMB代码中，分配一段半字对齐的半字内存单元。</td>
</tr>
<tr>
<td>DCQ/ DCQU</td>
<td>{label} DCQ{U}  {-} literal, {, {-} literal}…</td>
<td>分配一段以双字（8个字节）为单位的内存</td>
</tr>
<tr>
<td>DCW/DCWU</td>
<td>{label} DCW{U}  {-} literal, {, {-} literal}…</td>
<td>DCW用于分配一段半字对齐的半字内存单元</td>
</tr>
</tbody></table>
<h3 id="1、AREA"><a href="#1、AREA" class="headerlink" title="1、AREA"></a>1、AREA</h3><p>创建一段新的程序代码或数据区。</p>
<p>格式 ： </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">AREA  name, &#123;,attr,&#125; …</span><br></pre></td></tr></table></figure>

<p>其中，name是程序段名， atrr是段名属性</p>
<p>对于属性，有以下一些：</p>
<ul>
<li>CODE： 用于定义代码段，默认为是READONLY</li>
<li>DATA： 用于定于数据段，默认为READWRITE</li>
<li>READONLY: 指定本段的内容只读</li>
<li>READWRITE：  指定本段的内容可读可写</li>
<li>ALIGN:  指定对齐为2次幂</li>
<li>COMMON: 定义通用的段。不包含任何用户的代码和数据。各源文件中同名的COMMON属性段共享同一段存储单元</li>
</ul>
<h3 id="2、ALIGN"><a href="#2、ALIGN" class="headerlink" title="2、ALIGN"></a>2、ALIGN</h3><p>指定对齐</p>
<p>  ALIGN  4  表示4字节地址对齐</p>
<p>  ALIGN  8  表示8字节地址对齐</p>
<p>  注意：在AREA中使用和单独使用ALIGN的区别，在于格式和对齐的计算不一样。</p>
<h3 id="3、ENTRY"><a href="#3、ENTRY" class="headerlink" title="3、ENTRY"></a>3、ENTRY</h3><p>指定汇编程序的入口。</p>
<p>一个程序至少有一个入口点，也可以有多个入口点，但是在一个源文件中，最多只能有一个ENTRY。当多个源文件均有ENTRY时，由链接器指定程序真正的入口。</p>
<h3 id="4、END"><a href="#4、END" class="headerlink" title="4、END"></a>4、END</h3><p>表示源程序的结束</p>
<p>所以汇编语言源文件必须以END结束，汇编器遇到END, 将结束编译。</p>
<h3 id="5、EXPORT"><a href="#5、EXPORT" class="headerlink" title="5、EXPORT"></a>5、EXPORT</h3><p>格式：　EXPORT  标号  [,WEAK]</p>
<p>声明一个全局标号，其他源文件可以使用这个标号。WEAK表示碰上其他同名标号时，其他标号优先。</p>
<h3 id="6、IMPORT"><a href="#6、IMPORT" class="headerlink" title="6、IMPORT"></a>6、IMPORT</h3><p>格式:  IMPORT 标号，[,WEAK]</p>
<p>表示该引用的标号在其他源文件中，单要在当前文件中引用。WEAK表示找不到该标号时，也不报错，一般该标号置为0，如果是B 或BL指令用到该标号，该指令置为nop。</p>
<p>该标号会加入到当前源文件的符号表中。</p>
<h3 id="7、EXTERN"><a href="#7、EXTERN" class="headerlink" title="7、EXTERN"></a>7、EXTERN</h3><p>和IMPORT一样，不同在于，如果当前文件没有引用该标号，该标号不会加入到当前源文件的符号表中。</p>
<h3 id="8、GET-或INCLUDE"><a href="#8、GET-或INCLUDE" class="headerlink" title="8、GET(或INCLUDE)"></a>8、GET(或INCLUDE)</h3><p>将一个源文件含到当前的源文件中</p>
<h3 id="9、EQU"><a href="#9、EQU" class="headerlink" title="9、EQU"></a>9、EQU</h3><p>对一个常量标号赋值</p>
<p>格式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">name  EQU  expression</span><br></pre></td></tr></table></figure>

<p>其中： name符号名， expression寄存器相关或者程序相关的固定值</p>
<p>如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">num  EQU  2  ;  为符号赋予数字2</span><br></pre></td></tr></table></figure>

<p>EQU，等同于C语言中用#define定义一个常量</p>
<h3 id="10、SPCAE"><a href="#10、SPCAE" class="headerlink" title="10、SPCAE"></a>10、SPCAE</h3><p>用于分配一片连续内存单元，并用0初始化。SPACE可用%代替。</p>
<p>格式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;label&#125; SPACE expr</span><br></pre></td></tr></table></figure>

<p>label ： 是一个标号, 可选</p>
<p>expr：  分配的内存字节数</p>
<p>如</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">stack SPACE 100 ； 分配100个字节内存单元，并用0初始化。标号stack是这片空间的起始地址</span><br></pre></td></tr></table></figure>

<h3 id="11、DCB"><a href="#11、DCB" class="headerlink" title="11、DCB"></a>11、DCB</h3><p>用于分配段字节内存单元，并用伪操作中的expr初始化。</p>
<p>格式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;label&#125; DCB expr &#123;,expr&#125;</span><br></pre></td></tr></table></figure>

<p>label： 是一个标号，可选</p>
<p>expr： 可以是-128~255的数值或者字符串</p>
<p>如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">string  DCB  &quot;HELLO&quot;  ;为HELLO字符串分配空间， string是这块空间的起始地址</span><br></pre></td></tr></table></figure>

<h3 id="12、DCD及DCDU"><a href="#12、DCD及DCDU" class="headerlink" title="12、DCD及DCDU"></a>12、DCD及DCDU</h3><p>用于分配段字内存单元（分配的内存都是字对齐，DCDU并不严格字对齐），并用伪操作中的expr初始化。 DCD 可用 &amp; 代替。</p>
<p>格式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;label&#125; DCD expr, &#123;,expr&#125;</span><br></pre></td></tr></table></figure>

<p>label: 是一个标号，可选，表示这块内存单元的首地址</p>
<p>expr： 数字表达式或程序中的标号</p>
<p>如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">data DCD  1,2,3,4   ;分配字对齐的字单元空间，初始化为1，2，3，4</span><br></pre></td></tr></table></figure>

<h2 id="五、ARM原生汇编伪指令"><a href="#五、ARM原生汇编伪指令" class="headerlink" title="五、ARM原生汇编伪指令"></a>五、ARM原生汇编伪指令</h2><p>ARM伪指令包括： ADR, ADRL,LDR ,NOP</p>
<p>THUMB伪指令包括：ADR, LDR, NOP</p>
<table>
<thead>
<tr>
<th>伪指令</th>
<th>语法格式</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>ADR</td>
<td>ADR{cond} register, expr</td>
<td>将基于PC或基于寄存器的地址值读取到寄存器中。小范围的地址读取</td>
</tr>
<tr>
<td>ADRL</td>
<td>ADRL{cond} register, expr</td>
<td>将给予PC或基于寄存器的地址值读取到寄存器中。中等范围的地址读取</td>
</tr>
<tr>
<td>LDR</td>
<td>LDR {cond} register, =[expr|label]</td>
<td>将一个32位的立即数或者一个地址值读取到寄存器中。大范围的地址读取</td>
</tr>
<tr>
<td>NON</td>
<td>NOP</td>
<td>在汇编时，被替换成空操作</td>
</tr>
</tbody></table>
<h2 id="六、ARM-GNU编译环境"><a href="#六、ARM-GNU编译环境" class="headerlink" title="六、ARM GNU编译环境"></a>六、ARM GNU编译环境</h2><table>
<thead>
<tr>
<th>伪操作</th>
<th>语法格式</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>.byte</td>
<td>.byte expr {,expr}…</td>
<td>分配一段字节内存单元，并用expr初始化</td>
</tr>
<tr>
<td>.hword/.short</td>
<td>.hword expr {,expr}…</td>
<td>分配一段半字内存单元，并用expr初始化</td>
</tr>
<tr>
<td>.ascii</td>
<td>.ascii expr {,expr}…</td>
<td>定义字符串expr</td>
</tr>
<tr>
<td>.asciz/.string</td>
<td>.asciz expr {,expr}…</td>
<td>定义字符串expr（会增加/0为结束符）</td>
</tr>
<tr>
<td>.floar/.single</td>
<td>.float expr {,expr}…</td>
<td>定义32bit IEEE浮点数expr</td>
</tr>
<tr>
<td>.double</td>
<td>.doubel expr {,expr}…</td>
<td>定义64bit IEEE浮点数expr</td>
</tr>
<tr>
<td>.word/.long/.int</td>
<td>.word expr {,expr}…</td>
<td>分配一段字内存单元，并用expr初始化</td>
</tr>
<tr>
<td>.fill</td>
<td>.fill  repeat {,size} {,value}</td>
<td>分配一段字节内存单元，用sieze长度value填充repeat次</td>
</tr>
<tr>
<td>.zero</td>
<td>.zero size</td>
<td>分配一段字节内存单元，并用0填充内存</td>
</tr>
<tr>
<td>.space/.skip</td>
<td>.space size, {,value}</td>
<td>分配一段内存单元，用value将内存初始化</td>
</tr>
<tr>
<td>.section</td>
<td>.section expr</td>
<td>定义一个段</td>
</tr>
<tr>
<td>.text</td>
<td>.text {subsection}</td>
<td>代码段，</td>
</tr>
<tr>
<td>.data</td>
<td>.data{subsection}</td>
<td>数据段</td>
</tr>
<tr>
<td>.bss</td>
<td>.bss{subsection}</td>
<td>bss段</td>
</tr>
<tr>
<td>.cond 16/.thumb</td>
<td>.code 16/.thumb</td>
<td>表示之后的汇编指令使用THUMB指令集</td>
</tr>
<tr>
<td>.code 32/.arm</td>
<td>.code 32/.arm</td>
<td>表示之后的汇编指令使用ARM指令集</td>
</tr>
<tr>
<td>.end</td>
<td>.end</td>
<td>标记汇编文件的结束</td>
</tr>
<tr>
<td>.include</td>
<td>.include “filename”</td>
<td>将一个源文件包含到当前源文件中</td>
</tr>
<tr>
<td>.align/.balign</td>
<td>.align {alignment} {,fill},{max}</td>
<td>通过填充字节使当前位置满足一定的对齐格式</td>
</tr>
</tbody></table>
<h2 id="七、两种开发环境的区别"><a href="#七、两种开发环境的区别" class="headerlink" title="七、两种开发环境的区别"></a>七、两种开发环境的区别</h2><p>两种开发环境下的汇编代码，有较多不同的点，主要是符号及伪操作的不同。</p>
<table>
<thead>
<tr>
<th>ARM汇编的伪操作符</th>
<th>GNU汇编的伪操作符</th>
</tr>
</thead>
<tbody><tr>
<td>INLCUDE</td>
<td>.include</td>
</tr>
<tr>
<td>NUM   EQU  25</td>
<td>.equ  NUM,  25</td>
</tr>
<tr>
<td>EXPORT</td>
<td>.global</td>
</tr>
<tr>
<td>IMPORT</td>
<td>.extern</td>
</tr>
<tr>
<td>DCD</td>
<td>.long</td>
</tr>
<tr>
<td>IF:  DEF:</td>
<td>.ifdef</td>
</tr>
<tr>
<td>ELSE</td>
<td>.else</td>
</tr>
<tr>
<td>ENDIF</td>
<td>.endif</td>
</tr>
<tr>
<td>OR</td>
<td>|</td>
</tr>
<tr>
<td>SHL</td>
<td>&lt;&lt;</td>
</tr>
<tr>
<td>RN</td>
<td>.req</td>
</tr>
<tr>
<td>GBLA</td>
<td>.global</td>
</tr>
<tr>
<td>NUM  SETA 16</td>
<td>.equ  NUM , 16</td>
</tr>
<tr>
<td>MACRO</td>
<td>.macro</td>
</tr>
<tr>
<td>MEND</td>
<td>.endm</td>
</tr>
<tr>
<td>END</td>
<td>.end</td>
</tr>
<tr>
<td>AREA WORD, CODE, READONLY</td>
<td>.text</td>
</tr>
<tr>
<td>AREA BLOCK, DATE, READWRITE</td>
<td>.data</td>
</tr>
<tr>
<td>CODE32</td>
<td>.arm</td>
</tr>
<tr>
<td>CODE16</td>
<td>.thumb</td>
</tr>
<tr>
<td>LTORG</td>
<td>.ltorg</td>
</tr>
<tr>
<td>%</td>
<td>.fill</td>
</tr>
<tr>
<td>ENTRY</td>
<td>ENTRY:</td>
</tr>
<tr>
<td>ldr x0,=0xff</td>
<td>ldr x0,=0xff</td>
</tr>
</tbody></table>
<p><strong>本文为作者原创 转载时请注明出处 谢谢</strong></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em>乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</em></p>
]]></content>
      <tags>
        <tag>汇编</tag>
      </tags>
  </entry>
  <entry>
    <title>汇编语言之ARM32汇编</title>
    <url>/204.html</url>
    <content><![CDATA[<h2 id="ARM两种编译环境"><a href="#ARM两种编译环境" class="headerlink" title="ARM两种编译环境"></a>ARM两种编译环境</h2><p>两种常用的ARM的编译开发环境</p>
<ul>
<li>ARM原生编译环境：ARM官方提供的原生编译环境,相关集成开发软件有ADS,Keil等,常用于ARM单片机开发</li>
<li>GNU编译环境： 由GNU的汇编器as,交叉编译器gcc,和链接器ld等组成,一般适用于交叉编译环境需求 </li>
</ul>
<p>以上两种编译环境,使用的指令集都是一致的, 只是语法格式有不同,也就是宏指令,伪指令,伪操作不一样</p>
<h2 id="ARM原生环境搭建"><a href="#ARM原生环境搭建" class="headerlink" title="ARM原生环境搭建"></a>ARM原生环境搭建</h2><p>使用 Keil μVision5 这款软件进行ARM32的汇编学习</p>
<p>下载地址:<a href="http://www.mcuzone.com/down/Software.asp?ID=10000503" target="_blank" rel="noopener">http://www.mcuzone.com/down/Software.asp?ID=10000503</a></p>
<h2 id="ARM32系列命名"><a href="#ARM32系列命名" class="headerlink" title="ARM32系列命名"></a>ARM32系列命名</h2><table>
<thead>
<tr>
<th align="center">ARM产品</th>
<th align="center">ARM架构</th>
</tr>
</thead>
<tbody><tr>
<td align="center">ARM7</td>
<td align="center">ARM v4</td>
</tr>
<tr>
<td align="center">ARM9</td>
<td align="center">ARM v5</td>
</tr>
<tr>
<td align="center">ARM11</td>
<td align="center">ARM v6</td>
</tr>
<tr>
<td align="center">Cortex-A</td>
<td align="center">ARM v7-A</td>
</tr>
<tr>
<td align="center">Cortex-R</td>
<td align="center">ARM v7-R</td>
</tr>
<tr>
<td align="center">Cortex-M</td>
<td align="center">ARM v7-M</td>
</tr>
</tbody></table>
<h2 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h2><p>在ARM32中一共有37个寄存器,其中包含16个通用寄存器(R0~R15)和1个状态寄存器 ,15个通用影子寄存器,5个状态影子寄存器</p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20210105183952.png" alt></p>
<h4 id="影子寄存器"><a href="#影子寄存器" class="headerlink" title="影子寄存器"></a>影子寄存器</h4><p>如上图所示,在ARM32中一共有7中不同的处理器模式,分别为:<strong>用户模式</strong>（User）,<strong>快速中断模式</strong>（FIQ）,<strong>普通中断模式</strong>（IRQ）,<strong>管理模式</strong>（Svc）,<strong>数据访问中止模式</strong>（Abort）,<strong>未定义指令中止模式</strong>（Und）,<strong>系统模式</strong>（Sys)</p>
<p> 但是在不同的模式下,同样的一个寄存器名称指向不同的物理寄存器,这些不同的物理寄存器就被称之为影子寄存器</p>
<p>由于这些影子寄存器也属于通用寄存器的范畴, <strong>因此很多人也将ARM32的通用寄存器归纳为31个</strong> </p>
<h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><ol>
<li><p>注释(两种方式)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">; 我是注释</span><br><span class="line"></span><br><span class="line">/*…我是注释..*/</span><br></pre></td></tr></table></figure>
</li>
<li><p>声明一个代码段</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> 	AREA test, CODE	 ;声明一个代码段,段的名称为test(名称可自定义),CODE关键字大小写都可,为了区分,一般大写</span><br><span class="line">   </span><br><span class="line">;=========在此编写汇编代码==========</span><br><span class="line"></span><br><span class="line">   END			;END表示编译结束标记</span><br><span class="line">   </span><br><span class="line">   </span><br><span class="line">   ;段的声明需要以制表符开头,前面留出空</span><br></pre></td></tr></table></figure>
</li>
<li><p>数据表示</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mov R0,#13 ;将十进制13赋值给R0寄存器</span><br><span class="line"></span><br><span class="line">mov R0,#0x13 ;将十六进制0x13赋值给R0寄存器</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">mov R0,#8_12 ;将8进制数12赋值给R0寄存器  N进制则为#N_xxx</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">mov R0,#&apos;a&apos; ;将字符a对应的ascii码值传送给R0寄存器</span><br></pre></td></tr></table></figure>
</li>
<li><p>函数声明和调用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  	AREA test, CODE</span><br><span class="line">  	</span><br><span class="line">  	</span><br><span class="line">	bl print ;函数调用 </span><br><span class="line"></span><br><span class="line">print ;函数名称</span><br><span class="line">	mov R3,#5</span><br><span class="line"> 	bx lr</span><br><span class="line">    END			;END表示编译结束标记</span><br></pre></td></tr></table></figure>


</li>
</ol>
<ol start="5">
<li><p>声明一个数据段</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">AREA da, DATA	 ;声明一个数据段 默认可读可写状态</span><br><span class="line"> 	;数据定义伪操作</span><br></pre></td></tr></table></figure>


</li>
</ol>
<ol start="6">
<li><p>数据定义</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># DCB   </span><br><span class="line">Str DCB &quot;This is a test！&quot; ;分配一片连续的字节存储单元并初始化。取名为Str 类似于8086中的db</span><br><span class="line">Str = &quot;This is a test！&quot;   ;DCB也可用等号代替</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#DCW</span><br><span class="line">Str DCW 1,2,3 ;定义字型数据 每个字符占用2个字节的空间</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#DCD</span><br><span class="line">Str DCD 1,2,3 ;定义半字型数据 每个字符占用4个字节的空间</span><br></pre></td></tr></table></figure>

<blockquote>
<p>字符串必须使用DCB进行定义</p>
</blockquote>
</li>
<li><p>分配一块连续的内存空间</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sp1 SPACE 100 ;分配一块连续100个字节的空间</span><br><span class="line">   </span><br><span class="line">   ;或者使用%代替SPACE简写</span><br><span class="line">   sp1 % 100 ;分配一块连续100个字节的空间</span><br></pre></td></tr></table></figure>






</li>
</ol>
<h2 id="代码编写规范"><a href="#代码编写规范" class="headerlink" title="代码编写规范"></a>代码编写规范</h2><ol>
<li>所有指令和伪指令不允许顶格</li>
<li>所有变量和标签必须顶格</li>
<li>一般我们将伪指令大写,变量和标签小写</li>
</ol>
<h2 id="内存数据的读写"><a href="#内存数据的读写" class="headerlink" title="内存数据的读写"></a>内存数据的读写</h2><ol>
<li><p>从内存中读取数据</p>
<p><strong>使用中括号表示通过地址取值</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">LDR R0,[R1]               ;将内存地址为R1的字数据读入寄存器R0。</span><br><span class="line">LDR R0,[R1,R2]       ;将内存地址为R1+R2的字数据读入寄存器R0。</span><br><span class="line"></span><br><span class="line">LDR R0,[R1,#8]        ;将内存地址为R1+8的字数据读入寄存器R0。</span><br><span class="line">LDR R0,[R1,R2]!    ;将内存地址为R1+R2的字数据读入寄存器R0,并将新地 址R1＋R2写入R1。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">LDR R0,[R1,＃8]!   ;将内存地址为R1+8的字数据读入寄存器R0,并将新地址 R1＋8写入R1。</span><br><span class="line"></span><br><span class="line">LDR R0,[R1],R2        ;将内存地址为R1的字数据读入寄存器R0,并将新地址 R1＋R2写入R1。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">LDR R0,[R1,R2,LSL＃2]!   ;将内存地址为R1＋R2×4的字数据读入寄存器R0,并将新地址R1＋R2×4写入R1。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">LDR R0,[R1],R2,LSL＃2      ;将内存地址为R1的字数据读入 寄存器R0,并将新地址R1＋R2×4写入R1。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">;从标号即为地址</span><br><span class="line">   LDR R0,label ;将标号对应的内容赋值给R0</span><br></pre></td></tr></table></figure>

</li>
</ol>
<blockquote>
<p>复杂格式如LDR R0,[R1],R2,LSL＃2    其中 []运算优先<br>2. 向内存中写入数据<br>   <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">STR R0,[R1],＃8           ;将R0中的字数据写入以R1为地址的内存中,并 将新地址R1＋8写入R1。</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> STR R0,[R1,＃8]          ;将R0中的字数据写入以R1＋8为地址的内存中。</span><br><span class="line"> </span><br><span class="line"> STRB    R0,[R1]             ;将寄存器R0中的字节数据写入以R1为地 址的内存中。</span><br><span class="line"> STRB    R0,[R1,＃8]     ;将寄存器R0中的字节数据写入以R1＋8为地址的存 储器中。  </span><br><span class="line"> STR R0,[R1],＃8           ;将R0中的字数据写入以R1为地址的内存中,并 将新地址R1＋8写入R1。</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> STR R0,[R1,＃8]          ;将R0中的字数据写入以R1＋8为地址的内存中。</span><br><span class="line"> </span><br><span class="line"> STRB    R0,[R1]             ;将寄存器R0中的字节数据写入以R1为地 址的内存中。</span><br><span class="line"> STRB    R0,[R1,＃8]     ;将寄存器R0中的字节数据写入以R1＋8为地址的存 储器中。</span><br></pre></td></tr></table></figure></p>
</blockquote>
<h2 id="LDR伪指令"><a href="#LDR伪指令" class="headerlink" title="LDR伪指令"></a>LDR伪指令</h2><p>这个指令和内存读取指令长的一模一样,如果我们在使用的时候加个等号,那么它就是另外一个指令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">;如果不加等号 是内存读取功能</span><br><span class="line">LDR R0,label ;获取标签所对应的内存数据赋给R0  </span><br><span class="line"></span><br><span class="line">;一旦加了等号,则变成了传送指令</span><br><span class="line">LDR R0,=label ;将标号对应的实际物理地址值赋值给R0 此时它的作用和mov无异</span><br><span class="line">LDR R0,=&apos;a&apos; ;直接将字符数据传送给R0</span><br></pre></td></tr></table></figure>

<p>实际上,加了等号的<code>LDR</code>指令,刚好可以弥补<code>mov</code>指令的不足, <code>mov</code>指令只能传送由八个二进制位右移而得的数据,而<code>LDR</code>则没有这个限制</p>
<p>也就是说如果我们想将一个数值传入寄存器,可以有两种方式:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">;第一种</span><br><span class="line">mov R1,#0X100</span><br><span class="line"></span><br><span class="line">;第二种</span><br><span class="line">ldr R1,=0x100 </span><br><span class="line"></span><br><span class="line">;mov指令的限制:只能传送由八个二进制位右移而得的数据, 也就相当于是两个十六进制数据,由于可以不断移位那么数据的大小可以伸缩,比如以下数据都可使用mov指令</span><br><span class="line">0x00000058  0x00000580 0x00005800  0x00058000 0x00580000 0x05800000 0x58000000 </span><br><span class="line">;我们发现一个规律:mov指令只能传送最大两个十六进制空间的数据,注意是空间,这两个数据随意你移动,一旦不满足这个条件则无法传送,比如</span><br><span class="line">0x00000581</span><br></pre></td></tr></table></figure>

<h4 id="LDR伪指令总结"><a href="#LDR伪指令总结" class="headerlink" title="LDR伪指令总结"></a>LDR伪指令总结</h4><p>作用:</p>
<ul>
<li>弥补mov指令的不足</li>
<li>获取数据所对应的内存地址</li>
</ul>
<h4 id="ADR指令"><a href="#ADR指令" class="headerlink" title="ADR指令"></a>ADR指令</h4><p>那么除了通过<code>LDR</code>伪指令来获取数据所在地址外还有一个指令也可以获取数据地址,那就是<code>adr</code>指令,但这个指令只能获取当前段内数据的地址,段外数据无法获取,<code>ldr</code>则没有这个限制</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">	AREA test2,CODE</span><br><span class="line">		mov R3,#8</span><br><span class="line">aaaa dcb 1,2,3</span><br><span class="line">		adr R0,aaaa ;获取aaaa首地址</span><br><span class="line">  	END</span><br></pre></td></tr></table></figure>

<h2 id="段的拓展"><a href="#段的拓展" class="headerlink" title="段的拓展"></a>段的拓展</h2><p> <strong>段属性拓展</strong></p>
<ol>
<li><strong>段读写属性</strong></li>
</ol>
<ul>
<li><p>READONLY</p>
<p>该段内存区域数据只能读取,不能写入,也就是如果使用内存读写指令,数据也写入不了</p>
</li>
<li><p>READWRITE</p>
<p>该段内存区域可读可写,不仅可以使用内存读写指令,还可以在调试的时候直接在memory窗口双击修改</p>
</li>
</ul>
<p>示例:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">AREA code, CODE,READWRITE ;将代码段内存区域设置为可读可写状态,如果不写默认为只读</span><br><span class="line">AREA code, DATA,READONLY ;将数据段内存区域设置为只读状态,如果不写默认为可读可写</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p><strong>段对齐属性 ALIGN</strong> </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">AREA code, DATA,ALIGN=3  ;对齐数值范围为0~31</span><br></pre></td></tr></table></figure>

<p>该属性会使得该段的基地址进行相应的偏移,<code>ALIGN=3</code>表示基地址会在上一个段数据的基础之上偏移2^3=8个字节的位置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">   	 AREA test1,DATA  ;假设这个段的基地址为0x00000100</span><br><span class="line">STR1 = &quot;A&quot;  </span><br><span class="line"></span><br><span class="line">	 AREA test2,DATA   ;ALIGN默认为2 那么这个段的基地址为0x00000104</span><br><span class="line">STR2 = &quot;B&quot;</span><br><span class="line"></span><br><span class="line">	 AREA test3,DATA,ALIGN=8   ;这个段的基地址为0x0000010C</span><br><span class="line">STR2 = &quot;B&quot;</span><br></pre></td></tr></table></figure>

<p>我们可以简单理解为,使用ALIGN这个属性可以让我们给上一个段预留除一部分缓冲区域,以ALIGN=2为例,当上一个段中的数据超过4个字节时,当前段基地器会向后再偏移4个字节,避免数据被覆盖,也就是说内存数据位置会进行重新分布,那么我们可以通过这个值来设置内存数据刷新频率,<strong>值越低,内存利用率越高,但是内存刷新频率也越高,负荷加重,反之,内存浪费越大,但是内存数据不需要频繁重新分布</strong></p>
<p><strong>另外:</strong></p>
<p>除了在段属性中可以设置对齐之外,在指令中也可以插入ALGIN关键字:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">AREA code,CODE	   </span><br><span class="line">   </span><br><span class="line">   mov R0,R1</span><br><span class="line"></span><br><span class="line">	ALIGN 4,3  ;下一条指令4字节对齐,并且偏移3个字节 为了补满4个字节,用0填充剩余1个未偏移位置</span><br><span class="line">	mov R2,R0</span><br><span class="line">   </span><br><span class="line">END</span><br></pre></td></tr></table></figure>


</li>
</ol>
<p>   代码中使用AGLIN时用空格代替等号,同时单位为字节</p>
<p><strong>多个代码段入口区分</strong></p>
<p>当我们在同一个源文件中定义两个代码段时,程序从哪个段当做执行入口呢?</p>
<p>这个时候我们需要指定程序的入口,使用伪指令<code>entry</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> AREA test2,CODE </span><br><span class="line"></span><br><span class="line"> 	 	mov R0,#7</span><br><span class="line"></span><br><span class="line">  AREA test3,CODE </span><br><span class="line">entry  ;程序入口</span><br><span class="line">mov R0,#6</span><br><span class="line">mov R1,#0x00000100</span><br><span class="line">str R0,[R1]</span><br><span class="line">END</span><br></pre></td></tr></table></figure>

<h2 id="栈的操作"><a href="#栈的操作" class="headerlink" title="栈的操作"></a>栈的操作</h2><ol>
<li><strong>入栈</strong></li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">push &#123;R0&#125;  ;将R0中的值存入栈内存中  相当于是STR R0,[R13,#-4]</span><br><span class="line"></span><br><span class="line">入栈过程:</span><br><span class="line">* 第一步:将栈顶指针往低地址偏移四个字节</span><br><span class="line">* 第二步:将数据存入指针指向的内存空间</span><br></pre></td></tr></table></figure>

<ol>
<li><strong>出栈</strong></li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pop &#123;R0&#125;  ;将栈顶中的值取出存入R0寄存器 相当于是LDR R0,[R13],#0x0004</span><br><span class="line"></span><br><span class="line">出栈过程:</span><br><span class="line">* 第一步:将栈顶指针指向的内容取出存入寄存器</span><br><span class="line">* 第二步:将指针往高地址恢复四个字节</span><br></pre></td></tr></table></figure>

<blockquote>
<p>pop和push 本质上使用的是LDR和STR内存读写指令</p>
</blockquote>
<h4 id="对栈批量操作"><a href="#对栈批量操作" class="headerlink" title="对栈批量操作"></a>对栈批量操作</h4><p>如果想批量操作多个连续栈空间的话,直接使用逗号分隔开,连续标号的寄存器使用横杠分隔</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">push &#123;R0,R4-R12,LR&#125; ;大括号中寄存器从右往左LR R12...R4 R0依次存入</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">pop &#123;R0,R4-R12,PC&#125; ;从左往右取出</span><br></pre></td></tr></table></figure>

<p>除了使用<code>pop</code>和<code>push</code>之外,可以使用<code>STM</code>(store much)和<code>LDM</code>(load much)指令</p>
<p>格式:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">STM 起始地址/基地址寄存器,&#123;寄存器名称,多个寄存器以逗号或者-分割&#125; ;起始地址寄存器R0-R14任意选择</span><br></pre></td></tr></table></figure>

<p>示例:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">STMFD  R13!,&#123;R0,R4-R12,LR&#125;    ;将寄存器列表中的寄存器（R0,R4到 R12,LR）存入栈,。</span><br><span class="line">等价于</span><br><span class="line">push &#123;R0,R4-R12,LR&#125; ;大括号中寄存器从右往左存入</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">LDMFD  R13!,&#123;R0,R4-R12,PC&#125;     ;将栈内容恢复到寄存器（R0,R4到R12,LR）。           </span><br><span class="line">等价于</span><br><span class="line">pop &#123;R0,R4-R12,PC&#125; ;从左往右取出</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>pop</code>和<code>push</code>,它们内部也是转成<code>STM</code>和<code>LDM</code>指令:</p>
</blockquote>
<h4 id="批量存取指令扩展"><a href="#批量存取指令扩展" class="headerlink" title="批量存取指令扩展"></a>批量存取指令扩展</h4><p>相关后缀含义:</p>
<ul>
<li><strong>IA:（Increase After）</strong>:数据操作后基地址增4</li>
<li><strong>IB:（Increase Before）</strong>:数据操作前基地址增4</li>
<li><strong>DA:（Decrease After</strong>）:数据操作后基地址减4</li>
<li><strong>DB：（Decrease Before）</strong>:数据操作前基地址减4</li>
<li><strong>FD:</strong>  满递减堆栈 (相当于STMDB+LDMIA)</li>
<li><strong>FA:</strong>  满递增堆栈 (相当于STMIB+LDMDA)</li>
<li><strong>ED:</strong>  空递减堆栈(相当于STMDA+LDMIB)</li>
<li><strong>EA:</strong>  空递增堆栈 (相当于STMIA+LDMDB)</li>
</ul>
<blockquote>
<p>我们在使用的时候,要么使用结合的形式比如STMDB+LDMIA,要么直接使用封装形式比如STMFD+LDMFD</p>
</blockquote>
<h4 id="满栈和空栈"><a href="#满栈和空栈" class="headerlink" title="满栈和空栈"></a>满栈和空栈</h4><p>栈的生长方式可以有四种: <strong>满增栈、满减栈、空增栈、空减栈</strong> </p>
<ul>
<li><strong>满栈（full stack）</strong>：栈指针指向下一个将要取出数据的位置,数据入栈时,栈顶指针先偏移再入栈,数据出栈是,先取数据,后指针偏移。</li>
<li><strong>空栈（empty stack）</strong>：栈指针指向下一个将要放入数据的位置,数据入栈时,先存数据后指针偏移,数据出栈时,先指针偏移,后数据取出</li>
<li><strong>递增堆栈(ascending stack)</strong>：堆栈由低地址向高地址生长。</li>
<li><strong>递减堆栈(secending stack)</strong>：堆栈由高地址向低地址生长。</li>
</ul>
<blockquote>
<p>X86和mips架构都是采用满递减堆栈方式处理栈空间,ARM架构四种方式均支持</p>
</blockquote>
<p><strong>内存批量读写示例:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mov  R1,#4</span><br><span class="line">mov  R2,#5</span><br><span class="line">mov  R0,#0x00000008</span><br><span class="line">stm  R0,&#123;R1,R2&#125; </span><br><span class="line">;以上四行代码表示 从0x00000008这个内存地址开始 将R1和R2中的数据依次存入</span><br></pre></td></tr></table></figure>

<p>如果我想在上面的基础上再往后追加数据</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mov  R1,#6</span><br><span class="line">mov  R2,#7</span><br><span class="line">stm  R0,&#123;R1,R2&#125;</span><br></pre></td></tr></table></figure>

<p> 我们发现数据并没有追加,而是被覆盖了,因为<code>R0</code>的值依然还是 <code>0x00000008</code>,这个时候我们需要使用扩展指令,如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mov  R1,#4</span><br><span class="line">mov  R2,#5</span><br><span class="line">mov  R0,#0x00000008</span><br><span class="line">STMIA  R0!,&#123;R1,R2&#125; ;只有在寄存器后加上!才能修改寄存器中的值</span><br><span class="line"></span><br><span class="line">mov  R1,#6</span><br><span class="line">mov  R2,#7</span><br><span class="line">stm  R0,&#123;R1,R2&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>事实上 STM指令如果不加后缀写法,默认使用的是STMIA指令,LDM指令默认使用LDMIA</p>
</blockquote>
<h4 id="多寄存器数据存放顺序"><a href="#多寄存器数据存放顺序" class="headerlink" title="多寄存器数据存放顺序"></a>多寄存器数据存放顺序</h4><p>不管使用哪种扩展指令,皆为左低右高的形式,也就是左边的寄存器数据存放在低地址,右边的存放在高地址</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">STMIA  R0!,&#123;R1,R2&#125; ;左边R1的内容放低地址,右边R2的内容放高地址</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">LDMDB   R0!,&#123;R1,R2&#125; ;高地址数据放入R2,低地址数据放入R1</span><br></pre></td></tr></table></figure>

<h2 id="宏"><a href="#宏" class="headerlink" title="宏"></a>宏</h2><ol>
<li><p><strong>宏匹配</strong></p>
<ul>
<li>语法格式</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">MACRO</span><br><span class="line">$label macroname $param</span><br><span class="line">;指令序列   </span><br><span class="line">MEND  </span><br><span class="line"></span><br><span class="line">;例如声明一个宏名为print的宏语句</span><br><span class="line">MACRO</span><br><span class="line">$label print $param   ;带$的表示会被替换的内容</span><br><span class="line"> ;这里写相关汇编代码</span><br><span class="line">MEND</span><br></pre></td></tr></table></figure>

<ul>
<li>使用</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> MACRO</span><br><span class="line">  $label putR0 $param  </span><br><span class="line">  </span><br><span class="line">  mov R0,$param</span><br><span class="line">   </span><br><span class="line"> MEND   </span><br><span class="line"> </span><br><span class="line">; 使用</span><br><span class="line">putR0 #10</span><br></pre></td></tr></table></figure>


</li>
</ol>
<ul>
<li>延伸</li>
</ul>
<p>第一个<code>$label</code>是干嘛用的呢,由于宏的内部处理方式的替换,为了避免标签名称的冲突,增加一个标识</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">;假如我要在宏匹配中定义一个函数fun, 当我调用两次的时候,会出现函数名重复的问题</span><br><span class="line">	MACRO</span><br><span class="line">    $label putR0 $param  </span><br><span class="line">   fun</span><br><span class="line">    mov R0,$param</span><br><span class="line">     </span><br><span class="line">   MEND   </span><br><span class="line">   </span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"> putR0 #10</span><br><span class="line"> putR0 #10</span><br><span class="line"> </span><br><span class="line"> ;那么如果要解决这个问题的话,我可以利用第一个替换参数如下:</span><br><span class="line"> 	MACRO</span><br><span class="line">$label putR0 $param  </span><br><span class="line">$label</span><br><span class="line">    mov R0,$param</span><br><span class="line">     </span><br><span class="line">   MEND   </span><br><span class="line">   </span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">fun1 putR0 #10  ;函数名为fun1</span><br><span class="line">fun2 putR0 #10  ;函数名为fun2</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p><strong>宏定义</strong></p>
<ul>
<li><strong>全局宏</strong>的定义,可跨段访问 </li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">;全局数字变量</span><br><span class="line">GBLA number </span><br><span class="line">number SETA 0Xaa  </span><br><span class="line"></span><br><span class="line">;全局逻辑变量</span><br><span class="line">GBLL flag </span><br><span class="line">flag SETL &#123;TRUE&#125;  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">;全局字符串变量</span><br><span class="line">GBLS str </span><br><span class="line">str SETS &quot;hello world&quot;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>局部宏</strong>的定义,只能在当前宏内被访问</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">;局部数字变量</span><br><span class="line">LCLA number </span><br><span class="line">number SETA 0Xaa  </span><br><span class="line"></span><br><span class="line">;局部逻辑变量</span><br><span class="line">LCLL flag </span><br><span class="line">flag SETL &#123;TRUE&#125;  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">;局部字符串变量</span><br><span class="line">LCLS str </span><br><span class="line">str SETS &quot;hello world&quot;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>全局常量的定义</strong></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">num   EQU      10  ;关键字EQU  数据不允许修改</span><br></pre></td></tr></table></figure>




</li>
</ol>
<ol start="3">
<li><p>宏定义示例</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">;定义一个全局整型数据宏</span><br><span class="line">GBLA number </span><br><span class="line">number SETA 0Xaa  </span><br><span class="line"></span><br><span class="line">;使用</span><br><span class="line">mov R0,#number ;相当于mov R0,#0Xaa</span><br><span class="line">LDR R0,=number ;相当于LDR R0,=0Xaa</span><br></pre></td></tr></table></figure>

<p> 局部宏数据</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">MACRO ;声明一个宏</span><br><span class="line">$label    message  $a ;取名为message 参数为$a</span><br><span class="line"></span><br><span class="line">;定义宏内局部变量</span><br><span class="line">LCLA    number </span><br><span class="line">number SETA $a</span><br><span class="line"></span><br><span class="line">mov R0,#number</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">MEND ;宏结束,局部变量不再起作用</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">message 10 ;直接调用</span><br></pre></td></tr></table></figure>

<p> 常量数据</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">	AREA data ,DATA</span><br><span class="line">num   EQU      10 </span><br><span class="line">	AREA code ,CODE</span><br><span class="line"></span><br><span class="line">	mov R1,#5</span><br><span class="line">	ldr R1,=num</span><br><span class="line"></span><br><span class="line">	END</span><br></pre></td></tr></table></figure>

</li>
</ol>
<blockquote>
<p>宏匹配和宏定义需要遵循先定义后使用的原则</p>
<p>如果需要从宏中跳出,可以使用伪指令MEXIT</p>
</blockquote>
<ol start="3">
<li><p><strong>宏替换</strong></p>
<p>使用<code>include</code>或者<code>get</code>伪指令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">   ;使用get伪指令</span><br><span class="line">   AREA code, CODE</span><br><span class="line">GET pangshu.s         ;通知编译器当前源文件包含源文件 softool.s</span><br><span class="line">   GET C:\pp.s           ;通知编译器当前源文件包含源文件 C:\cn.s</span><br><span class="line">   END</span><br><span class="line">   </span><br><span class="line">   ;使用include伪指令</span><br><span class="line">   AREA code, CODE</span><br><span class="line">   include pangshu.s         ;通知编译器当前源文件包含源文件 softool.s</span><br><span class="line">   include C:\pp.s           ;通知编译器当前源文件包含源文件 C:\cn.s</span><br><span class="line">   END</span><br></pre></td></tr></table></figure>




</li>
</ol>
<h2 id="指令学习"><a href="#指令学习" class="headerlink" title="指令学习"></a>指令学习</h2><h4 id="传送指令"><a href="#传送指令" class="headerlink" title="传送指令"></a>传送指令</h4><ol>
<li><p>正常传送指令<code>mov</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mov R0,#4 ;将4传送至R0寄存器</span><br></pre></td></tr></table></figure>
</li>
<li><p>取反传送指令<code>mvn</code>,也叫<strong>数据非传送指令</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mvn R0,#4 ;将4取反后传送至R0寄存器  0100取反为1011</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h4 id="转移指令"><a href="#转移指令" class="headerlink" title="转移指令"></a>转移指令</h4><ol>
<li><strong>B指令</strong></li>
</ol>
<p>直接跳转,仅更改PC寄存器的值</p>
<p>示例:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">B 0x00040000 ;直接跳转到物理地址0x00040000读取指令并执行</span><br><span class="line"></span><br><span class="line">B 标号  ;直接跳转到标号处</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><strong>BL指令</strong></li>
</ol>
<p>跳转并链接,除了更改PC寄存器的值之外,还会将下一条指令所对应的物理地址存放至<code>lr</code>寄存器中</p>
<p>示例:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">BL 0x00040000</span><br><span class="line">mov r1,3  ;假设这行指令对应物理地址为0x0040004, 那么BL一旦执行,会将该值存入lr寄存器</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">或者</span><br><span class="line">BL 标号</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><p><strong>BX指令</strong></p>
<p>跳转并切换状态</p>
<p><strong>BX指令后面只能跟寄存器</strong>,弥补了B指令和BL指令的不足, 同时会根据寄存器中最低比特位值切换ARM/Thumb模式 </p>
</li>
</ol>
<p>示例:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">BL print</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">print</span><br><span class="line">	mov r1,#1</span><br><span class="line">	BX lr  ;函数返回     如果R0[0]=1,则进入Thumb状态 反之进入ARM模式</span><br></pre></td></tr></table></figure>

<p>除了通过指令来更改PC寄存器值之外,在ARM32中还可以<strong>直接使用传送指令对PC寄存器进行赋值</strong>:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mov pc,#0x00000008  ;往pc寄存器中写入一个地址值</span><br><span class="line"></span><br><span class="line">mov R0,pc  ;获取pc寄存器中的值</span><br></pre></td></tr></table></figure>

<ol start="4">
<li><p><strong>BLX指令</strong></p>
<p>该指令将以下功能集于一身</p>
<ul>
<li>更改PC寄存器的值</li>
<li>将下一条指令的地址存入lr寄存器</li>
<li>根据寄存器中最低比特位值切换ARM/Thumb模式 </li>
</ul>
</li>
</ol>
<h4 id="算术和逻辑运算指令"><a href="#算术和逻辑运算指令" class="headerlink" title="算术和逻辑运算指令"></a>算术和逻辑运算指令</h4><ol>
<li><p>算术运算</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">add R0,#5</span><br><span class="line">add R0,R1 ;加法 </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sub R0,#5</span><br><span class="line">sub R0,R1 ;减法 </span><br><span class="line"></span><br><span class="line">mul R0,R1,R2 ;乘法指令, 这里至少三个寄存器参与</span><br><span class="line"></span><br><span class="line">mla R0,R1,R2,R3  ;先乘后加      R0 = R1 × R2 + R3</span><br></pre></td></tr></table></figure>
</li>
<li><p>逻辑运算</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">and R0.#3</span><br><span class="line">and R0,R0 ;逻辑与</span><br><span class="line"></span><br><span class="line">orr R0.#3</span><br><span class="line">orr R0,R0 ;逻辑或</span><br><span class="line"></span><br><span class="line">eor R0.#3</span><br><span class="line">eor R0,R0 ;逻辑异或</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h4 id="移位指令"><a href="#移位指令" class="headerlink" title="移位指令"></a>移位指令</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">MOV   R0, R1, LSL#2    ;将R1中的内容左移两位后传送到R0中。</span><br><span class="line"></span><br><span class="line">MOV   R0, R1, LSR#2    ;将R1中的内容右移两位后传送到R0中,左端用零来填充。</span><br></pre></td></tr></table></figure>

<h4 id="比较指令"><a href="#比较指令" class="headerlink" title="比较指令"></a>比较指令</h4><ol>
<li><p>比较两个值是否相等</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cmp R0,R1 </span><br><span class="line">beq sub ;如果两个寄存器中的值相等则跳转到sub函数中,否则继续往下执行</span><br><span class="line"></span><br><span class="line">sub</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">cmp R0,#5</span><br><span class="line">bne sub ;如果两个值不相等,跳转到sub函数,否则继续往下执行</span><br><span class="line"></span><br><span class="line">sub</span><br></pre></td></tr></table></figure>
</li>
<li><p>大于和小于(带符号)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">;大于</span><br><span class="line">cmp R0,R1</span><br><span class="line">bgt sub ;如果R0寄存器中的值大于R1,则跳转至sub</span><br><span class="line"></span><br><span class="line">sub</span><br><span class="line"></span><br><span class="line">;小于</span><br><span class="line">cmp R0,R1</span><br><span class="line">blt sub ;如果R0寄存器中的值大于R1,则跳转至sub</span><br><span class="line"></span><br><span class="line">sub</span><br></pre></td></tr></table></figure>



</li>
</ol>
<h2 id="标志寄存器"><a href="#标志寄存器" class="headerlink" title="标志寄存器"></a>标志寄存器</h2><p>试想一下,我们的比较指令<code>cmp</code>,它内部是如何进行数据大小判断的</p>
<p>在高级语言里,直接使用<code>&gt;</code>或者<code>&lt;</code>运算符,来判断两个值的大小,比较结束后返回<code>True</code>或者<code>Flase</code>,可是在汇编语言里面没有这么简便,那它又是如何对两个数据之间大小进行判断的呢？</p>
<p>别忘了, 计算机最擅长做二进制的算术和逻辑运算</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cmp R0,R1</span><br></pre></td></tr></table></figure>

<p>要想判断两个数据是否相等,或者大于小于,直接做个减法运算不就完事了,也就是<code>R0-R1</code>,如果结果为0,那么两个值相等,如果结果为正数,则R0&gt;R1,结果为负数,则小于</p>
<p>但是问题来了,这个结果值放在哪里呢？放内存中还是寄存器呢? 答案是：寄存器</p>
<p>cpu设计者为了方便区分专门用了一个寄存器来存放数据运算后的结果,这个寄存器叫做<strong>状态寄存器</strong>,也叫标志寄存器</p>
<p>ARM32中一个寄存器有32二进制位的数据空间,那该怎么存放呢？</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">00000000000000000000000000000000  ;32个二进制位</span><br></pre></td></tr></table></figure>

<p>为了方便程序员开发,设计者给这些二进制位进行了相应的命名：</p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20210120151329.png" alt></p>
<p>当两个比较值相等,进行减法运算时,结果为0,那么Z标志位的值为1,也就是</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">01000000000000000000000000000000  ;32个二进制位</span><br></pre></td></tr></table></figure>

<p>如果不相等,结果不为0,那么Z标志位的值变成0</p>
<p>由于每个二进制位只能存0和1两个值,也就是最多只能表示两种状态,那大于和小于的状态表示就得放到另外一个二进制上了,由于二进制运算涉及到有符号和无符号两种情况,因此需要用到两个二进制分别进行处理,有符号的的结果存放在N标志位,无符号的结果存放在C标志位：</p>
<p><code>cmp</code>指令会同时对两个数据进行有符号和无符号运算</p>
<p><strong>有符号运算</strong>,如果结果为正数,N标志位值为0,如果为负数,N标志位值为1</p>
<p><strong>无符号运算</strong>,如果结果为正数,C标志位值为1,如果为负数,C标志位值为0</p>
<p>那么我们在使用<code>cmp</code>指令的时候,到底是根据那个标志位的结果进行判断的呢？</p>
<p>如果我们使用<code>bne</code>指令,那么取Z标志位的值进行参考</p>
<p>如果我们使用<code>blt</code>,<code>bgt</code>,那么取N标志位,Z标志位和V标志位三者的值进行参考</p>
<p>总结：</p>
<ol>
<li><p><code>cmp</code>指令的功能相当于减法指令,只是对操作数之间运算比较,结果间接保存在标志寄存器高位中</p>
</li>
<li><p><code>bne</code>,<code>blt</code>,<code>bgt</code>等这些指令都是通过获取标志寄存器中的值来得知比较结果从而进行相应跳转,不同的指令需要满足不同的条件</p>
</li>
<li><p>我们可以通过改变状态寄存器中的值来改变代码的走向</p>
</li>
</ol>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">  AREA test,CODE</span><br><span class="line"></span><br><span class="line">	mov R0,#5</span><br><span class="line">	mov R1,#6</span><br><span class="line">	cmp R0,R1</span><br><span class="line">	;在跳转之前改变状态寄存器的值 使得bgt必然跳转</span><br><span class="line">	MSR cpsr_f ,0x20000000</span><br><span class="line">	BGT fun</span><br><span class="line">	mov R1,#6</span><br><span class="line"></span><br><span class="line">fun</span><br><span class="line">	mov R0,#4</span><br><span class="line">	bx lr</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  END</span><br></pre></td></tr></table></figure>

<p>知识扩展：</p>
<ol>
<li><p>状态寄存器的读取和写入</p>
<p>读取指令:<strong>MRS</strong>{mov to register from special register）</p>
<p>写入指令: <strong>MSR</strong>(Move to Special register from Register )</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 读取状态寄存器中的值</span><br><span class="line">mrs R0,cpsr  ;将值读取到R0寄存器</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#修改状态寄存器中的值</span><br><span class="line">msr cpsr_c,#0x2d ;修改控制位区域</span><br><span class="line">msr cpsr_x,#0x2d00 ;修改扩展位区域</span><br><span class="line">msr cpsr_s,#0x2d0000 ;修改状态位区域</span><br><span class="line">msr cpsr_f,#0x2d000000 ;修改标志位区域</span><br><span class="line"></span><br><span class="line">#修改状态寄存器高位值时,低位必须补足0,虽然加了0但是不会影响其他区域的值</span><br></pre></td></tr></table></figure>
</li>
<li><p>状态寄存器中各个区域具体描述</p>
<p>一共分位四个大区域,从低到高分别为：<strong>控制位区域</strong>, <strong>扩展位区域,</strong> <strong>状态位区域</strong>, <strong>标志位区域</strong>,每个区域各占8个二进制位的空间</p>
<p>以下是<strong>控制位区域</strong>细分详解图：</p>
</li>
</ol>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20210120151619.png" alt> </p>
<ol start="3">
<li>比较指令标志位条件参考表</li>
</ol>
<table>
<thead>
<tr>
<th align="center">指令</th>
<th align="center">含义</th>
<th align="center">需要满足的条件</th>
</tr>
</thead>
<tbody><tr>
<td align="center">beq</td>
<td align="center">相等</td>
<td align="center">Z标志位为1</td>
</tr>
<tr>
<td align="center">bne</td>
<td align="center">不相等</td>
<td align="center">Z标志位为0</td>
</tr>
<tr>
<td align="center">bgt</td>
<td align="center">带符号大于</td>
<td align="center">Z标志位为0，且N和V标志位值相等</td>
</tr>
<tr>
<td align="center">blt</td>
<td align="center">带符号小于</td>
<td align="center">N不等于V</td>
</tr>
<tr>
<td align="center">bge</td>
<td align="center">带符号大于等于</td>
<td align="center">N等于V</td>
</tr>
<tr>
<td align="center">ble</td>
<td align="center">带符号小于等于</td>
<td align="center">Z标志位为1或者N不等于V</td>
</tr>
<tr>
<td align="center">bls</td>
<td align="center">无符号小于等于</td>
<td align="center">Z标志位为1且C标志位为0</td>
</tr>
<tr>
<td align="center">bhi</td>
<td align="center">无符号大于</td>
<td align="center">Z标志位为0且C标志位为1</td>
</tr>
<tr>
<td align="center">bcs</td>
<td align="center">无符号大于等于</td>
<td align="center">C标志位为1</td>
</tr>
<tr>
<td align="center">bhs</td>
<td align="center">无符号大于等于</td>
<td align="center">C标志位为1</td>
</tr>
<tr>
<td align="center">bcc</td>
<td align="center">无符号小于</td>
<td align="center">C标志位为0</td>
</tr>
<tr>
<td align="center">blo</td>
<td align="center">无符号小于</td>
<td align="center">C标志位为0</td>
</tr>
<tr>
<td align="center">bmi</td>
<td align="center">负数</td>
<td align="center">N标志位为1</td>
</tr>
<tr>
<td align="center">bpl</td>
<td align="center">正数或零</td>
<td align="center">N标志位为0</td>
</tr>
<tr>
<td align="center">bvs</td>
<td align="center">溢出</td>
<td align="center">V标志位为1</td>
</tr>
<tr>
<td align="center">bvc</td>
<td align="center">未溢出</td>
<td align="center">V标志位为0</td>
</tr>
<tr>
<td align="center">bnv</td>
<td align="center">无条件执行</td>
<td align="center">忽略</td>
</tr>
<tr>
<td align="center">bal</td>
<td align="center">无条件执行</td>
<td align="center">忽略</td>
</tr>
</tbody></table>
<h2 id="条件和循环伪指令"><a href="#条件和循环伪指令" class="headerlink" title="条件和循环伪指令"></a>条件和循环伪指令</h2><p>   IF、ELSE 和 ENDIF</p>
<ul>
<li><p>根据条件的成立与否决定是否执行某个程序段</p>
</li>
<li><p>IF、ELSE、ENDIF 伪指令可以嵌套使用</p>
</li>
<li><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GBLL Test ;声明一个全局逻辑变量Test</span><br><span class="line">Test SETL &#123;TRUE&#125; </span><br><span class="line"></span><br><span class="line">IF Test = &#123;TRUE&#125;</span><br><span class="line"> 程序段1 </span><br><span class="line">ELSE</span><br><span class="line"> 程序段2</span><br><span class="line">ENDIF</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="WHILE-和-WEND"><a href="#WHILE-和-WEND" class="headerlink" title="WHILE 和 WEND"></a>WHILE 和 WEND</h4><ul>
<li><p>根据条件的成立与否决定是否重复汇编一个程序段</p>
</li>
<li><p>若 WHILE 后面的逻辑表达式为真,则重复汇编该程序段,直到逻辑表达式为假</p>
</li>
<li><p>WHILE 和 WEND 伪指令可以嵌套使用</p>
</li>
<li><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GBLA Counter  ;声明一个全局数字变量Counter</span><br><span class="line">Counter SETA 3    ;赋值</span><br><span class="line">...</span><br><span class="line">WHILE Counter &lt; 10</span><br><span class="line">程序段</span><br><span class="line">WEND</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="汇编语言和C语言交互"><a href="#汇编语言和C语言交互" class="headerlink" title="汇编语言和C语言交互"></a>汇编语言和C语言交互</h2><ul>
<li>内嵌汇编</li>
<li>外链汇编</li>
</ul>
<h4 id="1-引入其他源文件函数"><a href="#1-引入其他源文件函数" class="headerlink" title="1.引入其他源文件函数"></a>1.引入其他源文件函数</h4><p>使用<code>import</code>或者<code>extern</code>伪指令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">;使用import伪指令</span><br><span class="line">AREA code, CODE</span><br><span class="line">import fun1 ;导入其他源文件中名为fun1的函数</span><br><span class="line">END</span><br><span class="line"></span><br><span class="line">;使用extern伪指令</span><br><span class="line">AREA code, CODE</span><br><span class="line">extern fun1       </span><br><span class="line">END</span><br></pre></td></tr></table></figure>

<p><strong>两者区别:</strong></p>
<ul>
<li><code>import</code>:不管当前文件是否使用该引入的函数,该标签都会加入当前文件符号表,即为静态引用</li>
<li><code>extern</code>:只有当前文件使用了该函数,才会将此标签加入符号表,即为动态引用</li>
</ul>
<h4 id="2-导出当前源文件中函数供其他文件访问"><a href="#2-导出当前源文件中函数供其他文件访问" class="headerlink" title="2.导出当前源文件中函数供其他文件访问"></a>2.导出当前源文件中函数供其他文件访问</h4><p>使用<code>export</code>或者<code>global</code>伪指令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">;使用import伪指令</span><br><span class="line">AREA code, CODE</span><br><span class="line">export fun         ;导出fun函数供其他源文件使用</span><br><span class="line"></span><br><span class="line">fun </span><br><span class="line">	mov R0,#4</span><br><span class="line">	bx lr</span><br><span class="line">END</span><br></pre></td></tr></table></figure>

<h4 id="3-外链汇编之C语言调汇编函数"><a href="#3-外链汇编之C语言调汇编函数" class="headerlink" title="3.外链汇编之C语言调汇编函数"></a>3.外链汇编之C语言调汇编函数</h4><p>第一步,在汇编原文件中将函数暴露出来给供外部调用,使用<code>export</code>或者<code>global</code>伪指令:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">AREA code, CODE</span><br><span class="line">export arm_strcpy  ;或者使用global</span><br><span class="line"></span><br><span class="line">arm_strcpy</span><br><span class="line">loop </span><br><span class="line">	ldrb R4,[R0],#1 ;如果使用ldr 那么将偏移值改成4</span><br><span class="line">	cmp R4,#0</span><br><span class="line">	beq over</span><br><span class="line">	strb R4,[R1],#1</span><br><span class="line">	b loop</span><br><span class="line">over	</span><br><span class="line">END</span><br></pre></td></tr></table></figure>

<p>第二步,在C文件中引用汇编中的函数,C文件中只能使用<code>extern</code>伪指令:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">extern arm_strcpy(char *src,char*des);</span><br><span class="line"></span><br><span class="line">int main2()&#123;</span><br><span class="line">	char *a=&quot;hello pangshu&quot;;</span><br><span class="line">	char b[64];</span><br><span class="line">	arm_strcpy(a,b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-外链汇编之汇编调c语言函数"><a href="#4-外链汇编之汇编调c语言函数" class="headerlink" title="4.外链汇编之汇编调c语言函数"></a>4.外链汇编之汇编调c语言函数</h4><p>第一步,在C文件中编写好函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">c_sum</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a+b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第二步, 在汇编文件中引入函数,使用<code>import</code>或者<code>extern</code>伪指令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">AREA code, CODE</span><br><span class="line">import c_sum  </span><br><span class="line"></span><br><span class="line">mov R0,#1 ;第一个参数</span><br><span class="line">mov R1,#2 ;第二个参数</span><br><span class="line"></span><br><span class="line">END</span><br></pre></td></tr></table></figure>

<p>第三步, 使用BL指令调用函数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">AREA code, CODE</span><br><span class="line">import c_sum  </span><br><span class="line"></span><br><span class="line">mov R0,#1 ;第一个参数</span><br><span class="line">mov R1,#2 ;第二个参数</span><br><span class="line">BL c_sum</span><br><span class="line">END</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在ARM中函数参数使用R0~R3这四个寄存器来进行传递,最多传递4个参数,超过4个参数使用栈进行处理,函数返回值通过R0进行传递</p>
</blockquote>
<h4 id="由于keil软件的特殊性-我们可以通过以下方式进行互调测试"><a href="#由于keil软件的特殊性-我们可以通过以下方式进行互调测试" class="headerlink" title="由于keil软件的特殊性,我们可以通过以下方式进行互调测试"></a>由于keil软件的特殊性,我们可以通过以下方式进行互调测试</h4><p>C文件中代码:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="title">arm_strcpy</span><span class="params">(<span class="keyword">char</span> *src,<span class="keyword">char</span>*des)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main2</span><span class="params">()</span></span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">char</span> *a=<span class="string">"hello pangshu"</span>	;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">char</span> b[<span class="number">64</span>];</span><br><span class="line"></span><br><span class="line">	arm_strcpy(a,b); <span class="comment">//调汇编中函数</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">c_sum</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a+b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>汇编文件中代码:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> AREA code, CODE</span><br><span class="line"></span><br><span class="line"> import c_sum   </span><br><span class="line"> export arm_strcpy  </span><br><span class="line"></span><br><span class="line">arm_strcpy</span><br><span class="line"></span><br><span class="line">	mov R0,#1 ;第一个参数</span><br><span class="line">	mov R1,#2 ;第二个参数</span><br><span class="line">	BL c_sum  ;结果存放至R0中</span><br><span class="line">	END</span><br></pre></td></tr></table></figure>

<h4 id="5-内嵌汇编"><a href="#5-内嵌汇编" class="headerlink" title="5.内嵌汇编"></a>5.内嵌汇编</h4><p>在C语言中嵌入汇编代码,格式如下:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a=<span class="number">4</span>;</span><br><span class="line">    <span class="keyword">int</span> b=<span class="number">4</span>;</span><br><span class="line">    <span class="keyword">int</span> c=<span class="number">4</span>;</span><br><span class="line">  </span><br><span class="line">	__asm__&#123;         <span class="comment">//使用__asm或者__asm__</span></span><br><span class="line">	mov R5,#<span class="number">0x00000005</span>   <span class="comment">//在大括号内部直接写入汇编代码即可</span></span><br><span class="line">	mov R6,#<span class="number">0x00000005</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>内嵌汇编的注意事项:</p>
<ul>
<li>不能直接给PC寄存器赋值,如果想改变pc值需要借助转移指令</li>
<li>由于R0<del>R3用于存放函数参数和返回值,R12</del>R15有特殊用途,因此<strong>我们能操作的寄存器只有R4~R11</strong>, 又因为编译器会优先将寄存器分配给函数中的局部变量,因此<strong>我们一般无法在内嵌汇编环境中准确地修改某个寄存器的值</strong>,比如我想修改R5寄存器的值,由于函数有个变量占用了R5这个寄存器,那么编译器会自动将你写的这个R5改成R6或者其他，所以，在内嵌汇编时我们需要把寄存器当作变量来看待，把局部变量也当成寄存器看待，就好理解了</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void c_strcopy(char *src,char *des)&#123;</span><br><span class="line">	char ch</span><br><span class="line">	__asm__&#123;    </span><br><span class="line">    loop:</span><br><span class="line">    	ldrb ch,[src],#1  //局部变量当成寄存器看待</span><br><span class="line">    	strb ch,[des],#1</span><br><span class="line">    	cmp,ch,#0</span><br><span class="line">    	bne loop</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="ARM32中寄存器别名补充"><a href="#ARM32中寄存器别名补充" class="headerlink" title="ARM32中寄存器别名补充"></a>ARM32中寄存器别名补充</h2><table>
<thead>
<tr>
<th align="left">寄存器</th>
<th align="left">别名</th>
<th align="left">用途</th>
</tr>
</thead>
<tbody><tr>
<td align="left">r0</td>
<td align="left">a1</td>
<td align="left">第一个函数参数和函数返回值</td>
</tr>
<tr>
<td align="left">r1</td>
<td align="left">a2</td>
<td align="left">第二个函数参数</td>
</tr>
<tr>
<td align="left">r2</td>
<td align="left">a3</td>
<td align="left">第三个函数参数</td>
</tr>
<tr>
<td align="left">r3</td>
<td align="left">a4</td>
<td align="left">第四个函数参数</td>
</tr>
<tr>
<td align="left">r4</td>
<td align="left">v1</td>
<td align="left">寄存器变量</td>
</tr>
<tr>
<td align="left">r5</td>
<td align="left">v2</td>
<td align="left">寄存器变量</td>
</tr>
<tr>
<td align="left">r6</td>
<td align="left">v3</td>
<td align="left">寄存器变量</td>
</tr>
<tr>
<td align="left">r7</td>
<td align="left">v4</td>
<td align="left">寄存器变量</td>
</tr>
<tr>
<td align="left">r8</td>
<td align="left">v5</td>
<td align="left">寄存器变量</td>
</tr>
<tr>
<td align="left">r9</td>
<td align="left">v6</td>
<td align="left">寄存器变量 实际的帧指针</td>
</tr>
<tr>
<td align="left">r10</td>
<td align="left">sl</td>
<td align="left">栈接线</td>
</tr>
<tr>
<td align="left">r11</td>
<td align="left">fp</td>
<td align="left">参数指针</td>
</tr>
<tr>
<td align="left">r12</td>
<td align="left">ip</td>
<td align="left">临时</td>
</tr>
<tr>
<td align="left">r13</td>
<td align="left">sp</td>
<td align="left">栈指针</td>
</tr>
<tr>
<td align="left">r14</td>
<td align="left">lr</td>
<td align="left">连接寄存器</td>
</tr>
<tr>
<td align="left">r15</td>
<td align="left">pc</td>
<td align="left">程序计数器</td>
</tr>
</tbody></table>
<h4 id="如何编译16位arm汇编指令"><a href="#如何编译16位arm汇编指令" class="headerlink" title="如何编译16位arm汇编指令"></a>如何编译16位arm汇编指令</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">AREA test, CODE</span><br><span class="line">code16		;声明为16位arm指令 如果不写默认则为code32 </span><br><span class="line"></span><br><span class="line"> END</span><br></pre></td></tr></table></figure>

<h4 id="附-指令集汇总"><a href="#附-指令集汇总" class="headerlink" title="附:指令集汇总"></a>附:指令集汇总</h4><p><strong>(一)</strong>  <strong>ARM</strong> <strong>指令集</strong></p>
<p>1． 指令格式</p>
<p>2． 条件码</p>
<p><strong>3． ARM</strong> <strong>存储器访问指令</strong></p>
<p>1)    LDR/ STR －加载 /存储指令</p>
<p>2)    LDM/ STM －多寄存器加载 /存储指令</p>
<p>3)    SWP －寄存器和存储器交换指令</p>
<p><strong>4． ARM</strong> <strong>数据处理指令</strong></p>
<p>1)    数据传送指令</p>
<p>a)    MOV －数据传送指令</p>
<p>b)    MVN －数据非传送指令</p>
<p>2)    算术逻辑运算指令</p>
<p>a)    ADD －加法运算指令</p>
<p>b)    SUB －减法运算指令</p>
<p>c)    RSB- 逆向减法指令</p>
<p>d)    ADC －带进位加法指令</p>
<p>e)    SBC －带进位减法指令</p>
<p>f)    RSC －带进位逆向减法指令</p>
<p>g)    AND －逻辑“与”</p>
<p>h)    ORR －逻辑“或”</p>
<p>i)    EOR －逻辑“异或”</p>
<p>j)    BIC －位清除指令</p>
<p>3)    比较指令</p>
<p>a)    CMP －比较指令</p>
<p>b)    CMN －负数比较指令</p>
<p>c)    TST －位测试指令</p>
<p>d)    TEQ －相等测试指令</p>
<p>4)    乘法指令</p>
<p>a)    MUL － 32位乘法指令</p>
<p>b)    MLA － 32位乘加指令</p>
<p>c)    UMULL － 64位无符号乘法指令</p>
<p>d)    UMLAL － 64位无符号乘加指令</p>
<p>e)    SMULL － 64位有符号乘法指令</p>
<p>f)    SMLAL － 64位有符号乘加指令</p>
<p><strong>5． ARM</strong> <strong>分支指令</strong></p>
<p>1)    B －分支指令</p>
<p>2)    BL －带连接的分支指令</p>
<p>3)    BX －带状态切换的分支指令</p>
<p><strong>6． ARM</strong> <strong>协处理器指令</strong></p>
<p>1)    CDP －协处理器数据操作指令</p>
<p>2)    LDC －协处理器数据读取指令</p>
<p>3)    STC －协处理器数据写入指令</p>
<p>4)    MCR － ARM处理器到协处理器的数据传送指令</p>
<p>5)    MRC －协处理器到 ARM处理器的数据传送指令</p>
<p><strong>7． ARM</strong> <strong>杂项指令</strong></p>
<p>1)    SWI －软中断指令</p>
<p>2)    MRS －读状态寄存器指令</p>
<p>3)    MSR －写状态寄存器指令</p>
<p><strong>8． ARM</strong> <strong>伪指令</strong></p>
<p>1)    ADR －小范围的地址读取伪指令</p>
<p>2)    ADRL －中等范围的地址读取伪指令</p>
<p>3)    LDR －大范围的地址读取伪指令</p>
<p>4)    NOP －空操作伪指令</p>
<p><strong>(二)</strong>  <strong>Thumb</strong> <strong>指令集</strong></p>
<p>1． Thumb 指令集和 ARM指令集的区别</p>
<p><strong>2． Thumb</strong> <strong>存储器访问指令</strong></p>
<p>1)    LDR/ STR －加载 /存储指令</p>
<p>2)    PUSH/ POP －寄存器入栈 /出栈指令</p>
<p>3)    LDMIA/ STMIA －多寄存器加载 /存储指令</p>
<p><strong>3． Thumb</strong> <strong>数据处理指令</strong></p>
<p>1)    数据传送指令</p>
<p>a)    MOV －数据传送指令</p>
<p>b)    MVN －数据非传送指令</p>
<p>c)    NEG －数据取负指令</p>
<p>2)    算术逻辑运算指令</p>
<p>a)    ADD －加法运算指令</p>
<p>b)    SUB －减法运算指令</p>
<p>c)    ADC －带进位加法指令</p>
<p>d)    SBC －带进位减法指令</p>
<p>e)    MUL －乘法运算指令</p>
<p>f)    AND －逻辑“与”</p>
<p>g)    ORR －逻辑“或”</p>
<p>h)    EOR －逻辑“异或”</p>
<p>i)    BIC －位清除指令</p>
<p>j)    ASR －算术右移指令</p>
<p>k)    LSL －逻辑左移指令</p>
<p>l)    LSR －逻辑右移指令</p>
<p>m)    ROR －循环右移指令</p>
<p>3)    比较指令</p>
<p>a)    CMP －比较指令</p>
<p>b)    CMN －负数比较指令</p>
<p>c)    TST －位测试指令</p>
<p><strong>4． Thumb</strong> <strong>分支指令</strong></p>
<p>1)    B －分支指令</p>
<p>2)    BL －带连接的分支指令</p>
<p>3)    BX －带状态切换的分支指令</p>
<p><strong>5． Thumb</strong> <strong>杂项指令</strong></p>
<p>1)    SWI －软中断指令</p>
<p><strong>6． Thumb</strong> <strong>伪指令</strong></p>
<p>1)    ADR －小范围的地址读取伪指令</p>
<p>2)    LDR －大范围的地址读取伪指令</p>
<p>3)    NOP －空操作伪指令</p>
<p><strong>本文为作者原创 转载时请注明出处 谢谢</strong></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em>乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</em></p>
]]></content>
      <tags>
        <tag>汇编</tag>
      </tags>
  </entry>
  <entry>
    <title>视频教程录制计划</title>
    <url>/208.html</url>
    <content><![CDATA[<h2 id="技术视频"><a href="#技术视频" class="headerlink" title="技术视频"></a>技术视频</h2><ol>
<li><p><strong>《<a href="https://code.newban.cn/450.html">Android进阶之逆向安全反编译视频教程-胖薯出品</a>》</strong></p>
<ul>
<li>录制时间 2020年11月6日</li>
<li>部分视频观看:<a href="https://www.bilibili.com/video/BV1QZ4y1V7zy/" target="_blank" rel="noopener">点击跳转</a></li>
</ul>
</li>
<li><p><strong>《<a href="https://code.newban.cn/449.html">Smali语言从入门到精通视频教程-胖薯出品</a>》</strong></p>
<ul>
<li>录制时间 2020年11月6日</li>
<li>部分视频观看:<a href="https://www.bilibili.com/video/BV1Vf4y1q7gh/" target="_blank" rel="noopener">点击跳转</a></li>
</ul>
</li>
<li><p><strong>《<a href="https://code.newban.cn/451.html">程序员进阶之三大架构汇编语言入门视频教程-胖薯出品</a>》</strong></p>
<ul>
<li>录制时间 2020年12月14日</li>
<li>部分视频观看:<a href="https://www.bilibili.com/video/BV1CK411u76E/" target="_blank" rel="noopener">点击跳转</a></li>
</ul>
</li>
<li><p><strong>《ARM汇编进阶之ARM64汇编视频教程-胖薯出品》</strong></p>
<ul>
<li>录制时间 </li>
<li>部分视频观看:</li>
</ul>
</li>
<li><p><strong>《MIPS汇编进阶之MIPS64汇编视频教程-胖薯出品》</strong></p>
<ul>
<li>录制时间 </li>
<li>部分视频观看:</li>
</ul>
</li>
<li><p><strong>《X86汇编进阶之Win32汇编视频教程-胖薯出品》</strong></p>
<ul>
<li>录制时间 </li>
<li>部分视频观看:</li>
</ul>
</li>
<li><p><strong>《X86汇编进阶之Win64汇编视频教程-胖薯出品》</strong></p>
<ul>
<li>录制时间 </li>
<li>部分视频观看:</li>
</ul>
</li>
<li><p><strong>《lua语言从入门到实战视频教程-胖薯出品》</strong></p>
<ul>
<li>录制时间 </li>
<li>部分视频观看:</li>
</ul>
</li>
<li><p><strong>《硬件开发入门视频教程-胖薯出品》</strong></p>
<ul>
<li>录制时间 </li>
<li>部分视频观看:</li>
</ul>
</li>
<li><p><strong>《从0到1打造一门属于自己的编程语言视频教程-胖薯出品》</strong></p>
<ul>
<li>录制时间 </li>
<li>部分视频观看:</li>
</ul>
</li>
<li><p><strong>《从0到1开发一款操作系统视频教程-胖薯出品》</strong></p>
<ul>
<li>录制时间 </li>
<li>部分视频观看:</li>
</ul>
</li>
<li><p><strong>《音乐制作之视唱练耳视频教程-胖薯出品》</strong></p>
<ul>
<li>录制时间 </li>
<li>部分视频观看:</li>
</ul>
</li>
<li><p><strong>《虚幻游戏开发从0到1视频教程-胖薯出品》</strong></p>
<ul>
<li>录制时间 </li>
<li>部分视频观看:</li>
</ul>
</li>
<li><p><strong>《音频插件开发视频教程-胖薯出品》</strong></p>
<ul>
<li>录制时间 </li>
<li>部分视频观看:</li>
</ul>
</li>
<li><p><strong>《SO库的反编译视频教程-胖薯出品》</strong></p>
<ul>
<li>录制时间 </li>
<li>部分视频观看:</li>
</ul>
</li>
<li><p><strong>《360和腾讯加固的原理和脱壳视频教程-胖薯出品》</strong></p>
<ul>
<li>录制时间 </li>
<li>部分视频观看:</li>
</ul>
</li>
</ol>
<p><strong>本文为作者原创 转载时请注明出处 谢谢</strong></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em>乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</em></p>
]]></content>
      <tags>
        <tag>视频录制</tag>
      </tags>
  </entry>
  <entry>
    <title>从0到1打造一门属于自己的编程语言(一)</title>
    <url>/209.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>学习编程语言的开发,目的不是为了造轮子,而是为了了解程序语言的本质和原理,方便我们日常的开发</p>
<p>学习此课程前需要提前掌握以下知识:</p>
<ul>
<li>了解汇编语言</li>
<li>熟悉至少一门高级编程语言</li>
</ul>
<h2 id="编程语言的来源"><a href="#编程语言的来源" class="headerlink" title="编程语言的来源"></a>编程语言的来源</h2><p>我们如果想要和外国人交流,那么我们必须学会外语, 或者让外国人学咱们的语言</p>
<p>我们如果想要指挥计算机,那么我们必须学会计算机语言,让计算机学咱们的语言不太可能,至少现在不行! </p>
<p>很多人都认为我们平常使用的编程语言比如C语言 Java语言等就是计算机语言,这种说法不太严谨, 因为计算机压根不认识编程语言,它只认识二进制码, 也就是说 二进制码才是计算机真正的语言</p>
<p>那我们要指挥计算机岂不是得学<strong>二进制码(机器码)</strong>,在编程语言发明之前,确实是如此</p>
<p><strong>科技的进步来源于懒惰</strong></p>
<p>人类势必不会甘愿长期忍受机器码的摧残, 为了摆脱效率低下的编码,于是乎,聪明的人类发明了编程语言,比如汇编, 相比机器码汇编显然要舒服的多, 但是随着时间的推移,人们发现汇编语言存在非常严重的弊端, 最突出的一点就是不同cpu架构需要制定一套不同指令集,通俗一点就是不同cpu对应着不同的一套汇编语言,这就导致了无法跨平台</p>
<p>有人会问,为什么当时大家不使用同一种cpu呢, 历史不能预知未来的发展,每个时代都有各自的商业竞争</p>
<p><strong>新技术的出现往往是因为问题的长期累积</strong></p>
<p>于是乎,跨平台语言C语言问世了, 但是C语言知识语言跨平台,但是其编写的程序并不跨平台</p>
<p>于是乎,可以程序跨平台的Java语言问世了</p>
<p>……..</p>
<p>从这段历史,我们不难发现:</p>
<p><strong>编程语言只是一个方便人类与计算机交流的工具</strong></p>
<p>只是工具,仅此而已</p>
<p>我们现在花大量时间和精力所学所用的都是别人制作出来的工具</p>
<p>当我们因熟练掌握几门编程语言而洋洋得意时,是否有想过,我们只是一个工具的熟练运用者</p>
<p>我并不是说学语言很low, 毕竟编程语言的门槛也不低,需要花大量时间和精力才能有效掌握,我只是想说,一旦你明白了语言的创造过程, 那就等于你掌握了现在市面上所有的编程语言, 所有的语言,原理都是一样的,只不过语法和关键字不同,仅此而已</p>
<p>也就是说,我们需要去了解工具的生产过程</p>
<h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>如果你去网上搜相关编程语言制作的视频或资料, 基本上都是词法分析,语法分析,语义分析等等, 让人一头雾水, 直接劝退</p>
<p>试想一下,在若干年前编程语言还没有问世的时候,有词法语法语义符号token等等这一些个含义么? 完全没有!</p>
<p>这些理论都是前人经验总结而成, 经验固然很好,能少走弯路,但是对于初学者来讲极其不友好</p>
<p>只有从初学者的角度出发,才能更平滑地学习到原本复杂的知识</p>
<p>因此抛开这些专业术语吧,从0开始出发</p>
<h2 id="起步"><a href="#起步" class="headerlink" title="起步"></a>起步</h2><p>假如现在编程语言还未问世,你现在要自创一门语言方便人类开发, 你会怎么做?</p>
<p> 比如我想让计算机帮忙算个数,计算1+1</p>
<p>原本使用机器码可能得这样写:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4F 9B 55 7C 2D 3A  ;实际过程中我们一般使用十六进制进行表示,cpu执行的时候执行的是对应的二进制</span><br></pre></td></tr></table></figure>

<p>此时,我可能会考虑用一句话来代替这个计算1加1的功能,比如</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">加:1+1   ;这是不是好理解多了</span><br></pre></td></tr></table></figure>

<p>问题来了, 如果将我这句话转成机器码呢? 也就是说,我们需要将这句话翻译成机器码, 那怎么翻译呢? 是不是得需要一个翻译工具呀</p>
<p>于是乎,我们与此同时需要想办法整一个翻译工具, 由于我设计的这句话是敲在计算机上的,而不是写在纸上的, 如果是写在纸上的,兴许我们可以造一台机器将我写的内容转印成机器码,然后机器码敲入计算机:cry:… 这种愚蠢的做法, 简直就是科技的倒退</p>
<p>既然是直接敲在计算机中,那我们的翻译工具必然也是一个能被cpu执行的程序, 那我们需要先编写翻译工具这个程序的机器码</p>
<p>理论上是这么个逻辑</p>
<p>我们需要一边指定语法规则,一边编写和优化的翻译程序,因为我们的需求不单单是让计算机做加法运算</p>
<blockquote>
<p>这个能把我们指定的语言翻译成机器码的翻译工具，就是当今所说的编译器，后文皆以编译器替代</p>
</blockquote>
<h2 id="编译器该如何写"><a href="#编译器该如何写" class="headerlink" title="编译器该如何写"></a>编译器该如何写</h2><p>由于源代码都是存放在文件中，按照我们的正常思维，最先想到的是将这个文件中的内容读取出来，然后从头到尾进行匹配判断，根据不同的关键字判断不同的功能，然后用与之对应的机器码进行替换</p>
<p>cpu在进行文件读取的时候，本质上读取的是二进制，那我们编写的中文或者英文和二进制数据的一一对应关系就涉及到编码格式问题，常见的编码格式有：</p>
<ul>
<li>ASCII码 (只识别英文)</li>
<li>GBK （识别英文和中文）</li>
<li>UTF-8 （识别各个国家的语言）</li>
<li>…</li>
</ul>
<p>假如我们接下来要使用UTF-8进行编码，那么我们需要指定一张表，也就是二进制码和功能之间的一一对应关系，比如算术运算中<code>加</code>这个关键字：编译器从文本中连续读取两个字节二进制数据然后查表，如果对应上了加法功能，那么继续往后读取需要进行运算的内容，读到结束标记的时候，然后将之前所读取的二进制转化成与之对应功能的机器码，以此类推，这个结束标记也是由我们来定，我们可以使用分号、回车换行或者其它特殊的符号作为一行语句的结束</p>
<p><strong>本文为作者原创 转载时请注明出处 谢谢</strong></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em>乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</em></p>
]]></content>
      <tags>
        <tag>编程语言</tag>
      </tags>
  </entry>
  <entry>
    <title>Ajax 跨域问题及其解决方案</title>
    <url>/21.html</url>
    <content><![CDATA[<h2 id="什么是-ajax-跨域"><a href="#什么是-ajax-跨域" class="headerlink" title="什么是 ajax 跨域"></a>什么是 ajax 跨域</h2><p>主流的<strong>前后端分离模式</strong>下，当前端调用后台接口时，由于是在非同一个域下的请求，从而会引发<strong>浏览器</strong>的自我安全保护机制，最终结果是<strong>接口成功请求并响应</strong>，但<strong>前端不能正常处理该返回数据</strong>。</p>
<p><img src="https://i.loli.net/2020/09/08/EGern4xhRwqF7gU.png" alt="Access-Control-Allow-Origin"></p>
<p>因此，当<strong>同时满足</strong>以下三个条件的情况下，就会出现跨域问题：</p>
<ol>
<li>浏览器限制</li>
<li>非同源请求（跨域）</li>
<li>发送的是 XHR ( XMLHttpRequest ) 请求</li>
</ol>
<p><img src="https://i.loli.net/2020/09/08/u8D62HznvwgcM1W.png" alt="跨域问题"></p>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>想要彻底解决跨域问题，只需要破坏以上三个条件的任一即可：</p>
<h4 id="1-修改浏览器（不推荐）"><a href="#1-修改浏览器（不推荐）" class="headerlink" title="1. 修改浏览器（不推荐）"></a>1. 修改浏览器（<strong>不推荐</strong>）</h4><p>添加浏览器启动参数：<code>chrome --disable-web-security</code>，但是极不推荐这种解决方式。</p>
<h4 id="2-JSONP请求（不常用）"><a href="#2-JSONP请求（不常用）" class="headerlink" title="2. JSONP请求（不常用）"></a>2. JSONP请求（<strong>不常用</strong>）</h4><p>Jsonp，全称 <code>JSON with Padding</code>，一种非官方的协议，而是一种约定；前端通过向后台发送 <code>script</code> 类型请求解决跨域，此时接口响应的 <code>application/javascript</code> 类型的数据会作为 <code>callback</code> 函数的参数进行处理。</p>
<p><img src="https://i.loli.net/2020/09/08/1RqpuXFLGTlMjI7.png" alt="Jsonp Request"></p>
<p>所以，后台也需要做相应的处理。以 Java 为例，添加如下配置即可：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@ControllerAdvice</span><br><span class="line">public class JsonpAdvice extends AbstractJsonpResponseBodyAdvice &#123;</span><br><span class="line"></span><br><span class="line">    public JsonpAdvice() &#123;</span><br><span class="line">		// 前后端约定的jsonp参数名，默认值是callback</span><br><span class="line">        super(&quot;callback&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意，<code>Spring 4.1</code> 版本之后，官方已不再推荐使用上述允许 <code>jsonp</code> 请求的配置，建议使用 <code>CROS</code> 配置来解决跨域问题，详情可查看<a href="https://docs.spring.io/spring/docs/5.0.x/spring-framework-reference/web.html#mvc-cors" target="_blank" rel="noopener">这里</a></p>
</blockquote>
<p>综上，<code>jsonp</code> 请求存在以下几个弊端：</p>
<ol>
<li>服务端需要改动代码进行支持；</li>
<li>只支持发送 <code>Get</code> 请求，请求头中更改其它类型的请求方式是无效的；</li>
<li>发送的不是 <code>XHR</code> 请求，而是 <code>script</code> 类型，无法享受到相关的特性。</li>
</ol>
<h4 id="3-调用方隐藏跨域"><a href="#3-调用方隐藏跨域" class="headerlink" title="3. 调用方隐藏跨域"></a>3. 调用方隐藏跨域</h4><p>用 <code>Nginx</code> 或 <code>Apache</code> 来代理调用方的请求（<strong>客户端变更为相对路径请求，而非绝对路径</strong>），此时对于浏览器来说，由于请求是同源的，因此就不存在跨域问题。</p>
<h4 id="4-被调用方允许跨域（最常用）"><a href="#4-被调用方允许跨域（最常用）" class="headerlink" title="4. 被调用方允许跨域（最常用）"></a>4. 被调用方允许跨域（<strong>最常用</strong>）</h4><ul>
<li>服务端配置</li>
</ul>
<p>以 Java 应用为例，添加如下全局配置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class CorsConfig implements WebMvcConfigurer &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void addCorsMappings(CorsRegistry registry) &#123;</span><br><span class="line">        registry.addMapping(&quot;/**&quot;)  // 允许跨域的接口</span><br><span class="line">                .allowedOrigins(&quot;*&quot;)  // 允许跨域的请求源</span><br><span class="line">                .allowedMethods(&quot;*&quot;)  // 允许跨域的请求方式</span><br><span class="line">                .allowedHeaders(&quot;*&quot;) // 允许跨域的请求头</span><br><span class="line">                .allowCredentials(true)  // 带cookie请求的时候需要开启，且allowedOrigins需要指定为具体的请求源（最好是动态配置）</span><br><span class="line">                .maxAge(60 * 60 * 24); // 设定options请求预检命令的缓存时长</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果只想针对某个类下的接口，或者是某个具体的接口配置允许跨域，只需要在相应的地方添加注解 <code>@CrossOrigin</code> 即可。</p>
<ul>
<li>Nginx 配置</li>
</ul>
<p>如果配置了 <code>nginx</code> 作为代理服务器，那么只需要为 <code>nginx</code> 添加支持跨域请求即可：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">	listen 80;</span><br><span class="line">	server_name xxx.com;</span><br><span class="line"></span><br><span class="line">	location / &#123;</span><br><span class="line">		proxy_pass http://localhost:8080/;</span><br><span class="line"></span><br><span class="line">		# 配置允许跨域</span><br><span class="line">		add_header Access-Control-Allow-Origin $http_origin;</span><br><span class="line">		add_header Access-Control-Allow-Methods *;</span><br><span class="line">		add_header Access-Control-Allow-Headers $http_access_control_request_headers;</span><br><span class="line">		add_header Access-Control-Max-Age 3600;</span><br><span class="line">		add_header Access-Control-Allow-Credentials true;</span><br><span class="line">		</span><br><span class="line">		# 对于options预检请求，直接响应200</span><br><span class="line">		if ($request_method = OPTIONS) &#123;</span><br><span class="line">			return 200;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="扩展思考"><a href="#扩展思考" class="headerlink" title="扩展思考"></a>扩展思考</h2><p>Q1：浏览器在执行跨域请求时，是先执行后判断，还是先判断后执行？<br>A1：都有可能，这需要根据所发送的请求是<strong>简单请求</strong>还是<strong>非简单请求</strong>来判断；如果是非简单请求，浏览器每次在执行真正的请求之前，还会先发送一个 <code>options</code> 请求方式的预检命令【 <strong>可设定缓存时长，取消每次请求都要预检，提高效率，参考上面的服务端配置</strong> 】。关于两种请求的区分及定义，参考下图说明：</p>
<p><img src="https://i.loli.net/2020/09/08/TWOvdB8wLxclq65.png" alt="简单请求 VS 非简单请求"></p>
<p>Q2：如果是允许带（<strong>被调用方</strong>） <code>cookie</code> 的跨域请求，此时服务端同样配置为 <code>Access-Control-Allow-Origin</code> 等于 <code>*</code>，前端是否还可以请求成功？<br>A2：不可以，此时要将 <code>Access-Control-Allow-Origin</code> 指定为<strong>调用方</strong>具体的域【 <strong>可以先取得调用方的域再动态配置，这样就不存在多个域请求的限制问题</strong> 】，并且添加配置 <code>Access-Control-Allow-Credentials</code> 为 <code>true</code>。</p>
<p><strong>本文为作者原创 转载时请注明出处 谢谢</strong></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em>乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</em></p>
]]></content>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>关于mysql崩溃之error establishing a database connection</title>
    <url>/210.html</url>
    <content><![CDATA[<h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>最近在进行网站检查的时候突然发现我的一个子网站挂了,提示<code>error establishing a database connection</code>, 如果是网站刚建立那好解决,80%的概率是数据连接参数不正确,或者是数据库端口没有开放</p>
<p>但是我这个网站运行很长一段时间了,之前一直好好的,突然之间就挂了, 而且这个数据库我使用的是<code>docker</code>进行维护,同时,在同一个<code>mysql</code>容器中我放置了好几个网站的数据,其他网站运行却是正常的</p>
<p>而且我通过第三方连接数据库的工具可以正常连接到被挂网站的数据库</p>
<p>通过以上情况可以排除以下原因:</p>
<ul>
<li><code>mysql</code>容器没有问题</li>
<li>数据库端口和连接参数也没问题(已经检查过配置文件,没有被外部篡改过)</li>
<li>网站程序正常运行</li>
</ul>
<p>这种情况下该如何处理呢? 当然是找日志了</p>
<p>第一步:查看主程序日志,没问题</p>
<p>第二步:查看<code>mysql</code>容器日志,发现问题</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker logs --tail=50 mysql</span><br></pre></td></tr></table></figure>

<p><code>Table &#39;./wordpress_wai/wp_options&#39; is marked as crashed and should be repaired when using LOCK TABLES</code></p>
<p><strong>数据库没有问题,但是表有问题</strong></p>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p><strong>对表进行修复即可：</strong></p>
<p>首先登录mysql选择指定的数据库,然后执行以下命令:</p>
<ol>
<li><p>执行修复指令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">repair table wp_option</span><br></pre></td></tr></table></figure>
</li>
<li><p>检查表的状态</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">check table wp_option</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>修复前最好先备份数据库</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysqldump -uroot -p密码 数据库名 &gt;xxxxx.sql</span><br></pre></td></tr></table></figure>

<p>如果表损坏比较严重,可能无法备份数据库</p>
<p>如果你不知道如何查看<code>mysql</code>日志,那么直接运行备份数据库指令,也能帮你检查数据库是否存在问题</p>
<p>修复完成后无需重启mysql容器, 直接刷新网址即可正常访问</p>
<h3 id="2021年9月1日补充"><a href="#2021年9月1日补充" class="headerlink" title="2021年9月1日补充"></a>2021年9月1日补充</h3><p>突然数据库又崩了, 网站同样提示<code>error establishing a database connection</code></p>
<p>我查看<code>docker</code>日志 报如下错误:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Database page corruption on disk or a failed file read of page [page id: space=0, page number=5]. You may have to recover from a backup</span><br></pre></td></tr></table></figure>

<p>此时<code>mysql</code>容器已经进不去了, 百度了一下说是数据库受损 要在<code>my.cnf</code>配置文件中添加<code>innodb_force_recovery=1</code></p>
<p>可是我在<code>conf</code>目录下并没有找到<code>my.cnf</code>文件 不知道是被谁给删了 难道被入侵了</p>
<p>只好新建一个配置文件看看可不可行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vim my.cnf</span><br></pre></td></tr></table></figure>

<p>然后将以下内容拷贝进去:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">pid-file        = /var/run/mysqld/mysqld.pid</span><br><span class="line">socket          = /var/run/mysqld/mysqld.sock</span><br><span class="line">datadir         = /var/lib/mysql</span><br><span class="line">secure-file-priv= NULL</span><br><span class="line"># Disabling symbolic-links is recommended to prevent assorted security risks</span><br><span class="line">symbolic-links=0</span><br><span class="line"></span><br><span class="line"># Custom config should go here</span><br><span class="line">!includedir /etc/mysql/conf.d/</span><br></pre></td></tr></table></figure>

<p><code>wq</code>保存退出 然后重启<code>mysql</code>容器, 重新访问网站 还是不行</p>
<p>紧接着我在配置文件末尾添加了<code>innodb_force_recovery=1</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">pid-file        = /var/run/mysqld/mysqld.pid</span><br><span class="line">socket          = /var/run/mysqld/mysqld.sock</span><br><span class="line">datadir         = /var/lib/mysql</span><br><span class="line">secure-file-priv= NULL</span><br><span class="line"># Disabling symbolic-links is recommended to prevent assorted security risks</span><br><span class="line">symbolic-links=0</span><br><span class="line"></span><br><span class="line"># Custom config should go here</span><br><span class="line">!includedir /etc/mysql/conf.d/</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">innodb_force_recovery=1</span><br></pre></td></tr></table></figure>

<p>保存重启后, 网站正常访问, 问题解决</p>
<p>但是mysql容器日志一直提示:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[ERROR] [MY-012803] [InnoDB] innodb_force_recovery is on. We do not allow database modifications by the user. Shut down mysqld and edit my.cnf to set innodb_force_recovery=0</span><br></pre></td></tr></table></figure>

<p>于是我把<code>innodb_force_recovery</code>值设为0 网站没问题 暂且就这样</p>
<h4 id="关于innodb-force-recovery参数"><a href="#关于innodb-force-recovery参数" class="headerlink" title="关于innodb_force_recovery参数"></a>关于innodb_force_recovery参数</h4><ul>
<li>Mode 1当遇到损坏页时，不使 MySQL 崩溃</li>
<li>Mode 2不运行后台操作</li>
<li>Mode 3不会尝试回滚事务</li>
<li>Mode 4不计算统计数据或应用存储/缓冲的变化</li>
<li>Mode 5在启动过程中不查看撤消日志</li>
<li>Mode 6在启动时不从重做日志（ib_logfiles）前滚</li>
</ul>
<p><strong>本文为作者原创 转载时请注明出处 谢谢</strong></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em>乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</em></p>
]]></content>
      <tags>
        <tag>网站运维</tag>
      </tags>
  </entry>
  <entry>
    <title>视频帧率和码率对视频质量和文件大小的影响</title>
    <url>/211.html</url>
    <content><![CDATA[<p>我们从<strong>画面流畅度</strong>,<strong>画面清晰度</strong>,和<strong>视频文件体积</strong>三个方面进行分析:</p>
<h2 id="帧率-FPS"><a href="#帧率-FPS" class="headerlink" title="帧率(FPS)"></a>帧率(FPS)</h2><p><strong>指每秒显示图像的张数</strong></p>
<p>比如30帧,表示每秒显示30张图像</p>
<p><strong>帧率越大,画面越流畅,帧率越小,画面越卡顿</strong>,如果低到1帧/秒,那么就相当于一个幻灯片了</p>
<p><strong>帧率不会影响到画面的清晰度,只会影响画面的流畅度和文件的体积</strong>,帧率越大,视频对应的体积越大</p>
<h2 id="分辨率-resolution"><a href="#分辨率-resolution" class="headerlink" title="分辨率(resolution)"></a>分辨率(resolution)</h2><p><strong>指像素点分布密度</strong></p>
<p>比如24寸的显示器,设置1920x1080的分辨率,那就是横向由1920个像素点构成,纵向由1080个像素点构成,也就是说在屏幕尺寸固定的情况下,<strong>分辨率越高,画面越清晰细腻,反之,画面越模糊</strong></p>
<p><strong>分辨率不会影响画面的流畅度,只会影响画面的清晰度和文件的体积</strong>,分辨率越大,视频体积越大</p>
<h2 id="码率-Bitrate"><a href="#码率-Bitrate" class="headerlink" title="码率(Bitrate)"></a>码率(Bitrate)</h2><p><strong>指每秒传输的数据位数</strong>,单位kbps 即千位每秒 ,这里的位指的是二进制位</p>
<p>基本的算法是:</p>
<ul>
<li><p>每秒传输的数据量=码率/8 </p>
</li>
<li><p>视频文件体积=码率/8x视频时长(s) =每秒传输的数据量*视频时长(s)</p>
</li>
</ul>
<p>比如500Kbps,也就是每秒传输62K大小的数据, 假如按照帧率30fps进行计算,那么每张图片大小约为2kb大小</p>
<p>也就是说视频时长固定的情况下,<strong>码率越高,文件体积越大,同时视频显示的有效像素越多</strong>,视频更加接近原始分辨率,反之,码率越低,文件体积越小,但是视频能显示的有效像素就越少,原本1080p的分辨率,每帧图像至少需要占用20k的数据量,但是码率过低每帧只能分配2K的量,此时像素点显示不全,就会造成视频模糊不清晰</p>
<p>因此,码率若是过低,再高的分辨率都拯救不了画质,反而会适得其反, </p>
<p>事实上,低码率环境下,低分辨率画面要比高分辨率画面更加清晰</p>
<p><strong>码率不会影响画面的流畅度,但是会影响画面的清晰度和文件的体积</strong></p>
<h2 id="我们的需求"><a href="#我们的需求" class="headerlink" title="我们的需求"></a>我们的需求</h2><p>我们一般<strong>追求高清流畅的画质,同时文件体积尽可能小</strong>,那么该如何找到帧率 码率和分辨率三者的平衡点呢?</p>
<p>首先在我们录制视频的时候,<strong>屏幕的分辨率一般是固定的</strong>,随着不同的电脑分辨率也不同(当然你要手动调整也行)</p>
<p>其次,为了保证视频的流畅度我们一般将<strong>帧率设置在25fps</strong>以上</p>
<p>那么我们想减小视频的体积的话,只能从码率入手了, 找到一个画质能接受,体积小的平衡点</p>
<p>比如1980x1080的分辨率,我使用500kbps左右的码率,差不多可以接受,OBS在录制时默认也是在这个码率内来回波动</p>
<p>以下是常见分辨率和码率之间平衡参考表:</p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20210124171800.png" alt></p>
<p><strong>举例</strong>:如果要想百分百还原1080p HQ的画质,至少需要5.76Mkpbs码率的支撑,如果是直播的话需要至少9M的宽带才能稳定传输对应的数据量,否则画面卡顿</p>
<p>直播中,在分辨率和网速一定的情况下,我们会适当降低码率,牺牲部分清晰度的来保证视频的流畅性</p>
<p>如果网速不行又希望画面还清晰流畅,那么就降低拍摄的分辨率,同时降低数据传输量也就是码率值,当然分辨率降低之后所谓的视频清晰度也只是相对的,凡事总有取舍</p>
<p><strong>本文为作者原创 转载时请注明出处 谢谢</strong></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt="img"></p>
<p><em>乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</em></p>
]]></content>
      <tags>
        <tag>视频录制</tag>
      </tags>
  </entry>
  <entry>
    <title>汇编语言之GNU ARM</title>
    <url>/212.html</url>
    <content><![CDATA[<h2 id="什么是GNU"><a href="#什么是GNU" class="headerlink" title="什么是GNU"></a>什么是GNU</h2><p>GNU最开始其实是一个<strong>操作系统</strong>,旨为打造一个开源免费自由的操作系统,目前操作系统还在完善中</p>
<p><strong>GNU计划</strong>: 最初目标是创建一套完全自由的操作系统GNU 和相应的软件</p>
<p><strong>GCC</strong> :（GNU Compiler Collection）GNU编译器套件,GNU提供的一整套的工具集,这套工具集中包含了汇编器,编译器和链接器,二进制转换,调试工具等</p>
<p><strong>GCC优势</strong>:</p>
<ul>
<li>免费开源</li>
<li>贴近系统底层,功能强大,灵活性高</li>
<li>跨平台，方便<a href="https://code.newban.cn/201.html">交叉编译</a></li>
</ul>
<p><strong>GCC劣势</strong>:</p>
<ul>
<li>工具基本采用命令行方式,学习和使用门槛较高</li>
</ul>
<p>接下来我们要学习的就是GNU计划众多的产物之一<strong>GNU FOR ARM</strong></p>
<h2 id="汇编器与指令集"><a href="#汇编器与指令集" class="headerlink" title="汇编器与指令集"></a>汇编器与指令集</h2><ol>
<li><p><strong>什么是汇编器</strong></p>
<p>将汇编语言翻译成机器码的工具</p>
</li>
<li><p><strong>什么是编译器</strong></p>
<p>将高级语言翻译成机器语言或者汇编语言的工具</p>
</li>
<li><p><strong>汇编器和编译器的区别</strong></p>
<p>汇编器的服务对象是汇编语言,编译器的服务对象是高级语言</p>
</li>
<li><p><strong>汇编器和汇编语法伪指令的关系</strong></p>
<p>不同的CPU对应不同的指令集 ,不同的汇编器对应不同的伪指令集和汇编语法。</p>
<p>每种汇编器都可以有自己的伪指令集和自己的语法</p>
</li>
</ol>
<p>使用不同的汇编器汇编同一个cpu架构的汇编代码,所对应的指令绝对是一致的,但伪指令各有千秋</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">;使用ARM官方的汇编器</span><br><span class="line">  	AREA test, CODE</span><br><span class="line">	mov R3,#5</span><br><span class="line">    END		</span><br><span class="line">    </span><br><span class="line">;使用GNU的汇编器</span><br><span class="line">    .text    ;伪指令</span><br><span class="line">    mov R3,#5   ;传送指令皆为mov</span><br><span class="line">    .end</span><br></pre></td></tr></table></figure>

<h2 id="常见的汇编器"><a href="#常见的汇编器" class="headerlink" title="常见的汇编器"></a>常见的汇编器</h2><ul>
<li><strong>MASM汇编器</strong>:微软旗下专为<strong>x86架构</strong>打造的一款汇编器,支持8086汇编和win32汇编</li>
<li><strong>GNU汇编器</strong> : 简称为<strong>GAS</strong>,是GNU旗下的一款免费开源跨平台汇编器其子集中包含了支持多种架构的汇编器,比如<code>GNU FOR ARM</code>就是单独面向ARM架构的汇编器,此外还有<code>GNU FOR X86</code>等</li>
<li><strong><a href="https://www.nasm.us/pub/nasm/releasebuilds/2.14.03rc2/win64/" target="_blank" rel="noopener">NASM汇编器</a></strong>: 是一款面向<strong>x86架构</strong>的汇编器,支持8086汇编和win32汇编,同时可跨平台, 免费开源</li>
<li><strong>ARMASM汇编器</strong>:ARM官方原生的汇编器,集成在了ADS工具上,适用于<strong>ARM架构</strong>,我们也一般称之为<strong>ADS汇编器</strong></li>
</ul>
<h2 id="两种ARM汇编器的各自用途"><a href="#两种ARM汇编器的各自用途" class="headerlink" title="两种ARM汇编器的各自用途"></a>两种ARM汇编器的各自用途</h2><ul>
<li><strong>ARMASM汇编器</strong>:一般用于windows平台</li>
<li><strong>GAS汇编器</strong>:支持windows平台和linux平台，方便跨平台<a href="https://code.newban.cn/201.html">交叉编译</a></li>
</ul>
<p>由于移动设备如<strong>安卓和iphone</strong>底层都是采用GNU的编译环境，我们如果要进行移动端的开发，那么势必需要掌握GNU ARM, 同时和ADS和KEIL收费工具相比,GUN工具全部免费,方便开发者进行使用</p>
<blockquote>
<p>如果你是从事android开发,有兴趣可以去翻NDK r17以下版本的库,里面用的编译工具就是GCC</p>
</blockquote>
<h2 id="GNU-ARM开发环境搭建"><a href="#GNU-ARM开发环境搭建" class="headerlink" title="GNU ARM开发环境搭建"></a>GNU ARM开发环境搭建</h2><p>我们需要准备以下两个工具:</p>
<ol>
<li><strong>GCC编译套件</strong></li>
<li><strong>安卓模拟器</strong></li>
</ol>
<p>GCC编译套件根据cpu架构和操作系统的不同,又分为了很多子类:</p>
<ul>
<li><strong>纯ARM裸机</strong>: 对应<code>arm-none-eabi</code>工具包</li>
<li><strong>ARM架构+Linux操作系统</strong>:对应<code>arm-none-linux-eabi</code>工具包</li>
</ul>
<p>由于接下来我们选择在安卓模拟器上进行开发学习,因此我们选择<code>arm-none-linux-eabi</code>这套工具来进行代码的编译</p>
<p><a href="https://code.newban.cn/202.html">工具下载</a></p>
<p><a href="https://code.newban.cn/215.html">GCC工具的具体使用</a></p>
<h2 id="伪指令和伪操作"><a href="#伪指令和伪操作" class="headerlink" title="伪指令和伪操作"></a>伪指令和伪操作</h2><ol>
<li><p>注释</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@我是注释</span><br></pre></td></tr></table></figure>
</li>
<li><p>段的声明</p>
<ul>
<li><p>代码段</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.text</span><br><span class="line">	@代码</span><br></pre></td></tr></table></figure>
</li>
<li><p>数据段</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.data</span><br><span class="line">	@代码</span><br></pre></td></tr></table></figure>


</li>
</ul>
</li>
</ol>
<ul>
<li><p>自定义一个段</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.section .pangshu @定义一个名为.panghsu的段</span><br></pre></td></tr></table></figure>




</li>
</ul>
<ol start="3">
<li><p>函数或者标签的声明</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fun:  @在GNU环境中标签后面需要加冒号,而原生环境则不用</span><br><span class="line">	mov R0,#4</span><br><span class="line">	bx lr</span><br></pre></td></tr></table></figure>
</li>
<li><p>数据的声明</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.byte @定义单字节数据，例如：.byte 0x14；</span><br><span class="line">.short @定义双字节数据，例如：.short 0x1000；</span><br><span class="line">.long @定义四字节数据，例如：.long 0x10001000；</span><br><span class="line">.quad @定义8字节，如：.quad 0x1234567890abcd；</span><br><span class="line">.float @定义浮点数，如：.float 0f-314159265358979323846264338327/95028841971.693993751E-40 @ -pi</span><br><span class="line"></span><br><span class="line">@字符串定义</span><br><span class="line">.string “abcd”, “efgh”, “hello!”</span><br><span class="line">.asciz “qwer”, “sun”, “world!”</span><br><span class="line">.ascii “welcome/0”</span><br><span class="line">@需要注意的是：.ascii伪操作定义的字符串需要自行添加结尾字符’/0’。</span><br></pre></td></tr></table></figure>
</li>
<li><p>数据的批量定义</p>
<ul>
<li><p>格式如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.rept @重复次数</span><br><span class="line">  @数据定义代码</span><br><span class="line">.endr @结束重复定义</span><br></pre></td></tr></table></figure>
</li>
<li><p>示例</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.rept 3</span><br><span class="line">.byte 0x23</span><br><span class="line">.endr</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>关于align</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.global _start</span><br><span class="line">_start:</span><br><span class="line">    mov r0, #0x12</span><br><span class="line">	</span><br><span class="line">    .byte 0x12</span><br><span class="line">    .byte 0x34</span><br><span class="line"></span><br><span class="line">    ;.align 后跟为0，1，2或者不跟参数时都当作是4字节对齐</span><br><span class="line">.align </span><br><span class="line">    .byte 0x56</span><br><span class="line"></span><br><span class="line">    ; 2^3次方，8字节对齐</span><br><span class="line">.align 3</span><br><span class="line">    .word 0x1</span><br><span class="line">	</span><br><span class="line">    ; 2^5次访，32字节对齐</span><br><span class="line">.align 5</span><br><span class="line">    .word 0x2	</span><br><span class="line">	</span><br><span class="line">    ; 填充0x12345678，直到16字节对齐</span><br><span class="line">.balignl 16,0x12345678	</span><br><span class="line"></span><br><span class="line">    ;字符串</span><br><span class="line">    .ascii &quot;abc123&quot;</span><br><span class="line">	</span><br><span class="line">.align	</span><br><span class="line">    ;.ascii和.asciz的区别是，.asciz会在字符串后自动添加结束符\0. </span><br><span class="line">    .asciz &quot;def456&quot;</span><br><span class="line"></span><br><span class="line">    mov r0, #0xab</span><br><span class="line">	</span><br><span class="line">    ;.balign[wl] align, fill_value, max_padding</span><br><span class="line">.align</span><br><span class="line">    ; .balign 后跟的align参数必须为2的次方，否则会报错，按字节填充， fill_value要为字节</span><br><span class="line">.balign 8, 0x12</span><br><span class="line"></span><br><span class="line">    ; .balignw 按2字节填充</span><br><span class="line">.balignw 8, 0x3456	</span><br><span class="line"></span><br><span class="line">    ; .balignl 按4字节填充</span><br><span class="line">.balignl 8, 0xabcdef01</span><br></pre></td></tr></table></figure>

<p>反汇编后的结果：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">00000000</span> &lt;_start&gt;:</span><br><span class="line">   <span class="number">0</span>:	e3a00012 	mov	r0, #<span class="number">18</span></span><br><span class="line">   <span class="number">4</span>:	<span class="number">3412</span>      	.<span class="keyword">short</span>	<span class="number">0x3412</span>              <span class="comment">// .byte 0x12 和 .byte 0x34</span></span><br><span class="line">   <span class="number">6</span>:	<span class="number">0000</span>      	.<span class="keyword">short</span>	<span class="number">0x0000</span>              <span class="comment">// .align 引起的填充</span></span><br><span class="line">   <span class="number">8</span>:	<span class="number">00000056</span> 	andeq	r0, r0, r6, asr r0  <span class="comment">// .byte 0x56</span></span><br><span class="line">   c:	e1a00000 	nop			; (mov r0, r0)  <span class="comment">// .align 3 8字节对齐</span></span><br><span class="line">  <span class="number">10</span>:	<span class="number">00000001</span> 	.word	<span class="number">0x00000001</span>          <span class="comment">// .word 0x1</span></span><br><span class="line">  <span class="number">14</span>:	e1a00000 	nop			; (mov r0, r0)  <span class="comment">// .align 5 ,32字节对齐</span></span><br><span class="line">  <span class="number">18</span>:	e1a00000 	nop			; (mov r0, r0)</span><br><span class="line">  <span class="number">1</span>c:	e1a00000 	nop			; (mov r0, r0)</span><br><span class="line">  <span class="number">20</span>:	<span class="number">00000002</span> 	.word	<span class="number">0x00000002</span>          <span class="comment">// .word 0x2	</span></span><br><span class="line">  <span class="number">24</span>:	<span class="number">12345678</span> 	.word	<span class="number">0x12345678</span>          <span class="comment">// .balignl 16,0x12345678,填充0x12345678，直到16字节对齐</span></span><br><span class="line">  <span class="number">28</span>:	<span class="number">12345678</span> 	.word	<span class="number">0x12345678</span></span><br><span class="line">  <span class="number">2</span>c:	<span class="number">12345678</span> 	.word	<span class="number">0x12345678</span></span><br><span class="line">  <span class="number">30</span>:	<span class="number">31636261</span> 	.word	<span class="number">0x31636261</span>          <span class="comment">// .ascii "abc123"</span></span><br><span class="line">  <span class="number">34</span>:	<span class="number">3332</span>      	.<span class="keyword">short</span>	<span class="number">0x3332</span></span><br><span class="line">  <span class="number">36</span>:	<span class="number">0000</span>      	.<span class="keyword">short</span>	<span class="number">0x0000</span></span><br><span class="line">  <span class="number">38</span>:	<span class="number">34666564</span> 	.word	<span class="number">0x34666564</span>          <span class="comment">// .asciz "def456"</span></span><br><span class="line">  <span class="number">3</span>c:	<span class="number">3635</span>      	.<span class="keyword">short</span>	<span class="number">0x3635</span></span><br><span class="line">  <span class="number">3</span>e:	<span class="number">00</span>          	.byte	<span class="number">0x00</span></span><br><span class="line">  <span class="number">3f</span>:	e3a000ab 	mov	r0, #<span class="number">171</span>	; <span class="number">0xab</span>      <span class="comment">// mov r0, #0xab, 这里就不对齐了</span></span><br><span class="line">  <span class="number">43</span>:	<span class="number">00</span>          	.byte	<span class="number">0x00</span></span><br><span class="line">  <span class="number">44</span>:	<span class="number">12121212</span> 	.word	<span class="number">0x12121212</span>          <span class="comment">// .balign 8, 0x12</span></span><br><span class="line">  <span class="number">48</span>:	e1a00000 	nop			; (mov r0, r0)</span><br><span class="line">  <span class="number">4</span>c:	e1a00000 	nop			; (mov r0, r0)</span><br><span class="line">  <span class="number">50</span>:	e1a00000 	nop			; (mov r0, r0)</span><br><span class="line">  <span class="number">54</span>:	e1a00000 	nop			; (mov r0, r0)</span><br><span class="line">  <span class="number">58</span>:	e1a00000 	nop			; (mov r0, r0)</span><br><span class="line">  <span class="number">5</span>c:	e1a00000 	nop			; (mov r0, r0)</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="指令和伪指令的区别"><a href="#指令和伪指令的区别" class="headerlink" title="指令和伪指令的区别"></a>指令和伪指令的区别</h2><ul>
<li><p><strong>指令</strong>: 有与之对应的机器码,能被cpu所识别,和编译器无关</p>
</li>
<li><p><strong>伪指令</strong>:没有与之对应的机器码,无法被cpu识别,只能被编译器识别,不同编译器伪指令不一样</p>
<p>不同的CPU对应不同的指令集；不同的汇编器对应不同的语法和伪指令集 </p>
</li>
</ul>
<p>例子:ARM原生编译器和GNU FOR ARM</p>
<h2 id="两种汇编器语法对比一览表"><a href="#两种汇编器语法对比一览表" class="headerlink" title="两种汇编器语法对比一览表"></a>两种汇编器语法对比一览表</h2><table>
<thead>
<tr>
<th>GNU ARM汇编</th>
<th>ADS ARM汇编</th>
</tr>
</thead>
<tbody><tr>
<td>“@”或“/<em>…</em>/”</td>
<td>“;”</td>
</tr>
<tr>
<td>.include</td>
<td>GET</td>
</tr>
<tr>
<td>.equ</td>
<td>EQU</td>
</tr>
<tr>
<td>.global</td>
<td>EXPORT</td>
</tr>
<tr>
<td>.extern</td>
<td>IMPORT</td>
</tr>
<tr>
<td>.long</td>
<td>DCD</td>
</tr>
<tr>
<td>.end</td>
<td>END</td>
</tr>
<tr>
<td>entry:</td>
<td>ENTRY</td>
</tr>
<tr>
<td>.text</td>
<td>AREA Init,CODE,READONLY</td>
</tr>
<tr>
<td>.data</td>
<td>AREA Block,DATA,READWRITE</td>
</tr>
<tr>
<td>.macro</td>
<td>MACRO</td>
</tr>
<tr>
<td>.endm</td>
<td>MEND</td>
</tr>
</tbody></table>
<h2 id="汇编语言和C语言交互"><a href="#汇编语言和C语言交互" class="headerlink" title="汇编语言和C语言交互"></a>汇编语言和C语言交互</h2><h4 id="1-引入其他源文件函数"><a href="#1-引入其他源文件函数" class="headerlink" title="1.引入其他源文件函数"></a>1.引入其他源文件函数</h4><p>使用<code>import</code>或者<code>extern</code>伪指令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">;使用import伪指令</span><br><span class="line">AREA code, CODE</span><br><span class="line">import fun1         ;导入其他源文件中名为fun1的函数</span><br><span class="line">END</span><br><span class="line"></span><br><span class="line">;使用extern伪指令</span><br><span class="line">AREA code, CODE</span><br><span class="line">extern fun1       </span><br><span class="line">END</span><br></pre></td></tr></table></figure>

<p><strong>两者区别:</strong></p>
<ul>
<li><code>import</code>:不管当前文件是否使用该引入的函数,该标签都会加入当前文件符号表,即为静态引用</li>
<li><code>extern</code>:只有当前文件使用了该函数,才会将此标签加入符号表,即为动态引用</li>
</ul>
<h4 id="2-导出当前源文件中函数供其他文件访问"><a href="#2-导出当前源文件中函数供其他文件访问" class="headerlink" title="2.导出当前源文件中函数供其他文件访问"></a>2.导出当前源文件中函数供其他文件访问</h4><p>使用<code>export</code>或者<code>global</code>伪指令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">;使用import伪指令</span><br><span class="line">AREA code, CODE</span><br><span class="line">export fun         ;导出fun函数供其他源文件使用</span><br><span class="line"></span><br><span class="line">fun </span><br><span class="line">	mov R0,#4</span><br><span class="line">	bx lr</span><br><span class="line">END</span><br></pre></td></tr></table></figure>

<h4 id="3-外链汇编之C语言调汇编函数"><a href="#3-外链汇编之C语言调汇编函数" class="headerlink" title="3.外链汇编之C语言调汇编函数"></a>3.外链汇编之C语言调汇编函数</h4><p>第一步,在汇编原文件中将函数暴露出来给供外部调用,使用<code>export</code>或者<code>global</code>伪指令:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">AREA code, CODE</span><br><span class="line">export arm_strcpy  ;或者使用global</span><br><span class="line"></span><br><span class="line">arm_strcpy</span><br><span class="line">loop </span><br><span class="line">	ldrb R4,[R0],#1 ;如果使用ldr 那么将偏移值改成4</span><br><span class="line">	cmp R4,#0</span><br><span class="line">	beq over</span><br><span class="line">	strb R4,[R1],#1</span><br><span class="line">	b loop</span><br><span class="line">over	</span><br><span class="line">END</span><br></pre></td></tr></table></figure>

<p>第二步,在C文件中引用汇编中的函数,C文件中只能使用<code>extern</code>伪指令:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">extern arm_strcpy(char *src,char*des);</span><br><span class="line"></span><br><span class="line">int main2()&#123;</span><br><span class="line">	char *a=&quot;hello pangshu&quot;;</span><br><span class="line">	char b[64];</span><br><span class="line">	arm_strcpy(a,b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-外链汇编之汇编调c语言函数"><a href="#4-外链汇编之汇编调c语言函数" class="headerlink" title="4.外链汇编之汇编调c语言函数"></a>4.外链汇编之汇编调c语言函数</h4><p>第一步,在C文件中编写好函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">c_sum</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a+b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第二步, 在汇编文件中引入函数,使用<code>import</code>或者<code>extern</code>伪指令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">AREA code, CODE</span><br><span class="line">import c_sum  </span><br><span class="line"></span><br><span class="line">mov R0,#1 ;第一个参数</span><br><span class="line">mov R1,#2 ;第二个参数</span><br><span class="line"></span><br><span class="line">END</span><br></pre></td></tr></table></figure>

<p>第三步, 使用BL指令调用函数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">AREA code, CODE</span><br><span class="line">import c_sum  </span><br><span class="line"></span><br><span class="line">mov R0,#1 ;第一个参数</span><br><span class="line">mov R1,#2 ;第二个参数</span><br><span class="line">BL c_sum</span><br><span class="line">END</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在ARM中函数参数使用R0~R3这三个寄存器来进行传递,最多传递4个参数,超过4个参数使用栈进行处理,函数返回值通过R0进行传递</p>
</blockquote>
<h4 id="5-内嵌汇编"><a href="#5-内嵌汇编" class="headerlink" title="5.内嵌汇编"></a>5.内嵌汇编</h4><p>GNU内嵌汇编,格式如下:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main2</span><span class="params">()</span></span>&#123;</span><br><span class="line">	__asm__(           <span class="comment">//大括号改成中括号</span></span><br><span class="line">	<span class="string">"mov R5,#0x00000005\n"</span>   <span class="comment">//汇编指令需要使用引号包裹，多条语句之间使用回车换行符进行分隔</span></span><br><span class="line">	<span class="string">"mov R6,#0x00000005"</span></span><br><span class="line">	);  <span class="comment">//需要以分号结尾</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="学习工具"><a href="#学习工具" class="headerlink" title="学习工具"></a>学习工具</h2><ul>
<li>在线ARM汇编编辑器:<a href="https://azm.azerialabs.com/" target="_blank" rel="noopener">https://azm.azerialabs.com/</a></li>
</ul>
<p><strong>本文为作者原创 转载时请注明出处 谢谢</strong></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt="img"></p>
<p><em>乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</em></p>
]]></content>
      <tags>
        <tag>汇编</tag>
      </tags>
  </entry>
  <entry>
    <title>GCC工具的具体使用</title>
    <url>/215.html</url>
    <content><![CDATA[<h2 id="编译工具链"><a href="#编译工具链" class="headerlink" title="编译工具链"></a>编译工具链</h2><p>高级语言翻译成机器语言不是一步到位的,以C语言为例,通常要经历以下四个步骤:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">预处理---&gt;编译---&gt;汇编---&gt;连接</span><br><span class="line"></span><br><span class="line">源代码---&gt;汇编代码---&gt;目标代码---&gt;可执行程序</span><br></pre></td></tr></table></figure>

<p>每一步都需要使用不同的工具,比如源代码需要借助编译工具翻译成汇编代码,汇编代码需要借助汇编器翻译成目标代码,最后还要借助连接器帮忙整理汇总, 那么这些个工具集合到一块就叫做<strong>工具链</strong></p>
<h2 id="GCC工具链"><a href="#GCC工具链" class="headerlink" title="GCC工具链"></a>GCC工具链</h2><p>由GNU提供的一整套的工具集,这套工具集中包含了汇编器,编译器和链接器,二进制转换,调试工具等</p>
<p>通过GCC，我们可以一步完成源码到可执行文件的编译， 也可以单步独立进行，方便程序员获取中间代码代码，进行调试 </p>
<h2 id="GCC常用命令选项"><a href="#GCC常用命令选项" class="headerlink" title="GCC常用命令选项"></a>GCC常用命令选项</h2><p>假设只编译<strong>单个源文件test.c</strong></p>
<ol>
<li><p>无选项编译</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc test.c  </span><br><span class="line">或者</span><br><span class="line">gcc test.o</span><br></pre></td></tr></table></figure>

<p>在当前目录下直接生成可执行文件,默认名称为<code>a.out</code></p>
</li>
<li><p>选项<code>-o</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc test.c  -o test</span><br></pre></td></tr></table></figure>

<p>在当前目录下生成名为<code>test</code>的可执行文件</p>
</li>
<li><p>选项<code>-E</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc -E test.c  -o test.i</span><br></pre></td></tr></table></figure>

<p>在当前目录下生成名为<code>test.i</code>的预处理文件</p>
</li>
<li><p>选项<code>-S</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc -S test.c  -o test.s</span><br></pre></td></tr></table></figure>

<p>在当前目录下生成名为<code>test.s</code>的汇编文件，将源码转成汇编代码</p>
</li>
<li><p>选项<code>-c</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc -c test.c</span><br></pre></td></tr></table></figure>

<p>在当前目录下生成名为<code>test.o</code>的目标文件</p>
</li>
<li><p>选项<code>-O数字</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc -O1 test.c  -o test</span><br></pre></td></tr></table></figure>

<p>在当前目录下生成名为<code>test</code>的可执行文件,并且使用编译优化级别1编译程序。可选级别为1~3，级别越大优化效果越好，但编译时间越长。 </p>
</li>
</ol>
<h2 id="多文件编译"><a href="#多文件编译" class="headerlink" title="多文件编译"></a>多文件编译</h2><p>比如一个汇编文件<code>aaa.s</code>一个C源文件<code>test.c</code>:</p>
<ol>
<li><p><strong>方式一 多文件同时编译</strong></p>
<p>直接追加文件名进行同时编译输出即可</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gcc aaa.s test.c -o bbb</span><br></pre></td></tr></table></figure>

<p> 如果要编译的文件都在同一个目录下，可以用通配符<code>gcc *.c -o</code> 来进行编译 </p>
</li>
<li><p><strong>方式二 多文件分开编译</strong></p>
<p>首先将源文件编译成目标文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc -c aaa.s  //生成aaa.o</span><br><span class="line"></span><br><span class="line">gcc -c test.c  //生成test.o</span><br></pre></td></tr></table></figure>

<p>然后将所有目标文件连接成可执行文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc  test.o aaa.o -o test</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>方式三 编写makefile文件进行编译</strong></p>
<p>第一步 <code>makefile</code>文件编写</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 我是注释</span></span><br><span class="line">SRC=aaa.s test.c</span><br><span class="line">main: $(OBJS)   <span class="comment">#指定需要生成的文件名称以及相应的依赖关系 </span></span><br><span class="line">        gcc -o main $(SRC) <span class="comment">#生成所需要的指令</span></span><br></pre></td></tr></table></figure>

<p>第二步 使用<code>bin</code>包下的<code>cs-make</code>工具，直接在命令窗口中执行该指令，默认在当前目录虚招makefile文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> cs-make</span></span><br></pre></td></tr></table></figure>

<p>该指令实际上执行的就是makefile中我们编写的指令<code>gcc -o main aaa.s test.c</code></p>
</li>
</ol>
<p>以上三种方法相比较，第一中方法编译时需要所有文件重新编译，而第二种方法可以只重新编译修改的文件，未修改的文件不用重新编译 ,第三种方法适用于文件较多依赖关系复杂的工程编译</p>
<p><strong>本文为作者原创 转载时请注明出处 谢谢</strong></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt="img"></p>
<p><em>乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</em></p>
]]></content>
      <tags>
        <tag>编译</tag>
      </tags>
  </entry>
  <entry>
    <title>GCC工具链都包含哪些工具</title>
    <url>/213.html</url>
    <content><![CDATA[<h2 id="GCC"><a href="#GCC" class="headerlink" title="GCC"></a>GCC</h2><p> GCC原名为GNU C语言编译器（GNU C Compiler），原本只能处理C语言。后来随着功能的扩展,支持的语言种类越来越多 ,故更名为<em>GCC</em>（GNU Compiler Collection，GNU编译器套件）</p>
<p>因此 GCC既可以指代C编译器,也可以指代GNU编译套件</p>
<p>其套件囊括了许多子工具:</p>
<ul>
<li><p>gcc: C 编译器</p>
</li>
<li><p>g++: C++ 编译器</p>
</li>
<li><p>cpp: C 预处理器</p>
</li>
<li><p>as: 汇编器</p>
</li>
<li><p>ld: 连接器</p>
</li>
<li><p>objcopy: 目标文件翻译器,用于从连接器输出中创建一个ROM 映像</p>
</li>
<li><p>objdump: 目标文件阅读器, 用于反汇编目标文件</p>
</li>
<li><p>make: make 工具</p>
</li>
<li><p>gdb: 源代码调试器</p>
</li>
</ul>
<h2 id="GCC工具链"><a href="#GCC工具链" class="headerlink" title="GCC工具链"></a>GCC工具链</h2><p>一个程序从代码编译到机器执行,中间需要经历很多步骤,比如从预编译,编译,到汇编和连接, 这一系列环环相扣过程中涉及到的GNU工具集,称之为GCC工具链</p>
<p>在windows平台中,我们有许多的图形化IDE可以选择,一般编译工具链都集成进了软件内部,无需开发者关心,但是在Linux平台,基本以命令行的方式进行操作,那么对于开发者来说,需要了解每个工具的作用和具体使用方法</p>
<p><strong>本文为作者原创 转载时请注明出处 谢谢</strong></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt="img"></p>
<p><em>乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</em></p>
]]></content>
      <tags>
        <tag>GNU</tag>
      </tags>
  </entry>
  <entry>
    <title>汇编语言之行x86_32汇编</title>
    <url>/214.html</url>
    <content><![CDATA[<h2 id="两大汇编语法"><a href="#两大汇编语法" class="headerlink" title="两大汇编语法"></a>两大汇编语法</h2><p>两种语法主要是针对x86架构汇编而言，对于其他架构没有这么一个说法</p>
<ul>
<li>Intel型语法: Intel官方语法，在Windows平台原生环境中采用该语法</li>
<li>AT&amp;T型 :非Intel官方语法，在Unix/Linux的GCC编译环境中采用该语法</li>
</ul>
<h2 id="原生环境搭建"><a href="#原生环境搭建" class="headerlink" title="原生环境搭建"></a>原生环境搭建</h2><ul>
<li>windows系统</li>
<li>RedAsm集成工具</li>
</ul>
<h2 id="指令和语法"><a href="#指令和语法" class="headerlink" title="指令和语法"></a>指令和语法</h2><p>在让我们看看 x86_64 平台提供了哪些寄存器给我们使用，</p>
<ul>
<li>16个通用寄存器，例如，rax，rbx，rcx，rdx等</li>
<li>6个16位段寄存器，例如：cs，ds，等</li>
</ul>
<p><strong>本文为作者原创 转载时请注明出处 谢谢</strong></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt="img"></p>
<p><em>乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</em></p>
]]></content>
      <tags>
        <tag>汇编</tag>
      </tags>
  </entry>
  <entry>
    <title>Makefile的详细介绍和使用</title>
    <url>/216.html</url>
    <content><![CDATA[<p>待完善。。。</p>
<p><a href="https://seisman.github.io/how-to-write-makefile/invoke.html" target="_blank" rel="noopener">makefile详细介绍和使用</a></p>
<h3 id="Makefile定义规则"><a href="#Makefile定义规则" class="headerlink" title="Makefile定义规则"></a>Makefile定义规则</h3><p>参考链接1：<a href="https://seisman.github.io/how-to-write-makefile/invoke.html" target="_blank" rel="noopener">https://seisman.github.io/how-to-write-makefile/invoke.html</a></p>
<p>参考链接2：<a href="https://www.cnblogs.com/LittleHann/p/3855905.html" target="_blank" rel="noopener">https://www.cnblogs.com/LittleHann/p/3855905.html</a></p>
<p>规则是<code>makefile</code>中<strong>最重要的概念</strong>，其告诉<code>make</code> 目标文件的依赖关系，以及如何生成及更新这些目标文件。在<code>makefile</code>文件规则有2种，一种是<strong>显式规则</strong>，另一种是<strong>隐式规则。</strong></p>
<ol>
<li><strong>显示规则</strong></li>
</ol>
<p>显式规则用于说明何时及如何重新生成目标，其列出了目标依赖的文件信息，并通过调用命令来创建或更新目标，其语法一般为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">targets : prerequisites</span><br><span class="line"></span><br><span class="line">recipe</span><br><span class="line">…</span><br></pre></td></tr></table></figure>

<ul>
<li><p>targets：为要生成或更新的目标</p>
</li>
<li><p>prerequisites：为目标依赖的关系</p>
</li>
<li><p>recipe：为生成目标的命令，</p>
<p>一个规则可以有多条recipe，比如</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">foo.o : foo.c defs.h</span><br><span class="line"></span><br><span class="line">cc -c -g foo.c</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>其中<code>foo.o</code>为target，<code>foo.c defs.h</code> 为prerequisites，<code>cc -c -g foo.c</code>为recipe。</p>
<h4 id="示例讲解"><a href="#示例讲解" class="headerlink" title="示例讲解"></a>示例讲解</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">test:main.o channle.o</span><br><span class="line">	gcc main.o channle.o -o test</span><br><span class="line">main.o:main.c function.h</span><br><span class="line">	gcc -c main.c -o main.o</span><br><span class="line">channle.o:channle.c  WavHead.h</span><br><span class="line">	gcc -c channle.c -o channle.o -<span class="built_in">std</span>=c99</span><br><span class="line"></span><br><span class="line">.PHONY:clean</span><br><span class="line">clean:</span><br><span class="line">	-rm -rf *.o</span><br></pre></td></tr></table></figure>

<p>执行的过程简单说就是最终需要生成一个名为test的文件，这个文件需要<code>main.o</code>和<code>channle.o</code>，于是继续往下执行，然后通过命令<code>gcc -c main.c -o main.o</code>得到了<code>main.o</code>文件，同理再得到<code>channle.o</code>文件，最后通过命令<code>gcc main.o channle.o -o test</code>进行链接最终就会得到一个名为test的可执行文件了。</p>
<p>上面的代码在<code>linux</code>的命令窗口下输入<code>make</code>命令就可以执行了，最终会生成一个<code>test</code>的可执行文件。 如果需要清除生成的中间<code>.o</code>文件，输入<code>make clean</code>就可以全部清除了。</p>
<p><strong>本文为作者原创 转载时请注明出处 谢谢</strong></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt="img"></p>
<p><em>乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</em></p>
]]></content>
      <tags>
        <tag>编译</tag>
      </tags>
  </entry>
  <entry>
    <title>GCC调试工具GDB的常用指令</title>
    <url>/217.html</url>
    <content><![CDATA[<h2 id="常用指令"><a href="#常用指令" class="headerlink" title="常用指令"></a>常用指令</h2><ol>
<li><p>进入调试模式</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">gdb 可执行文件</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果忘了指定调试文件可以使用<code>file</code>指令指定</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(gdb) file 文件名</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用<code>quit</code>指令退出调试模式 可简写为q</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">(gdb) q</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用<code>start</code>指令开始调试  停在第一行代码处 </p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">(gdb) start</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用<code>step</code>指令进行单步执行 可简写为<code>s</code></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">(gdb) s   <span class="comment">#会进入函数内部</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>使用<code>next</code>执行进行单步执行 可简写为<code>n</code> </p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">(gdb) n  <span class="comment">#不会进入函数内部</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>汇编级别单步执行(上面<code>n</code>和<code>s</code>为c语言级别单步指令)</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">(gdb) ni <span class="comment">#不进入函数内部</span></span><br><span class="line">(gdb) si <span class="comment">#会进入函数内部</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>使用<code>list</code>指令列出所有源代码 可简写为<code>l</code></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">(gdb) l</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用<code>break</code>指令设置断点位置 可简写为<code>b</code></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">(gdb) b main <span class="comment">#在main函数处打断点</span></span><br><span class="line">(gdb) b 10 <span class="comment">#在第十行位置打断点</span></span><br><span class="line">(gdb) b <span class="built_in">test</span>:10 <span class="comment">#在test文件的第十行位置打断点 </span></span><br><span class="line">(gdb) b 0x3400a <span class="comment">#在0x3400a内存位置打断点</span></span><br><span class="line">(gdb) b 10 <span class="keyword">if</span> i==3 <span class="comment">#设置条件断点 i等于3时在第十行位置打断点 适用于循环</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>使用<code>delete+断点编号</code>指令删除断点 可简写为<code>d</code></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">(gdb) delete 3 <span class="comment">#删除编号为3的断点  清除时GDB不会给出任何提示</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>使用 <code>clear+断点行号</code>指令清除断点</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">(gdb) clear 3 <span class="comment">#清除第三行的断点  清除时GDB会给出提示</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>使用 <code>disable/enable + 断点编号</code> 指令冻结或启动断点</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">disable</span> 3,4 <span class="comment">#冻结编号为3和4的断点 多个断点使用逗号分隔</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>使用<code>info break</code>指令查看断点的情况</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">(gdb) info <span class="built_in">break</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>使用 <code>tbreak</code> 指令设置临时断点</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">(gdb) tbreak 行号/函数名 <span class="comment">#设置临时断点，到达后被自动删除</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>使用 <code>awatch/watch + 变量</code> 设置变量读写观察点</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">(gdb) awatch/watch a <span class="comment">#当变量a被读出或写入时程序被暂停 </span></span><br><span class="line">(gdb) rwatch a <span class="comment">#当变量a被读出时程序被暂停</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>使用<code>continue</code>指令运行到断点处 可简写为<code>c</code></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">(gdb) c</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用<code>print</code>指令打印变量的值 可简写为p</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">(gdb) p a <span class="comment">#打印变量a的值</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>使用x指令打印指定内存地址数据</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">(gdb) x /6cb 0x804835c <span class="comment">#打印地址0x804835c起始的内存内容，连续6个字节，以字符格式输出。</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>使用<code>run</code>指令运行整个程序 可简写为<code>r</code></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">(gdb) r  <span class="comment">#如果此前没有下过断点，则执行完整个程序；如果有断点，则程序暂停在第一个可用断点处</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>使用 call 指令直接运行某个函数</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">(gdb) call fun <span class="comment">#在当前位置执行函数fun</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>使用<code>display</code> 指令设置需要跟踪的变量</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">(gdb) display a <span class="comment">#跟踪变量a 每次断点到该处就显示该变量的值</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>使用 <code>info display</code> 显示当前所有跟踪的情况</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">(gdb) info display</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用<code>undisplay+编号</code> 指令取消对变量的跟踪</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">(gdb) undisplay 3 <span class="comment">#取消对编号为3的跟踪事件</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>使用 <code>set+ 变量</code> 指令改变变量的值</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">(gdb) <span class="built_in">set</span> i=3 <span class="comment">#临时设置变量i的值为3</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>使用 <code>set</code>  指令设置运行时参数</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">(gdb) <span class="built_in">set</span> i=3 <span class="comment">#临时这只变量i的值为3</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>使用 <code>show</code>  指令查看运行时参数</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">(gdb) show i</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用 <code>finish</code> 指令函数结束</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">(gdb) finish</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用<code>help</code>指令查看指令使用说明</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">(gdb) <span class="built_in">help</span> <span class="built_in">print</span> <span class="comment">#查看print指令的解释说明</span></span><br><span class="line">(gdb) <span class="built_in">help</span> <span class="comment">#查看所有指令</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>使用<code>info reg</code>指令查看寄存器状态</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">(gdb)  info reg</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用 <code>info stack</code>指令查看堆栈状态</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">(gdb) info stack</span><br></pre></td></tr></table></figure>
</li>
<li><p>运行shell指令</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">(gdb) shell ls   <span class="comment">#运行shell指令ls。</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>其他指令</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">(gdb)  path <span class="comment">#可设定程序的运行路径。 </span></span><br><span class="line">(gdb)  show paths <span class="comment">#查看程序的运行路径。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">(gdb) 　<span class="built_in">cd</span>　　  <span class="comment">#相当于shell的cd命令。 </span></span><br><span class="line"></span><br><span class="line">(gdb) 　<span class="built_in">pwd</span>　　<span class="comment">#显示当前的所在目录</span></span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="32">
<li>使用<code>回车</code>重复上一条指令</li>
</ol>
<p><strong>本文为作者原创 转载时请注明出处 谢谢</strong></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt="img"></p>
<p><em>乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</em></p>
]]></content>
      <tags>
        <tag>编译</tag>
      </tags>
  </entry>
  <entry>
    <title>GDB与GDBServer配合实现在安卓设备中进行程序调试</title>
    <url>/218.html</url>
    <content><![CDATA[<h2 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h2><ul>
<li><p>windows开发平台</p>
</li>
<li><p>安卓模拟器(ARM架构+linux系统 已Root):</p>
<blockquote>
<p>可以通过<code>adb shell getprop</code>指令查看当前设备的cpu架构</p>
</blockquote>
</li>
<li><p><code>arm-linux-androideabi</code>编译工具 <code>gdb</code>和<code>gdbserver</code>皆存放在此开发包下</p>
</li>
</ul>
<h2 id="实验开始"><a href="#实验开始" class="headerlink" title="实验开始"></a>实验开始</h2><p><strong>第一步 编写测试代码 文件名为<code>test.c</code></strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"> 	<span class="keyword">char</span> *a=<span class="string">"he"</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"hello pangshu"</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>第二步 将测试代码编译成可执行文件</strong></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">arm-linux-androideabi-gcc.exe -g test.c -o main -static <span class="comment">#输出可执行文件名为main</span></span><br></pre></td></tr></table></figure>

<p><strong>第三步 将可执行文件传送到模拟器中</strong></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">adb push main /data/<span class="built_in">local</span>/tmp</span><br></pre></td></tr></table></figure>

<p><strong>第四步 将<code>gdbserver</code>工具传送到模拟器中</strong></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">adb push gdbserver /data/<span class="built_in">local</span>/tmp</span><br></pre></td></tr></table></figure>

<p><strong>第五步 进入模拟器<code>shell</code>窗口,使用<code>gdbserver</code>执行程序</strong></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">./gdbserver 192.168.177.71:23946 main <span class="comment">#这里的ip是宿主机的ip  23946为监听端口</span></span><br></pre></td></tr></table></figure>

<p><strong>第六步 在宿主机中运行<code>gdb</code>工具</strong></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">gdb.exe main  <span class="comment">#这里需要指定调试的执行文件</span></span><br></pre></td></tr></table></figure>

<p>此时进入到<code>gdb</code>模式</p>
<p><strong>第七步 在<code>gdb</code>模式下连接模拟器中的<code>gdbserver</code></strong></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">(gdb) target remote 192.168.0.1:23946  <span class="comment">#这里的ip是模拟器的ip</span></span><br></pre></td></tr></table></figure>

<p>连接成功后进入断点调试模式,该模式下可以使用~调试指令进行相关调试</p>
<h2 id="开始调试"><a href="#开始调试" class="headerlink" title="开始调试"></a>开始调试</h2><ol>
<li><p>使用<code>list</code>指令列出所有源代码 可简写为<code>l</code></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">(gdb) l</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用<code>break</code>指令设置断点位置 可简写为<code>b</code></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">(gdb) b main <span class="comment">#在main函数处打断点</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>使用<code>continue</code>指令运行到断点处 可简写为<code>c</code></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">(gdb) c</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用<code>step</code>指令进行单步执行 可简写为<code>s</code></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">(gdb) s   <span class="comment">#会进入函数内部</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>使用<code>next</code>执行进行单步执行 可简写为<code>n</code> </p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">(gdb) n  <span class="comment">#不会进入函数内部</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>使用<code>print</code>指令打印变量的值 可简写为<code>a</code></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">(gdb) p a <span class="comment">#打印变量a的值</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>使用<code>quit</code>指令退出调试模式 可简写为<code>q</code></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">(gdb) q</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h4 id="更多调试指令"><a href="#更多调试指令" class="headerlink" title="更多调试指令"></a>更多调试指令</h4><p><a href="https://code.newban.cn/217.html">GCC调试工具GDB的常用指令</a></p>
<h3 id="关于arm-linux-androideabi的获取"><a href="#关于arm-linux-androideabi的获取" class="headerlink" title="关于arm-linux-androideabi的获取"></a>关于<code>arm-linux-androideabi</code>的获取</h3><p>建议下载<code>Android NDK</code>开发包，然后将里面的GCC套件单独抽出来使用，NDK提供了抽包脚本<code>make-standalone-toolchain</code>，在<code>bulid</code>目录的<code>tools</code>文件夹中可以找到，执行脚本自动抽取打包成压缩包到当前目录：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">python make-standalone-toolchain.py --arch arm</span><br></pre></td></tr></table></figure>

<h2 id="附加"><a href="#附加" class="headerlink" title="附加"></a>附加</h2><p>如果是在非安卓系统的ARM模拟器上，比如qemu模拟器，那么直接使用官方的<code>arm-none-linux-eabi</code>即可，即便是安卓设备，如果没有代码调试需求的话，仅仅是编译运行程序，也是完全够用了</p>
<p>但是你需要进行代码调试的话，由于<code>android</code>系统的安全策略，<code>arm-none-linux-eabi</code>包中的<code>gdbserver</code>无法运行，提示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">error: only position independent executables (PIE) are supported.</span><br></pre></td></tr></table></figure>

<p>为了解决这个问题，我们因此采用<code>arm-linux-androideabi</code>，这里面的<code>gdbserver</code>可以正常运行</p>
<p>上面的例子中使用的NDKr17的版本</p>
<p><strong>本文为作者原创 转载时请注明出处 谢谢</strong></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt="img"></p>
<p><em>乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</em></p>
]]></content>
      <tags>
        <tag>编译</tag>
      </tags>
  </entry>
  <entry>
    <title>使用NDK下的GCC工具编译c代码至android设备中运行</title>
    <url>/219.html</url>
    <content><![CDATA[<blockquote>
<p>之前我们学过使用GCC子集之一<code>arm-none-linux-gnueabi</code>进行C代码编译,这次我们学习GCC另外一个子集<code>arm-linux-androideabi</code>,这是专门为android平台打造的一个GCC编译环境,该工具被包含在Android NDK库当中</p>
</blockquote>
<h2 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h2><ul>
<li>windows宿主机</li>
<li>安卓模拟器(ARM架构+linux系统 已Root)</li>
<li><code>android-ndk-r9b</code></li>
</ul>
<h2 id="实验开始"><a href="#实验开始" class="headerlink" title="实验开始"></a>实验开始</h2><p><strong>第一步 编写测试代码 文件名为<code>test.c</code></strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"hello pangshu"</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>第二步 将测试代码编译成可执行文件</strong></p>
<p>如果直接编译:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">arm-none-linux-androideabi-gcc.exe test.c -o main</span><br></pre></td></tr></table></figure>

<p>则报错,提示:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">clude-fixed\stdio.h:50:23: fatal error: sys/cdefs.h: No such file or directory</span><br></pre></td></tr></table></figure>

<p>这是因为缺少相应的依赖库导致的,在我们使用<code>arm-none-linux-gnueabi</code>时直接在命令行后面添加<code>-static</code>即可,但是使用<code>arm-linux-androideabi</code>则不行</p>
<p>这里需要通过<code>--sysroot</code>指定依赖的库,指令改成如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">arm-none-linux-androideabi-gcc.exe --sysroot=E:\android-ndk-r9b\platforms\android-19\arch-arm test.c -o main</span><br></pre></td></tr></table></figure>

<p>此时编译通过,但是将生成的执行文件push到安卓设备上之后,却无法运行,提示:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">error: only position independent executables (PIE) are supported.</span><br></pre></td></tr></table></figure>

<p>因此我们需要借助<code>-pie -fPIE</code>将编译选项设置为PIE,指令最后改成如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">arm-none-linux-androideabi-gcc.exe  -pie -fPIE --sysroot=E:\android-ndk-r9b\platforms\android-19\arch-arm test.c -o main</span><br></pre></td></tr></table></figure>

<p>此时程序可正常执行</p>
<blockquote>
<p>使用<code>arm-linux-androideabi</code>生成的可执行文件大小为6kB</p>
<p>使用<code>arm-none-linux-gnueabi</code>生成的可执行文件约为620KB</p>
</blockquote>
<p><strong>本文为作者原创 转载时请注明出处 谢谢</strong></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt="img"></p>
<p><em>乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</em></p>
]]></content>
      <tags>
        <tag>编译</tag>
      </tags>
  </entry>
  <entry>
    <title>Android 图片实现阴影效果的若干种方法</title>
    <url>/22.html</url>
    <content><![CDATA[<h2 id="第一种-使用-layer-list"><a href="#第一种-使用-layer-list" class="headerlink" title="第一种 使用 layer-list"></a>第一种 使用 layer-list</h2><figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"utf-8"</span>?&gt;</span><br><span class="line">&lt;layer-list xmlns:android=<span class="string">"http://schemas.android.com/apk/res/android"</span>&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--底层的左边距离上层左边<span class="number">3</span>dp, 底层的顶部，距离上层的顶部<span class="number">6</span>dp,如果不做这个控制，底层和上层的左侧和上侧会重合在一起--&gt;</span><br><span class="line">&lt;item android:left=<span class="string">"3dp"</span></span><br><span class="line">      android:top=<span class="string">"6dp"</span>&gt;</span><br><span class="line">    &lt;shape&gt;</span><br><span class="line">        &lt;solid android:color=<span class="string">"#b4b5b6"</span>/&gt;</span><br><span class="line">    &lt;/shape&gt;</span><br><span class="line">&lt;/item&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--上层的右边距离底层的右边<span class="number">3</span>dp, 上层的底部距离底层的底部<span class="number">6</span>dp--&gt;</span><br><span class="line">&lt;item android:bottom=<span class="string">"6dp"</span></span><br><span class="line">      android:right=<span class="string">"3dp"</span>&gt;</span><br><span class="line">    &lt;shape&gt;</span><br><span class="line">        &lt;solid android:color=<span class="string">"#fff"</span>/&gt;</span><br><span class="line">    &lt;/shape&gt;</span><br><span class="line">&lt;/item&gt;</span><br><span class="line"></span><br><span class="line">&lt;/layer-list&gt;</span><br></pre></td></tr></table></figure>

<h2 id="第二种-使用-shadow属性"><a href="#第二种-使用-shadow属性" class="headerlink" title="第二种 使用 shadow属性"></a>第二种 使用 shadow属性</h2><p>shadowDX、shadowDy、shadowRadius，分别指的是阴影的横、纵坐标偏移，以及阴影的半径，</p>
<p><strong>如果是TextView可以直接在布局中设置</strong>:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;TextView </span><br><span class="line">	    android:id=<span class="string">"@+id/test_shadow"</span></span><br><span class="line">	    android:layout_width=<span class="string">"wrap_content"</span></span><br><span class="line">	    android:layout_height=<span class="string">"wrap_content"</span></span><br><span class="line">	    android:textSize=<span class="string">"60sp"</span></span><br><span class="line">	    android:textColor=<span class="string">"#cc000000"</span></span><br><span class="line">	    android:text=<span class="string">"Test Shadow"</span></span><br><span class="line">	    android:layout_gravity=<span class="string">"center"</span></span><br><span class="line">	    android:shadowColor=<span class="string">"#aa22ff22"</span></span><br><span class="line">	    android:shadowRadius=<span class="string">"10"</span></span><br><span class="line">	    android:shadowDx=<span class="string">"0"</span></span><br><span class="line">	    android:shadowDy=<span class="string">"0"</span></span><br><span class="line">	    /&gt;</span><br></pre></td></tr></table></figure>

<h2 id="第三种-使用android-elevation属性"><a href="#第三种-使用android-elevation属性" class="headerlink" title="第三种 使用android:elevation属性"></a>第三种 使用android:elevation属性</h2><pre><code>&lt;TextView
android:id=&quot;@+id/btn_test_performance&quot;
android:layout_width=&quot;wrap_content&quot;
android:layout_height=&quot;wrap_content&quot;
android:elevation=&quot;5dp&quot;
android:text=&quot;@string/hello&quot;
android:background=&quot;@drawable/shape_round_white&quot;
android:padding=&quot;20dp&quot;
android:layout_marginTop=&quot;10dp&quot;
android:layout_gravity=&quot;center&quot;/&gt;</code></pre><p><strong>这种方式有个局限性, 那就是api25以上才能显示出来</strong></p>
<h2 id="第四种-使用第三方控件"><a href="#第四种-使用第三方控件" class="headerlink" title="第四种 使用第三方控件"></a>第四种 使用第三方控件</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ShadowLayout.java</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * Created by lijiankun on 17/8/11.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShadowLayout</span> <span class="keyword">extends</span> <span class="title">RelativeLayout</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ALL = <span class="number">0x1111</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> LEFT = <span class="number">0x0001</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TOP = <span class="number">0x0010</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RIGHT = <span class="number">0x0100</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> BOTTOM = <span class="number">0x1000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Paint mPaint = <span class="keyword">new</span> Paint(Paint.ANTI_ALIAS_FLAG);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> RectF mRectF = <span class="keyword">new</span> RectF();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 阴影的颜色</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> mShadowColor = Color.TRANSPARENT;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 阴影的大小范围</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">float</span> mShadowRadius = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 阴影 x 轴的偏移量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">float</span> mShadowDx = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 阴影 y 轴的偏移量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">float</span> mShadowDy = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 阴影显示的边界</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> mShadowSide = ALL;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ShadowLayout</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(context, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ShadowLayout</span><span class="params">(Context context, AttributeSet attrs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(context, attrs, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ShadowLayout</span><span class="params">(Context context, AttributeSet attrs, <span class="keyword">int</span> defStyleAttr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context, attrs, defStyleAttr);</span><br><span class="line">        init(attrs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取绘制阴影的位置，并为 ShadowLayout 设置 Padding 以为显示阴影留出空间</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onLayout</span><span class="params">(<span class="keyword">boolean</span> changed, <span class="keyword">int</span> left, <span class="keyword">int</span> top, <span class="keyword">int</span> right, <span class="keyword">int</span> bottom)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onLayout(changed, left, top, right, bottom);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">float</span> effect = mShadowRadius + dip2px(<span class="number">5</span>);</span><br><span class="line">        <span class="keyword">float</span> rectLeft = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">float</span> rectTop = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">float</span> rectRight = <span class="keyword">this</span>.getWidth();</span><br><span class="line">        <span class="keyword">float</span> rectBottom = <span class="keyword">this</span>.getHeight();</span><br><span class="line">        <span class="keyword">int</span> paddingLeft = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> paddingTop = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> paddingRight = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> paddingBottom = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (((mShadowSide &amp; LEFT) == LEFT)) &#123;</span><br><span class="line">            rectLeft = effect;</span><br><span class="line">            paddingLeft = (<span class="keyword">int</span>) effect;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (((mShadowSide &amp; TOP) == TOP)) &#123;</span><br><span class="line">            rectTop = effect;</span><br><span class="line">            paddingTop = (<span class="keyword">int</span>) effect;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (((mShadowSide &amp; RIGHT) == RIGHT)) &#123;</span><br><span class="line">            rectRight = <span class="keyword">this</span>.getWidth() - effect;</span><br><span class="line">            paddingRight = (<span class="keyword">int</span>) effect;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (((mShadowSide &amp; BOTTOM) == BOTTOM)) &#123;</span><br><span class="line">            rectBottom = <span class="keyword">this</span>.getHeight() - effect;</span><br><span class="line">            paddingBottom = (<span class="keyword">int</span>) effect;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (mShadowDy != <span class="number">0.0f</span>) &#123;</span><br><span class="line">            rectBottom = rectBottom - mShadowDy;</span><br><span class="line">            paddingBottom = paddingBottom + (<span class="keyword">int</span>) mShadowDy;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (mShadowDx != <span class="number">0.0f</span>) &#123;</span><br><span class="line">            rectRight = rectRight - mShadowDx;</span><br><span class="line">            paddingRight = paddingRight + (<span class="keyword">int</span>) mShadowDx;</span><br><span class="line">        &#125;</span><br><span class="line">        mRectF.left = rectLeft;</span><br><span class="line">        mRectF.top = rectTop;</span><br><span class="line">        mRectF.right = rectRight;</span><br><span class="line">        mRectF.bottom = rectBottom;</span><br><span class="line">        <span class="keyword">this</span>.setPadding(paddingLeft, paddingTop, paddingRight, paddingBottom);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 真正绘制阴影的方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDraw</span><span class="params">(Canvas canvas)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onDraw(canvas);</span><br><span class="line">        canvas.drawRect(mRectF, mPaint);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 读取设置的阴影的属性</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> attrs 从其中获取设置的值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(AttributeSet attrs)</span> </span>&#123;</span><br><span class="line">        setLayerType(View.LAYER_TYPE_SOFTWARE, <span class="keyword">null</span>);  <span class="comment">// 关闭硬件加速</span></span><br><span class="line">        <span class="keyword">this</span>.setWillNotDraw(<span class="keyword">false</span>);                    <span class="comment">// 调用此方法后，才会执行 onDraw(Canvas) 方法</span></span><br><span class="line"></span><br><span class="line">        TypedArray typedArray = getContext().obtainStyledAttributes(attrs, R.styleable.ShadowLayout);</span><br><span class="line">        <span class="keyword">if</span> (typedArray != <span class="keyword">null</span>) &#123;</span><br><span class="line">            mShadowColor = typedArray.getColor(R.styleable.ShadowLayout_shadowColor,</span><br><span class="line">                    ContextCompat.getColor(getContext(), android.R.color.black));</span><br><span class="line">            mShadowRadius = typedArray.getDimension(R.styleable.ShadowLayout_shadowRadius, dip2px(<span class="number">0</span>));</span><br><span class="line">            mShadowDx = typedArray.getDimension(R.styleable.ShadowLayout_shadowDx, dip2px(<span class="number">0</span>));</span><br><span class="line">            mShadowDy = typedArray.getDimension(R.styleable.ShadowLayout_shadowDy, dip2px(<span class="number">0</span>));</span><br><span class="line">            mShadowSide = typedArray.getInt(R.styleable.ShadowLayout_shadowSide, ALL);</span><br><span class="line">            typedArray.recycle();</span><br><span class="line">        &#125;</span><br><span class="line">        mPaint.setAntiAlias(<span class="keyword">true</span>);</span><br><span class="line">        mPaint.setColor(Color.TRANSPARENT);</span><br><span class="line">        mPaint.setShadowLayer(mShadowRadius, mShadowDx, mShadowDy, mShadowColor);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * dip2px dp 值转 px 值</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> dpValue dp 值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> px 值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">float</span> <span class="title">dip2px</span><span class="params">(<span class="keyword">float</span> dpValue)</span> </span>&#123;</span><br><span class="line">        DisplayMetrics dm = getContext().getResources().getDisplayMetrics();</span><br><span class="line">        <span class="keyword">float</span> scale = dm.density;</span><br><span class="line">        <span class="keyword">return</span> (dpValue * scale + <span class="number">0.5F</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>属性文件:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;declare-styleable name=&quot;ShadowLayout&quot;&gt;</span><br><span class="line">    &lt;attr name=&quot;shadowColor&quot; format=&quot;color&quot;/&gt;</span><br><span class="line">    &lt;attr name=&quot;shadowRadius&quot; format=&quot;dimension&quot;/&gt;</span><br><span class="line">    &lt;attr name=&quot;shadowDx&quot; format=&quot;dimension&quot;/&gt;</span><br><span class="line">    &lt;attr name=&quot;shadowDy&quot; format=&quot;dimension&quot;/&gt;</span><br><span class="line">    &lt;attr name=&quot;shadowSide&quot; format=&quot;integer&quot;/&gt;</span><br><span class="line">&lt;/declare-styleable&gt;</span><br></pre></td></tr></table></figure>

<h2 id="第五种-使用9patch图片-强烈推荐"><a href="#第五种-使用9patch图片-强烈推荐" class="headerlink" title="第五种 使用9patch图片(强烈推荐)"></a>第五种 使用9patch图片(强烈推荐)</h2><p>该种方式定制性强, 兼容性好, 需要注意的是避免将9patch宽高设置过大  小图可以拉大  大图不方便缩小</p>
<p>链接地址:<a href="http://inloop.github.io/shadow4android/" target="_blank" rel="noopener">http://inloop.github.io/shadow4android/</a></p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/dsff.png" alt></p>
<p><strong>本帖附件</strong></p>
<p><a href="https://u21519047.pipipan.com/fs/21519047-395416051" target="_blank" rel="noopener">点击下载</a></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em>乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</em></p>
]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>X86的安卓手机为什么可以运行ARM应用程序</title>
    <url>/220.html</url>
    <content><![CDATA[<h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>从事<code>android</code>开发的小伙伴都知道,在我们进行so库适配的时候,只需要保留<code>armabi</code>这个库,就可以匹配市面上几乎所有的机型</p>
<p>但同时我们也知道,不同架构<code>cpu</code>只能执行与其对应架构编译出来的程序,也就是说x86设备只能执行x86程序,而不能执行ARM程序</p>
<p>那为什么x86的安卓设备却可以执行<code>armabi</code>的so库呢?</p>
<h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><p>我们知道从最一开始基于ARM的程序占据了几乎所有的Android生态环境。Inter为了顺利打入移动市场,一个至关重要的问题就是需要兼容ARM应用程序。</p>
<p>但是不同架构cpu对应的指令集不一致,为了解决这个问题,就需要一个中间翻译器,于是Inter开发了软件Houdini。Houdini可以把ARM指令集转化为X86指令集从而在Android X86设备上运行</p>
<p>同时由于市面上<code>mips</code>架构的安卓设备非常少,这也就是为什么只需一个<code>armabi</code>就可以通吃几乎所有设备,不过x86设备运行ARM程序虽然没什么问题,但是执行效率的损伤是必然的</p>
<h2 id="附加"><a href="#附加" class="headerlink" title="附加"></a>附加</h2><p>在<code>adb shell</code>模式下, 可以通过一下命令查看当前安卓设备支持的指令架构:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">getprop</span><br></pre></td></tr></table></figure>

<p>如果是<code>x86</code>的<code>cpu</code>,既可以运行<code>x86</code>的可执行文件,也可执行<code>ARM</code>架构的程序,具体的参考<code>prop</code>中对应的<code>abi</code></p>
<p><strong>本文为作者原创 转载时请注明出处 谢谢</strong></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt="img"></p>
<p><em>乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</em></p>
]]></content>
      <tags>
        <tag>编译</tag>
      </tags>
  </entry>
  <entry>
    <title>原生ARM环境中使用的编译工具集介绍</title>
    <url>/221.html</url>
    <content><![CDATA[<p>这里说原生ARM环境指的是由ARM公司官方提供的的ARM编译工具集，主要包括以下几个工具：</p>
<ul>
<li><p><strong>armclang</strong>:  用于编译 c ,c++, GNU assembly language的源代码,不能编译ARM汇编代码</p>
</li>
<li><p><strong>armasm</strong>：汇编器, 只能编译 arm汇编代码</p>
</li>
<li><p><strong>armlink</strong>:  链接器，用来将目标代码，链接成可执行程序</p>
</li>
<li><p><strong>armar</strong>:  打包，将目标代码打包成一个库</p>
</li>
<li><p><strong>fromelf</strong>： 将可执行程序，转换为其他的镜像文件。</p>
<p>以下是编译流程</p>
</li>
</ul>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20210201153724.png" alt></p>
<p>  这个编译器，<strong>和ARM-GCC编译器最大的区别</strong>在于，这个工具是要<strong>收费</strong>的，而ARM-GCC是不用收费的。</p>
<h2 id="ArmClang编译器的参数介绍"><a href="#ArmClang编译器的参数介绍" class="headerlink" title="ArmClang编译器的参数介绍"></a>ArmClang编译器的参数介绍</h2><p> <strong>1、<code>–target</code>选项</strong></p>
<p>必选项,指定使用哪一种ARM指令集进行编译。只有两个选项：</p>
<ul>
<li><p><strong>–target=aarch64-arm-none-eabi</strong>  : 指定使用aarch64</p>
</li>
<li><p><strong>–target=arm-arm-none-eabi</strong>    : 指定使用aarch32</p>
</li>
</ul>
<p><strong>2、<code>–mcpu</code>选项</strong></p>
<p>通过指定特定的处理器型号进行编译。当指定了target，可以不指定这个。</p>
<p>如：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">–mcpu=cortex-a53   <span class="comment">#表示 指定处理器是cortex-a53，</span></span><br></pre></td></tr></table></figure>

<p>如果要查看指定target下支持的处理器型号,可使用<code>–mcpu=list</code>指令选项,如下:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">armclang –target=aarch64-arm-none-eabi  –mcpu=list <span class="comment">#查看 aarch64下支持的处理器</span></span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20210201153644.png" alt></p>
<p> <strong>3、–march选项</strong></p>
<p>指定编译时针对哪一个架构进行编译。</p>
<p>可以使用<code>armclang –target= aarch64-arm-none-eabi -march=list</code> 查看aarch64下支持的架构，可以看出对于aarch64，总共支持3种架构。</p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20210201153606.png" alt></p>
<p>而aarch32下支持的架构就多了，从armv6-armv8。</p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20210201153554.png" alt></p>
<p> <strong>4、<code>-g</code>选项</strong></p>
<p>表示编译器编译的时候，加上调试信息</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">armclang –target=aarch64-arm-none-eabi -g test.c</span><br></pre></td></tr></table></figure>

<p> <strong>5、<code>-Olevel</code>选项</strong></p>
<p>  优化等级，level越高，优化等级越高。</p>
<ul>
<li><p>-O0表示没有优化。</p>
</li>
<li><p>-Os表示减小代码密度，平衡代码大小和代码速度。</p>
</li>
<li><p>-Omax表示针对该target，使用最大的优化。</p>
</li>
</ul>
<p><strong>6、<code>-marm -mthumb</code>选项</strong></p>
<p> <code>-marm</code>表示A32指令集  ， <code>-mthumb</code>表示T32指令集</p>
<p><strong>7、<code>-Wpedantic</code>选项</strong></p>
<p>显示警告信息</p>
<p><strong>8、<code>-S</code>选项</strong></p>
<p>将c代码，或者.S代码，预处理，生成.s代码。</p>
<p><strong>9、<code>-c</code>选项</strong></p>
<p>只编译不链接，生成中间目标代码（.o）</p>
<p>例子：</p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20210201153541.png" alt></p>
<h2 id="ArmAsm汇编器的参数介绍"><a href="#ArmAsm汇编器的参数介绍" class="headerlink" title="ArmAsm汇编器的参数介绍"></a>ArmAsm汇编器的参数介绍</h2><p><strong>1、<code>-I</code>选项</strong></p>
<p>指定搜索目录</p>
<p><strong>2、<code>–cpu</code>选项</strong></p>
<p>指定的指令集</p>
<p>如  <code>–cpu=8-A.64</code>  ,  指定armv8架构的64bit的指令集</p>
<p><strong>3、<code>-g</code>选项</strong></p>
<p>汇编，加上调试信息</p>
<p><strong>4、<code>–predefine</code>选项</strong></p>
<p>定义一个宏，传递给汇编代码中使用。</p>
<p>例子：</p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20210201153527.png" alt></p>
<h2 id="Armlink连接器参数介绍"><a href="#Armlink连接器参数介绍" class="headerlink" title="Armlink连接器参数介绍"></a>Armlink连接器参数介绍</h2><p>链接器，用来链接各个.o文件，得到最终的elf。</p>
<p><strong>1、<code>–ro_base</code>选项</strong></p>
<p>指定RO段的起始地址</p>
<p><strong>2、<code>–rw_base</code>选项</strong></p>
<p>指定RW段的起始地址</p>
<p><strong>3、<code>–zi_base</code>选项</strong></p>
<p>指定bss段的起始地址</p>
<p><strong>4、<code>–map  –symbols</code>选项</strong></p>
<p>显示生成镜像的memory map，以及symbols信息</p>
<p><strong>5、<code>–scatter</code>选项</strong></p>
<p>指定链接脚本</p>
<p><strong>6、<code>–output</code>选项</strong></p>
<p>指定生成的文件</p>
<p><strong>7、诊断信息</strong></p>
<p>诊断信息的选项：</p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20210201153513.png" alt></p>
<p><strong>8、不使用链接脚本</strong></p>
<p>使用<code>armlink</code>链接<code>init.o</code> 和 <code>main.o</code>，生成可执行文件。</p>
<p>其中：</p>
<ul>
<li><p>代码段起始地址是0，</p>
</li>
<li><p>数据段起始地址是0x400000，</p>
</li>
<li><p>bss段的起始地址是0x405000。</p>
</li>
</ul>
<p><code>init.o</code>的init段，作为生成可执行文件的最开始段。</p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20210201153501.png" alt></p>
<p><strong>9、使用链接脚本</strong></p>
<p>以下是使用链接脚本来进行链接。</p>
<p>下图中，链接脚本的格式。</p>
<p>外面指定LR1，是一个大段，从地址0x0000-0x2000。在这个RL1段，包括3个小段</p>
<ul>
<li><strong>ER_RO</strong>： 只读段，从0地址开始。其中<code>init.o</code>的INIT段作为这个段的开始，其他段放置在这个段的后面</li>
<li><strong>ER_RW</strong>:  可读可写段，从0x400000开始</li>
<li><strong>ER_ZI</strong>:  bss段，从0x405000开始</li>
</ul>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20210201153448.png" alt></p>
<p><strong>10、#pragma pack（n）</strong></p>
<p>#pragma用来指定打包数据时，各个数据的空间占据。</p>
<p>!<img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20210201153437.png" alt></p>
<p>对于char型，占用1个字节， 对于short型，占用2个字节， 对于int型，占用4个字节。</p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20210201153417.png" alt></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20210201153400.png" alt></p>
<h2 id="fromelf工具介绍"><a href="#fromelf工具介绍" class="headerlink" title="fromelf工具介绍"></a>fromelf工具介绍</h2><p>反汇编工具。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fromelf  –text  –c  –a  elf文件  -o  文本文件</span><br></pre></td></tr></table></figure>

<p><strong>本文为作者原创 转载时请注明出处 谢谢</strong></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt="img"></p>
<p><em>乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</em></p>
]]></content>
      <tags>
        <tag>编译</tag>
      </tags>
  </entry>
  <entry>
    <title>xcode中三种编译器的区别</title>
    <url>/222.html</url>
    <content><![CDATA[<blockquote>
<p>在xcode中有三种编译器供我们选择，分别是GCC、LLVM GCC、LLVM compliler </p>
</blockquote>
<h2 id="三者区别"><a href="#三者区别" class="headerlink" title="三者区别"></a>三者区别</h2><ul>
<li><strong>GCC</strong> ：是一套由 <code>GNU</code> 开发的编程语言编译器。<code>Linux/Unix</code>操作系统的标准编译器。编译前端和后端皆使用<code>GCC</code></li>
<li><strong>LLVM GCC</strong>：编译前端使用<code>GCC</code>，后端使用<code>LLVM</code></li>
<li><strong>LLVM compliler</strong> ：编译前端使用<code>Clang</code>，后端使用<code>LLVM</code></li>
</ul>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20210201154646.png" alt></p>
<h2 id="为什么存在三种编译器"><a href="#为什么存在三种编译器" class="headerlink" title="为什么存在三种编译器"></a>为什么存在三种编译器</h2><p>苹果公司最开始使用<code>GCC</code>编译器</p>
<p>为了实现对 <strong>Objective-C</strong> 新特性的支持，苹果公司结合<code>LLVM</code>改进<code>GCC</code>，从而衍生出了一个<code>GCC</code>分支，也就是<strong>LLVM GCC</strong></p>
<p>由于<strong>LLVM GCC</strong>的笨重和局限性,苹果公司从零开始开发了一套自己的编译前端系统<strong>Clang</strong>,配合<strong>LLVM</strong>,就有了<strong>LLVM GCC</strong></p>
<h2 id="Clang的优势"><a href="#Clang的优势" class="headerlink" title="Clang的优势"></a>Clang的优势</h2><p>相比<code>GCC</code>而言:</p>
<ul>
<li>编译速度快,占用内存小</li>
<li>模块化设计,易于扩展,易于IDE集成</li>
<li>错误提示人性化</li>
<li>产出小</li>
</ul>
<p>值得一提的是,<code>Android NDK</code>从<code>r18</code>开始就已经抛弃<code>GCC</code>,转而采用<code>Clang</code>编译,<code>Clang</code>未来可期</p>
<p><strong>本文为作者原创 转载时请注明出处 谢谢</strong></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt="img"></p>
<p><em>乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</em></p>
]]></content>
      <tags>
        <tag>编译</tag>
      </tags>
  </entry>
  <entry>
    <title>Git HEAD detached from XXX (git HEAD 游离) 解决办法</title>
    <url>/225.html</url>
    <content><![CDATA[<h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>通常我们在首次进行代码的拉取的时候容易出现HEAD游离状态, 也就是说当前操作不在任何一个现有分支上, 一般情况下我们在进行代码修改时需要先将对分支进行相应切换, 比如在<code>master</code>分支上进行开发, 那就<code>git checkout master</code>切换到<code>master</code>分支</p>
<p>但是很多情况下我们容易忽视这个习惯, 导致代码提交时才发现处在游离分支上, 这个时候如果进行分支的强行切换意味着所做的代码修改全部付之一炬, 那我们该如何处理这种情况呢?</p>
<p>事实上, <code>git</code>已经给我们提供了相应的智能提示, 在我们<code>push</code>代码时会警告提示我们:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Warning: you are leaving 1 commit behind, not connected to</span><br><span class="line">any of your branches:</span><br><span class="line"></span><br><span class="line">  84220ac update</span><br><span class="line"></span><br><span class="line">If you want to keep it by creating a new branch, this may be a good time</span><br><span class="line">to do so with:</span><br><span class="line"></span><br><span class="line"> git branch &lt;new-branch-name&gt; 84220ac</span><br><span class="line"></span><br><span class="line">Switched to branch &apos;master&apos;</span><br></pre></td></tr></table></figure>

<p>这时我们只需要新开一个分支存储游离的内容, 然后再将两个分支进行合并即可</p>
<h3 id="解决方案一"><a href="#解决方案一" class="headerlink" title="解决方案一"></a>解决方案一</h3><ol>
<li><p>第一步 将游离部分代码放到一个临时分支</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git branch temp 84220ac</span><br></pre></td></tr></table></figure>
</li>
<li><p>第二步 切换到开发主分支</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git checkout master</span><br></pre></td></tr></table></figure>
</li>
<li><p>第三步 将临时分支代码合并到开发主分支</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git merge temp</span><br></pre></td></tr></table></figure>
</li>
<li><p>第四步 删除临时分支</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git branch -d temp</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="解决方案二"><a href="#解决方案二" class="headerlink" title="解决方案二"></a>解决方案二</h3><p><strong>本方案适用于代码还未commit</strong></p>
<ol>
<li><p>第一步 将游离代码放置到暂存区域</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git stash</span><br></pre></td></tr></table></figure>
</li>
<li><p>第二步 将暂存区域的代码pop出来到当前分支</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git pop</span><br></pre></td></tr></table></figure>











</li>
</ol>
<p><strong>本文为作者原创 转载时请注明出处 谢谢</strong></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt="img"></p>
<p><em>乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</em></p>
]]></content>
      <tags>
        <tag>GIT</tag>
      </tags>
  </entry>
  <entry>
    <title>Windows平台使用QEMU搭建ARM+Linux开发环境</title>
    <url>/224.html</url>
    <content><![CDATA[<h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>由于目前市面上很多模拟器诸如夜神,网易MUMU,基本上使用的是x86的架构,虽然运行ARM程序没有问题,但是如果想使用<code>gdb</code>对ARM程序进行调试的话,就显得力不从心了,各种问题层出不穷,</p>
<p>当然调试x86程序是没有问题的，</p>
<p>如果非要对ARM程序进行<code>gdb</code>调试的话，可以采用Android Studio原生的模拟器（原生ARM太卡），但是考虑到很多人并不是从事安卓开发，加上Studio中的模拟器本就基于QEMU,  那么为了方便，我们直接搭建QEMU的环境</p>
<h2 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h2><ul>
<li><p>Windows宿主平台</p>
</li>
<li><p>QEMU安装包（这里使用的是20201124的版本）：<a href="https://qemu.weilnetz.de/w64/" target="_blank" rel="noopener">https://qemu.weilnetz.de/w64/</a></p>
</li>
<li><p>树莓派系统镜像：<a href="http://downloads.raspberrypi.org/raspbian/images/raspbian-2020-02-14/" target="_blank" rel="noopener">http://downloads.raspberrypi.org/raspbian/images/raspbian-2020-02-14/</a></p>
<blockquote>
<p>树莓派是基于Debian的Linux系统</p>
</blockquote>
</li>
</ul>
<h2 id="操作步骤"><a href="#操作步骤" class="headerlink" title="操作步骤"></a>操作步骤</h2><p>QEMU下载安装完毕后,其安装目录会包含很多不同架构的执行文件,这里我们选择<code>qemu-system-arm.exe</code>,打开命令窗口:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">qemu-system-arm.exe -machine versatilepb -L  -m 128  -hda 2020-02-13-raspbian-buster.img</span><br></pre></td></tr></table></figure>

<p><strong>相关指令选项介绍:</strong></p>
<ul>
<li><strong>-M</strong> :指定机器</li>
<li><strong>-name</strong>：给虚拟系统起个名称</li>
<li><strong>-cpu</strong>:指定cpu型号</li>
<li><strong>-smp</strong> :指定cpu的个数 比如<code>-smp 2</code></li>
<li><strong>-m</strong>: 指定内存大小单位MB</li>
<li><strong>-vga</strong> :指定显卡 比如 <code>-vga vmware</code> </li>
<li><strong>-hda</strong>: 指定硬盘镜像</li>
<li><strong>-initrd</strong>: 指定 RAM磁盘镜像</li>
<li><strong>-fda</strong> : 指定软盘镜像</li>
<li><strong>-L</strong>:bios位置</li>
<li><strong>-cdrom</strong>:光盘镜像</li>
<li><strong>-no-reboot:</strong> 不重启退出 </li>
<li><strong>-kernel</strong> :指定内核文件</li>
<li><strong>-serial</strong> :设置串口 比如:<code>-serial stdio</code> 表示 重定向Guest 的串口到Host的标准输入输出 </li>
<li><strong>-boot</strong> :启动模式 一共有三种 , 分别为<code>floppy(a), hard disk(c), CD-ROM(d)</code></li>
</ul>
<p>上面这条指令显然无法启动系统，因为还缺少了相应<code>kernel-qemu</code>文件和配置：</p>
<p><strong>kernel-qemu下载</strong>：</p>
<p><a href="https://github.com/dhruvvyas90/qemu-rpi-kernel" target="_blank" rel="noopener">GitHub - dhruvvyas90/qemu-rpi-kernel: Qemu kernel for emulating Rpi on QEMU</a></p>
<p>我们选择里面的<code>versatile-pb-buster.dtb</code> 和<code>kernel-qemu-5.4.51-buster</code> 这两个文件进行下载，这是和系统版本一一对应的。下载后最好放在qemu的安装目录</p>
<p>然后输入以下指令：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">qemu-system-arm -M versatilepb -cpu arm1176 -m <span class="number">256</span> -drive <span class="string">"file=系统镜像路径,if=none,index=0,media=disk,format=raw,id=disk0"</span> -device <span class="string">"virtio-blk-pci,drive=disk0,disable-modern=on,disable-legacy=off"</span> -net <span class="string">"user,hostfwd=tcp::5022-:22"</span> -dtb versatile-pb-buster.dtb -kernel kernel-qemu-<span class="number">5.4</span>.<span class="number">51</span>-buster -append <span class="string">"root=/dev/vda2 panic=1"</span> -no-reboot -net nic</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：需要按照以上指令运行，否则有可能出现系统启动不起来的情况</p>
<p><code>-net nic</code> 可开启网络 方便远程连接</p>
<p><code>-net &quot;user,hostfwd=tcp::5022-:22&quot;</code>  表示设置端口映射</p>
</blockquote>
<p>系统安装完毕后，直接进入树莓派桌面，在弹出的设置窗口中可以更改系统语言为中文, 还可以设置系统密码</p>
<p>至此<code>ARM+Linux</code>环境搭建完毕</p>
<h2 id="准备开发"><a href="#准备开发" class="headerlink" title="准备开发"></a>准备开发</h2><p>接下来我们通过<code>ssh</code>连接树莓派终端,打开<code>cmd</code>命令窗口,输入:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh pi@127.0.0.1 -p 5022</span><br></pre></td></tr></table></figure>

<p>回车后会提示输入密码,这里输入之前设置的系统密码</p>
<p>此时就进入树莓派的<code>Linux</code>终端,为什么不直接使用<code>qemu</code>中的LX终端? 还不是因为模拟器延迟卡顿</p>
<p>如果想往树莓派中传输文件,可以直接使用<code>ftp</code>工具,比如<code>FileZilla</code>或者 <code>SecureCRT</code> 选择<code>sftp</code>或者<code>ssh2</code>模式,其登陆参数如下:</p>
<ul>
<li><strong>主机</strong>:127.0.0.1</li>
<li><strong>用户名</strong>:pi</li>
<li><strong>端口</strong>:5022,</li>
<li><strong>密码同上</strong></li>
</ul>
<h2 id="程序调试"><a href="#程序调试" class="headerlink" title="程序调试"></a>程序调试</h2><p>紧接着使用<code>gdb+gdbserver</code>对C程序进行调试</p>
<p>首先利用<code>ftp</code>工具将已经编译好的可执行文件和GCC包下<code>arm-none-linux-gnueabi\libc\usr\bin</code>目录中的<code>gdbserver</code>传送到模拟器中</p>
<p>然后执行以下命令:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">./gdbserver :22349 test</span><br></pre></td></tr></table></figure>

<p>开始监听端口, 但是问题来了,该模拟器的<code>ip</code>不在局域网段上,导致宿主机连接不上, 如果你也出现同样的问题,可以采用端口映射的办法来替代,方法很简单,只需要在模拟器启动时多追加加上一行参数<code>hostfwd=tcp::22349-:22349</code>,具体启动指令修改如下:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">qemu-system-arm -M versatilepb -cpu arm1176 -m 256 -drive "file=2020-02-13-raspbian-buster.img,if=none,index=0,media=disk,format=raw,id=disk0" -device "virtio-blk-pci,drive=disk0,disable-modern=on,disable-legacy=off" -net "user,hostfwd=tcp::5022-:22,hostfwd=tcp::22349-:22349" -dtb versatile-pb-buster.dtb -kernel kernel-qemu-5.4.51-buster -append "root=/dev/vda2 panic=1" -no-reboot  -net nic</span><br></pre></td></tr></table></figure>

<p>如此一来就可以在宿主<code>gdb</code>调试窗口中直接使用以下指令进行连接:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(gdb) target remote 127.0.0.1:22349</span><br></pre></td></tr></table></figure>

<p>连接成功了,通过以上这种方式,我们只需要将模拟器启动使其后台运行,我们通过ssh进行登录连接,这样速度快了很多,而且相比一些安卓模拟器,QEMU占用系统资源也不高</p>
<p>另外我们发现，还存在<strong>声卡缺失，</strong>同时运行有<strong>延迟卡顿</strong>现象，我们接下来对这两方面进行优化</p>
<h2 id="小问题"><a href="#小问题" class="headerlink" title="小问题"></a>小问题</h2><p>如果是raw格式,可能会有些风险警告,可以通过<code>-drive format=raw</code>进行指定处理:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">qemu-system-arm.exe  -machine raspi2b -drive file=2020-02-13-raspbian-buster.img,format=raw,index=0,media=disk</span><br></pre></td></tr></table></figure>

<h2 id="附加内容"><a href="#附加内容" class="headerlink" title="附加内容"></a>附加内容</h2><p><strong>查看cpu信息:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">lscpu</span><br></pre></td></tr></table></figure>

<p><strong>查看系统和内核版本:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">uname -a</span><br></pre></td></tr></table></figure>

<h3 id="镜像备份模式"><a href="#镜像备份模式" class="headerlink" title="镜像备份模式"></a>镜像备份模式</h3><p>随着我们对系统的频繁操作我们发现系统镜像文件在不断增大，此时想要回到原来的状态，只能重新下载镜像安装了，如果你不想遭受重新下载的痛苦，那么建议你使用备份镜像的模式进行系统的安装</p>
<p>这时<code>qemu-img.exe</code>派上了用场，它不仅可以帮助你创建空镜像文件，而且还可以对已有的镜像文件进行格式转换，QEMU支持的镜像有以下：</p>
<table>
<thead>
<tr>
<th align="left">Image format</th>
<th align="center">Argument for -f and -O options</th>
</tr>
</thead>
<tbody><tr>
<td align="left">VMDK (VMware)</td>
<td align="center">vmdk</td>
</tr>
<tr>
<td align="left">QCOW2 (KVM, Xen)</td>
<td align="center">qcow2</td>
</tr>
<tr>
<td align="left">VHD (Hyper-V)</td>
<td align="center">vpc</td>
</tr>
<tr>
<td align="left">VHDX (Hyper-V)</td>
<td align="center">vhdx</td>
</tr>
<tr>
<td align="left">RAW</td>
<td align="center">raw</td>
</tr>
<tr>
<td align="left">VDI (VirtualBox)</td>
<td align="center">vdi</td>
</tr>
</tbody></table>
<blockquote>
<p> <code>qemu-img</code> 支持非常多种的文件格式，可以通过 <code>qemu-img -h</code> 查看.<br>其中 <code>raw</code> 和 <code>qcow2</code> 是比较常用的两种，</p>
<p><code>raw</code> 是 <code>qemu-img</code> 命令默认的，<code>qcow2</code> 是 <code>qemu</code> 目前推荐的镜像格式，是功能最多的格式 </p>
</blockquote>
<p><strong>创建空镜像文件：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">qemu-img create -f qcow2 test.qcow2 10G</span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>-f</code> 选项用于指定镜像的格式，</p>
</li>
<li><p><code>qcow2</code> 格式是 QEMU最常用的镜像格式，采用来写时复制技术来优化性能。</p>
</li>
<li><p><code>test.qcow2</code> 是镜像文件的名字，</p>
</li>
<li><p>10G是镜像文件最大值</p>
</li>
</ul>
<p><strong>镜像转换:</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">qemu-img.exe  convert -f raw system.img -O vmdk  system.vmdk</span><br></pre></td></tr></table></figure>

<p>表示将原始格式的镜像文件转换成<code>vmdk</code>格式</p>
<p><strong>使用备份镜像的方式启动镜像示例：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">qemu-system-x86_64 -m 2048 -enable-kvm test.qcow2 -cdrom Centos-Desktop-x86_64-20-1.iso</span><br></pre></td></tr></table></figure>

<h2 id="附加镜像"><a href="#附加镜像" class="headerlink" title="附加镜像"></a>附加镜像</h2><ul>
<li><p>openwrt:<a href="https://archive.openwrt.org/chaos_calmer/" target="_blank" rel="noopener">https://archive.openwrt.org/chaos_calmer/</a></p>
</li>
<li><p>Debian系统镜像：<a href="https://people.debian.org/~aurel32/qemu/" target="_blank" rel="noopener">https://people.debian.org/~aurel32/qemu/</a></p>
</li>
<li><p>谷歌安卓原生镜像：<a href="https://developers.google.cn/android/images" target="_blank" rel="noopener">https://developers.google.cn/android/images</a></p>
</li>
<li><p>树莓派x86镜像: <a href="https://www.raspberrypi.org/downloads/raspberry-pi-desktop/" target="_blank" rel="noopener">https://www.raspberrypi.org/downloads/raspberry-pi-desktop/</a> </p>
</li>
</ul>
<p><strong>本文为作者原创 转载时请注明出处 谢谢</strong></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt="img"></p>
<p><em>乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</em></p>
]]></content>
      <tags>
        <tag>编译</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Clang编译C程序在安卓设备中执行</title>
    <url>/223.html</url>
    <content><![CDATA[<blockquote>
<p>由于<code>Android NDK</code>从r18开始就已经抛弃GCC,转而将Clang当作默认编译器，因此我们直接使用NDK工具包进行编译</p>
</blockquote>
<h2 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h2><ul>
<li>安卓模拟器</li>
<li><code>android-ndk-r19c</code></li>
</ul>
<h2 id="实验步骤"><a href="#实验步骤" class="headerlink" title="实验步骤"></a>实验步骤</h2><p> <strong>第一步 源码编写</strong></p>
<p>新建<code>test.c</code>文件</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;  </span></span></span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Hello world!\n"</span>);  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> <strong>第二步 源码编译</strong></p>
<p>在<code>android-ndk-r19c</code>目录下<code>toolchains</code>文件夹中的<code>llvm</code>文件夹即为<code>clang</code>编译工具包</p>
<p>在<code>llvm</code>的子目录<code>bin</code>下存放这针对各个架构的clang编译器，由于模拟器是ARM架构，这里我们使用<code>armv7a-linux-androideabi23-clang</code></p>
<p>在命令窗口执行如下指令：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">armv7a-linux-androideabi23-clang test.c -o test</span><br></pre></td></tr></table></figure>

<p> 由于clang已经指定了Android23版本的SDK，这里无需要像GCC那样指定<code>-static</code>编译</p>
<p><strong>第三步 将编译后的可执行文件传至安卓设备</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">adb push test /data/</span><br></pre></td></tr></table></figure>

<p> <strong>第四步 执行文件</strong></p>
<p>直接在控制台输入文件名即可执行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">./test</span><br></pre></td></tr></table></figure>

<p>如果提示权限拒绝,那么</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">chmod 777 test</span><br></pre></td></tr></table></figure>

<h2 id="附加"><a href="#附加" class="headerlink" title="附加"></a>附加</h2><p><strong>如果C语言和汇编语言混合开发</strong>，同样也可使用clang编译：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">armv7a-linux-androideabi23-clang aaa.s test.c -o test</span><br></pre></td></tr></table></figure>

<p><strong>本文为作者原创 转载时请注明出处 谢谢</strong></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt="img"></p>
<p><em>乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</em></p>
]]></content>
      <tags>
        <tag>编译</tag>
      </tags>
  </entry>
  <entry>
    <title>Could not resolve all dependencies for configuration app:debugRuntimeClasspath</title>
    <url>/226.html</url>
    <content><![CDATA[<h2 id="报错"><a href="#报错" class="headerlink" title="报错"></a>报错</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Could not resolve all dependencies for configuration &apos;:app:debugRuntimeClasspath&apos;.</span><br><span class="line">Could not create task &apos;:app:minifyReleaseWithR8&apos;.</span><br><span class="line">Cannot query the value of this provider because it has no value available</span><br></pre></td></tr></table></figure>

<p>同时提示:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Warning:&lt;i&gt;&lt;b&gt;project &apos;:app&apos;: Unable to build kotlin-kapt plugin configuration&lt;/b&gt;</span><br><span class="line">Details: org.gradle.api.internal.tasks.DefaultTaskContainer$TaskCreationException: Could not create task &apos;:app:minifyReleaseWithR8&apos;.</span><br><span class="line">Caused by: org.gradle.api.internal.provider.MissingValueException: Cannot query the value of this provider because it has no value available.&lt;/i&gt;</span><br></pre></td></tr></table></figure>

<p>同事那边代码正常编译运行, 我这边把代码拉下来后报错, 很大可能性是Studio环境问题</p>
<p>百度试了很多方案均不奏效</p>
<p>最后在<a href="https://stackoverflow.com/questions/64459937/could-not-create-task-appminifyreleasewithr8-cannot-query-the-value-of-this" target="_blank" rel="noopener">StackOverflow</a>上找到了答案:</p>
<p><strong>是SDK版本和buildToolsVersion不一致导致的</strong></p>
<p><strong>只需将buildToolsVersion版本改成本机已装SDK版本即可, 或者不改动代码 下载一个与之对应的SDK版本</strong></p>
<p>问题解决</p>
<p><strong>本文为作者原创 转载时请注明出处 谢谢</strong></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt="img"></p>
<p><em>乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</em></p>
]]></content>
      <tags>
        <tag>Android错误集锦</tag>
      </tags>
  </entry>
  <entry>
    <title>Mac下 SSR无法正常使用Telegram问题及解决方法</title>
    <url>/227.html</url>
    <content><![CDATA[<h4 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h4><p>最近在Mac上使用Telegram时，发现无法正常连接，无论是PAC还是全局均无效，在Google之后大多数答案都是Windows下的处理方法，并不适用。</p>
<p>Mac 配置了 ShadowsocksX-NG，开启后，浏览器可正常访问 Google，但是 Telegram 一直显示 Connection…</p>
<p>解决步骤如下：</p>
<p>选择 Proxy 为 Socks5 模式，服务器地址填 127.0.0.1 端口填 1080 (端口号需要查看你自己的)</p>
<h4 id="下面我会用几张图来说明"><a href="#下面我会用几张图来说明" class="headerlink" title="下面我会用几张图来说明"></a>下面我会用几张图来说明</h4><p>1、在SSR的高级设置里查看Socks5端口号</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image.png" alt></p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-1.png" alt="img"></p>
<p>2、设置Telegram代理 (共3步)</p>
<h4 id="第1步"><a href="#第1步" class="headerlink" title="第1步"></a>第1步</h4><p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-2.png" alt="img"></p>
<h4 id="第2步"><a href="#第2步" class="headerlink" title="第2步"></a>第2步</h4><p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-3.png" alt="img"></p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-4.png" alt="img"></p>
<h4 id="第3步"><a href="#第3步" class="headerlink" title="第3步"></a>第3步</h4><p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-5.png" alt="img"></p>
<p>设置完后，发现代理前面有了一个勾，说明已经设置成功。</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-6.png" alt="img"></p>
<p>至此，就完成了所有设置，<strong>记得重启 Telegram</strong>，然后可以尽情在墙外漫游了</p>
<p>如果mac使用的socksx的客户端可能没有高级设置以查看地址及端口号。</p>
<p>此客户端一般是默认127.0.0.1，1080端口。</p>
<p>另外给大家分享一个免费的mtproxy分享网站：<a href="https://mtproto.cc/" target="_blank" rel="noopener">mtproto.cc</a></p>
<p><strong>本文为作者原创 转载时请注明出处 谢谢</strong></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt="img"></p>
<p><em>乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</em></p>
]]></content>
      <tags>
        <tag>墙里墙外</tag>
      </tags>
  </entry>
  <entry>
    <title>wordpress批量修改文章状态的方法</title>
    <url>/228.html</url>
    <content><![CDATA[<h4 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h4><p>手上有一个采集站点, 剩余3万的草稿, 原计划手动每日发布几十篇文章, 后来实在有些反人类, 干脆一次性全发布</p>
<p>如果使用<code>wordpress</code>自带的批量操作, 文章太多容易卡顿超时, 还是直接操作数据库来的快, 但是修改数据库存在一定风险, 因此建议提前做好备份 </p>
<h3 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h3><ol>
<li>第一步 备份数据库</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysqldump -uroot -p 数据库名 &gt;数据库地址和名称</span><br></pre></td></tr></table></figure>

<p>比如:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysqldump -uroot -p wordpress&gt;/logs/wordpress_bak.mql</span><br></pre></td></tr></table></figure>

<p>回车后提示输入密码, 输入后即可备份</p>
<ol start="2">
<li>第二步 操作wordpress数据库</li>
</ol>
<p>进入mysql内部</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql -uroot -p 密码</span><br></pre></td></tr></table></figure>

<p>查看所有数据库</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">show datebase;</span><br></pre></td></tr></table></figure>

<p>选择指定数据库</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">use wordpress;</span><br></pre></td></tr></table></figure>

<p>查看<code>wordpress</code>表</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">show tables;</span><br></pre></td></tr></table></figure>

<p>查看<code>wp-posts</code>表字段</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">desc wp-posts;</span><br></pre></td></tr></table></figure>

<p>最后修改<code>wp-posts</code>表中的<code>post_status</code>字段(关键)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">UPDATE `wp_posts` SET `post_status` =&apos;publish&apos; WHERE (`post_status`=&apos;draft&apos;);</span><br></pre></td></tr></table></figure>

<p>这里我是将所有的草稿改成已发布</p>
<p><code>wordpress</code>中的文章状态有以下几种:</p>
<ul>
<li>pending：待审</li>
<li>draft：草稿</li>
<li>auto-draft：自动保存的草稿</li>
<li>inherit：修订版本</li>
<li>trash：回收站</li>
<li>publish：已发布</li>
<li>future：定时</li>
<li>private：私有</li>
</ul>
<p>如果你有其他需求, 比如想将所有待审的文章全部改成草稿, 那么只需修改相应的关键字就行,如:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">UPDATE `wp_posts` SET `post_status` =&apos;draft&apos; WHERE (`post_status`=&apos;pending&apos;);</span><br></pre></td></tr></table></figure>

<p>或者 你只想修改某一时间段内的文章, 那么可以加上时间条件,如:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">UPDATE `wp_posts` SET `post_status` =&apos;draft&apos; WHERE `post_status`=&apos;pending&apos; and `post_date` &gt;=&apos;2020-05-01 00:00:00&apos; and `post_date` &lt; &apos;2021-03-22 22:00:00:00&apos;;</span><br></pre></td></tr></table></figure>

<p><strong>本文为作者原创 转载时请注明出处 谢谢</strong></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt="img"></p>
<p><em>乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</em></p>
]]></content>
      <tags>
        <tag>wordpress</tag>
      </tags>
  </entry>
  <entry>
    <title>Mac上通过homebrew安装adb</title>
    <url>/229.html</url>
    <content><![CDATA[<h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p>Mac安装adb，如果电脑上没有装android studio 那么最简单的办法是用homebrew</p>
<p>其中 homebrew是macOS的一个包管理工具</p>
<h4 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h4><p>1、安装homebrew</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;</span><br></pre></td></tr></table></figure>

<p>2、安装adb</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">brew cask install android-platform-tools</span><br></pre></td></tr></table></figure>

<p>3、运行adb</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">adb devices</span><br></pre></td></tr></table></figure>

<h2 id="如果你有装Android-Studio-那么可以参考以下步骤"><a href="#如果你有装Android-Studio-那么可以参考以下步骤" class="headerlink" title="如果你有装Android Studio 那么可以参考以下步骤:"></a>如果你有装Android Studio 那么可以参考以下步骤:</h2><h3 id="1-安装IDE-（android-studio）"><a href="#1-安装IDE-（android-studio）" class="headerlink" title="1. 安装IDE （android studio）"></a>1. 安装IDE （android studio）</h3><p>安装后，确认自己的<code>adb</code>目录，一般目录在 <code>~/Library/Android/sdk/platform-tools</code>，<code>~</code>代表当前用户的根目录，如果不知道当前用户的根目录在终端上输入<code>echo $HOME</code>便可知晓。<br> 最简单的方法，就是按快捷键<code>command + shift + G</code> ，然后把<code>~/Library/Android/sdk/platform-tools</code>这个目录复制到输入框内，按回车便可打开文件夹位置</p>
<h3 id="2-打开终端（应用程序——实用工具），运行："><a href="#2-打开终端（应用程序——实用工具），运行：" class="headerlink" title="2. 打开终端（应用程序——实用工具），运行："></a>2. 打开终端（应用程序——实用工具），运行：</h3><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">sudo</span> <span class="selector-tag">vi</span> <span class="selector-class">.bash_profile</span></span><br></pre></td></tr></table></figure>

<p>屏幕上会提示你输入密码（输入密码的时候不会有任何字符显示，输完之后按回车就是了）<br> 打开文件之后按<code>i</code>键进入插入模式（可理解为编辑模式），然后对该文件进行编辑</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$&#123;PATH&#125;</span>:你的platform-tools具体地址</span><br></pre></td></tr></table></figure>

<p>我输入的是</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">export PATH=$&#123;PATH&#125;<span class="symbol">:~/Library/Android/sdk/platform-tools</span></span><br></pre></td></tr></table></figure>

<p>当然这是比较默认的情况，如果你改了<code>Android</code>的目录就要根据<code>platform-tools</code>这个文件夹的实际目录去填写。<br> 编辑完成之后按 <code>esc</code> 键退出插入模式，之后按 <code>:wq</code>+ 回车保存退出，记得英文的冒号也是要输入的哦。</p>
<h4 id="最关键的要输入生效命令"><a href="#最关键的要输入生效命令" class="headerlink" title="最关键的要输入生效命令"></a>最关键的要输入生效命令</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">source</span> ~/.bash_profile</span><br></pre></td></tr></table></figure>

<p>之后在终端里试一下输入adb，如果显示出来是一大串文字而不是之前的 command not found就大功告成。</p>
<h5 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h5><p>如果遇到关闭终端后再打开，又无法使用adb命令了，可以尝试以下办法<br> 在<code>~/.zshrc</code>文件最后，增加一行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">source</span> ~/.bash_profile</span><br></pre></td></tr></table></figure>

<p>如果没有这个文件，可自己创建，运行命令<code>touch .zshrc</code>，运行命令<code>open .zshrc</code>打开编译。</p>
<h3 id="3-下面附上常用的adb命令"><a href="#3-下面附上常用的adb命令" class="headerlink" title="3. 下面附上常用的adb命令"></a>3. 下面附上常用的adb命令</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 查看所有设备：</span></span><br><span class="line">adb devices</span><br><span class="line"><span class="comment">// 安装指定apk(路径可不用手写，直接把apk文件拖拽过来)：</span></span><br><span class="line">adb  install &lt;file&gt;</span><br><span class="line"><span class="comment">// 卸载指定包 ：</span></span><br><span class="line">adb uninstall &lt;<span class="keyword">package</span>&gt;</span><br><span class="line"><span class="comment">// 拷贝文件到设备上:</span></span><br><span class="line"> adb push &lt;local&gt; &lt;remote&gt;</span><br><span class="line"><span class="comment">// 从设备中拷贝文件：</span></span><br><span class="line"> adb pull &lt;remote&gt; [&lt;local&gt;]</span><br><span class="line"><span class="comment">// 查看命令帮助：</span></span><br><span class="line">adb help</span><br></pre></td></tr></table></figure>

<p><strong>本文为作者原创 转载时请注明出处 谢谢</strong></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt="img"></p>
<p><em>乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</em></p>
]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>App自动化之Appium入门</title>
    <url>/23.html</url>
    <content><![CDATA[<blockquote>
<p>像<code>Selenium</code>可以操控Web浏览器，手机APP平台也有类似的自动化测试工具：<code>Appium</code>；<br>全文分基础介绍、环境搭建和案例演示三部分介绍<code>Appium</code>，以帮助Learner快速的上手。</p>
</blockquote>
<h3 id="基础介绍"><a href="#基础介绍" class="headerlink" title="基础介绍"></a>基础介绍</h3><p>Appium是一个开源的自动化测试框架，用于原生，混合和移动Web应用程序。 它使用WebDriver协议驱动iOS，Android和Windows应用程序。关于它的运作流程，用图来介绍会更加生动形象一些：</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/Nd9GcRnhRoLusz8RMt6P3dBn_po4ozGjHWB-20200907103239987.png" alt="Appium运行流程、原理"></p>
<p>在上图中，左边这部分是<code>Appium-Client</code>，通俗点来说，是用于间接驱动最右边的设备执行预定的自动化测试流程，支持使用多种主流的编程语言进行编写，这也是测试开发人员需要关注的核心部分；中间的<code>Appium-Server</code>是衔接左边客户端以及右边APP设备端的重要桥梁，一般仅需要配置好环境及启动运行；右边这块，当然就是实际执行自动化测试的终端，如IOS真机、Android真机，或者是模拟器。</p>
<h3 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h3><ul>
<li>NodeJS</li>
</ul>
<p>Appium是使用nodejs实现的，因此Node是解释器，首先要确认安装好</p>
<ul>
<li>Appium-Server<ul>
<li>nodejs</li>
<li><a href="https://github.com/appium/appium-desktop/releases" target="_blank" rel="noopener">appium-desktop</a></li>
</ul>
</li>
</ul>
<p>上述的两种方式都可以搭建<code>Appium-Server</code>环境，后面演示会基于Appium-Desktop。(PS：下载太慢了?分享个<a href="https://pan.baidu.com/s/1QQcYcDlOngdFjLhaJWAXCg" target="_blank" rel="noopener">百度网盘</a>)</p>
<ul>
<li>Andrioid SDK<ul>
<li><a href="https://android-sdk.en.softonic.com/" target="_blank" rel="noopener">android sdk</a></li>
<li><a href="https://developer.android.com/studio/" target="_blank" rel="noopener">android studio</a></li>
</ul>
</li>
</ul>
<p>上述方式可以直接和间接搭建安装<code>Android</code>环境，因为后面要用到<code>adb</code>这个工具，所以需要配置好<code>ANDROID_HOME</code>这个环境变量。(PS：下载太慢了?分享个<a href="https://pan.baidu.com/s/1Y7UC8S2Plsieo59MPmQgMw" target="_blank" rel="noopener">百度网盘</a>)</p>
<ul>
<li>Appium-Python-Client</li>
</ul>
<p>后面会用到Python来编写Appium客户端：<code>pip install Appium-Python-Client</code></p>
<p>okay，准备好以上几个环境后，启动Appium测试一下：</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/20181030111040-20200907103248988.png" alt="Appium Desktop Server"></p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/20181030111212-20200907103257799.png" alt="Appium Desktop Server"></p>
<h3 id="案例演示"><a href="#案例演示" class="headerlink" title="案例演示"></a>案例演示</h3><p>下面演示在安卓真机上的自动登录<code>Keep</code>(APP)。</p>
<ol>
<li>获取设备名称。操作流程：开启手机的开发和调试模式，连接电脑授权认证，<code>Window + R</code>输入并运行<code>cmd</code>，用<code>adb devices -l</code>查看：</li>
</ol>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/20181030134047-20200907103307894.png" alt="获取设备号"></p>
<ol>
<li>启动Appium Server进行调试：</li>
</ol>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/20181030134400-20200907103312054.png" alt="Inspector Session"></p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/20181030134702-20200907103318824.png" alt="Desired Capabilities"></p>
<p>从上图可以看到，启动App Session需要有以下几个参数(点击了解更详细的<a href="https://appium.io/docs/en/writing-running-appium/caps/" target="_blank" rel="noopener">Appium Desired Capabilities</a>）:</p>
<ul>
<li><code>platformName</code>，如<code>Android</code>、<code>iOS</code>等</li>
<li><code>deviceName</code>，参考前面是如何获取的</li>
<li><code>appPackage</code>和<code>appActivity</code>，获取<a href="https://blog.csdn.net/mtbaby/article/details/78676477" target="_blank" rel="noopener">参考这里</a></li>
</ul>
<p>综上所述，这里对应<code>Keep</code>的信息如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;platformName&quot;: &quot;Android&quot;,</span><br><span class="line">  &quot;deviceName&quot;: &quot;WAS_AL00&quot;,</span><br><span class="line">  &quot;appPackage&quot;: &quot;com.gotokeep.keep&quot;,</span><br><span class="line">  &quot;appActivity&quot;: &quot;com.gotokeep.keep.splash.SplashActivity&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>点击<code>Start Session</code>，之后可以看到手机端启动了<code>Keep</code>，并且在Appium Server端中同步展示：</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/20181030150015-20200907103327336.png" alt="Start Session"></p>
<p><img src="http://image.mariojd.cn/happyjared/20181030/20181030150055.png" alt="Keep"></p>
<p>上述的操作通常只是用来方便获取控件id及定位的，下面基于Python编写完整的<code>Appium-Client</code>以实现自动登录操作：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from appium import webdriver</span><br><span class="line">from selenium.webdriver.common.by import By</span><br><span class="line">from selenium.webdriver.support.ui import WebDriverWait</span><br><span class="line">from selenium.webdriver.support import expected_conditions as EC</span><br><span class="line"></span><br><span class="line">server = &apos;http://localhost:4723/wd/hub&apos;  # Appium Server, 端口默认为4723</span><br><span class="line">desired_capabilities = &#123;</span><br><span class="line">    &apos;platformName&apos;: &apos;Android&apos;,</span><br><span class="line">    &apos;deviceName&apos;: &apos;WAS_AL00&apos;,  # 需替换成你的deviceName</span><br><span class="line">    &apos;appPackage&apos;: &apos;com.gotokeep.keep&apos;,</span><br><span class="line">    &apos;appActivity&apos;: &apos;com.gotokeep.keep.splash.SplashActivity&apos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">driver = webdriver.Remote(server, desired_capabilities)</span><br><span class="line">wait = WebDriverWait(driver, 10)  # 最大查找等待超时时间：10s</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def get_permission():</span><br><span class="line">    &quot;&quot;&quot;允许APP获取的某些权限&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">    try:</span><br><span class="line">        ask = wait.until(EC.presence_of_element_located((By.ID, &apos;com.android.packageinstaller:id/do_not_ask_checkbox&apos;)))</span><br><span class="line">        ask.click()</span><br><span class="line">        allow = wait.until(</span><br><span class="line">            EC.presence_of_element_located((By.ID, &apos;com.android.packageinstaller:id/permission_allow_button&apos;)))</span><br><span class="line">        allow.click()</span><br><span class="line">    except:</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 允许两项授权</span><br><span class="line">get_permission()</span><br><span class="line">get_permission()</span><br><span class="line"></span><br><span class="line"># 点击“立即使用”</span><br><span class="line">welcome = wait.until(EC.presence_of_element_located((By.ID, &apos;com.gotokeep.keep:id/btn_bottom_in_video_welcome&apos;)))</span><br><span class="line">welcome.click()</span><br><span class="line"></span><br><span class="line"># 切换“密码登录”(同样可以使用第三方进行授权登录)</span><br><span class="line">driver.tap([(900, 110)])</span><br><span class="line"></span><br><span class="line"># 输入“手机号”</span><br><span class="line">phone = driver.find_element_by_accessibility_id(&apos;Phone Number In Login&apos;)</span><br><span class="line">phone.send_keys(&apos;13988888888&apos;)  # 替换成实际的账号</span><br><span class="line"></span><br><span class="line"># 输入“密码”</span><br><span class="line">password = driver.find_element_by_accessibility_id(&apos;Password In Login&apos;)</span><br><span class="line">password.send_keys(&apos;123456&apos;)  # 替换成实际的密码</span><br><span class="line"></span><br><span class="line"># 点击“登录”</span><br><span class="line">login = driver.find_element_by_id(&apos;com.gotokeep.keep:id/btn_action&apos;)</span><br><span class="line">login.click()</span><br></pre></td></tr></table></figure>

<p>最后，附上运行效果图：</p>
<p><img src="http://image.mariojd.cn/happyjared/20181030/20181030160014.gif" alt="效果图"></p>
<p><strong>本文转载自;<a href="https://blog.mariojd.cn/get-started-with-appium.html" target="_blank" rel="noopener">https://blog.mariojd.cn/get-started-with-appium.html</a></strong></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em>乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</em></p>
]]></content>
      <tags>
        <tag>python自动化</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux下查看目录和文件大小以及隐藏文件</title>
    <url>/230.html</url>
    <content><![CDATA[<h4 id="查看当前目录下的隐藏文件"><a href="#查看当前目录下的隐藏文件" class="headerlink" title="查看当前目录下的隐藏文件"></a>查看当前目录下的隐藏文件</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ls -a</span><br></pre></td></tr></table></figure>

<h3 id="移动隐藏文件"><a href="#移动隐藏文件" class="headerlink" title="移动隐藏文件"></a>移动隐藏文件</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mv xxx/.[^.]*</span><br></pre></td></tr></table></figure>

<h4 id="查看目录和文件大小"><a href="#查看目录和文件大小" class="headerlink" title="查看目录和文件大小"></a>查看目录和文件大小</h4><ol>
<li><p>以字节形式显示</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ls -ll</span><br></pre></td></tr></table></figure>
</li>
<li><p>以KB MB等单位显示(推荐)</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ls -lh</span><br></pre></td></tr></table></figure>
</li>
<li><p>遍历当前目录下所有子目录大小</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">du -h </span><br><span class="line"><span class="comment"># 或指定层级遍历(*表示遍历所有子目录)</span></span><br><span class="line">du -h –max-depth=1 *</span><br><span class="line"><span class="comment"># 或指定某个子目录下的层级</span></span><br><span class="line">du -h –max-depth=1 software/</span><br></pre></td></tr></table></figure>
</li>
<li><p>只查看当前目录总大小</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">du -sh</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看当前目录下所有文件夹的大小</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">du -sh *</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看当前目录下除某些目录以外的所有文件夹大小</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">du -sh --exclude=dir1 --exclude=dir2 *</span><br></pre></td></tr></table></figure>





</li>
</ol>
<p><strong>本文为作者原创 转载时请注明出处 谢谢</strong></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt="img"></p>
<p><em>乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</em></p>
]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>如何将自定义库上传至jitpack仓库</title>
    <url>/233.html</url>
    <content><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>最近<code>bintray</code>好像不能用了, 以前传的依赖包全都挂了, 目前正在进行库转移</p>
<p>相比<code>bintray</code>而言 <code>jitpack</code>可以说是非常简单, 只需一个<code>github</code>就完全搞定了</p>
<h4 id="快速上手"><a href="#快速上手" class="headerlink" title="快速上手"></a>快速上手</h4><p>首先 将代码推送至<code>github</code>, 然后进入<a href="https://jitpack.io/" target="_blank" rel="noopener">https://jitpack.io/</a></p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20210727145153403.png" alt="image-20210727145153403"></p>
<p>绿色表示 编译成功 红色表示编译失败, 编译成功后 就可以开始使用库啦</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20210727145906319.png" alt="image-20210727145906319"></p>
<p>是不是非常简单</p>
<p>由于大部分人习惯使用版本号的依赖形式, 因此 如果你想将<code>commitId</code>换成版本号, 那么只需在<code>github</code>上<code>push release</code>即可, 如下:</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20210727150302447.png" alt="image-20210727150302447"></p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20210727150429243.png" alt="image-20210727150429243"></p>
<p>创建成功后,回到<code>jitpack</code>主页刷新, 此时在<code>Release</code>一栏下出现相应的版本</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20210727150604728.png" alt="image-20210727150604728"></p>
<p>我们发现<code>1.0.5</code>版本的<code>Log</code>一栏是红色, 我们可以点击进入查看编译日志 寻找编译失败原因</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20210727150827296.png" alt="image-20210727150827296"></p>
<p>如果编译成功, 将会生成相应的<code>jar</code>包并存储在<code>jitpack</code>仓库中</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20210727151000773.png" alt="image-20210727151000773"></p>
<p>此时我们就可以使用版本号形式的啦</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20210727151055721.png" alt="image-20210727151055721"></p>
<h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><ul>
<li>对于<code>android</code> 必须是<code>Lib</code>库 而不是<code>APP</code></li>
<li>由于<code>jitpack</code>会对整个项目库进行编译打包, 因此项目中避免出现多个库的情况, 如果是<code>android</code> 可以在<code>settings.gradle</code>里面进行注释屏蔽</li>
</ul>
<p>除了<code>github</code>之外,<code>jitpack</code>还支持以下仓库:</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20210727153831851.png" alt="image-20210727153831851"></p>
<p><strong>本文为作者原创 转载时请注明出处 谢谢</strong></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt="img"></p>
<p><em>乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</em></p>
]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>Mac平台下adb连接网易MuMu模拟器</title>
    <url>/231.html</url>
    <content><![CDATA[<p>第三方模拟器<code>adb</code>无法自动识别, 每个模拟器都有各自的端口占用</p>
<p>在<code>Mac</code>平台下, 可以输入以下指令连接<code>MuMu</code>模拟器并调试</p>
<h4 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">adb connect 127.0.0.1:5555</span><br></pre></td></tr></table></figure>

<h4 id="WatchDog"><a href="#WatchDog" class="headerlink" title="WatchDog"></a>WatchDog</h4><p>网易模拟器自带应用崩溃日志收集功能, 可以快速定位<code>crash</code>原因, 针对一些第三方的<code>App</code>, 可以有效抓出异常</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20220719122152894.png" alt="image-20220719122152894"></p>
<p><strong>本文为作者原创 转载时请注明出处 谢谢</strong></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt="img"></p>
<p><em>乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</em></p>
]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>关于android scheme跳转配置中pathPattern的使用</title>
    <url>/232.html</url>
    <content><![CDATA[<h4 id="Scheme协议在Android中使用场景"><a href="#Scheme协议在Android中使用场景" class="headerlink" title="Scheme协议在Android中使用场景"></a>Scheme协议在Android中使用场景</h4><ol>
<li><p>H5页面和Native页面的交互</p>
</li>
<li><p>客户端获取push消息中后，点击消息跳转到APP内部页面</p>
</li>
<li><p>APP根据URL跳转到另外一个APP指定页面</p>
</li>
<li><p>外部浏览器唤醒App</p>
</li>
</ol>
<h4 id="Scheme协议的使用"><a href="#Scheme协议的使用" class="headerlink" title="Scheme协议的使用"></a>Scheme协议的使用</h4><ol>
<li><strong>场景一 外部浏览器唤醒app</strong></li>
</ol>
<p>以<code>app://test/good?goodsId=3</code>这个内链为例, 假设浏览器中点击该内链需要跳转到应用的指定Activity</p>
<p>那么,首先在清单文件中对指定Activity进行intent过滤配置:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;activity</span><br><span class="line">          android:name=&quot;.ui.login.LoginActivity&quot;</span><br><span class="line">          android:screenOrientation=&quot;portrait&quot;&gt;</span><br><span class="line">          &lt;intent-filter&gt;</span><br><span class="line">          &lt;!--可以根据用户的数据类型，打开相应的Activity--&gt;</span><br><span class="line">              &lt;action android:name=&quot;android.intent.action.VIEW&quot; /&gt;</span><br><span class="line">              &lt;!--界面可以被隐式调用--&gt;</span><br><span class="line">              &lt;category android:name=&quot;android.intent.category.DEFAULT&quot; /&gt;</span><br><span class="line">              &lt;!--界面可以通过浏览器的连接启动--&gt;</span><br><span class="line">              &lt;category android:name=&quot;android.intent.category.BROWSABLE&quot; /&gt;</span><br><span class="line">              &lt;!--协议部分，主要是配置scheme和host--&gt;</span><br><span class="line">              &lt;data</span><br><span class="line">              		android:path=&quot;/good&quot;</span><br><span class="line">                  android:host=&quot;test&quot;</span><br><span class="line">                  android:scheme=&quot;app&quot; /&gt;</span><br><span class="line">          &lt;/intent-filter&gt;</span><br><span class="line">      &lt;/activity&gt;</span><br></pre></td></tr></table></figure>

<p>然后在<code>Activity</code>的<code>onCreate</code>方法中进行参数的获取和逻辑的处理:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Uri data = getIntent().getData();</span><br><span class="line">String param = data.getQueryParameter(&quot;goodsId&quot;);//获取指定key下的参数</span><br></pre></td></tr></table></figure>

<p>最后测试跳转即可</p>
<ol start="2">
<li><p><strong>场景二 应用内部H5交互(页面跳转)</strong></p>
<p>还是以<code>app://test/good?goodsId=3</code>这个内链为例, 假设WebView中点击该内链需要跳转到应用的指定Activity</p>
<p>首先还是在清单文件中配置,如上</p>
<p>然后配置webview:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">override fun shouldOverrideUrlLoading(view: WebView, url: String): Boolean &#123;</span><br><span class="line">startActivity(Intent(Intent.ACTION_VIEW, url.toUri()))</span><br><span class="line">  return true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为webview属于开发者自定义, 因此内链跳转逻辑需要在<code>shouldOverrideUrlLoading</code>方法中自行处理</p>
</li>
<li><p><strong>场景三 应用内部H5交互(非页面跳转)</strong></p>
<p>有时候需求不单单是页面的跳转, 可能还涉及到其他ui或者逻辑的交互, 比如跳转到支付宝失败后弹出弹窗等等, 这个时候,我们需要在<code>shouldOverrideUrlLoading</code>方法中进行不同scheme的处理:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">override fun shouldOverrideUrlLoading(view: WebView, url: String): Boolean &#123;</span><br><span class="line">                 if (url.startsWith(&quot;alipay&quot;)) &#123;</span><br><span class="line">                        try &#123;</span><br><span class="line">                            startActivity(Intent(Intent.ACTION_VIEW, url.toUri()))</span><br><span class="line">                        &#125; catch (e: Exception) &#123;</span><br><span class="line">                            e.printStackTrace()</span><br><span class="line">                            AlertDialog.Builder(requireContext())</span><br><span class="line">                                .setMessage(&quot;未检测到支付宝客户端，请安装后重试。&quot;)</span><br><span class="line">                                .setPositiveButton(&quot;&quot;) &#123; _, _ -&gt;</span><br><span class="line">                                    startActivity(</span><br><span class="line">                                        Intent(</span><br><span class="line">                                            Intent.ACTION_VIEW,</span><br><span class="line">                                            &quot;https://d.alipay.com&quot;.toUri()</span><br><span class="line">                                        )</span><br><span class="line">                                    )</span><br><span class="line">                                &#125;</span><br><span class="line">                                .setNegativeButton(&quot;取消&quot;, null).show()</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; </span><br><span class="line">                    return true</span><br><span class="line">                    &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>场景四 应用内Activity之间的跳转</strong></p>
<p>首先依然在清单文件中配置</p>
<p>然后使用隐式跳转:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">startActivity(new Intent(Intent.ACTION_VIEW,Uri.parse(&quot;`app://test/good?goodsId=3`&quot;)))</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h4 id="多个不同scheme跳转同一个页面"><a href="#多个不同scheme跳转同一个页面" class="headerlink" title="多个不同scheme跳转同一个页面"></a>多个不同scheme跳转同一个页面</h4><p>只需要在清单文件增加多个<code>data</code>标签即可:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;activity</span><br><span class="line">          android:name=&quot;.ui.login.LoginActivity&quot;</span><br><span class="line">          android:screenOrientation=&quot;portrait&quot;&gt;</span><br><span class="line">          &lt;intent-filter&gt;</span><br><span class="line">              &lt;action android:name=&quot;android.intent.action.VIEW&quot; /&gt;</span><br><span class="line">              &lt;category android:name=&quot;android.intent.category.DEFAULT&quot; /&gt;</span><br><span class="line">              &lt;category android:name=&quot;android.intent.category.BROWSABLE&quot; /&gt;</span><br><span class="line">					</span><br><span class="line">              &lt;data</span><br><span class="line">              		android:path=&quot;/good&quot;</span><br><span class="line">                  android:host=&quot;test&quot;</span><br><span class="line">                  android:scheme=&quot;app&quot; /&gt;</span><br><span class="line">                  </span><br><span class="line">					</span><br><span class="line">              &lt;data</span><br><span class="line">                  android:host=&quot;test2&quot;</span><br><span class="line">                  android:scheme=&quot;app&quot; /&gt;</span><br><span class="line">          &lt;/intent-filter&gt;</span><br><span class="line">      &lt;/activity&gt;</span><br></pre></td></tr></table></figure>

<h4 id="使用pathPattern匹配模式"><a href="#使用pathPattern匹配模式" class="headerlink" title="使用pathPattern匹配模式"></a>使用pathPattern匹配模式</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;data</span><br><span class="line">                   android:pathPattern=&quot;/.*&quot;</span><br><span class="line">                   android:host=&quot;test&quot;</span><br><span class="line">                   android:scheme=&quot;app&quot; /&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.表示匹配任意字符 *表示匹配0次或多次  遗憾的是pathPattern无法使用标准的正则表达式 只有* 和.可用</span><br></pre></td></tr></table></figure>

<h4 id="关于sspPattern匹配模式"><a href="#关于sspPattern匹配模式" class="headerlink" title="关于sspPattern匹配模式"></a>关于sspPattern匹配模式</h4><p>我们使用内链的格式一般和<code>url</code>格式一致,比如<code>app://test</code>, 如果我们想使用自定义格式比如这种<code>app:test</code>, 那常规的方法则不奏效,此时<code>sspPattern</code>就可以派上用场</p>
<p>我们在清单文件中如下配置即可:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;data</span><br><span class="line">                   android:ssp=&quot;test&quot;</span><br><span class="line">                   android:scheme=&quot;app&quot; /&gt;</span><br></pre></td></tr></table></figure>

<p>同样该模式下对应三个属性:</p>
<ul>
<li>ssp :字面值匹配模式(PATTERN_LITERAL) 内部采用equals函数</li>
<li>sspPrefix 前缀匹配模式(PATTERN_PREFIX) 内部采用startWith函数</li>
<li>sspPattern 全局匹配模式(PATTERN_GLOB) glob规则是一种简化的模式，只支持“*”和“.”作为通配符 </li>
</ul>
<p>实际上类似于url格式的内链, 比如<code>app://test</code>也可以使用<code>ssp</code>进行匹配:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;data</span><br><span class="line">                    android:ssp=&quot;//test&quot;</span><br><span class="line">                    android:scheme=&quot;app&quot; /&gt;</span><br></pre></td></tr></table></figure>

<p>不过一般我们不会这么做, 因为直接使用<code>host</code>属性更加简洁</p>
<p><strong>本文为作者原创 转载时请注明出处 谢谢</strong></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt="img"></p>
<p><em>乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</em></p>
]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>Android开发者快速上手鸿蒙应用开发</title>
    <url>/234.html</url>
    <content><![CDATA[<h4 id="Android和鸿蒙对比"><a href="#Android和鸿蒙对比" class="headerlink" title="Android和鸿蒙对比"></a>Android和鸿蒙对比</h4><p>组件</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/4d086e061d950a7ba9141cf42a128ddef2d3c92c.png" alt="img"></p>
<p>触摸事件</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/3801213fb80e7bec6a5e07440eed563f99506bdd.png" alt="img"></p>
<p>鸿蒙页面生命周期</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/267f9e2f07082838628466f7a65a46064e08f197.png" alt="img"></p>
<p><strong>本文为作者原创 转载时请注明出处 谢谢</strong></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt="img"></p>
<p><em>乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</em></p>
]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>Android开发者快速上手Flutter应用开发</title>
    <url>/235.html</url>
    <content><![CDATA[<h4 id="工程目录概览"><a href="#工程目录概览" class="headerlink" title="工程目录概览"></a>工程目录概览</h4><p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/20210728113806.png" alt></p>
<h4 id="UI编写"><a href="#UI编写" class="headerlink" title="UI编写"></a>UI编写</h4><p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/20210728114039.png" alt></p>
<h2 id="main-dart分析"><a href="#main-dart分析" class="headerlink" title="main.dart分析"></a>main.dart分析</h2><h4 id="1-StatelessWidget和StatefullWidget"><a href="#1-StatelessWidget和StatefullWidget" class="headerlink" title="1. StatelessWidget和StatefullWidget"></a>1. StatelessWidget和StatefullWidget</h4><p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20210728145631191.png" alt="image-20210728145631191"></p>
<ul>
<li><strong>StatelessWidget</strong>: <strong>无状态不可更新</strong>Widget，其<code>build</code>方法只在组件创建执行一次, 就是说一旦这个Widget创建完成，相关的属性配置就不允许再变动, 适用于属性固定不变的控件, 节约性能。</li>
<li><strong>StatefulWidget</strong>:<strong>有状态可更新</strong>Widget，State类中的<code>build</code>方法可以通过调用setState函数来重复执行, 类似于android自定义控件中的invalidate, 适用于属性需要动态改变的控件, 比如点击或者网络请求后控件内容更新</li>
</ul>
<p><strong>注</strong>: 这种状态只针对当前控件有效, 不影响父控件或者子控件</p>
<h4 id="2-函数"><a href="#2-函数" class="headerlink" title="2. 函数"></a>2. 函数</h4><ol>
<li>在<code>dart</code>中函数形参, 我们可以使用大括号<code>map</code>形式的参数:</li>
</ol>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20210728154529647.png" alt="image-20210728154529647"></p>
<p>也可以使用普通的形参表示:</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20210728155125323.png" alt="image-20210728155125323"></p>
<p>或者两者混搭:</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20210728171730504.png" alt="image-20210728171730504"></p>
<p><strong>两者区别:</strong></p>
<ul>
<li><strong>map形式</strong>: 传参时, 采用<code>key:value</code>的形式, 可设置默认值, 参数<strong>可传可不传</strong></li>
</ul>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20210728154701753.png" alt="image-20210728154701753"></p>
<ul>
<li><strong>普通形式</strong>: 传参方式和<code>java</code>函数传参一样, <strong>参数必传</strong>,否则报错</li>
</ul>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20210728155231818.png" alt="image-20210728155231818"></p>
<p>此外, 我们还可以将函数当做参数进行传递:</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20210728161913775.png" alt="image-20210728161913775"></p>
<p>定义一个形参和返回值皆为函数的方法:</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20210728165822497.png" alt="image-20210728165822497"></p>
<p>一般这种写法太复杂, 为了简化写法, 我们可以给函数定义一个别名,类似于这种:</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20210728170107196.png" alt="image-20210728170107196"></p>
<p>这样看起来就清爽多了:</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20210728170335274.png" alt="image-20210728170335274"></p>
<ol start="2">
<li>内部匿名函数与外部函数</li>
</ol>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20210728170905542.png" alt="image-20210728170905542"></p>
<p>当然 函数内部也可以声明函数:</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20210728171034497.png" alt="image-20210728171034497"></p>
<ol start="3">
<li>函数返回的简化写法:</li>
</ol>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20210728152316338.png" alt="image-20210728152316338"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">_MyHomePageState createState() =&gt; _MyHomePageState();</span><br></pre></td></tr></table></figure>

<p>相当于</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">_MyHomePageState createState()&#123; </span><br><span class="line">	return  _MyHomePageState();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>UI的隐藏与显示</li>
</ol>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20210728163636872.png" alt="image-20210728163636872"></p>
<p><code>Scaffold</code>这个类为我们预制了很多控件, 类似于一个模板,我们可以对内置的控件进行排列组合, 需要显示的就定义, 不显示就不定义, 非常方便</p>
<p><strong>本文为作者原创 转载时请注明出处 谢谢</strong></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt="img"></p>
<p><em>乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</em></p>
]]></content>
      <tags>
        <tag>flutter</tag>
      </tags>
  </entry>
  <entry>
    <title>为什么建议你使用枚举</title>
    <url>/236.html</url>
    <content><![CDATA[<p>枚举是 JDK 1.5 新增的数据类型，使用枚举我们可以很好的描述一些特定的业务场景，比如一年中的春、夏、秋、冬，还有每周的周一到周天，还有各种颜色，以及可以用它来描述一些状态信息，比如错误码等。</p>
<p>枚举类型不止存在在 Java 语言中，在其它语言中也都能找到它的身影，例如 C# 和 Python 等，但我发现在实际的项目中使用枚举的人很少，所以本文就来聊一聊枚举的相关内容，好让朋友们对枚举有一个大概的印象，这样在编程时起码还能想到有“枚举”这样一个类型。</p>
<p>本文的结构目录如下：</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/v2-80ca1407a3ceabbf7e2be786b4c9bdcf_720w.jpg" alt="img"></p>
<h2 id="枚举的-7-种使用方法"><a href="#枚举的-7-种使用方法" class="headerlink" title="枚举的 7 种使用方法"></a>枚举的 7 种使用方法</h2><p>很多人不使用枚举的一个重要的原因是对枚举不够熟悉，那么我们就先从枚举的 7 种使用方法说起。</p>
<h3 id="用法一：常量"><a href="#用法一：常量" class="headerlink" title="用法一：常量"></a>用法一：常量</h3><p>在 JDK 1.5 之前，我们定义常量都是 <code>public static final...</code> ，但有了枚举，我们就可以把这些常量定义成一个枚举类了，实现代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public enum ColorEnum &#123;  </span><br><span class="line">  RED, GREEN, BLANK, YELLOW  </span><br><span class="line">&#125; </span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<h3 id="用法二：switch"><a href="#用法二：switch" class="headerlink" title="用法二：switch"></a>用法二：switch</h3><p>将枚举用在 switch 判断中，使得代码可读性更高了，实现代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">enum ColorEnum &#123;</span><br><span class="line">    GREEN, YELLOW, RED</span><br><span class="line">&#125;</span><br><span class="line">public class ColorTest &#123;</span><br><span class="line">    ColorEnum color = ColorEnum.RED;</span><br><span class="line"></span><br><span class="line">    public void change() &#123;</span><br><span class="line">        switch (color) &#123;</span><br><span class="line">            case RED:</span><br><span class="line">                color = ColorEnum.GREEN;</span><br><span class="line">                break;</span><br><span class="line">            case YELLOW:</span><br><span class="line">                color = ColorEnum.RED;</span><br><span class="line">                break;</span><br><span class="line">            case GREEN:</span><br><span class="line">                color = ColorEnum.YELLOW;</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<h3 id="用法三：枚举中增加方法"><a href="#用法三：枚举中增加方法" class="headerlink" title="用法三：枚举中增加方法"></a>用法三：枚举中增加方法</h3><p>我们可以在枚举中增加一些方法，让枚举具备更多的特性，实现代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class EnumTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ErrorCodeEnum errorCode = ErrorCodeEnum.SUCCESS;</span><br><span class="line">        System.out.println(&quot;状态码：&quot; + errorCode.code() + </span><br><span class="line">                           &quot; 状态信息：&quot; + errorCode.msg());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">enum ErrorCodeEnum &#123;</span><br><span class="line">    SUCCESS(1000, &quot;success&quot;),</span><br><span class="line">    PARAM_ERROR(1001, &quot;parameter error&quot;),</span><br><span class="line">    SYS_ERROR(1003, &quot;system error&quot;),</span><br><span class="line">    NAMESPACE_NOT_FOUND(2001, &quot;namespace not found&quot;),</span><br><span class="line">    NODE_NOT_EXIST(3002, &quot;node not exist&quot;),</span><br><span class="line">    NODE_ALREADY_EXIST(3003, &quot;node already exist&quot;),</span><br><span class="line">    UNKNOWN_ERROR(9999, &quot;unknown error&quot;);</span><br><span class="line"></span><br><span class="line">    private int code;</span><br><span class="line">    private String msg;</span><br><span class="line"></span><br><span class="line">    ErrorCodeEnum(int code, String msg) &#123;</span><br><span class="line">        this.code = code;</span><br><span class="line">        this.msg = msg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int code() &#123;</span><br><span class="line">        return code;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String msg() &#123;</span><br><span class="line">        return msg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static ErrorCodeEnum getErrorCode(int code) &#123;</span><br><span class="line">        for (ErrorCodeEnum it : ErrorCodeEnum.values()) &#123;</span><br><span class="line">            if (it.code() == code) &#123;</span><br><span class="line">                return it;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return UNKNOWN_ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>以上程序的执行结果为：</p>
<blockquote>
<p>状态码：1000 状态信息：success</p>
</blockquote>
<h3 id="用法四：覆盖枚举方法"><a href="#用法四：覆盖枚举方法" class="headerlink" title="用法四：覆盖枚举方法"></a>用法四：覆盖枚举方法</h3><p>我们可以覆盖一些枚举中的方法用于实现自己的业务，比如我们可以覆盖 <code>toString()</code> 方法，实现代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class EnumTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ColorEnum colorEnum = ColorEnum.RED;</span><br><span class="line">        System.out.println(colorEnum.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">enum ColorEnum &#123;</span><br><span class="line">    RED(&quot;红色&quot;, 1), GREEN(&quot;绿色&quot;, 2), BLANK(&quot;白色&quot;, 3), YELLOW(&quot;黄色&quot;, 4);</span><br><span class="line">    //  成员变量</span><br><span class="line">    private String name;</span><br><span class="line">    private int index;</span><br><span class="line"></span><br><span class="line">    //  构造方法</span><br><span class="line">    private ColorEnum(String name, int index) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.index = index;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //覆盖方法</span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return this.index + &quot;：&quot; + this.name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>以上程序的执行结果为：</p>
<blockquote>
<p>1：红色</p>
</blockquote>
<h3 id="用法五：实现接口"><a href="#用法五：实现接口" class="headerlink" title="用法五：实现接口"></a>用法五：实现接口</h3><p>枚举类可以用来实现接口，但不能用于继承类，因为枚举默认继承了 <code>java.lang.Enum</code> 类，在 Java 语言中允许实现多接口，但不能继承多个父类，实现代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class EnumTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ColorEnum colorEnum = ColorEnum.RED;</span><br><span class="line">        colorEnum.print();</span><br><span class="line">        System.out.println(&quot;颜色：&quot; + colorEnum.getInfo());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface Behaviour &#123;</span><br><span class="line">    void print();</span><br><span class="line"></span><br><span class="line">    String getInfo();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">enum ColorEnum implements Behaviour &#123;</span><br><span class="line">    RED(&quot;红色&quot;, 1), GREEN(&quot;绿色&quot;, 2), BLANK(&quot;白色&quot;, 3), YELLOW(&quot;黄色&quot;, 4);</span><br><span class="line">    private String name;</span><br><span class="line">    private int index;</span><br><span class="line"></span><br><span class="line">    private ColorEnum(String name, int index) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.index = index;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void print() &#123;</span><br><span class="line">        System.out.println(this.index + &quot;：&quot; + this.name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String getInfo() &#123;</span><br><span class="line">        return this.name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>以上程序的执行结果为：</p>
<blockquote>
<p>1：红色</p>
<p>颜色：红色</p>
</blockquote>
<h3 id="用法六：在接口中组织枚举类"><a href="#用法六：在接口中组织枚举类" class="headerlink" title="用法六：在接口中组织枚举类"></a>用法六：在接口中组织枚举类</h3><p>我们可以在一个接口中创建多个枚举类，用它可以很好的实现“多态”，也就是说我们可以将拥有相同特性，但又有细微实现差别的枚举类聚集在一个接口中，实现代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class EnumTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        // 赋值第一个枚举类</span><br><span class="line">        ColorInterface colorEnum = ColorInterface.ColorEnum.RED;</span><br><span class="line">        System.out.println(colorEnum);</span><br><span class="line">        // 赋值第二个枚举类</span><br><span class="line">        colorEnum = ColorInterface.NewColorEnum.NEW_RED;</span><br><span class="line">        System.out.println(colorEnum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface ColorInterface &#123;</span><br><span class="line">    enum ColorEnum implements ColorInterface &#123;</span><br><span class="line">        GREEN, YELLOW, RED</span><br><span class="line">    &#125;</span><br><span class="line">    enum NewColorEnum implements ColorInterface &#123;</span><br><span class="line">        NEW_GREEN, NEW_YELLOW, NEW_RED</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>以上程序的执行结果为：</p>
<blockquote>
<p>RED</p>
<p>NEW_RED</p>
</blockquote>
<h3 id="用法七：使用枚举集合"><a href="#用法七：使用枚举集合" class="headerlink" title="用法七：使用枚举集合"></a>用法七：使用枚举集合</h3><p>在 Java 语言中和枚举类相关的，还有两个枚举集合类 <code>java.util.EnumSet</code> 和 <code>java.util.EnumMap</code>，使用它们可以实现更多的功能。</p>
<p>使用 <code>EnumSet</code> 可以保证元素不重复，并且能获取指定范围内的元素，示例代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.EnumSet;</span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">public class EnumTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        List&lt;ColorEnum&gt; list = new ArrayList&lt;ColorEnum&gt;();</span><br><span class="line">        list.add(ColorEnum.RED);</span><br><span class="line">        list.add(ColorEnum.RED);  // 重复元素</span><br><span class="line">        list.add(ColorEnum.YELLOW);</span><br><span class="line">        list.add(ColorEnum.GREEN);</span><br><span class="line">        // 去掉重复数据</span><br><span class="line">        EnumSet&lt;ColorEnum&gt; enumSet = EnumSet.copyOf(list);</span><br><span class="line">        System.out.println(&quot;去重：&quot; + enumSet);</span><br><span class="line"></span><br><span class="line">        // 获取指定范围的枚举（获取所有的失败状态）</span><br><span class="line">        EnumSet&lt;ErrorCodeEnum&gt; errorCodeEnums = EnumSet.range(ErrorCodeEnum.ERROR, ErrorCodeEnum.UNKNOWN_ERROR);</span><br><span class="line">        System.out.println(&quot;所有失败状态：&quot; + errorCodeEnums);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">enum ColorEnum &#123;</span><br><span class="line">    RED(&quot;红色&quot;, 1), GREEN(&quot;绿色&quot;, 2), BLANK(&quot;白色&quot;, 3), YELLOW(&quot;黄色&quot;, 4);</span><br><span class="line">    private String name;</span><br><span class="line">    private int index;</span><br><span class="line"></span><br><span class="line">    private ColorEnum(String name, int index) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.index = index;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">enum ErrorCodeEnum &#123;</span><br><span class="line">    SUCCESS(1000, &quot;success&quot;),</span><br><span class="line">    ERROR(2001, &quot;parameter error&quot;),</span><br><span class="line">    SYS_ERROR(2002, &quot;system error&quot;),</span><br><span class="line">    NAMESPACE_NOT_FOUND(2003, &quot;namespace not found&quot;),</span><br><span class="line">    NODE_NOT_EXIST(3002, &quot;node not exist&quot;),</span><br><span class="line">    NODE_ALREADY_EXIST(3003, &quot;node already exist&quot;),</span><br><span class="line">    UNKNOWN_ERROR(9999, &quot;unknown error&quot;);</span><br><span class="line"></span><br><span class="line">    private int code;</span><br><span class="line">    private String msg;</span><br><span class="line"></span><br><span class="line">    ErrorCodeEnum(int code, String msg) &#123;</span><br><span class="line">        this.code = code;</span><br><span class="line">        this.msg = msg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int code() &#123;</span><br><span class="line">        return code;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String msg() &#123;</span><br><span class="line">        return msg;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>以上程序的执行结果为：</p>
<blockquote>
<p>去重：[RED, GREEN, YELLOW]</p>
<p>所有失败状态：[ERROR, SYS_ERROR, NAMESPACE_NOT_FOUND, NODE_NOT_EXIST, NODE_ALREADY_EXIST, UNKNOWN_ERROR]</p>
</blockquote>
<p><code>EnumMap</code> 与 <code>HashMap</code> 类似，不过它是一个专门为枚举设计的 <code>Map</code> 集合，相比 <code>HashMap</code> 来说它的性能更高，因为它内部放弃使用链表和红黑树的结构，采用数组作为数据存储的结构。</p>
<p><code>EnumMap</code> 基本使用示例如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java.util.EnumMap;</span><br><span class="line"></span><br><span class="line">public class EnumTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        EnumMap&lt;ColorEnum, String&gt; enumMap = new EnumMap&lt;&gt;(ColorEnum.class);</span><br><span class="line">        enumMap.put(ColorEnum.RED, &quot;红色&quot;);</span><br><span class="line">        enumMap.put(ColorEnum.GREEN, &quot;绿色&quot;);</span><br><span class="line">        enumMap.put(ColorEnum.BLANK, &quot;白色&quot;);</span><br><span class="line">        enumMap.put(ColorEnum.YELLOW, &quot;黄色&quot;);</span><br><span class="line">        System.out.println(ColorEnum.RED + &quot;:&quot; + enumMap.get(ColorEnum.RED));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">enum ColorEnum &#123;</span><br><span class="line">    RED, GREEN, BLANK, YELLOW;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>以上程序的执行结果为：</p>
<blockquote>
<p>RED:红色</p>
</blockquote>
<h3 id="使用注意事项"><a href="#使用注意事项" class="headerlink" title="使用注意事项"></a>使用注意事项</h3><p>阿里《Java开发手册》对枚举的相关规定如下，我们在使用时需要稍微注意一下。</p>
<blockquote>
<p>【强制】所有的枚举类型字段必须要有注释，说明每个数据项的用途。</p>
<p>【参考】枚举类名带上 Enum 后缀，枚举成员名称需要全大写，单词间用下划线隔开。说明：枚举其实就是特殊的常量类，且构造方法被默认强制是私有。正例：枚举名字为 ProcessStatusEnum 的成员名称：SUCCESS / UNKNOWN_REASON。</p>
</blockquote>
<h2 id="假如不使用枚举"><a href="#假如不使用枚举" class="headerlink" title="假如不使用枚举"></a>假如不使用枚举</h2><p>在枚举没有诞生之前，也就是 JDK 1.5 版本之前，我们通常会使用 <code>int</code> 常量来表示枚举，实现代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static final int COLOR_RED = 1;</span><br><span class="line">public static final int COLOR_BLUE = 2;</span><br><span class="line">public static final int COLOR_GREEN = 3;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>但是使用 <code>int</code> 类型可能存在两个问题：</p>
<p>第一， <code>int</code> 类型本身并不具备安全性，假如某个程序员在定义 <code>int</code> 时少些了一个 <code>final</code> 关键字，那么就会存在被其他人修改的风险，而反观枚举类，它“天然”就是一个常量类，不存在被修改的风险（原因详见下半部分）；</p>
<p>第二，使用 <code>int</code> 类型的语义不够明确，比如我们在控制台打印时如果只输出 1…2…3 这样的数字，我们肯定不知道它代表的是什么含义。</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/6/28/172f889e786a4b0b?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<p>那有人就说了，那就使用常量字符呗，这总不会还不知道语义吧？实现示例代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static final String COLOR_RED = &quot;RED&quot;;</span><br><span class="line">public static final String COLOR_BLUE = &quot;BLUE&quot;;</span><br><span class="line">public static final String COLOR_GREEN = &quot;GREEN&quot;;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>但是这样同样存在一个问题，有些初级程序员会不按套路出牌，他们可能会直接使用字符串的值进行比较，而不是直接使用枚举的字段，实现示例代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class EnumTest &#123;</span><br><span class="line">    public static final String COLOR_RED = &quot;RED&quot;;</span><br><span class="line">    public static final String COLOR_BLUE = &quot;BLUE&quot;;</span><br><span class="line">    public static final String COLOR_GREEN = &quot;GREEN&quot;;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        String color = &quot;BLUE&quot;;</span><br><span class="line">        if (&quot;BLUE&quot;.equals(color)) &#123;</span><br><span class="line">            System.out.println(&quot;蓝色&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>这样当我们修改了枚举中的值，那程序就凉凉了。</p>
<h2 id="枚举使用场景"><a href="#枚举使用场景" class="headerlink" title="枚举使用场景"></a>枚举使用场景</h2><p>枚举的常见使用场景是单例，它的完整实现代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Singleton &#123;</span><br><span class="line">    // 枚举类型是线程安全的，并且只会装载一次</span><br><span class="line">    private enum SingletonEnum &#123;</span><br><span class="line">        INSTANCE;</span><br><span class="line">        // 声明单例对象</span><br><span class="line">        private final Singleton instance;</span><br><span class="line">        // 实例化</span><br><span class="line">        SingletonEnum() &#123;</span><br><span class="line">            instance = new Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        private Singleton getInstance() &#123;</span><br><span class="line">            return instance;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // 获取实例（单例对象）</span><br><span class="line">    public static Singleton getInstance() &#123;</span><br><span class="line">        return SingletonEnum.INSTANCE.getInstance();</span><br><span class="line">    &#125;</span><br><span class="line">    private Singleton() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    // 类方法</span><br><span class="line">    public void sayHi() &#123;</span><br><span class="line">        System.out.println(&quot;Hi,Java.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class SingletonTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Singleton singleton = Singleton.getInstance();</span><br><span class="line">        singleton.sayHi();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>因为枚举只会在类加载时装载一次，所以它是线程安全的，这也是《Effective Java》作者极力推荐使用枚举来实现单例的主要原因。</p>
<h2 id="知识扩展"><a href="#知识扩展" class="headerlink" title="知识扩展"></a>知识扩展</h2><h3 id="枚举为什么是线程安全的？"><a href="#枚举为什么是线程安全的？" class="headerlink" title="枚举为什么是线程安全的？"></a>枚举为什么是线程安全的？</h3><p>这一点要从枚举最终生成的字节码说起，首先我们先来定义一个简单的枚举类：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public enum ColorEnumTest &#123;</span><br><span class="line">    RED, GREEN, BLANK, YELLOW;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>然后我们再将上面的那段代码编译为字节码，具体内容如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public final class ColorEnumTest extends java.lang.Enum&lt;ColorEnumTest&gt; &#123;</span><br><span class="line">  public static final ColorEnumTest RED;</span><br><span class="line">  public static final ColorEnumTest GREEN;</span><br><span class="line">  public static final ColorEnumTest BLANK;</span><br><span class="line">  public static final ColorEnumTest YELLOW;</span><br><span class="line">  public static ColorEnumTest[] values();</span><br><span class="line">  public static ColorEnumTest valueOf(java.lang.String);</span><br><span class="line">  static &#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>从上述结果可以看出枚举类最终会被编译为被 <code>final</code> 修饰的普通类，它的所有属性也都会被 <code>static</code> 和 <code>final</code> 关键字修饰，所以枚举类在项目启动时就会被 JVM 加载并初始化，而这个执行过程是线程安全的，所以枚举类也是线程安全的类。</p>
<blockquote>
<p>小贴士：代码反编译的过程是先用 javac 命令将 java 代码编译字节码（.class），再使用 javap 命令查看编译的字节码。</p>
</blockquote>
<h3 id="枚举比较小技巧"><a href="#枚举比较小技巧" class="headerlink" title="枚举比较小技巧"></a>枚举比较小技巧</h3><p>我们在枚举比较时使用 == 就够了，因为枚举类是在程序加载时就创建了（它并不是 <code>new</code> 出来的），并且枚举类不允许在外部直接使用 <code>new</code> 关键字来创建枚举实例，所以我们在使用枚举类时本质上只有一个对象，因此在枚举比较时使用 == 就够了。</p>
<p>并且我们在查看枚举的 <code>equlas()</code> 源码会发现，它的内部其实还是直接调用了 == 方法，源码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public final boolean equals(Object other) &#123;</span><br><span class="line">    return this==other;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文我们介绍了枚举类的 7 种使用方法：常量、switch、枚举中添加方法、覆盖枚举方法、实现接口、在接口中组织枚举类和使用枚举集合等，然后讲了如果不使用枚举类使用 <code>int</code> 类型和 <code>String</code> 类型存在的一些弊端：语义不够清晰、容易被修改、存在被误用的风险，所以我们在适合的环境下应该尽量使用枚举类。并且我们还讲了枚举类的使用场景——单例，以及枚举类为什么是安全的，最后我们讲了枚举比较的小技巧，希望本文对你有帮助。</p>
<p><strong>本文转载自</strong>:<a href="https://juejin.cn/post/6844904200652980231" target="_blank" rel="noopener">https://juejin.cn/post/6844904200652980231</a></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt="img"></p>
<p><em>乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</em></p>
]]></content>
      <tags>
        <tag>flutter</tag>
      </tags>
  </entry>
  <entry>
    <title>一个软件让你的手机或者平板成为电脑扩展屏</title>
    <url>/237.html</url>
    <content><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>划水摸鱼老司机的你, 是否时常感觉一块屏幕不够用, 这里给大家推荐几款扩展屏幕软件, 方便大家把充分利用手中的闲置设备</p>
<p>毕竟 不用就是浪费</p>
<h4 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h4><ul>
<li><p><a href="https://link.zhihu.com/?target=http%3A//www.spacedesk.net/" target="_blank" rel="noopener">Spacedesk</a>：主机端目前只支持Windows,扩展端支持IOS,Android和PC,甚至一个有html5浏览器的设备都可以, <strong>支持WIFI连接</strong>。</p>
</li>
<li><p><strong>Air Display</strong> : 主机端支持Mac和Windows,扩展端支持全平台</p>
<p>以下是扩展端应用下载链接:</p>
<p><em>iOS:</em> Get <strong><a href="https://itunes.apple.com/app/id967502646?at=10lazq&ct=getairdisplay" target="_blank" rel="noopener">Air Display 3</a></strong> from the App Store</p>
<p><em>macOS:</em> Get <strong><a href="https://apps.apple.com/app/id419449718" target="_blank" rel="noopener">Air Display for Mac</a></strong> from the Mac App Store</p>
<p><em>Android:</em> Get <a href="https://play.google.com/store/apps/details?id=com.avatron.airdisplay2" target="_blank" rel="noopener"><strong>Air Display 2</strong></a> from Google Play</p>
<p><em>Windows:</em> Get <a href="https://sites.fastspring.com/avatron/product/airdisplayforwindows" target="_blank" rel="noopener"><strong>Air Display for Windows</strong></a> from avatron.com</p>
</li>
</ul>
<p>  以下是Mac版宿主应用下载链接(Windows版自行百度):</p>
<p>  Download <a href="https://avatron.com/air-display-hosts/" target="_blank" rel="noopener"><strong>Air Display Host</strong></a></p>
<ul>
<li><p><a href="https://www.getidisplay.com/" target="_blank" rel="noopener">IDisplay</a>: 主机端支持Mac和Windows,扩展端支持全平台, <strong>支持WIFI连接</strong></p>
</li>
<li><p><strong>YamDisplay:</strong>  支持mac和ipad扩展, 有免费7分钟试用版, 每隔七分钟重连一次</p>
<p>官网地址: <a href="https://www.yamdisplay.com/" target="_blank" rel="noopener">https://www.yamdisplay.com/</a></p>
</li>
</ul>
<h4 id="其他参考"><a href="#其他参考" class="headerlink" title="其他参考"></a>其他参考</h4><p><a href="https://link.zhihu.com/?target=https%3A//sspai.com/post/29016%3Fpreview" target="_blank" rel="noopener">一秒把平板变 PC 电脑的扩展屏幕：TwomonUSB &amp; Duet Display 对比评测</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/339109353" target="_blank" rel="noopener">Yam Display-免费Mac扩展屏，让旧iPad成为Mac的第二个外接屏！</a></p>
<p><strong>本文为作者原创 转载时请注明出处 谢谢</strong></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt="img"></p>
<p><em><a href="https://code.newban.cn/">乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</a></em></p>
]]></content>
      <tags>
        <tag>实用工具</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue的组件为什么要export default</title>
    <url>/238.html</url>
    <content><![CDATA[<h4 id="Vue-的模块机制"><a href="#Vue-的模块机制" class="headerlink" title="Vue 的模块机制"></a>Vue 的模块机制</h4><p>　　Vue 是通过 webpack 实现的模块化，因此可以使用 import 来引入模块，例如：</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/1170308-20180313210235200-1714149358.png" alt="img"> </p>
<p>　　此外，你还可以在 <code>bulid/webpack.base.conf.js</code>文件中修改相关配置：</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/1170308-20180313210924147-1028432506.png" alt="img"></p>
<p>　　意思是，你的模块可以省略 <code>&quot;.js&quot;，&quot;.vue&quot;，“.json”</code>后缀，<code>webpack</code> 会在之后自动添加上；可以用 <code>&quot;@&quot;</code>符号代替 <code>&quot;src&quot;</code>字符串等。</p>
<p>　　export 用来导出模块，Vue 的单文件组件通常需要导出一个对象，这个对象是 Vue 实例的选项对象，以便于在其它地方可以使用 import 引入。而 new Vue() 相当于一个构造函数，在入口文件 main.js 构造根组件的同时，如果根组件还包含其它子组件，那么 Vue 会通过引入的选项对象构造其对应的 Vue 实例，最终形成一棵组件树。</p>
<p>　　<code>export</code>和<code>export default</code>的区别在于：<code>export</code>可以导出多个命名模块，例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//demo1.js</span><br><span class="line">export const str = &apos;hello world&apos;</span><br><span class="line"></span><br><span class="line">export function f(a)&#123;</span><br><span class="line">    return a+1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　对应的引入方式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//demo2.js</span><br><span class="line">import &#123; str, f &#125; from &apos;demo1&apos;</span><br></pre></td></tr></table></figure>

<p>　　<code>export default</code>只能导出一个默认模块，这个模块可以匿名，例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//demo1.js</span><br><span class="line">export default &#123;</span><br><span class="line">    a: &apos;hello&apos;,</span><br><span class="line">    b: &apos;world&apos;      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　对应的引入方式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//demo2.js</span><br><span class="line">import obj from &apos;demo1&apos;</span><br></pre></td></tr></table></figure>

<p>　　引入的时候可以给这个模块取<strong>任意名字</strong>，例如 <code>&quot;obj&quot;</code>，且不需要用大括号括起来。</p>
<p>本文转载自:<a href="https://www.cnblogs.com/blog-cxj2017522/p/8562536.html" target="_blank" rel="noopener">https://www.cnblogs.com/blog-cxj2017522/p/8562536.html</a></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt="img"></p>
<p><em><a href="https://code.newban.cn/">乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</a></em></p>
]]></content>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue2入门基础语法</title>
    <url>/239.html</url>
    <content><![CDATA[<h4 id="MVC与MVVM"><a href="#MVC与MVVM" class="headerlink" title="MVC与MVVM"></a>MVC与MVVM</h4><p><strong>MVC（Model-View-Controller）</strong>：</p>
<figure class="highlight cos"><table><tr><td class="code"><pre><span class="line">M指的是从后台获取到的数据， </span><br><span class="line">V指的是显示动态数据的html页面，</span><br><span class="line">C是指响应用户操作、经过业务逻辑处理后去更新视图的过程，在此过程中会导致对<span class="keyword">view</span>层的引用。</span><br></pre></td></tr></table></figure>

<p>这里我们发现我们网站的大量代码都被放在Controller，导致Controller代码臃肿；而且不利于单元测试，因为业务逻辑处理和视图更新操作会混杂在一起。</p>
<p><strong>MVVM (Model-View-ViewModel)</strong>：<br>MVVM是MVC的一个衍生模型，这里的 ViewModel 把业务逻辑处理、用户输入验证等跟视图更新操作分离开了。MVVM是数据驱动的，我们只需要关心数据的处理逻辑即可，它会通过模板渲染去单独处理视图的更新而不需要我们亲自去操作Dom元素。</p>
<h4 id="实例化Vue对象"><a href="#实例化Vue对象" class="headerlink" title="实例化Vue对象"></a>实例化Vue对象</h4><figure class="highlight handlebars"><table><tr><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"js/vue.min.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="xml">    //调用Vue的构造函数创建实例对象</span></span><br><span class="line"><span class="xml">    var vm = new Vue(&#123;</span></span><br><span class="line"><span class="xml">        //根节点选择器</span></span><br><span class="line"><span class="xml">        el: '#app',</span></span><br><span class="line"><span class="xml">        //数据对象</span></span><br><span class="line"><span class="xml">        data: &#123;</span></span><br><span class="line"><span class="xml">            message: 'hello world',</span></span><br><span class="line"><span class="xml">        &#125;,</span></span><br><span class="line"><span class="xml">        //渲染模板</span></span><br><span class="line"><span class="xml">        template: '<span class="tag">&lt;<span class="name">div</span>&gt;</span>message: </span><span class="template-variable">&#123;&#123; message &#125;&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span>'</span></span><br><span class="line"><span class="xml">    &#125;)</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<p>Vue会将渲染模板结合数据对象生成的html结构替换掉根节点，只要数据对象上的message发生改变，插值处的内容就会跟着改变，上述例子的实际效果如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>message: hello world<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="模板语法"><a href="#模板语法" class="headerlink" title="模板语法"></a>模板语法</h4><p>上面的双大括号绑定是vue最常用的数据绑定方式，除了双大括号还可以使用v-text属性进行绑定</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>message: <span class="tag">&lt;<span class="name">span</span> <span class="attr">v-text</span>=<span class="string">"message"</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>如果要绑定html结构的话，需要使用到v-html指令，否则vue会把这段html代码看成字符串直接绑定到对应位置</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">new Vue(&#123;</span><br><span class="line">    el: '#app',</span><br><span class="line">    data:&#123;</span><br><span class="line">        message: 'hello world',</span><br><span class="line">        html: '<span class="tag">&lt;<span class="name">span</span>&gt;</span>hello world<span class="tag">&lt;/<span class="name">span</span>&gt;</span>'</span><br><span class="line">    &#125;,</span><br><span class="line">    template: '<span class="tag">&lt;<span class="name">div</span>&gt;</span>message: <span class="tag">&lt;<span class="name">span</span> <span class="attr">v-html</span>=<span class="string">"html"</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span>'</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>需要绑定html元素特性的时候需要使用v-bind指令，v-bind可以省略</p>
<figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">&lt;<span class="keyword">div</span> v-bind:<span class="built_in">id</span>=<span class="string">"id"</span>&gt;&lt;/<span class="keyword">div</span>&gt;</span><br><span class="line">&lt;<span class="keyword">div</span> :<span class="built_in">id</span>=<span class="string">"id"</span>&gt;&lt;/<span class="keyword">div</span>&gt;</span><br></pre></td></tr></table></figure>

<p>双大括号的插值方法还可以使用js表达式，这些表达式会在所属 Vue 实例的数据作用域下被解析</p>
<figure class="highlight handlebars"><table><tr><td class="code"><pre><span class="line"><span class="xml"></span><span class="template-variable">&#123;&#123; number + 1 &#125;&#125;</span><span class="xml"></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml"></span><span class="template-variable">&#123;&#123; boolean ? 'true' : 'false' &#125;&#125;</span><span class="xml"></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml"></span><span class="template-variable">&#123;&#123; message.split('').reverse().join('') &#125;&#125;</span><span class="xml"></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">:id</span>=<span class="string">"'is' + id"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<p>注意，这里的javascript语句只能是单个表达式，其他的声明变量、流程控制语法都不会生效</p>
<h4 id="事件绑定"><a href="#事件绑定" class="headerlink" title="事件绑定"></a>事件绑定</h4><p>除了数据绑定外，vue还帮我们优化了事件绑定流程，指令为v-on，可缩写为@，后面是事件名称</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">v-on:click</span>=<span class="string">"console.log(1)"</span>&gt;</span>打印1<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> @<span class="attr">click</span>=<span class="string">"console.log(1)"</span>&gt;</span>打印1<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>仅仅一句js表达式是不够支撑我们的日常开发的，所以vue给我们提供了自定义事件处理方法</p>
<figure class="highlight scilab"><table><tr><td class="code"><pre><span class="line">new Vue(&#123;</span><br><span class="line">    el: <span class="string">'#app'</span>,</span><br><span class="line">    data: &#123;</span><br><span class="line">        message: <span class="string">'hello world'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">//log为methods中定义的函数名，vue会默认把原生DOM事件对象当做参数传到处理函数中</span></span><br><span class="line">    template: <span class="string">'&lt;a @click="</span><span class="built_in">log</span><span class="string">"&gt;Click Me&lt;/a&gt;'</span>,</span><br><span class="line">    methods: &#123;</span><br><span class="line">        <span class="built_in">log</span>: <span class="function"><span class="keyword">function</span><span class="params">(event)</span>&#123;</span></span><br><span class="line">            console.<span class="built_in">log</span>(this.message);</span><br><span class="line">            event.stopPropagation();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>除了直接绑定到一个方法，也可以在内联 JavaScript 语句中调用方法</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 使用内联语法后，原生DOM对象需要手动传入(变量名变更为 $event ) --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> @<span class="attr">click</span>=<span class="string">"log(1, $event)"</span>&gt;</span>Click Me<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="计算属性-computed"><a href="#计算属性-computed" class="headerlink" title="计算属性 computed"></a>计算属性 computed</h4><p>模板内的表达式非常便利，但是设计它们的初衷是用于简单运算的。在模板中放入太多的逻辑会让模板过重且难以维护。例如这个字符串反转：</p>
<figure class="highlight handlebars"><table><tr><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><span class="template-variable">&#123;&#123; message.split('').reverse().join('') &#125;&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<p>这种情况我们可以用 computed 解决</p>
<figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el: <span class="string">'#app'</span>,</span><br><span class="line">    data: &#123;</span><br><span class="line">        message: <span class="string">'hello'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    template: <span class="string">'&lt;div&gt;&#123;&#123; reversedMessage &#125;&#125;&lt;/div&gt;'</span>, <span class="comment">//olleh</span></span><br><span class="line">    computed: &#123;</span><br><span class="line">        reversedMessage: <span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.message.split(<span class="string">''</span>).reverse().join(<span class="string">''</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>这里看渲染模板就直观多了</p>
<h4 id="监听属性-watch"><a href="#监听属性-watch" class="headerlink" title="监听属性 watch"></a>监听属性 watch</h4><p>Vue 提供了 watch 这种通用的方式来观察和响应 Vue 实例上的数据变动</p>
<figure class="highlight handlebars"><table><tr><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>问题: <span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model</span>=<span class="string">"question"</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><span class="template-variable">&#123;&#123; answer &#125;&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"js/vue.min.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="xml">    var vm = new Vue(&#123;</span></span><br><span class="line"><span class="xml">        el: '#app',</span></span><br><span class="line"><span class="xml">        data: &#123;</span></span><br><span class="line"><span class="xml">            question: '',</span></span><br><span class="line"><span class="xml">            answer: '请先输入问题',</span></span><br><span class="line"><span class="xml">            timer: undefined,</span></span><br><span class="line"><span class="xml">        &#125;,</span></span><br><span class="line"><span class="xml">        watch: &#123;</span></span><br><span class="line"><span class="xml">            question: function(newVal, oldVal)&#123;</span></span><br><span class="line"><span class="xml">                if(this.timer)&#123; clearTimeout(this.timer); &#125;</span></span><br><span class="line"><span class="xml">                var _this = this;</span></span><br><span class="line"><span class="xml">                this.answer = '等待停止输入...';</span></span><br><span class="line"><span class="xml">                setTimeout(function()&#123; _this.answer = 'Yes!!!'; &#125;, 1000);</span></span><br><span class="line"><span class="xml">            &#125;</span></span><br><span class="line"><span class="xml">        &#125;</span></span><br><span class="line"><span class="xml">    &#125;);</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<h4 id="表单绑定，指令为-v-model"><a href="#表单绑定，指令为-v-model" class="headerlink" title="表单绑定，指令为 v-model"></a>表单绑定，指令为 v-model</h4><p>v-model 指令在表单 <input> 及 <textarea> 元素上创建双向数据绑定。它会根据控件类型自动选取正确的方法来更新元素。v-model 会忽略所有表单元素的 value、checked、selected 特性的初始值而总是将 Vue 实例的数据作为数据来源。</textarea></p>
<figure class="highlight handlebars"><table><tr><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model</span>=<span class="string">"message"</span> <span class="attr">placeholder</span>=<span class="string">"写点什么。。"</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="comment">&lt;!-- 通过v-model绑定message后,</span></span></span><br><span class="line"><span class="xml">        在input输入的文字会实时更新到数据对象上,</span></span><br><span class="line"><span class="xml">        从而自动渲染在下面的p标签上</span></span><br><span class="line"><span class="xml">    --&gt;</span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Message: </span><span class="template-variable">&#123;&#123; message &#125;&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"js/vue.min.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="xml">    var vm = new Vue(&#123;</span></span><br><span class="line"><span class="xml">        el: '#app',</span></span><br><span class="line"><span class="xml">        data: &#123;</span></span><br><span class="line"><span class="xml">            message: ''</span></span><br><span class="line"><span class="xml">        &#125;</span></span><br><span class="line"><span class="xml">    &#125;)</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<p>单个复选框</p>
<figure class="highlight handlebars"><table><tr><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">id</span>=<span class="string">"checkbox"</span> <span class="attr">v-model</span>=<span class="string">"checked"</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"checkbox"</span>&gt;</span></span><span class="template-variable">&#123;&#123; checked &#125;&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">label</span>&gt;</span></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">data: &#123; checked: true &#125;</span></span><br></pre></td></tr></table></figure>

<p>多个复选框的情况下，把v-model绑定到同一个数组即可:</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">&lt;input <span class="attribute">type</span>=<span class="string">"checkbox"</span> <span class="attribute">value</span>=<span class="string">"blue"</span> <span class="attribute">id</span>=<span class="string">"blue"</span> <span class="attribute">v-model</span>=<span class="string">"checkedColor"</span>/&gt;</span><br><span class="line">&lt;label <span class="attribute">for</span>=<span class="string">"blue"</span>&gt;blue&lt;/label&gt;</span><br><span class="line">&lt;input <span class="attribute">type</span>=<span class="string">"checkbox"</span> <span class="attribute">value</span>=<span class="string">"red"</span> <span class="attribute">id</span>=<span class="string">"red"</span> <span class="attribute">v-model</span>=<span class="string">"checkedColor"</span>/&gt;</span><br><span class="line">&lt;label <span class="attribute">for</span>=<span class="string">"red"</span>&gt;red&lt;/label&gt;</span><br><span class="line"></span><br><span class="line">data: &#123; checkedColor: [] &#125;</span><br></pre></td></tr></table></figure>

<p>单选按钮</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;input <span class="attribute">type</span>=<span class="string">"checkbox"</span> <span class="attribute">value</span>=<span class="string">"true"</span> <span class="attribute">id</span>=<span class="string">"true"</span> <span class="attribute">v-model</span>=<span class="string">"checkedRadio"</span>/&gt;</span><br><span class="line">&lt;label <span class="attribute">for</span>=<span class="string">"true"</span>&gt;true&lt;/label&gt;</span><br><span class="line">&lt;input <span class="attribute">type</span>=<span class="string">"checkbox"</span> <span class="attribute">value</span>=<span class="string">"false"</span> <span class="attribute">id</span>=<span class="string">"false"</span> <span class="attribute">v-model</span>=<span class="string">"checkedRadio"</span>/&gt;</span><br><span class="line">&lt;label <span class="attribute">for</span>=<span class="string">"false"</span>&gt;false&lt;/label&gt;</span><br><span class="line"></span><br><span class="line">data: &#123; checkedRadio: '' &#125;</span><br></pre></td></tr></table></figure>

<h4 id="条件渲染"><a href="#条件渲染" class="headerlink" title="条件渲染"></a>条件渲染</h4><p>在javascript语法中有if-else等流程语句让程序执行不同的代码块，在vue中同样有 <code>v-if</code>、<code>v-else-if</code>、<code>v-else</code> 这些指令控制某些节点的显示与否</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-if</span>=<span class="string">"isShow"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">label</span>&gt;</span>用户名<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">placeholder</span>=<span class="string">"请输入用户名"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- v-else 元素必须紧跟在带 v-if 或者 v-else-if 的元素的后面，否则它将不会被识别。 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-else</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">label</span>&gt;</span>邮箱<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">placeholder</span>=<span class="string">"请输入邮箱"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"switchDom"</span>&gt;</span>切换输入框类型<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"js/vue.min.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="actionscript">        el: <span class="string">'#app'</span>,</span></span><br><span class="line"><span class="actionscript">        data: &#123; isShow: <span class="literal">true</span> &#125;,</span></span><br><span class="line">        methods: &#123;</span><br><span class="line"><span class="actionscript">            switchDom: <span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123; <span class="keyword">this</span>.isShow = !<span class="keyword">this</span>.isShow; &#125;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在上述例子中，我们点击 button 会显示不同的dom，但是如果我们在input里面输入文字再进行切换的时候会发现，输入的文字并不会被清除，这是因为vue的 <strong>就地复用</strong> 策略导致的。vue为了尽可能高效地渲染dom元素，通常会复用已有元素而不是从头开始渲染，如果不想vue复用这些元素，我们可以添加一个具有唯一值的 key 属性</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">&lt;input <span class="attribute">type</span>=<span class="string">"text"</span> <span class="attribute">placeholder</span>=<span class="string">"请输入用户"</span> <span class="attribute">key</span>=<span class="string">"username"</span>/&gt;</span><br><span class="line"></span><br><span class="line">&lt;input <span class="attribute">type</span>=<span class="string">"text"</span> <span class="attribute">placeholder</span>=<span class="string">"请输入邮箱"</span> <span class="attribute">key</span>=<span class="string">"email"</span>/&gt;</span><br></pre></td></tr></table></figure>

<p>另一个用于根据条件展示元素的选项是 v-show 指令。用法大致一样：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">v-show</span>=<span class="string">"show"</span>&gt;</span>Hello!<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><code>v-if</code> 与 <code>v-show</code> 区别：<br><code>v-if</code> 是惰性渲染，在初始渲染时条件为假，什么也不做——直到条件第一次变为真时，才会开始渲染条件块；在切换过程中条件块内的事件监听器和子组件会被销毁和重建。<br><code>v-show</code> 不管初始条件是什么，元素总会被渲染，切换的只是css的display属性</p>
<h4 id="列表渲染"><a href="#列表渲染" class="headerlink" title="列表渲染"></a>列表渲染</h4><p>我们用 <code>v-for</code> 指令根据一组数据表进行列表渲染。<code>v-for</code> 指令需要使用 <code>item in list</code> 的语法，list指的是原数据数组，item指的是迭代的数组元素。<code>v-for</code> 指令还支持一个可选的表示当前迭代元素索引的第二个参数 <code>(item, index) in list</code></p>
<figure class="highlight handlebars"><table><tr><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">"item in list"</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="comment">&lt;!-- 效果一样 --&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="comment">&lt;!-- &lt;li v-for="item of list"&gt; --&gt;</span></span></span><br><span class="line"><span class="xml">            </span><span class="template-variable">&#123;&#123; item.text &#125;&#125;</span><span class="xml"></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"js/vue.min.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="xml">    var vm = new Vue(&#123;</span></span><br><span class="line"><span class="xml">        el: '#app',</span></span><br><span class="line"><span class="xml">        data: &#123;</span></span><br><span class="line"><span class="xml">            list: [</span></span><br><span class="line"><span class="xml">                &#123;text: 'blue'&#125;,</span></span><br><span class="line"><span class="xml">                &#123;text: 'red'&#125;,</span></span><br><span class="line"><span class="xml">                &#123;text: 'yellow'&#125;,</span></span><br><span class="line"><span class="xml">            ]</span></span><br><span class="line"><span class="xml">        &#125;</span></span><br><span class="line"><span class="xml">    &#125;)</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<p>除了数组，<code>v-for</code>指令还可以通过一个对象的属性来迭代，<code>v-for</code> 指令最多可以支持3个参数，第二第三个可选。</p>
<figure class="highlight handlebars"><table><tr><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">"(value, key, index) in object"</span>&gt;</span></span></span><br><span class="line"><span class="xml">    </span><span class="template-variable">&#123;&#123; index &#125;&#125;</span><span class="xml">. </span><span class="template-variable">&#123;&#123; key &#125;&#125;</span><span class="xml">: </span><span class="template-variable">&#123;&#123; value &#125;&#125;</span><span class="xml"></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">data:&#123;</span></span><br><span class="line"><span class="xml">    object: &#123;</span></span><br><span class="line"><span class="xml">        firstName: 'John',</span></span><br><span class="line"><span class="xml">        lastName: 'Doe',</span></span><br><span class="line"><span class="xml">        age: 26</span></span><br><span class="line"><span class="xml">    &#125;</span></span><br><span class="line"><span class="xml">&#125;</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">//结果</span></span><br><span class="line"><span class="xml">0. firstName: John</span></span><br><span class="line"><span class="xml">1. lastName: Doe</span></span><br><span class="line"><span class="xml">2. age: 26</span></span><br></pre></td></tr></table></figure>

<h4 id="Vue的生命周期"><a href="#Vue的生命周期" class="headerlink" title="Vue的生命周期"></a>Vue的生命周期</h4><p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/bV4xju.png" alt="图片描述"></p>
<p>根据上图做了一个测试例子，列出了每个生命周期对应的不同属性的状态</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">&lt;div id=<span class="string">"app"</span>&gt;</span><br><span class="line">    &#123;&#123;message&#125;&#125;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;script src=<span class="string">"js/vue.min.js"</span>&gt;&lt;/script&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="keyword">var</span> vm = new Vue(&#123;</span><br><span class="line">        el: <span class="string">'#app'</span>,</span><br><span class="line">        <span class="keyword">data</span>: &#123;</span><br><span class="line">            message : <span class="string">"hello"</span></span><br><span class="line">        &#125;,</span><br><span class="line">        beforeCreate: function () &#123;</span><br><span class="line">            console.group(<span class="string">'beforeCreate 创建前状态===============》'</span>);</span><br><span class="line">            console.log(<span class="string">"%c%s"</span>, <span class="string">"color:red"</span> , <span class="string">"el     : "</span> + <span class="keyword">this</span>.$el); <span class="comment">//undefined</span></span><br><span class="line">            console.log(<span class="string">"%c%s"</span>, <span class="string">"color:red"</span>,<span class="string">"data   : "</span> + <span class="keyword">this</span>.$<span class="keyword">data</span>); <span class="comment">//undefined</span></span><br><span class="line">            console.log(<span class="string">"%c%s"</span>, <span class="string">"color:red"</span>,<span class="string">"message: "</span> + <span class="keyword">this</span>.message)</span><br><span class="line">        &#125;,</span><br><span class="line">        created: function () &#123;</span><br><span class="line">            console.group(<span class="string">'created 创建完毕状态===============》'</span>);</span><br><span class="line">            console.log(<span class="string">"%c%s"</span>, <span class="string">"color:red"</span>,<span class="string">"el     : "</span> + <span class="keyword">this</span>.$el); <span class="comment">//undefined</span></span><br><span class="line">            console.log(<span class="string">"%c%s"</span>, <span class="string">"color:red"</span>,<span class="string">"data   : "</span> + <span class="keyword">this</span>.$<span class="keyword">data</span>); <span class="comment">//已被初始化</span></span><br><span class="line">            console.log(<span class="string">"%c%s"</span>, <span class="string">"color:red"</span>,<span class="string">"message: "</span> + <span class="keyword">this</span>.message); <span class="comment">//已被初始化</span></span><br><span class="line">        &#125;,</span><br><span class="line">        beforeMount: function () &#123;</span><br><span class="line">            console.group(<span class="string">'beforeMount 挂载前状态===============》'</span>);</span><br><span class="line">            console.log(<span class="string">"%c%s"</span>, <span class="string">"color:red"</span>,<span class="string">"el     : "</span> + (<span class="keyword">this</span>.$el)); <span class="comment">//已被初始化</span></span><br><span class="line">            console.log(<span class="keyword">this</span>.$el);</span><br><span class="line">            console.log(<span class="string">"%c%s"</span>, <span class="string">"color:red"</span>,<span class="string">"data   : "</span> + <span class="keyword">this</span>.$<span class="keyword">data</span>); <span class="comment">//已被初始化</span></span><br><span class="line">            console.log(<span class="string">"%c%s"</span>, <span class="string">"color:red"</span>,<span class="string">"message: "</span> + <span class="keyword">this</span>.message); <span class="comment">//已被初始化</span></span><br><span class="line">        &#125;,</span><br><span class="line">        mounted: function () &#123;</span><br><span class="line">            console.group(<span class="string">'mounted 挂载结束状态===============》'</span>);</span><br><span class="line">            console.log(<span class="string">"%c%s"</span>, <span class="string">"color:red"</span>,<span class="string">"el     : "</span> + <span class="keyword">this</span>.$el); <span class="comment">//已被初始化</span></span><br><span class="line">            console.log(<span class="keyword">this</span>.$el);</span><br><span class="line">            console.log(<span class="string">"%c%s"</span>, <span class="string">"color:red"</span>,<span class="string">"data   : "</span> + <span class="keyword">this</span>.$<span class="keyword">data</span>); <span class="comment">//已被初始化</span></span><br><span class="line">            console.log(<span class="string">"%c%s"</span>, <span class="string">"color:red"</span>,<span class="string">"message: "</span> + <span class="keyword">this</span>.message); <span class="comment">//已被初始化</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">var</span> _this = <span class="keyword">this</span>;</span><br><span class="line">            setTimeout(function()&#123;</span><br><span class="line">                _this.message = <span class="string">'hello world!!'</span>;</span><br><span class="line">            &#125;, <span class="number">3000</span>);</span><br><span class="line">        &#125;,</span><br><span class="line">        beforeUpdate: function () &#123;</span><br><span class="line">            console.group(<span class="string">'beforeUpdate 更新前状态===============》'</span>);</span><br><span class="line">            console.log(<span class="string">"%c%s"</span>, <span class="string">"color:red"</span>,<span class="string">"el     : "</span> + <span class="keyword">this</span>.$el);</span><br><span class="line">            console.log(<span class="keyword">this</span>.$el);</span><br><span class="line">            console.log(<span class="string">"%c%s"</span>, <span class="string">"color:red"</span>,<span class="string">"data   : "</span> + <span class="keyword">this</span>.$<span class="keyword">data</span>);</span><br><span class="line">            console.log(<span class="string">"%c%s"</span>, <span class="string">"color:red"</span>,<span class="string">"message: "</span> + <span class="keyword">this</span>.message);</span><br><span class="line">        &#125;,</span><br><span class="line">        updated: function () &#123;</span><br><span class="line">            console.group(<span class="string">'updated 更新完成状态===============》'</span>);</span><br><span class="line">            console.log(<span class="string">"%c%s"</span>, <span class="string">"color:red"</span>,<span class="string">"el     : "</span> + <span class="keyword">this</span>.$el);</span><br><span class="line">            console.log(<span class="keyword">this</span>.$el);</span><br><span class="line">            console.log(<span class="string">"%c%s"</span>, <span class="string">"color:red"</span>,<span class="string">"data   : "</span> + <span class="keyword">this</span>.$<span class="keyword">data</span>);</span><br><span class="line">            console.log(<span class="string">"%c%s"</span>, <span class="string">"color:red"</span>,<span class="string">"message: "</span> + <span class="keyword">this</span>.message);</span><br><span class="line">        &#125;,</span><br><span class="line">        beforeDestroy: function () &#123;</span><br><span class="line">            console.group(<span class="string">'beforeDestroy 销毁前状态===============》'</span>);</span><br><span class="line">            console.log(<span class="string">"%c%s"</span>, <span class="string">"color:red"</span>,<span class="string">"el     : "</span> + <span class="keyword">this</span>.$el);</span><br><span class="line">            console.log(<span class="keyword">this</span>.$el);</span><br><span class="line">            console.log(<span class="string">"%c%s"</span>, <span class="string">"color:red"</span>,<span class="string">"data   : "</span> + <span class="keyword">this</span>.$<span class="keyword">data</span>);</span><br><span class="line">            console.log(<span class="string">"%c%s"</span>, <span class="string">"color:red"</span>,<span class="string">"message: "</span> + <span class="keyword">this</span>.message);</span><br><span class="line">        &#125;,</span><br><span class="line">        destroyed: function () &#123;</span><br><span class="line">            console.group(<span class="string">'destroyed 销毁完成状态===============》'</span>);</span><br><span class="line">            console.log(<span class="string">"%c%s"</span>, <span class="string">"color:red"</span>,<span class="string">"el     : "</span> + <span class="keyword">this</span>.$el);</span><br><span class="line">            console.log(<span class="keyword">this</span>.$el);</span><br><span class="line">            console.log(<span class="string">"%c%s"</span>, <span class="string">"color:red"</span>,<span class="string">"data   : "</span> + <span class="keyword">this</span>.$<span class="keyword">data</span>);</span><br><span class="line">            console.log(<span class="string">"%c%s"</span>, <span class="string">"color:red"</span>,<span class="string">"message: "</span> + <span class="keyword">this</span>.message)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>本文转载自:<a href="https://segmentfault.com/a/1190000015209557" target="_blank" rel="noopener">https://segmentfault.com/a/1190000015209557</a></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt="img"></p>
<p><em><a href="https://code.newban.cn/">乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</a></em></p>
]]></content>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>Android开发者快速上手Web前端开发</title>
    <url>/240.html</url>
    <content><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>我们都知道Web前端主要由<strong>HTML</strong> <strong>CSS</strong> 和<strong>JS</strong>三部分语言组成, 其中<strong>HTML</strong>和<strong>CSS</strong>负责界面, <strong>JS</strong>负责事件逻辑</p>
<p>任何一个应用, 无非就是界面和事件两大块组成, 本文主要介绍如何快速上手界面的编写</p>
<h4 id="控件对比"><a href="#控件对比" class="headerlink" title="控件对比"></a>控件对比</h4><p><code>Android</code>应用界面的编写主要通过控件的排列组合, 常用的控件有<code>TextView</code>, <code>EditText</code>, <code>ImageView</code>, 那么在<code>Web</code>前端中也有类似于<code>Android</code>中的控件,只不过在前端中不叫控件, 而叫标签, 部分对比如下:</p>
<table>
<thead>
<tr>
<th align="center">Html标签</th>
<th align="center">Android控件</th>
</tr>
</thead>
<tbody><tr>
<td align="center">img标签</td>
<td align="center">ImageView</td>
</tr>
<tr>
<td align="center">input标签和textarea标签</td>
<td align="center">EditText</td>
</tr>
<tr>
<td align="center">button标签</td>
<td align="center">Button</td>
</tr>
<tr>
<td align="center">h系列标签,p标签,span标签</td>
<td align="center">类似于TextView</td>
</tr>
<tr>
<td align="center">div标签</td>
<td align="center">类似于水平方向的LinearLayout</td>
</tr>
</tbody></table>
<p><strong>容器标签和文本标签以及叶子标签的区别</strong>:</p>
<ul>
<li><strong>容器标签</strong>: 里面可以嵌套其他标签, 比如<code>div</code>标签</li>
<li><strong>文本标签</strong>: 里面可以填充文本显示, 比如<code>p</code>标签</li>
<li><strong>叶子标签</strong>:里面既不可以嵌套标签也不可以嵌套文本, 比如<code>img</code>标签</li>
</ul>
<p>当然, 有些标签<strong>既是容器标签又是文本标签</strong>:</p>
<table>
<thead>
<tr>
<th align="center">标签</th>
<th align="center">容器标签</th>
<th align="center">文本标签</th>
<th align="center">叶子标签</th>
</tr>
</thead>
<tbody><tr>
<td align="center">div</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">×</td>
</tr>
<tr>
<td align="center">p</td>
<td align="center">×</td>
<td align="center">√</td>
<td align="center">×</td>
</tr>
<tr>
<td align="center">span</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">×</td>
</tr>
<tr>
<td align="center">h系列</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">×</td>
</tr>
<tr>
<td align="center">button</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">x</td>
</tr>
<tr>
<td align="center">img</td>
<td align="center">×</td>
<td align="center">×</td>
<td align="center">√</td>
</tr>
<tr>
<td align="center">audio</td>
<td align="center">×</td>
<td align="center">×</td>
<td align="center">√</td>
</tr>
<tr>
<td align="center">video</td>
<td align="center">×</td>
<td align="center">×</td>
<td align="center">√</td>
</tr>
</tbody></table>
<p>除此之外, 有的<strong>标签本身自带换行符</strong>:</p>
<table>
<thead>
<tr>
<th align="center">标签</th>
<th align="center">开头自带换行符</th>
<th align="center">结尾自带换行符</th>
</tr>
</thead>
<tbody><tr>
<td align="center">div</td>
<td align="center">√</td>
<td align="center">√</td>
</tr>
<tr>
<td align="center">h系列</td>
<td align="center">√</td>
<td align="center">√</td>
</tr>
<tr>
<td align="center">button</td>
<td align="center">x</td>
<td align="center">x</td>
</tr>
<tr>
<td align="center">p</td>
<td align="center">√</td>
<td align="center">×</td>
</tr>
<tr>
<td align="center">ul</td>
<td align="center">√</td>
<td align="center">√</td>
</tr>
<tr>
<td align="center">span</td>
<td align="center">×</td>
<td align="center">×</td>
</tr>
<tr>
<td align="center">img</td>
<td align="center">×</td>
<td align="center">×</td>
</tr>
<tr>
<td align="center">audio</td>
<td align="center">×</td>
<td align="center">×</td>
</tr>
<tr>
<td align="center">video</td>
<td align="center">×</td>
<td align="center">×</td>
</tr>
</tbody></table>
<p><strong>关于控件的宽高显示</strong>:</p>
<table>
<thead>
<tr>
<th align="center">样式属性</th>
<th align="center">Android宽高属性</th>
</tr>
</thead>
<tbody><tr>
<td align="center">display:block</td>
<td align="center">android:layout_width=”match_parent”</td>
</tr>
<tr>
<td align="center">display:inline</td>
<td align="center">android:layout_width=”wrap_content”<br>android:layout_height=”wrap_content”</td>
</tr>
<tr>
<td align="center">display:inline-block</td>
<td align="center">android:layout_width=”自定义” <br>android:layout_height=”自定义”</td>
</tr>
</tbody></table>
<p><strong>关于元素的位置定位:</strong></p>
<table>
<thead>
<tr>
<th>标签</th>
<th>Android控件</th>
</tr>
</thead>
<tbody><tr>
<td>position:absolute<br>元素的位置以浏览器窗口为参照摆放</td>
<td>相当于设置成为Framelayout的子控件</td>
</tr>
<tr>
<td>position:relative<br>元素位置以邻近元素为参照摆放</td>
<td>相当于设置成为LinearLayout的子控件</td>
</tr>
<tr>
<td>position:fixed<br>元素的位置以浏览器窗口为参照摆放, 但是不随滚动条移动</td>
<td>相当于在ScrollView上层增加一个固定控件</td>
</tr>
<tr>
<td>position: sticky<br>粘性定位, 元素滚动超出页面时切换为fixed模式</td>
<td>和Android中粘性控件一样</td>
</tr>
<tr>
<td>position: static<br>默认状态,此时top left right bottom等属性均无效</td>
<td></td>
</tr>
</tbody></table>
<p>也就是说, <code>top left right bottom</code>这几个属性需要和<code>position</code>配合使用</p>
<p><strong>关于自定义控件(标签)</strong></p>
<p>在<code>Android</code>中除了官方提供的原生控件外, 我们还可以自定义控件, 那么<code>Web</code>前端可以吗?</p>
<p>如果放在以前肯定不行, 只能使用官方提供的<code>html</code>标签, 现在<strong>nodejs环境下可以实现自定义标签</strong>, 比如<code>vue</code>中:</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20210806111608395.png" alt="image-20210806111608395"></p>
<p>在<code>Android</code>中我们可以对控件设置相应的属性, 并且把共同的属性抽取到<code>style</code>文件中</p>
<p>那么<code>Web</code>前端也一样, 只不过属性和样式分开处理,抽取出来样式放置在<code>style</code>标签下, 如果单独放到一个文件中, 那么这个文件的后缀必须为<code>.css</code>, 所以我们又称之为<code>CSS</code>样式表 或者<code>CSS</code>语言</p>
<p>事实上, 我们会发现, <strong>Android的界面编写方式很多都是参考的Web前端</strong></p>
<p><strong>小练习:</strong></p>
<ol>
<li><p>写一个左侧带图标的文本:</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20210806122728724.png" alt="image-20210806122728724"></p>
<p>只要一个<code>img</code>标签和一个<code>span</code>标签够了:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">style</span>=<span class="string">"max-width: 26px; max-height: 26px"</span> <span class="attr">src</span>=<span class="string">"./assets/logo.png"</span>&gt;</span> <span class="tag">&lt;<span class="name">span</span>&gt;</span>成墨文档<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>效果如下:</p>
<p><img style="max-width: 26px; max-height: 26px" src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/logo.82b9c7a5.png"> <span>成墨文档</span></p>
<p>接下来需要给内容增加一个超链接, 所以在最外层包裹一个<code>a</code>标签</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">style</span>=<span class="string">"max-width: 26px; max-height: 26px"</span> <span class="attr">src</span>=<span class="string">"./assets/logo.png"</span>&gt;</span> <span class="tag">&lt;<span class="name">span</span>&gt;</span>成墨文档<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>效果如下:</p>
<p><a><img style="max-width: 26px; max-height: 26px" src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/logo.82b9c7a5.png"> <span>成墨文档</span></a></p>
<p>考虑到这个内容属于网站的网站标题, 为了利于<code>seo</code> 因此最外层再包裹一个<code>h1</code>标签, 此时文本也变大</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">"navbar-brand"</span> <span class="attr">href</span>=<span class="string">"/web/homepage/index"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">img</span> <span class="attr">style</span>=<span class="string">"max-width: 26px; max-height: 26px"</span> <span class="attr">src</span>=<span class="string">"./assets/logo.png"</span>&gt;</span> <span class="tag">&lt;<span class="name">span</span>&gt;</span>成墨文档<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>效果如下:</p>
<h1>
  <a class="navbar-brand" href="/web/homepage/index">
  <img style="max-width: 26px; max-height: 26px" src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/logo.82b9c7a5.png"> <span>成墨文档</span>
  </a>
  </h1>
</li>
<li><p>写一个网站导航条:</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20210806154307953.png" alt="image-20210806154307953"></p>
<p>html代码如下:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>  <span class="attr">id</span>=<span class="string">"navbar"</span>&gt;</span></span><br><span class="line">   </span><br><span class="line">   <span class="tag">&lt;<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">"navbar-brand"</span> <span class="attr">href</span>=<span class="string">"/web/homepage/index"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">style</span>=<span class="string">"max-width: 26px; max-height: 26px"</span> <span class="attr">src</span>=<span class="string">"./assets/logo.png"</span>&gt;</span> <span class="tag">&lt;<span class="name">span</span>&gt;</span>成墨文档<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">      </span><br><span class="line">        <span class="tag">&lt;<span class="name">ul</span> &gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"/web/homepage/index"</span>&gt;</span>首页<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">target</span>=<span class="string">"_blank"</span> <span class="attr">href</span>=<span class="string">"https://www.xxx.com/pricing"</span>&gt;</span>价格<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"http://blog.xxx.com/"</span>&gt;</span>博客<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"https://docs.xxx.com/#/"</span>&gt;</span>帮助文档<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"/web/homepage/apidoc"</span>&gt;</span>API<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"long-li nav-item"</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"/web/signup/sign_up"</span> <span class="attr">id</span>=<span class="string">"btn-register"</span>&gt;</span>免费注册<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"short-li nav-item"</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"/web/login"</span>&gt;</span>登录<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>效果如下:</p>
</li>
</ol>
   <h1>
     <a class="navbar-brand" href="/web/homepage/index">
     <img style="max-width: 26px; max-height: 26px" src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/logo.82b9c7a5.png"> <span>成墨文档</span>
     </a>
     </h1>


<pre><code>&lt;ul &gt;
   &lt;li&gt;&lt;a href=&quot;/web/homepage/index&quot;&gt;首页&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://www.xxx.com/pricing&quot;&gt;价格&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.xxx.com/&quot;&gt;博客&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://docs.xxx.com/#/&quot;&gt;帮助文档&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/web/homepage/apidoc&quot;&gt;API&lt;/a&gt;&lt;/li&gt;
&lt;li class=&quot;long-li nav-item&quot;&gt;&lt;a href=&quot;/web/signup/sign_up&quot; id=&quot;btn-register&quot;&gt;免费注册&lt;/a&gt;&lt;/li&gt;
&lt;li class=&quot;short-li nav-item&quot;&gt;&lt;a href=&quot;/web/login&quot;&gt;登录&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</code></pre><p>   我们需要给其添加相应的样式:</p>
   <figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;<span class="selector-tag">style</span> &gt;</span><br><span class="line">   <span class="selector-id">#navbar</span>&#123;</span><br><span class="line"> <span class="comment">/*固定在顶部*/</span></span><br><span class="line">   <span class="attribute">position</span>: fixed;</span><br><span class="line">   <span class="attribute">top</span>:<span class="number">0px</span>;</span><br><span class="line">   <span class="attribute">left</span>:<span class="number">0px</span>;</span><br><span class="line">   <span class="attribute">width</span>:<span class="number">100%</span>;</span><br><span class="line">   <span class="attribute">height</span>:<span class="number">64px</span>;</span><br><span class="line">   <span class="attribute">background-color</span>:<span class="number">#AAAAAA</span>;</span><br><span class="line">   <span class="attribute">padding-left</span>:<span class="number">50px</span>;</span><br><span class="line">   <span class="attribute">padding-right</span>:<span class="number">20px</span>;</span><br><span class="line">   <span class="attribute">display</span>:flex;</span><br><span class="line">       <span class="attribute">align-items</span>:center;<span class="comment">/*指定垂直居中*/</span></span><br><span class="line">   &#125;</span><br><span class="line"><span class="selector-tag">ul</span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="attribute">display</span>: inline-block;</span><br><span class="line">     <span class="comment">/*列表向右浮动*/</span></span><br><span class="line">			<span class="attribute">float</span>: right;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">h1</span>&#123;</span><br><span class="line">  <span class="attribute">display</span>:inline;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">li</span>&#123;</span><br><span class="line">  <span class="comment">/*去除列表中的原点样式*/</span></span><br><span class="line">  <span class="attribute">list-style</span>: none; </span><br><span class="line">  </span><br><span class="line"> </span><br><span class="line">   <span class="comment">/*列表从左向右浮动*/</span></span><br><span class="line">			<span class="attribute">float</span>: left;</span><br><span class="line">    <span class="attribute">margin-left</span>: <span class="number">40px</span>;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="selector-tag">a</span>&#123;</span><br><span class="line">  <span class="comment">/*取消超链接下划线*/</span>	</span><br><span class="line">  <span class="attribute">text-decoration</span>: none;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>

<p>以上是比较基础的练习, 熟悉的差不多了后, 我们开始进入到使用vue的开发阶段</p>
<h4 id="Vue快速上手"><a href="#Vue快速上手" class="headerlink" title="Vue快速上手"></a>Vue快速上手</h4><p><strong>环境配置</strong>:</p>
<ul>
<li><a href="http://nodejs.cn/download/" target="_blank" rel="noopener">nodejs</a></li>
<li><a href="https://cli.vuejs.org/zh/guide/" target="_blank" rel="noopener">@vue/cli</a></li>
</ul>
<p><strong>vue项目创建</strong>:</p>
<p>第一步 安装vue:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install -g @vue/cli-service-global</span><br></pre></td></tr></table></figure>

<p>第二步 创建脚手架(模板工程)</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vue create hello-world</span><br><span class="line"></span><br><span class="line"><span class="comment">#或者直接使用图形化界面创建</span></span><br><span class="line">vue ui</span><br></pre></td></tr></table></figure>

<p>这里直接使用图形化创建:</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20210806115245063.png" alt="image-20210806115245063"></p>
<p>创建后自动生成相应的文件和目录, 目录结构如下:</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20210806115856398.png" alt="image-20210806115856398"></p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20210806162357285.png" alt="image-20210806162357285"></p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20210806170246960.png" alt="image-20210806170246960"></p>
<p>大部分和原生相比差别不大, 但是开发上更加高效,具体参考:</p>
<p><a href="https://code.newban.cn/239.html">Vue入门基础语法</a></p>
<h4 id="为什么选择vue"><a href="#为什么选择vue" class="headerlink" title="为什么选择vue"></a>为什么选择vue</h4><p><strong>vue只是一个开发框架 或者理解为一个中间人</strong>, 它借助于<code>nodejs</code>环境, 使得我们可以采用<code>MVVM</code>的模型, 同时集成第三方各种插件, 方便而又快速地组件化开发, 相比原生而言整体的架构也更加清晰, 后期维护也得心应手</p>
<p>当然, 你也可以使用其他前端框架, 比如<code>Facebook</code>的<code>React</code>框架, 或者<code>Google</code>推出的<code>Angular</code>框架, 未来也可能出现新的框架, 但有一点是不会变的, 不管是什么框架, 它编译出来最终文件还是<code>html</code> <code>css</code>和<code>js</code>, 因为 目前浏览器只识别这三种文件</p>
<p><strong>本文为作者原创 转载时请注明出处 谢谢</strong></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt="img"></p>
<p><em><a href="https://code.newban.cn/">乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</a></em></p>
]]></content>
      <tags>
        <tag>Web前端</tag>
      </tags>
  </entry>
  <entry>
    <title>SQL修改字段属性</title>
    <url>/241.html</url>
    <content><![CDATA[<p><strong>1.增加字段</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ALTER TABLE tableName ADD COLUMN columnName VARCHAR(20) DEFAULT NULL --增加一个字段，默认为空</span><br><span class="line">ALTER TABLE tableName ADD COLUMN columnName VARCHAR(20) NOT NULL     --增加一个字段，默认不能为空</span><br></pre></td></tr></table></figure>

<p><strong>2.删除字段</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ALTER TABLE tableName DROP COLUMN columnName --删除一个字段</span><br></pre></td></tr></table></figure>

<p><strong>3.修改字段类型</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ALTER TABLE tableName MODIFY COLUMN columnName VARCHAR(10) --修改一个字段的类型</span><br></pre></td></tr></table></figure>

<p><strong>4.删除主键</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Declare @Pk varChar(100);</span><br><span class="line">Select @Pk=Name from sysobjects where Parent_Obj=OBJECT_ID(&apos;tableName&apos;) and xtype=&apos;PK&apos;;</span><br><span class="line">if @Pk is not null</span><br><span class="line">exec(&apos;Alter table tableName Drop &apos;+ @Pk)</span><br></pre></td></tr></table></figure>

<p><strong>5.给已经建好的表字段添加唯一性约束</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">alter table 表名 add unique(字段名);</span><br></pre></td></tr></table></figure>

<p><strong>本文为作者原创 转载时请注明出处 谢谢</strong></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt="img"></p>
<p><em><a href="https://code.newban.cn/">乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</a></em></p>
]]></content>
      <tags>
        <tag>sql</tag>
      </tags>
  </entry>
  <entry>
    <title>Django博客开发之将文章html内容写入数据库遇到的坑</title>
    <url>/24.html</url>
    <content><![CDATA[<h2 id="坑1-Python操作mysql数据库出现pymysql-err-ProgrammingError-1064-“You-have-an-error-in-your-SQL-syntax"><a href="#坑1-Python操作mysql数据库出现pymysql-err-ProgrammingError-1064-“You-have-an-error-in-your-SQL-syntax" class="headerlink" title="坑1: Python操作mysql数据库出现pymysql.err.ProgrammingError: (1064, “You have an error in your SQL syntax;"></a>坑1: Python操作mysql数据库出现pymysql.err.ProgrammingError: (1064, “You have an error in your SQL syntax;</h2><p>下面为python中做mysql数据库插入数据代码操作：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import pymysql.cursors</span><br><span class="line"></span><br><span class="line">    # 循环入库操作</span><br><span class="line">    for ll in range(0, len(wallPaperBeanList)):</span><br><span class="line">        # 连接MySQL数据库</span><br><span class="line">        connection = pymysql.connect(host=&apos;127.0.0.1&apos;, port=3306, user=&apos;ad&apos;, password=&apos;ad&apos;, db=&apos;AllThingArePower&apos;,</span><br><span class="line">                                     charset=&apos;utf8mb4&apos;, cursorclass=pymysql.cursors.DictCursor)</span><br><span class="line"></span><br><span class="line">        # 通过cursor创建游标</span><br><span class="line">        cursor = connection.cursor()</span><br><span class="line">        insert_sql = &quot;INSERT INTO &apos;wallpaper&apos; (&apos;category&apos;,&apos;view_img&apos;,&apos;img&apos;,&apos;created_time&apos;,&apos;img_tag&apos;) VALUES (&quot;+ wallPaperBeanList[ll].category +&apos;,&apos;+wallPaperBeanList[ll].view_img +&apos;,&apos;+wallPaperBeanList[ll].img +&apos;,&apos;+wallPaperBeanList[ll].created_time +&apos;,&apos;+&apos;null&apos; +&apos;)&apos;</span><br><span class="line"></span><br><span class="line">        # print(&apos;category==&apos; + wallPaperBeanList[ll].category + &apos;;view_img==&apos; + str(</span><br><span class="line">        #     wallPaperBeanList[ll].view_img) + &apos;;img==&apos; + str(wallPaperBeanList[ll].img) + &apos;;created_time==&apos; + str(wallPaperBeanList[ll].created_time) + &apos;;img_tag==&apos; + str(wallPaperBeanList[ll].img_tag))</span><br><span class="line">        cursor.execute(insert_sql)</span><br><span class="line"></span><br><span class="line">        # 提交SQL</span><br><span class="line">        connection.commit()</span><br><span class="line">        # 关闭数据连接</span><br><span class="line">        connection.close()</span><br><span class="line"></span><br><span class="line">12345678910111213141516171819202122</span><br></pre></td></tr></table></figure>

<p>运行后就出现了下面这个异常，下面贴下完整的异常日志信息：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pymysql.err.ProgrammingError: (1064, &quot;You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near &apos;&apos;wallpaper&apos; (&apos;category&apos;,&apos;view_img&apos;,&apos;img&apos;,&apos;created_time&apos;,&apos;img_tag&apos;) VALUES (Origi&apos; at line 1&quot;)1</span><br></pre></td></tr></table></figure>

<p>正常文本没有问题 唯独html文本报错,刚开始我一直以为是mysql语法有错误，但找来找去始终没有找到可以改动的地方，百度后网上有博客讲mysql语句拼接的时候里面可能有参数有双引号导致的，使用pymysql.escape_string()方法把有双引号的参数处理一下就行，这个方案没有解决了我的问题，后来找到了一个比较好的解决方案，就是不要用%或者+操作符来拼接SQL语句，应该使用占位符。即execute的第二个参数。</p>
<p>修改后的代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import pymysql.cursors</span><br><span class="line"></span><br><span class="line">    # 循环入库操作</span><br><span class="line">    for ll in range(0, len(wallPaperBeanList)):</span><br><span class="line">        # 连接MySQL数据库</span><br><span class="line">        connection = pymysql.connect(host=&apos;127.0.0.1&apos;, port=3306, user=&apos;ad&apos;, password=&apos;ad&apos;, db=&apos;AllThingArePower&apos;,</span><br><span class="line">                                     charset=&apos;utf8mb4&apos;, cursorclass=pymysql.cursors.DictCursor)</span><br><span class="line"></span><br><span class="line">        # 通过cursor创建游标</span><br><span class="line">        cursor = connection.cursor()</span><br><span class="line">                cursor.execute(&apos;insert into wallpaper (category,view_img,img,created_time,img_tag) values (%s,%s,%s,%s,%s)&apos;, (str(wallPaperBeanList[ll].category), str(</span><br><span class="line">            wallPaperBeanList[ll].view_img),str(wallPaperBeanList[ll].img),str(wallPaperBeanList[ll].created_time),str(wallPaperBeanList[ll].img_tag)))</span><br><span class="line"></span><br><span class="line">        # 提交SQL</span><br><span class="line">        connection.commit()</span><br><span class="line">        # 关闭数据连接</span><br></pre></td></tr></table></figure>

<h2 id="坑2-写入数据库中途出现-Mysql失败，异常pymysql-err-InternalError-1366-“Incorrect-string-value-‘-xF0-x9D-x90-xBF-……"><a href="#坑2-写入数据库中途出现-Mysql失败，异常pymysql-err-InternalError-1366-“Incorrect-string-value-‘-xF0-x9D-x90-xBF-……" class="headerlink" title="坑2: 写入数据库中途出现: Mysql失败，异常pymysql.err.InternalError: (1366, “Incorrect string value: ‘\xF0\x9D\x90\xBF;……"></a>坑2: 写入数据库中途出现: Mysql失败，异常pymysql.err.InternalError: (1366, “Incorrect string value: ‘\xF0\x9D\x90\xBF;……</h2><h4 id="问题描述："><a href="#问题描述：" class="headerlink" title="问题描述："></a>问题描述：</h4><p>　　插入Mysql时失败了，python代码报如下异常：</p>
<p>　　pymysql.err.InternalError: (1366, “Incorrect string value: ‘\xF0\x9D\x90\xBF;……</p>
<h4 id="原因分析："><a href="#原因分析：" class="headerlink" title="原因分析："></a>原因分析：</h4><p>　　UTF-8编码有可能是两个、三个、四个字节。Emoji表情是4个字节，而Mysql的utf8编码最多3个字节，所以数据插不进去。</p>
<h4 id="解决方案："><a href="#解决方案：" class="headerlink" title="解决方案："></a>解决方案：</h4><p>　　修改Mysql表的字符集和Pymysql连接库时的字符集。</p>
<h3 id="1、修改Mysql表的字符集"><a href="#1、修改Mysql表的字符集" class="headerlink" title="　　1、修改Mysql表的字符集"></a>　　1、修改Mysql表的字符集</h3><p>　　　　说明：将已经建好的表字符集转改成 utf8mb4，排序规则改为 utf8mb4_bin</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">　　　命令：alter table TABLE_NAME convert to character set utf8mb4 collate utf8mb4_bin; （将TABLE_NAME替换成你的表名）</span><br></pre></td></tr></table></figure>

<p>　　　　注意：排序规则不是 utf8mb4_general_ci，而是utf8mb4_bin，不要想当然</p>
<h3 id="2、修改数据库连接的字符集"><a href="#2、修改数据库连接的字符集" class="headerlink" title="　　2、修改数据库连接的字符集   　　"></a>　　2、修改数据库连接的字符集   　　</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">　　　　conn = pymysql.connect(host=&apos;localhost&apos;, user=&apos;root&apos;, password=&apos;root&apos;, port=3306, db=&apos;cncb&apos;, charset=&apos;utf8mb4&apos;)</span><br></pre></td></tr></table></figure>

<p><strong>本文为作者原创 转载时请注明出处 谢谢</strong></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em>乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</em></p>
]]></content>
      <tags>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title>Javascript中click点击事件的若干种种写法</title>
    <url>/243.html</url>
    <content><![CDATA[<h4 id="第一种"><a href="#第一种" class="headerlink" title="第一种"></a>第一种</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Javascript中点击事件方法一<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">"btn"</span>&gt;</span>click<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">"btn"</span>);</span></span><br><span class="line"><span class="actionscript">        btn.onclick=<span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span></span><br><span class="line"><span class="actionscript">            alert(<span class="string">"hello world"</span>);</span></span><br><span class="line">        &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>移除事件:</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">btn.onclick=<span class="literal">null</span>;</span><br></pre></td></tr></table></figure>

<h4 id="第二种"><a href="#第二种" class="headerlink" title="第二种"></a>第二种</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Javascript中点击事件方法二<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">"btn"</span>&gt;</span>click<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">"btn"</span>);</span></span><br><span class="line"><span class="actionscript">        btn.addEventListener(<span class="string">'click'</span>,<span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span></span><br><span class="line"><span class="actionscript">            alert(<span class="string">"hello wrold"</span>);</span></span><br><span class="line"><span class="actionscript">        &#125;,<span class="literal">false</span>)</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="第三种"><a href="#第三种" class="headerlink" title="第三种"></a>第三种</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Javascript中点击事件方法三<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span><br><span class="line"><span class="actionscript">        <span class="function"><span class="keyword">function</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span></span><br><span class="line"><span class="actionscript">            alert(<span class="string">"hello world"</span>);</span></span><br><span class="line">        &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">"btn"</span> <span class="attr">onclick</span>=<span class="string">"test()"</span>&gt;</span>click<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="第四种"><a href="#第四种" class="headerlink" title="第四种"></a>第四种</h4><p>模拟触发事件:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>usually function<span class="tag">&lt;/<span class="name">title</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span> </span><br><span class="line"><span class="actionscript"><span class="function"><span class="keyword">function</span> <span class="title">load</span><span class="params">()</span></span>&#123; </span></span><br><span class="line"><span class="actionscript">  <span class="comment">//下面两种方法效果是一样的 </span></span></span><br><span class="line"><span class="javascript"> <span class="built_in">document</span>.getElementById(<span class="string">"target"</span>).onclick(); </span></span><br><span class="line"><span class="javascript">  <span class="built_in">document</span>.getElementById(<span class="string">"target"</span>).click(); </span></span><br><span class="line">&#125; </span><br><span class="line"><span class="actionscript"><span class="function"><span class="keyword">function</span> <span class="title">test</span><span class="params">()</span></span>&#123; </span></span><br><span class="line"><span class="actionscript">  alert(<span class="string">"test"</span>); </span></span><br><span class="line">&#125; </span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span> <span class="attr">onload</span>=<span class="string">"load()"</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">"target"</span> <span class="attr">onclick</span>=<span class="string">"test()"</span>&gt;</span>test<span class="tag">&lt;/<span class="name">button</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>本文为作者原创 转载时请注明出处 谢谢</strong></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt="img"></p>
<p><em><a href="https://code.newban.cn/">乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</a></em></p>
]]></content>
      <tags>
        <tag>Web前端</tag>
      </tags>
  </entry>
  <entry>
    <title>springboot整合mybatis访问mysql数据库</title>
    <url>/242.html</url>
    <content><![CDATA[<h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><ul>
<li><strong>构建工具</strong>:Gradle</li>
<li><strong>开发语言</strong>:Kotlin</li>
<li><strong>mysql版本</strong>: 8.0</li>
</ul>
<h2 id="配置步骤"><a href="#配置步骤" class="headerlink" title="配置步骤"></a>配置步骤</h2><h4 id="1-引入依赖"><a href="#1-引入依赖" class="headerlink" title="1.引入依赖"></a>1.引入依赖</h4><p>在build,gradle文件引入mybatis-spring-boot-starter-web的依赖：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">implementation &quot;org.springframework.boot:spring-boot-starter-web:2.4.9&quot;</span><br></pre></td></tr></table></figure>

<p>引入数据库连接依赖：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">implementation &quot;mysql:mysql-connector-java:8.0.26&quot;</span><br></pre></td></tr></table></figure>

<h4 id="2-引入数据源"><a href="#2-引入数据源" class="headerlink" title="2.引入数据源"></a>2.引入数据源</h4><p><code>application.yml</code>配置文件中引入数据源：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">  datasource:</span><br><span class="line">    url: jdbc:mysql://localhost:3306/test?characterEncoding=utf-8&amp;useSSL=false</span><br><span class="line">    username: root</span><br><span class="line">    password: 123456</span><br><span class="line">    driver: com.mysql.cj.jdbc.Driver</span><br></pre></td></tr></table></figure>

<p>这样，<code>springboot</code>就可以访问数据了。</p>
<h4 id="3-创建数据库表"><a href="#3-创建数据库表" class="headerlink" title="3.创建数据库表"></a>3.创建数据库表</h4><p>建表语句：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- create table `account`</span><br><span class="line"># DROP TABLE `account` IF EXISTS</span><br><span class="line">CREATE TABLE `account` (</span><br><span class="line">  `id` int(11) NOT NULL AUTO_INCREMENT,</span><br><span class="line">  `name` varchar(20) NOT NULL,</span><br><span class="line">  `money` double DEFAULT NULL,</span><br><span class="line">  PRIMARY KEY (`id`)</span><br><span class="line">) ENGINE=InnoDB AUTO_INCREMENT=4 DEFAULT CHARSET=utf8;</span><br><span class="line">INSERT INTO `account` VALUES (&apos;1&apos;, &apos;aaa&apos;, &apos;1000&apos;);</span><br><span class="line">INSERT INTO `account` VALUES (&apos;2&apos;, &apos;bbb&apos;, &apos;1000&apos;);</span><br><span class="line">INSERT INTO `account` VALUES (&apos;3&apos;, &apos;ccc&apos;, &apos;1000&apos;);</span><br></pre></td></tr></table></figure>

<h4 id="4-具体实现"><a href="#4-具体实现" class="headerlink" title="4.具体实现"></a>4.具体实现</h4><p>这篇文篇通过注解的形式实现。</p>
<h5 id="5-创建实体："><a href="#5-创建实体：" class="headerlink" title="5.创建实体："></a>5.创建实体：</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">data class Account (</span><br><span class="line">    var id:Int = 0,</span><br><span class="line">    var name: String? = null,</span><br><span class="line">    var money :Double= 0.0</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h5 id="6-Dao层"><a href="#6-Dao层" class="headerlink" title="6.Dao层"></a>6.Dao层</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Mapperpublic interface AccountMapper &#123;</span><br><span class="line"></span><br><span class="line">    @Insert(&quot;insert into account(name, money) values(#&#123;name&#125;, #&#123;money&#125;)&quot;)</span><br><span class="line">    int add(@Param(&quot;name&quot;) String name, @Param(&quot;money&quot;) double money);</span><br><span class="line"></span><br><span class="line">    @Update(&quot;update account set name = #&#123;name&#125;, money = #&#123;money&#125; where id = #&#123;id&#125;&quot;)</span><br><span class="line">    int update(@Param(&quot;name&quot;) String name, @Param(&quot;money&quot;) double money, @Param(&quot;id&quot;) int  id);</span><br><span class="line"></span><br><span class="line">    @Delete(&quot;delete from account where id = #&#123;id&#125;&quot;)</span><br><span class="line">    int delete(int id);</span><br><span class="line"></span><br><span class="line">    @Select(&quot;select id, name as name, money as money from account where id = #&#123;id&#125;&quot;)</span><br><span class="line">    Account findAccount(@Param(&quot;id&quot;) int id);</span><br><span class="line"></span><br><span class="line">    @Select(&quot;select id, name as name, money as money from account&quot;)</span><br><span class="line">    List&lt;Account&gt; findAccountList();&#125;</span><br></pre></td></tr></table></figure>

<h4 id="7-service层"><a href="#7-service层" class="headerlink" title="7.service层"></a>7.service层</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Mapper</span><br><span class="line">interface AccountMapper &#123;</span><br><span class="line">    @Insert(&quot;insert into account(name, money) values(#&#123;name&#125;, #&#123;money&#125;)&quot;)</span><br><span class="line">    fun add(@Param(&quot;name&quot;) name: String?, @Param(&quot;money&quot;) money: Double): Int</span><br><span class="line"></span><br><span class="line">    @Update(&quot;update account set name = #&#123;name&#125;, money = #&#123;money&#125; where id = #&#123;id&#125;&quot;)</span><br><span class="line">    fun update(</span><br><span class="line">        @Param(&quot;name&quot;) name: String?,</span><br><span class="line">        @Param(&quot;money&quot;) money: Double,</span><br><span class="line">        @Param(&quot;id&quot;) id: Int</span><br><span class="line">    ): Int</span><br><span class="line"></span><br><span class="line">    @Delete(&quot;delete from account where id = #&#123;id&#125;&quot;)</span><br><span class="line">    fun delete(id: Int): Int</span><br><span class="line"></span><br><span class="line">    @Select(&quot;select id, name as name, money as money from account where id = #&#123;id&#125;&quot;)</span><br><span class="line">    fun findAccount(@Param(&quot;id&quot;) id: Int): Account?</span><br><span class="line"></span><br><span class="line">    @Select(&quot;select id, name as name, money as money from account&quot;)</span><br><span class="line">    fun findAccountList(): List&lt;Account?&gt;?</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="8-controller层，构建restful-API"><a href="#8-controller层，构建restful-API" class="headerlink" title="8.controller层，构建restful API"></a>8.controller层，构建restful API</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">@CrossOrigin</span><br><span class="line">@RestController</span><br><span class="line">class MainControl &#123;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    lateinit var accountService: AccountService</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @GetMapping(value = [&quot;/list&quot;])</span><br><span class="line">    fun getAccounts(): List&lt;Account&gt; &#123;</span><br><span class="line">        return accountService.findAccountList()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @GetMapping(value = [&quot;/&#123;id&#125;&quot;])</span><br><span class="line">    fun getAccountById(@PathVariable(&quot;id&quot;) id: Int): Account? &#123;</span><br><span class="line">        return accountService.findAccount(id)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @PutMapping(value = [&quot;/&#123;id&#125;&quot;])</span><br><span class="line">    fun updateAccount(</span><br><span class="line">        @PathVariable(&quot;id&quot;) id: Int, @RequestParam(value = &quot;name&quot;, required = true) name: String?,</span><br><span class="line">        @RequestParam(value = &quot;money&quot;, required = true) money: Double</span><br><span class="line">    ): String &#123;</span><br><span class="line">        val t = accountService.update(name, money, id)</span><br><span class="line">        return if (t == 1) &#123;</span><br><span class="line">            &quot;success&quot;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            &quot;fail&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @DeleteMapping(value = [&quot;/&#123;id&#125;&quot;])</span><br><span class="line">    fun delete(@PathVariable(value = &quot;id&quot;) id: Int): String &#123;</span><br><span class="line">        val t = accountService.delete(id)</span><br><span class="line">        return if (t == 1) &#123;</span><br><span class="line">            &quot;success&quot;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            &quot;fail&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>配置完毕</p>
<p>最后启动程序, 浏览器访问:<a href="http://localhost:8080/list进行测试" target="_blank" rel="noopener">http://localhost:8080/list进行测试</a></p>
<p><strong>本文为作者原创 转载时请注明出处 谢谢</strong></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt="img"></p>
<p><em><a href="https://code.newban.cn/">乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</a></em></p>
]]></content>
      <tags>
        <tag>springboot</tag>
      </tags>
  </entry>
  <entry>
    <title>Android开发中实现全局数据共享的几种方式</title>
    <url>/246.html</url>
    <content><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>这里的数据并不是指单纯的字面值数据, 字面值数据我们可以使用数据库实现, 但是如果我们需要将一些变量, 对象设置成全局共享 那么有以下几种方式</p>
<ul>
<li>静态变量/常量</li>
<li>单例</li>
<li>枚举</li>
<li>后台服务</li>
</ul>
<h4 id="静态变量-常量"><a href="#静态变量-常量" class="headerlink" title="静态变量/常量"></a>静态变量/常量</h4><p>既可以存储字面值数据, 也可以存储引用型数据</p>
<h4 id="单例"><a href="#单例" class="headerlink" title="单例"></a>单例</h4><p>全局唯一的对象实例, 这个不必多说</p>
<h4 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h4><p>由静态常量/变量延伸而来, jdk早期版本不支持枚举, 都是使用静态常量替代</p>
<p>枚举使用相对静态常量更加方便 </p>
<h4 id="后台服务"><a href="#后台服务" class="headerlink" title="后台服务"></a>后台服务</h4><p>属于Android独有, 四大组件之一, 可以利用service维护一个全局唯一对象或者变量</p>
<p>由于Service自带Context对象, 因此在需要使用到Context的场景下推荐使用Service来实现全局数据共享, 避免内存泄露</p>
<p><strong>本文为作者原创 转载时请注明出处 谢谢</strong></p>
<p><a href="https://space.bilibili.com/485691562" target="_blank" rel="noopener">B站入口</a></p>
<p><a href="https://code.newban.cn/0.html">打赏通道</a></p>
<p>微信公众号二维码如下:</p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt="img"></p>
<p><em><a href="https://code.newban.cn/">乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</a></em></p>
]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库操作之多表联合查询sql语句</title>
    <url>/244.html</url>
    <content><![CDATA[<h4 id="表准备"><a href="#表准备" class="headerlink" title="表准备"></a>表准备</h4><p>假设数据库有两张表 名为<code>person</code>和<code>city</code></p>
<p>表<code>person</code>字段如下:</p>
<table>
<thead>
<tr>
<th>id</th>
<th>name</th>
<th>c_id</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>张三</td>
<td>1</td>
</tr>
<tr>
<td>2</td>
<td>李四</td>
<td>2</td>
</tr>
<tr>
<td>3</td>
<td>王五</td>
<td>5</td>
</tr>
</tbody></table>
<p>表<code>city</code>字段如下</p>
<table>
<thead>
<tr>
<th>id</th>
<th>city</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>北京</td>
</tr>
<tr>
<td>2</td>
<td>上海</td>
</tr>
<tr>
<td>3</td>
<td>广州</td>
</tr>
</tbody></table>
<h4 id="多表合一查询"><a href="#多表合一查询" class="headerlink" title="多表合一查询"></a>多表合一查询</h4><ol>
<li><strong>第一种</strong></li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> xxx,xxx <span class="keyword">from</span> 表<span class="number">1</span>，表<span class="number">2</span> <span class="keyword">where</span> 表<span class="number">1.</span>xxx=表<span class="number">2.</span>xxx</span><br></pre></td></tr></table></figure>

<p>示例:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">name</span>, city <span class="keyword">from</span> person, city <span class="keyword">where</span> name.c_id = city.id;</span><br></pre></td></tr></table></figure>

<p>查询结果:</p>
<table>
<thead>
<tr>
<th>city</th>
<th>name</th>
</tr>
</thead>
<tbody><tr>
<td>北京</td>
<td>张三</td>
</tr>
<tr>
<td>上海</td>
<td>李四</td>
</tr>
</tbody></table>
<ol start="2">
<li><strong>第二种 使用 <code>join</code></strong></li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> xxx,xxx <span class="keyword">from</span> 表<span class="number">1</span> <span class="keyword">inner</span> <span class="keyword">join</span> 表<span class="number">2</span> <span class="keyword">on</span> 表<span class="number">1.</span>xxx=表<span class="number">2.</span>xxx</span><br></pre></td></tr></table></figure>

<p>示例:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">name</span>, city <span class="keyword">from</span> person <span class="keyword">inner</span> <span class="keyword">join</span> city <span class="keyword">on</span> name.c_id = city.id;</span><br></pre></td></tr></table></figure>

<p>查询结果和第一种一致</p>
<h4 id="根据一张表字段查询另外一张表"><a href="#根据一张表字段查询另外一张表" class="headerlink" title="根据一张表字段查询另外一张表"></a>根据一张表字段查询另外一张表</h4><ol>
<li>查询所属北京的都有哪些人</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 嵌套查询方式</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">name</span></span><br><span class="line"><span class="keyword">from</span> person </span><br><span class="line"><span class="keyword">where</span> c_id = ( <span class="keyword">select</span> <span class="keyword">id</span>  <span class="keyword">from</span> city  <span class="keyword">where</span> city = <span class="string">'北京'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#或者非嵌套查询方式</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">name</span></span><br><span class="line"><span class="keyword">from</span> person p, city c</span><br><span class="line"><span class="keyword">where</span> p.c_id = c.id <span class="keyword">and</span> c.city= <span class="string">'北京'</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li><code>like</code>关键字查询姓张的有多少人</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">count</span>(<span class="keyword">distinct</span>(<span class="keyword">name</span>)) </span><br><span class="line">  <span class="keyword">from</span> person</span><br><span class="line">  <span class="keyword">where</span> <span class="keyword">name</span> <span class="keyword">like</span> <span class="string">'张%'</span>;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><code>in</code>嵌套查询 判断查询的表达式是否在多个值的列表中</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">name</span> </span><br><span class="line"><span class="keyword">from</span> person </span><br><span class="line"><span class="keyword">where</span> c_id <span class="keyword">in</span> ( <span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> city);</span><br></pre></td></tr></table></figure>

<ol start="4">
<li><code>some</code>部分匹配查询 如果在一系列比较中，有些值为True，那么结果就为True</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">name</span> </span><br><span class="line"><span class="keyword">from</span> person </span><br><span class="line"><span class="keyword">where</span> c_id = <span class="keyword">some</span> ( <span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> city);</span><br></pre></td></tr></table></figure>

<ol start="5">
<li><code>all</code>全部匹配查询 如果一系列的比较都为true，那么结果才能为true</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">#大于以下返回的所有id，此结果才为True，此结果才返回</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">name</span> </span><br><span class="line"><span class="keyword">from</span> person </span><br><span class="line"><span class="keyword">where</span> c_id &gt; <span class="keyword">all</span> ( <span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> city);</span><br></pre></td></tr></table></figure>

<ol start="6">
<li><code>exists</code>嵌套查询 如果子查询有结果集返回，那么就为True 一旦找到第一个匹配的记录后，就马上停止查找</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * </span><br><span class="line"><span class="keyword">from</span> person </span><br><span class="line"><span class="keyword">where</span> <span class="keyword">exists</span> ( <span class="keyword">select</span> * <span class="keyword">from</span> city);</span><br></pre></td></tr></table></figure>

<p>子查询必定返回true的三种情况:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">#第一种select 1</span></span><br><span class="line"><span class="keyword">select</span> * </span><br><span class="line"><span class="keyword">from</span> person </span><br><span class="line"><span class="keyword">where</span> <span class="keyword">exists</span> ( <span class="keyword">select</span> <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">#第二种select 0</span></span><br><span class="line"><span class="keyword">select</span> * </span><br><span class="line"><span class="keyword">from</span> person </span><br><span class="line"><span class="keyword">where</span> <span class="keyword">exists</span> ( <span class="keyword">select</span> <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">#第三种select null</span></span><br><span class="line"><span class="keyword">select</span> * </span><br><span class="line"><span class="keyword">from</span> person </span><br><span class="line"><span class="keyword">where</span> <span class="keyword">exists</span> ( <span class="keyword">select</span> <span class="literal">null</span>);</span><br></pre></td></tr></table></figure>

<h4 id="根据子查询结果充当临时表进行查询"><a href="#根据子查询结果充当临时表进行查询" class="headerlink" title="根据子查询结果充当临时表进行查询"></a>根据子查询结果充当临时表进行查询</h4><ol>
<li>子查询是一种嵌套查询，将一个查询用小括号包围起来，然后作为下一个查询的结果，<strong>子查询必须有别名</strong> ,一般用于二次或多次筛查。</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> nan.id <span class="keyword">FROM</span> (<span class="keyword">SELECT</span> <span class="keyword">name</span>,c_id <span class="keyword">FROM</span> person <span class="keyword">WHERE</span> <span class="keyword">id</span>=<span class="number">2</span>) <span class="keyword">AS</span> <span class="keyword">nan</span> <span class="keyword">WHERE</span> c_id = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<h4 id="关于join的特殊用法"><a href="#关于join的特殊用法" class="headerlink" title="关于join的特殊用法"></a>关于<code>join</code>的特殊用法</h4><ul>
<li><strong>JOIN</strong>: 如果表中有至少一个匹配，则返回行</li>
<li><strong>LEFT JOIN</strong>: 即使右表中没有匹配，也从左表返回所有的行</li>
<li><strong>RIGHT JOIN</strong>: 即使左表中没有匹配，也从右表返回所有的行</li>
<li><strong>FULL JOIN</strong>: 只要其中一个表中存在匹配，就返回行 </li>
</ul>
<p><strong>LEFT JOIN示例:</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">name</span>, city <span class="keyword">from</span> person <span class="keyword">left</span> <span class="keyword">join</span> city <span class="keyword">on</span> name.c_id = city.id;</span><br></pre></td></tr></table></figure>

<p>返回结果:</p>
<table>
<thead>
<tr>
<th>city</th>
<th>name</th>
</tr>
</thead>
<tbody><tr>
<td>北京</td>
<td>张三</td>
</tr>
<tr>
<td>上海</td>
<td>李四</td>
</tr>
<tr>
<td></td>
<td>王五</td>
</tr>
</tbody></table>
<p><strong>RIGHT JOIN示例:</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">name</span>, city <span class="keyword">from</span> person <span class="keyword">right</span> <span class="keyword">join</span> city <span class="keyword">on</span> name.c_id = city.id;</span><br></pre></td></tr></table></figure>

<p>返回结果:</p>
<table>
<thead>
<tr>
<th>city</th>
<th>name</th>
</tr>
</thead>
<tbody><tr>
<td>北京</td>
<td>张三</td>
</tr>
<tr>
<td>上海</td>
<td>李四</td>
</tr>
<tr>
<td>广州</td>
<td></td>
</tr>
</tbody></table>
<p><strong>FULL JOIN示例:</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">name</span>, city <span class="keyword">from</span> person <span class="keyword">full</span> <span class="keyword">join</span> city <span class="keyword">on</span> name.c_id = city.id;</span><br></pre></td></tr></table></figure>

<p>返回结果:</p>
<table>
<thead>
<tr>
<th>city</th>
<th>name</th>
</tr>
</thead>
<tbody><tr>
<td>北京</td>
<td>张三</td>
</tr>
<tr>
<td>上海</td>
<td>李四</td>
</tr>
<tr>
<td>广州</td>
<td></td>
</tr>
<tr>
<td></td>
<td>王五</td>
</tr>
</tbody></table>
<p><strong>本文为作者原创 转载时请注明出处 谢谢</strong></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt="img"></p>
<p><em><a href="https://code.newban.cn/">乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</a></em></p>
]]></content>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>Web中关于转发和重定向的区别</title>
    <url>/245.html</url>
    <content><![CDATA[<h3 id="转发"><a href="#转发" class="headerlink" title="转发"></a>转发</h3><p>服务端内部页面的跳转, 只作用于服务器内部, 和浏览器无关</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDAwMTEyNQ==,size_16,color_FFFFFF,t_70.png" alt="在这里插入图片描述"></p>
<p><strong>特点</strong>:</p>
<ul>
<li><p>地址栏不发生变化，显示的是上一个页面的地址</p>
</li>
<li><p>请求次数：只有1次请求</p>
</li>
<li><p>请求域中数据不会丢失</p>
</li>
</ul>
<p><strong>关键方法</strong>:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">request.getRequestDispatcher(&quot;/jump_ad&quot;).forward(request, response)</span><br></pre></td></tr></table></figure>

<p><strong>示例</strong>:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">@CrossOrigin</span><br><span class="line">@RestController</span><br><span class="line">class JumpControllor &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    lateinit var shortService: ShortKeyService</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @GetMapping(&quot;/test&quot;)</span><br><span class="line">    fun test(</span><br><span class="line">        response: HttpServletResponse,</span><br><span class="line">        request: HttpServletRequest</span><br><span class="line">    ) &#123;</span><br><span class="line">                request.getRequestDispatcher(&quot;/jump_ad&quot;).forward(request, response)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    @GetMapping(&quot;/jump_ad&quot;)</span><br><span class="line">    fun jumpAd(request: HttpServletRequest,response: HttpServletResponse) &#123;</span><br><span class="line">        response.writer.println(&quot;哈哈哈&quot;)</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="转发-1"><a href="#转发-1" class="headerlink" title="转发"></a>转发</h3><p>浏览器端的页面跳转, 同时作用于浏览器和服务端</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDAwMTEyNQ==,size_16,color_FFFFFF,t_70-20210816111205564.png" alt="在这里插入图片描述"></p>
<p><strong>特点</strong>:</p>
<ul>
<li>地址栏：显示新的地址</li>
<li>请求次数：2次</li>
<li>请求域中的数据会丢失，因为是2次请求</li>
</ul>
<p><strong>关键方法</strong>:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">response.sendRedirect(&quot;新地址&quot;)</span><br></pre></td></tr></table></figure>

<p><strong>示例</strong>:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@CrossOrigin</span><br><span class="line">@RestController</span><br><span class="line">class JumpControllor &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    lateinit var shortService: ShortKeyService</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @GetMapping(&quot;/test&quot;)</span><br><span class="line">    fun test(</span><br><span class="line">        response: HttpServletResponse,</span><br><span class="line">        request: HttpServletRequest</span><br><span class="line">    ) &#123;</span><br><span class="line">        response.sendRedirect(&quot;http://www.baidu.com&quot;)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>本文为作者原创 转载时请注明出处 谢谢</strong></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt="img"></p>
<p><em><a href="https://code.newban.cn/">乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</a></em></p>
]]></content>
      <tags>
        <tag>Web开发</tag>
      </tags>
  </entry>
  <entry>
    <title>原生JS中判断数组中是否包含某个元素的若干种方法</title>
    <url>/247.html</url>
    <content><![CDATA[<h3 id="第一种-使用indexOf方法"><a href="#第一种-使用indexOf方法" class="headerlink" title="第一种 使用indexOf方法"></a>第一种 使用<code>indexOf</code>方法</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">"A"</span>, <span class="string">"B"</span>, <span class="string">"C"</span>, <span class="string">"D"</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> index = arr.indexOf(<span class="string">"A"</span>);</span><br><span class="line"><span class="comment">//如果返回-1 则表示不存在</span></span><br></pre></td></tr></table></figure>

<h3 id="第二种-使用find方法"><a href="#第二种-使用find方法" class="headerlink" title="第二种 使用find方法"></a>第二种 使用<code>find</code>方法</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">"A"</span>, <span class="string">"B"</span>, <span class="string">"C"</span>, <span class="string">"D"</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> element = arr.find(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> value == <span class="string">"A"</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//如果没有找到返回undefined 否则返回符合条件的元素</span></span><br></pre></td></tr></table></figure>

<h3 id="第三种-使用findIndex方法"><a href="#第三种-使用findIndex方法" class="headerlink" title="第三种 使用findIndex方法"></a>第三种 使用<code>findIndex</code>方法</h3><p>和<code>find</code>方法类似, 只不过返回值不一样</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">"A"</span>, <span class="string">"B"</span>, <span class="string">"C"</span>, <span class="string">"D"</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> index = arr.find(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> value == <span class="string">"A"</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//如果没有找到返回-1 否则返回符合条件元素的角标</span></span><br></pre></td></tr></table></figure>

<h3 id="第四种-使用for循环"><a href="#第四种-使用for循环" class="headerlink" title="第四种 使用for循环"></a>第四种 使用<code>for</code>循环</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">"A"</span>, <span class="string">"B"</span>, <span class="string">"C"</span>, <span class="string">"D"</span>];</span><br><span class="line"></span><br><span class="line">arr.forEach(<span class="function"><span class="params">e</span>=&gt;</span>&#123;</span><br><span class="line">  	<span class="keyword">if</span>(e==<span class="string">"A"</span>)&#123;</span><br><span class="line">      <span class="comment">//找到元素</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="第五种-使用includes方法"><a href="#第五种-使用includes方法" class="headerlink" title="第五种 使用includes方法"></a>第五种 使用<code>includes</code>方法</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">"A"</span>, <span class="string">"B"</span>, <span class="string">"C"</span>, <span class="string">"D"</span>];</span><br><span class="line"></span><br><span class="line">arr.includes(<span class="string">"A"</span>);</span><br><span class="line"><span class="comment">//返回true表示存在 否则返回false</span></span><br></pre></td></tr></table></figure>

<h3 id="第六种-使用some方法"><a href="#第六种-使用some方法" class="headerlink" title="第六种 使用some方法"></a>第六种 使用<code>some</code>方法</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">"A"</span>, <span class="string">"B"</span>, <span class="string">"C"</span>, <span class="string">"D"</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> index = arr.some(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> value == <span class="string">"A"</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//返回true表示存在 否则返回false</span></span><br></pre></td></tr></table></figure>

<h3 id="第七中-使用filter方法"><a href="#第七中-使用filter方法" class="headerlink" title="第七中 使用filter方法"></a>第七中 使用<code>filter</code>方法</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">"A"</span>, <span class="string">"B"</span>, <span class="string">"C"</span>, <span class="string">"D"</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> newArr = arr.filter(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> value == <span class="string">"A"</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//返回一个新数组, 如果新数组有数据 表示存在</span></span><br></pre></td></tr></table></figure>

<h3 id="第八中-自定义扩展方法"><a href="#第八中-自定义扩展方法" class="headerlink" title="第八中 自定义扩展方法"></a>第八中 自定义扩展方法</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.has = <span class="function"><span class="keyword">function</span> (<span class="params"> target</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.includes(target);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>本文为作者原创 转载时请注明出处 谢谢</strong></p>
<p><a href="https://space.bilibili.com/485691562" target="_blank" rel="noopener">B站入口</a></p>
<p><a href="https://code.newban.cn/0.html">打赏通道</a></p>
<p>微信公众号二维码如下:</p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt="img"></p>
<p><em><a href="https://code.newban.cn/">乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</a></em></p>
]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>快速掌握正则表达式</title>
    <url>/249.html</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>正则是一把利器, 用好了编程事半功倍</p>
<p>但估计很多小伙伴初学正则时已经被其奇形怪状的字符给劝退了, 今天我们来将其解剖一下</p>
<h3 id="三个部分"><a href="#三个部分" class="headerlink" title="三个部分"></a>三个部分</h3><p>正则主要包含三个部分:</p>
<ul>
<li><strong>小括号() :</strong> 表示分组</li>
<li><strong>中括号[] :</strong> 表示需要匹配的单个字符 以及表示区间范围或者随机样本</li>
<li><strong>大括号{}:</strong> 表示重复出现的次数</li>
</ul>
<p><strong>比如:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a&#123;3&#125;b&#123;2&#125;</span><br><span class="line"></span><br><span class="line">或者</span><br><span class="line">[a]&#123;3&#125;[b]&#123;2&#125;</span><br></pre></td></tr></table></figure>

<p>表示字符<code>a</code>重复出现3次 字符<code>b</code>重复出现2次</p>
<p>可匹配以下字符串:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">aaabb</span><br></pre></td></tr></table></figure>

<p>如果我想将字符<code>a</code>和字符<code>b</code>分离, 可以使用小括号分组功能, 比如:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(a&#123;3&#125;)(b&#123;2&#125;)</span><br><span class="line"></span><br><span class="line">或者</span><br><span class="line">([a]&#123;3&#125;)([b]&#123;2&#125;)</span><br></pre></td></tr></table></figure>

<p>那么<code>$1</code>表示取出第一组内容<code>aaa</code>, <code>$2</code>取出第二组内容<code>bb</code></p>
<p>在匹配单个字符的时候, 中括号写与不写都一样, 中括号主要的作用在于区间匹配和样本匹配:</p>
<p><strong>区间匹配:</strong></p>
<p>使用字符<code>-</code>表示区间</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[a-z] //表示匹配小写a到z的26个英文字母 但凡出现26个字母中的任何一个 都匹配成功</span><br><span class="line"></span><br><span class="line">[a-zA-Z0-9] //表示匹配大小写26个字母加上0到9十个数字中的任何一个</span><br></pre></td></tr></table></figure>

<p><strong>样本匹配:</strong></p>
<p>提供一个有限个数的字符的样本, 然后在样本中随机匹配</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[abcd] //表示匹配abcd这四个英文字母中任意一个</span><br></pre></td></tr></table></figure>

<p><strong>举例:</strong></p>
<p>假如我写了一个正则表达式如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[ab][cd]</span><br></pre></td></tr></table></figure>

<p>那么它将匹配到四个:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ac</span><br><span class="line">ad</span><br><span class="line">bc</span><br><span class="line">bd</span><br></pre></td></tr></table></figure>

<p>是不是感觉像排列组合, 没错</p>
<p>在样本匹配模式下, <strong>中括号中的内容相当于取或</strong>, 在正则中取或有一个专门的符号, 用<code>|</code>表示</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[ab] 匹配a或b </span><br><span class="line">a|b  匹配a或b</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">那么:</span><br><span class="line">[ab][cd]  也可以写成 (a|b)(c|d)</span><br></pre></td></tr></table></figure>

<p>至此, 正则最核心的功能我们就学完了</p>
<h3 id="扩展部分"><a href="#扩展部分" class="headerlink" title="扩展部分"></a>扩展部分</h3><p><strong>关于出现次数:</strong></p>
<ul>
<li><p>字符<code>?</code>: 表示重复出现零次或一次</p>
</li>
<li><p>字符<code>*</code>: 表示出现零次或多次</p>
</li>
<li><p>字符<code>+</code>: 表示出现一次或多次</p>
</li>
</ul>
<p>示例:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a?b   //可以匹配b 和ab</span><br><span class="line">a*b   //可以匹配b 或者a....b </span><br><span class="line">a+b   //可以匹配ab 或者a....b</span><br></pre></td></tr></table></figure>

<p>如果放中括号中:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[a?]   //可以匹配a或者?</span><br><span class="line">[a*]   //可以匹配a或者*</span><br><span class="line">[a+]   //可以匹配a或者+</span><br></pre></td></tr></table></figure>

<p>也就是说一旦放到中括号中, 这三个字符将失去表示次数的含义, 成为一个普通的匹配字符</p>
<p><strong>关于匹配内容:</strong></p>
<ul>
<li>字符<code>.</code>: 表示匹配除了回车和换行外的任意字符</li>
<li>字符<code>^</code>: 表示限定开头内容</li>
<li>字符<code>$</code>: 表示限定结束内容</li>
</ul>
<p>我们挨个举例说明:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.&#123;3&#125;b  //表示任意字符出现三次然后再出现b</span><br></pre></td></tr></table></figure>

<p>可以匹配到以下内容:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">aaab</span><br><span class="line">xxxb</span><br><span class="line">yyyb</span><br><span class="line">kjfb</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>如果我加个<code>^</code>:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">^1.&#123;3&#125;b //表示需要匹配的内容必须以1开头</span><br></pre></td></tr></table></figure>

<p>假如我有两个字符串变量:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">String data1=&quot;1aaab&quot;; //匹配成功</span><br><span class="line">String data2=&quot;gg1aaab&quot;; //匹配失败</span><br></pre></td></tr></table></figure>

<p>如果我去掉这个<code>^</code>:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.&#123;3&#125;b</span><br></pre></td></tr></table></figure>

<p>那么:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">String data1=&quot;1aaab&quot;; //匹配成功</span><br><span class="line">String data2=&quot;gg1aaab&quot;; //匹配成功</span><br></pre></td></tr></table></figure>

<p>也就是说<code>^</code>这个限定符, 是针对整个字符串进行匹配, 需要整体满足条件, 而不加限定符, 则可以进行局部匹配</p>
<p><code>$</code>和<code>^</code>同理:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.&#123;3&#125;b$  //表示需要匹配的内容必须以b结尾</span><br></pre></td></tr></table></figure>

<p>如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">String data1=&quot;aaab&quot;; //匹配成功</span><br><span class="line">String data2=&quot;aaabg&quot;; //匹配失败</span><br></pre></td></tr></table></figure>

<p>注意: 如果字符<code>^</code>放到中括号中则表示取反</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[^a] //表示除了字符a外任意字符都行</span><br></pre></td></tr></table></figure>

<p>学到这, 基本上可以实现大部分的正则匹配了</p>
<h3 id="升级"><a href="#升级" class="headerlink" title="升级"></a>升级</h3><p>为了方便开发, 正则提供了常用字符的简易写法, 也可以称之为<strong>别名</strong></p>
<p>比如:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[0-9] 可以使用 \d 代替</span><br><span class="line"></span><br><span class="line">[a-zA-Z_0-9] 可以使用 \w 代替</span><br><span class="line"></span><br><span class="line">[\t\n\x0B\f\r] 可以使用 \s 代替</span><br></pre></td></tr></table></figure>

<p>如果要取反, 那么直接将小写变成大写:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">\D 表示 [^0-9]</span><br><span class="line"></span><br><span class="line">\W 表示 [^a-zA-Z_0-9] </span><br><span class="line"></span><br><span class="line">\S 表示 [^\t\n\x0B\f\r]</span><br></pre></td></tr></table></figure>

<p>现在 我们再来看几个常用的正则表达式:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//手机号正则匹配</span><br><span class="line">^1[34578][0-9]&#123;9&#125;$</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//年月日正则匹配</span><br><span class="line">^\d&#123;4&#125;-\d&#123;2&#125;-\d&#123;2&#125;$</span><br></pre></td></tr></table></figure>

<p>是不是感觉和蔼可亲多了呢</p>
<p><strong>本文为作者原创 转载时请注明出处 谢谢</strong></p>
<p><a href="https://space.bilibili.com/485691562" target="_blank" rel="noopener">B站入口</a></p>
<p><a href="https://code.newban.cn/0.html">打赏通道</a></p>
<p>微信公众号二维码如下:</p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt="img"></p>
<p><em><a href="https://code.newban.cn/">乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</a></em></p>
]]></content>
      <tags>
        <tag>正则</tag>
      </tags>
  </entry>
  <entry>
    <title>JS使用正则从文本中提取所有的url</title>
    <url>/248.html</url>
    <content><![CDATA[<h3 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h3><p>有一段文本如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">我是文本</span><br><span class="line">![](https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fn.sinaimg.cn%2Ftranslate%2F620%2Fw910h510%2F20180429%2FfvFl-fzrwiaz1256884.jpg&amp;refer=http%3A%2F%2Fn.sinaimg.cn&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=jpeg?sec=1631068659&amp;t=f21770640c21b19d6236c33ac13f77c3)</span><br><span class="line"></span><br><span class="line">[点击下载](http:it.newban.cn)</span><br><span class="line"></span><br><span class="line">![](https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20210106181201.png)</span><br></pre></td></tr></table></figure>

<p>需要将里面所有的非图片<code>url</code>提取出来并替换</p>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><ol>
<li><code>url</code>提取代码如下:</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">let</span> allReg = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">"[^!]\\[.*\\]\\((http.+)\\)"</span>, <span class="string">"g"</span>);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">let</span> result;</span><br><span class="line">  <span class="keyword">let</span> allArr = [];</span><br><span class="line">  <span class="keyword">while</span> ((result = urlReg.exec(data)) != <span class="literal">null</span>) &#123;</span><br><span class="line">    getShortUrl(result[<span class="number">1</span>], (value) =&gt; &#123;</span><br><span class="line">   </span><br><span class="line">      allArr.push(value)</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// allArr里面装着所有匹配到的url</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li><code>url</code>替换;</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//比如将所有的链接替换成A</span></span><br><span class="line">allArr.forEach(<span class="function"><span class="params">e</span>=&gt;</span>&#123;</span><br><span class="line">  data.replace(e,<span class="string">"A"</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="RegExp对象介绍"><a href="#RegExp对象介绍" class="headerlink" title="RegExp对象介绍"></a>RegExp对象介绍</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> reg=<span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">"[^!]\\[.*\\]\\((http.+)\\)"</span>,<span class="string">"g"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//或者简写成</span></span><br><span class="line"><span class="keyword">let</span> reg=<span class="regexp">/[^!]\\[.*\\]\\((http.+)\\)/g</span>;</span><br></pre></td></tr></table></figure>

<h4 id="参数"><a href="#参数" class="headerlink" title="参数:"></a>参数:</h4><p>第一个参数填入正则表达式, 第二个参数填入正则修饰符,其中<code>g</code>表示全局匹配</p>
<h5 id="正则表达式修饰符"><a href="#正则表达式修饰符" class="headerlink" title="正则表达式修饰符:"></a>正则表达式修饰符:</h5><table>
<thead>
<tr>
<th align="center">修饰符</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">i</td>
<td align="center">执行对大小写不敏感的匹配。</td>
</tr>
<tr>
<td align="center">g</td>
<td align="center">执行全局匹配（查找所有匹配而非在找到第一个匹配后停止）。</td>
</tr>
<tr>
<td align="center">m</td>
<td align="center">执行多行匹配。</td>
</tr>
</tbody></table>
<h4 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法:"></a>常用方法:</h4><p><strong>使用<code>String</code>对象的<code>match</code>方法匹配多个</strong>:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr=data.match(reg);</span><br><span class="line"><span class="comment">//返回一个装有匹配到内容的数组</span></span><br></pre></td></tr></table></figure>

<p><strong><code>exec</code>方法 用于匹配单个:</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> reg=<span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">"[^!]\\[.*\\]\\((http.+)\\)"</span>)</span><br><span class="line"><span class="keyword">let</span> element=reg.exec(<span class="string">"http:xxxxx"</span>)</span><br><span class="line"><span class="comment">//返回第一个匹配到的内容</span></span><br></pre></td></tr></table></figure>

<p>在不加第二个参数<code>g</code>的前提下, 重复执行exec方法, 始终返回第一个</p>
<p>如果加了<code>g</code> ,重复执行相当于遍历, 如下:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> reg=<span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">"[^!]\\[.*\\]\\((http.+)\\)"</span>,<span class="string">"g"</span>)</span><br><span class="line"><span class="keyword">let</span> element=reg.exec(<span class="string">"http:xxxxx"</span>)</span><br><span class="line"><span class="comment">//返回第一个</span></span><br><span class="line"><span class="keyword">let</span> element2=reg.exec(<span class="string">"http:xxxxx"</span>)</span><br><span class="line"><span class="comment">//返回第二个</span></span><br></pre></td></tr></table></figure>

<p><strong><code>test</code>方法, 检查是否有符合匹配的存在:</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> reg=<span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">"[^!]\\[.*\\]\\((http.+)\\)"</span>,<span class="string">"g"</span>)</span><br><span class="line"><span class="keyword">let</span> isHas=reg.test(<span class="string">"http:xxx"</span>)<span class="comment">//如果匹配上了返回ture 否则false</span></span><br></pre></td></tr></table></figure>

<p><strong><code>String</code>对象的search方法也可以检查是否有符合匹配的存在</strong>:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> index=data.search(reg);</span><br><span class="line"><span class="comment">//index为-1表示没有匹配上 否则 匹配成功</span></span><br></pre></td></tr></table></figure>

<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><ol>
<li><p>从<code>url</code>中提取子域名</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> url = <span class="string">"http://xxx.domain.com"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="regexp">/[^.]+/</span>.exec(url)[<span class="number">0</span>].substr(<span class="number">7</span>)); <span class="comment">// logs "xxx"</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>从一个单词中分离出<code>Unicode</code> 字符</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> text = <span class="string">"Образец text на русском языке"</span>;</span><br><span class="line"><span class="keyword">let</span> regex = <span class="regexp">/[\u0400-\u04FF]+/g</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> match = regex.exec(text);</span><br><span class="line"><span class="built_in">console</span>.log(match[<span class="number">1</span>]);  <span class="comment">// prints "Образец"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> match2 = regex.exec(text);</span><br><span class="line"><span class="built_in">console</span>.log(match2[<span class="number">1</span>]);  <span class="comment">// prints "на" [did not print "text"]</span></span><br></pre></td></tr></table></figure>



</li>
</ol>
<p>使用前建议使用正则<a href="https://c.runoob.com/front-end/854" target="_blank" rel="noopener">表达式测试工具</a>验证正则表达式是否可行</p>
<p><strong>本文为作者原创 转载时请注明出处 谢谢</strong></p>
<p><a href="https://space.bilibili.com/485691562" target="_blank" rel="noopener">B站入口</a></p>
<p><a href="https://code.newban.cn/0.html">打赏通道</a></p>
<p>微信公众号二维码如下:</p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt="img"></p>
<p><em><a href="https://code.newban.cn/">乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</a></em></p>
]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>Django创建数据库常用字段及参数</title>
    <url>/25.html</url>
    <content><![CDATA[<h2 id="常用字段"><a href="#常用字段" class="headerlink" title="常用字段"></a>常用字段</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1、models.AutoField　　自增列= int(11)</span><br><span class="line">　　如果没有的话，默认会生成一个名称为 id 的列，如果要显示的自定义一个自增列，必须将给列设置为主键 primary_key=True。</span><br><span class="line">　　</span><br><span class="line">　　</span><br><span class="line">2、models.CharField　　字符串字段</span><br><span class="line">　　必须 max_length 参数</span><br><span class="line">　　</span><br><span class="line">3、models.BooleanField　　布尔类型=tinyint(1)</span><br><span class="line">　　不能为空，Blank=True</span><br><span class="line">　　</span><br><span class="line">4、models.ComaSeparatedIntegerField　　用逗号分割的数字=varchar</span><br><span class="line">　　继承CharField，所以必须 max_lenght 参数</span><br><span class="line">　　</span><br><span class="line">5、models.DateField　　日期类型 date</span><br><span class="line">　　对于参数，auto_now =True则每次更新都会更新这个时间；auto_now_add 则只是第一次创建添加，之后的更新不再改变。</span><br><span class="line">　　</span><br><span class="line">6、models.DateTimeField　　日期类型 datetime</span><br><span class="line">　　同DateField的参数</span><br><span class="line">　　</span><br><span class="line">7、models.Decimal　　十进制小数类型= decimal</span><br><span class="line">　　必须指定整数位max_digits和小数位decimal_places</span><br><span class="line">　　</span><br><span class="line">8、models.EmailField　　字符串类型（正则表达式邮箱）=varchar</span><br><span class="line">　　对字符串进行正则表达式</span><br><span class="line">　　</span><br><span class="line">9、models.FloatField　　浮点类型= double</span><br><span class="line"></span><br><span class="line">10、models.IntegerField　　整形</span><br><span class="line"></span><br><span class="line">11、models.BigIntegerField　　长整形</span><br><span class="line">　　integer_field_ranges =&#123;</span><br><span class="line">　　　　&apos;SmallIntegerField&apos;:(-32768,32767),</span><br><span class="line">　　　　&apos;IntegerField&apos;:(-2147483648,2147483647),</span><br><span class="line">　　　　&apos;BigIntegerField&apos;:(-9223372036854775808,9223372036854775807),</span><br><span class="line">　　　　&apos;PositiveSmallIntegerField&apos;:(0,32767),</span><br><span class="line">　　　　&apos;PositiveIntegerField&apos;:(0,2147483647),</span><br><span class="line">　　&#125;</span><br><span class="line">　　</span><br><span class="line">12、models.IPAddressField　　字符串类型（ip4正则表达式）</span><br><span class="line"></span><br><span class="line">13、models.GenericIPAddressField　　字符串类型（ip4和ip6是可选的）</span><br><span class="line">　　参数protocol可以是：both、ipv4、ipv6</span><br><span class="line">　　验证时，会根据设置报错</span><br><span class="line">　　</span><br><span class="line">14、models.NullBooleanField　　允许为空的布尔类型</span><br><span class="line"></span><br><span class="line">15、models.PositiveIntegerFiel　　正Integer</span><br><span class="line"></span><br><span class="line">16、models.PositiveSmallIntegerField　　正smallInteger</span><br><span class="line"></span><br><span class="line">17、models.SlugField　　减号、下划线、字母、数字</span><br><span class="line"></span><br><span class="line">18、models.SmallIntegerField　　数字</span><br><span class="line">　　数据库中的字段有：tinyint、smallint、int、bigint</span><br><span class="line">　　</span><br><span class="line">19、models.TextField　　字符串=longtext</span><br><span class="line"></span><br><span class="line">20、models.TimeField　　时间 HH:MM[:ss[.uuuuuu]]</span><br><span class="line"></span><br><span class="line">21、models.URLField　　字符串，地址正则表达式</span><br><span class="line"></span><br><span class="line">22、models.BinaryField　　二进制</span><br><span class="line"></span><br><span class="line">23、models.ImageField  图片</span><br><span class="line"></span><br><span class="line">24、models.FilePathField  文件</span><br></pre></td></tr></table></figure>

<h2 id="常用参数"><a href="#常用参数" class="headerlink" title="常用参数"></a>常用参数</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1、null=True</span><br><span class="line">　　数据库中字段是否可以为空</span><br><span class="line">　　</span><br><span class="line">2、blank=True</span><br><span class="line">　　django的Admin中添加数据时是否可允许空值</span><br><span class="line">　　</span><br><span class="line">3、primary_key =False</span><br><span class="line">　　主键，对AutoField设置主键后，就会代替原来的自增 id 列</span><br><span class="line">　　</span><br><span class="line">4、auto_now 和 auto_now_add</span><br><span class="line">　　auto_now 自动创建---无论添加或修改，都是当前操作的时间</span><br><span class="line">　　auto_now_add 自动创建---永远是创建时的时间</span><br><span class="line">　　</span><br><span class="line">5、choices</span><br><span class="line">GENDER_CHOICE =(</span><br><span class="line">(u&apos;M&apos;, u&apos;Male&apos;),</span><br><span class="line">(u&apos;F&apos;, u&apos;Female&apos;),</span><br><span class="line">) </span><br><span class="line">gender = models.CharField(max_length=2,choices = GENDER_CHOICE)  #字段模板展示</span><br><span class="line"></span><br><span class="line">6、max_length  最大长度</span><br><span class="line"></span><br><span class="line">7、default　　默认值</span><br><span class="line"></span><br><span class="line">8、verbose_name　　Admin中字段的显示名称</span><br><span class="line"></span><br><span class="line">9、name|db_column　　数据库中的字段名称</span><br><span class="line"></span><br><span class="line">10、unique=True　　不允许重复</span><br><span class="line"></span><br><span class="line">11、db_index =True　　数据库索引</span><br><span class="line"></span><br><span class="line">12、editable=True　　在Admin里是否可编辑</span><br><span class="line"></span><br><span class="line">13、error_messages=None　　错误提示</span><br><span class="line"></span><br><span class="line">14、auto_created=False　　自动创建</span><br><span class="line"></span><br><span class="line">15、help_text　　在Admin中提示帮助信息</span><br><span class="line"></span><br><span class="line">16、validators=[]  验证器</span><br><span class="line"></span><br><span class="line">17、upload-to    重定义上传文件的路径前缀</span><br></pre></td></tr></table></figure>

<p><strong>本文为作者原创 转载时请注明出处 谢谢</strong></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em>乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</em></p>
]]></content>
      <tags>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title>跨服务器数据迁移</title>
    <url>/251.html</url>
    <content><![CDATA[<h3 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h3><p>最近有台云服务器到期, 续费太贵, 打算换一台便宜的, 之前服务器上使用<code>docker</code>部署了几个网站, 涉及到数据和程序迁移的问题, 在此做个记录</p>
<h3 id="持久化数据迁移"><a href="#持久化数据迁移" class="headerlink" title="持久化数据迁移"></a>持久化数据迁移</h3><p>首先使用<code>scp</code>指令进行数据卷的迁移, 也就是跨服务器数据拷贝</p>
<p>假设两台机器IP分别为：</p>
<ul>
<li><p>服务器A: 114.238.161.75，</p>
</li>
<li><p>服务器B: 143.224.34.73。</p>
</li>
</ul>
<p>比如我在A服务器上操作，需要将B服务器上<code>/home/lk/</code>目录下所有的文件全部复制到本地的<code>/root</code>目录下，命令为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">scp -r  root@143.224.34.73:/home/lk /root</span><br></pre></td></tr></table></figure>

<p>具体过程为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@XX ~]# scp -r root@43.224.34.73:/home/lk /root</span><br><span class="line">root@43.224.34.73&apos;s password: </span><br><span class="line">k2.sql                                                     100%    0     0.0KB/s   00:00    </span><br><span class="line">k.zip                                                      100%  176     0.2KB/s   00:00    </span><br><span class="line">.bash_history                                              100%   32     0.0KB/s   00:00    </span><br><span class="line">.bash_logout                                               100%   18     0.0KB/s   00:00    </span><br><span class="line">.bashrc                                                    100%  231     0.2KB/s   00:00    </span><br><span class="line">k3.sql                                                     100%    0     0.0KB/s   00:00    </span><br><span class="line">.bash_profile                                              100%  193     0.2KB/s   00:00    </span><br><span class="line">[root@XX ~]# ls</span><br></pre></td></tr></table></figure>

<p>或者在A服务器上将<code>/root/lk</code>目录下所有的文件传输到B的<code>/home/lk/cpfile</code>目录下，命令为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">scp -r /root/lk root@143.224.34.73:/home/lk/cpfile</span><br></pre></td></tr></table></figure>

<p>具体过称为:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@XX lk]# scp -r /root/lk root@43.224.34.73:/home/lk/cpfile</span><br><span class="line">root@43.224.34.73&apos;s password: </span><br><span class="line">k2.sql                                                     100%    0     0.0KB/s   00:00    </span><br><span class="line">k3.sql                                                     100%    0     0.0KB/s   00:00    </span><br><span class="line">.bash_profile                                              100%  193     0.2KB/s   00:00    </span><br><span class="line">.bash_logout                                               100%   18     0.0KB/s   00:00    </span><br><span class="line">.bash_history                                              100%   32     0.0KB/s   00:00    </span><br><span class="line">k.zip                                                      100%  176     0.2KB/s   00:00    </span><br><span class="line">.bashrc                                                    100%  231     0.2KB/s   00:00    </span><br><span class="line">[root@XX lk]#</span><br></pre></td></tr></table></figure>

<p>此外 加上<code>-p</code>参数还可以保留原文件的修改时间，访问权限:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">scp -r  -p root@143.224.34.73:/home/lk /root</span><br></pre></td></tr></table></figure>

<h5 id="scp后台运行"><a href="#scp后台运行" class="headerlink" title="scp后台运行"></a>scp后台运行</h5><ol>
<li><p>方式一 使用<code>nohup</code>, 同时尾部加<code>&amp;</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nohup scp -r  -p root@143.224.34.73:/home/lk /root &amp;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>nohup</strong>: 表示忽略<code>hup</code>信号, 终端关闭任务进程也不销毁</p>
</li>
<li><p><strong>&amp;</strong>: 表示后台运行</p>
</li>
</ul>
</li>
<li><p>方式二 使用<code>bg</code>+<code>disown</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.输入ctrl + z 暂停任务</span><br><span class="line">2.输入jobs查看任务号</span><br><span class="line">3.使用 bg %任务号 将该任务号放入后台</span><br><span class="line">4.使用 disown -h %任务号 使后台任务忽略hup信号</span><br></pre></td></tr></table></figure>

<p>如下:</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20210913143619200.png" alt="image-20210913143619200"></p>
<p><strong>注</strong>: 执行<code>disown</code>后, 任务被移出<code>jobs</code>, 使用<code>jobs</code>指令已经无法查看该任务, 可以使用<code>ps</code>进程查看指令判断任务是否已经结束:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ps -aux</span><br></pre></td></tr></table></figure>




</li>
</ol>
<h3 id="Docker容器迁移"><a href="#Docker容器迁移" class="headerlink" title="Docker容器迁移"></a>Docker容器迁移</h3><ol>
<li><p>首先 需要将容器保存为镜像</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker commit 容器名称 镜像名称</span><br></pre></td></tr></table></figure>
</li>
<li><p>然后 将保存的镜像进行压缩</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker save -o xxx.tar 镜像名称</span><br><span class="line"></span><br><span class="line">//如果多个镜像同时打包</span><br><span class="line">docker save [images] [images] &gt; [name.tar]</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用<code>scp</code>指令将压缩包传至新服务器</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">scp -r xxx.tar root@143.224.34.73:/home/lk/cpfile</span><br></pre></td></tr></table></figure>
</li>
<li><p>在新服务器中进行镜像恢复(新服务器需要先安装Docker)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker load &lt; xxx.tar</span><br><span class="line">或</span><br><span class="line">docker load -i xxx.tar</span><br></pre></td></tr></table></figure>
</li>
<li><p>最后创建并运行容器</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run --name 容器名 -p 12309:80 -d 镜像名</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="数据库迁移"><a href="#数据库迁移" class="headerlink" title="数据库迁移"></a>数据库迁移</h3><p>详情查看《<a href="https://code.newban.cn/131.html">mysql使用命令导入和导出sql文件</a>》</p>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p><code>docker</code>容器在创建时配置的挂载目录, 如果宿主中挂载的目录不存在则自动创建并写入默认数据, 如果目录已经存在则使用已存在的目录和数据</p>
<p>也就是说我们在进行容器迁移重新运行时, 不用担心原先目录下的数据会被覆盖重写 </p>
<p>但是有一点需要注意的是, 原先目录中的配置文件如果包含原服务器中的<code>ip</code>配置, 需要手动修改</p>
<p>比如我们迁移一个<code>wordpress</code>, 在新服务器中使用以下参数进行启动:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run -id \</span><br><span class="line">--name=wordpress_sex \</span><br><span class="line">-p 7778:80 \</span><br><span class="line">-h wordpress_sex \</span><br><span class="line">-v /root/wordpress/sex_www:/var/www/html \</span><br><span class="line">-e WORDPRESS_DB_HOST=119.33.15.174:3306 \</span><br><span class="line">-e WORDPRESS_DB_USESR=root \</span><br><span class="line">-e WORDPRESS_DB_PASSWORD=123456 \</span><br><span class="line">-e WORDPRESS_DB_NAME=wordpress_sex \</span><br><span class="line">-d wordpress:latest</span><br></pre></td></tr></table></figure>

<p>由于源文件目录和文件未被覆盖重写, 那么上面数据库相关的配置参数不起作用, 我们需要手动进如源文件目录, 对<code>wp-config.php</code>中数据库配置进行修改, 否则无法访问</p>
<h5 id="数据库内网访问保证访问速度"><a href="#数据库内网访问保证访问速度" class="headerlink" title="数据库内网访问保证访问速度"></a>数据库内网访问保证访问速度</h5><p>一般来说 我们最好避免直接使用公网<code>ip</code>访问数据库, 而是使用<code>Docker</code>内部桥接网络的方式以容器名替代<code>ip</code>的方式进行访问, 这样既能减少迁移的风险, 又能加快数据的读取 </p>
<p>网站的访问流畅度和数据库的访问速度有非常大的关系, 经测试, 使用桥接网络访问数据库的速度远快于使用公网映射访问  </p>
<p>大部分人刚开始会将网站的访问速度归结于服务器硬件配置、带宽、程序语言甚至是数据库的数据量太大和<code>sql</code>查询语句不合理上, 殊不知 数据库的访问速度也是重中之重</p>
<p><strong>本文为作者原创 转载时请注明出处 谢谢</strong></p>
<p><a href="https://space.bilibili.com/485691562" target="_blank" rel="noopener">B站入口</a></p>
<p><a href="https://code.newban.cn/0.html">打赏通道</a></p>
<p>微信公众号二维码如下:</p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt="img"></p>
<p><em><a href="https://code.newban.cn/">乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</a></em></p>
]]></content>
      <tags>
        <tag>运维</tag>
      </tags>
  </entry>
  <entry>
    <title>在Mac平台上使用Multipass安装Ubuntu虚拟机</title>
    <url>/252.html</url>
    <content><![CDATA[<h3 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h3><p>最近需要在<code>Ubuntu</code>系统上安装应用进行测试, 无奈手头上只有一台<code>mac</code>电脑, 怎么办呢</p>
<p>如果使用第三方诸如<code>Vmware</code>虚拟机软件是在太费劲了</p>
<p>好在<code>Ubuntu</code>官方给咱建议了一款虚拟机软件<code>Multipass</code>, 相比<code>Vmware</code>更加轻量, 只需一行命令快速创建Ubuntu容器</p>
<p>注意了 <code>Multipass</code>目前只支持创建<code>Ubuntu</code>容器, 但是除了<code>Mac</code>平台外, <code>Multipass</code>还可以在<code>Windows</code>和<code>Linux</code>平台上使用</p>
<p>本文直介绍<code>Mac</code>平台的用法, 其他的可以参考<a href="https://multipass.run/" target="_blank" rel="noopener">官网</a></p>
<h2 id="开始使用"><a href="#开始使用" class="headerlink" title="开始使用"></a>开始使用</h2><h3 id="1-Multipass安装"><a href="#1-Multipass安装" class="headerlink" title="1.Multipass安装"></a>1.<code>Multipass</code>安装</h3><p>首先需要安装<code>Multipass</code>工具</p>
<p><a href="https://url97.ctfile.com/f/21042697-510890551-fbedfb" target="_blank" rel="noopener">下载地址</a>（访问密码：312306）</p>
<p>如果电脑装了<code>brew</code>可以直接命令行下载安装:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">brew cask install multipass</span><br></pre></td></tr></table></figure>

<p>下载安装成功后, 执行以下命令可以查看当前软件版本:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">multipass --version</span><br></pre></td></tr></table></figure>

<h3 id="2-创建Ubuntu容器"><a href="#2-创建Ubuntu容器" class="headerlink" title="2.创建Ubuntu容器"></a>2.创建Ubuntu容器</h3><p>可以通过以下指令查看可供下载的Ubuntu镜像:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">multipass find</span><br></pre></td></tr></table></figure>

<p>下载最新版的<code>Ubuntu</code>镜像并运行:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">multipass launch --name ubuntu</span><br></pre></td></tr></table></figure>

<p>命令执行后将自动下载并后台运行</p>
<p>如果你想自定义配置创建可以参考如下方式:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">multipass launch -n vm01 -c 4 -m 4G -d 40G</span><br></pre></td></tr></table></figure>

<ul>
<li>-n, –name: 名称</li>
<li>-c, –cpus: cpu核心数, 默认: 1</li>
<li>-m, –mem: 内存大小, 默认: 1G</li>
<li>-d, –disk: 硬盘大小, 默认: 5G</li>
</ul>
<h3 id="3-操作容器"><a href="#3-操作容器" class="headerlink" title="3.操作容器"></a>3.操作容器</h3><ol>
<li><p><strong>进入容器</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 如果对应实例没有运行的话，会主动运行对应实例</span><br><span class="line">multipass shell 容器名称</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20210831150818963.png" alt="image-20210831150818963"></p>
<p>此时便进入到了<code>Ubuntu</code>环境中, 在此可以执行相关的<code>linux</code>指令</p>
<p>如果你不想进入容器直接执行<code>linux</code>指令, 可以使用<code>multipass exec</code>指令, 比如我想在容器中创建一个名为ABC文件夹:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">multipass exec 容器名 mkdir ABC</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>查看容器信息</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">multipass info 容器名</span><br></pre></td></tr></table></figure>

<p>显示结果:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">State:          Running</span><br><span class="line">IPv4:           192.168.64.2</span><br><span class="line">Release:        Ubuntu 20.04.3 LTS</span><br><span class="line">Image hash:     97bb9f79af52 (Ubuntu 20.04 LTS)</span><br><span class="line">Load:           0.00 0.00 0.00</span><br><span class="line">Disk usage:     1.3G out of 4.7G</span><br><span class="line">Memory usage:   136.0M out of 981.3M</span><br><span class="line">Mounts:         --</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>主机和容器数据交互</strong></p>
<p>第一种 使用挂载数据卷的方式:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">multipass mount $HOME 容器名</span><br><span class="line"></span><br><span class="line"># 或者指定容器目录</span><br><span class="line">multipass mount $HOME 容器名:目录名</span><br></pre></td></tr></table></figure>

<p>如果要卸载数据卷:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">multipass umount 容器名</span><br></pre></td></tr></table></figure>

<p>第二种 <code>transfer</code> 进行文件复制传输</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">multipass transfer 主机文件 容器名:容器目录</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>容器配置自动化</strong></p>
<p>为了保持开发环境和线上环境一致性 同时节省部署时间 <code>multipass</code>给我们提供了<code>--cloud-init</code>选项进行容器启动初始化配置:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">multipass launch --name ubuntu --cloud-init config.yaml</span><br></pre></td></tr></table></figure>

<p>上面 <code>config.yaml</code> 则是容器的初始化配置文件，内容如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#cloud-config</span><br><span class="line"></span><br><span class="line">runcmd:</span><br><span class="line">  - curl -sL https://deb.nodesource.com/setup_12.x | sudo -E bash -</span><br><span class="line">  - sudo apt-get install -y nodejs</span><br></pre></td></tr></table></figure>

<p><code>runcmd</code> 可以指定容器 <strong>首次启动</strong> 时运行的命令，上面表示首次启动自动下载安装 Node.js </p>
</li>
</ol>
<h3 id="容器管理"><a href="#容器管理" class="headerlink" title="容器管理"></a>容器管理</h3><ol>
<li><p>查看所有创建的容器</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">multipass list</span><br></pre></td></tr></table></figure>
</li>
<li><p>启动和停止运行容器</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 停止ubuntu和ubuntu1</span><br><span class="line">multipass stop ubuntu ubuntu1</span><br><span class="line"># 启动ubuntu</span><br><span class="line">multipass start ubuntu</span><br></pre></td></tr></table></figure>
</li>
<li><p>对 所有容器统一操作</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 启动所有容器</span><br><span class="line">multipass start --all</span><br><span class="line"># 停止所有容器</span><br><span class="line">multipass stop --all</span><br><span class="line"># 所有容器放入回收站</span><br><span class="line">multipass delete --all</span><br><span class="line"># 彻底删除所有容器</span><br><span class="line">multipass delete --purge --all</span><br></pre></td></tr></table></figure>



</li>
</ol>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>整体操作来看, 感觉和<code>docker</code>很像, 如果你只需要一个<code>ubuntu</code>系统, 那么选择<code>Multipass</code>还是很方便的, 节省大量的时间</p>
<p><code>multipass</code>和<code>docker</code>区别:</p>
<p><code>docker</code>比<code>multipass</code>更加轻量一些, <code>multipass</code>更倾向于独立虚拟机, 分配独立的<code>cpu</code>和内存, 而<code>docker</code>容器是共享宿主<code>cpu</code>和内存</p>
<p>如果你要跑比较消耗资源的程序, 建议使用<code>docker</code>, 可以充分使用宿主的性能, <code>multipass</code>需要预算分配程序需要的硬件资源, 分多了不仅浪费而且还影响宿主性能, 分少了也没法动态调整只能新开示例</p>
<p><strong>本文为作者原创 转载时请注明出处 谢谢</strong></p>
<p><a href="https://space.bilibili.com/485691562" target="_blank" rel="noopener">B站入口</a></p>
<p><a href="https://code.newban.cn/0.html">打赏通道</a></p>
<p>微信公众号二维码如下:</p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt="img"></p>
<p><em><a href="https://code.newban.cn/">乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</a></em></p>
]]></content>
      <tags>
        <tag>虚拟机</tag>
      </tags>
  </entry>
  <entry>
    <title>给Multipass容器安装桌面环境</title>
    <url>/253.html</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p><code>linux</code>环境下的桌面程序多达十几种, 比较流行的有<code>Unity</code>、<code>Gnome3</code>、<code>kde</code>、<code>mate</code>、<code>xfce</code>、<code>lxde</code></p>
<p>我们来看看它们分别都长什么样:</p>
<p><strong>Unity:</strong></p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/841693-20180305010017582-310753998.png" alt="img"></p>
<p><strong>Gnome2:</strong></p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/841693-20180305005834169-1731748738.png" alt="img"></p>
<p><strong>Gnome3:</strong></p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/841693-20180305005812083-619129357.png" alt="img"></p>
<p><strong>KDE:</strong></p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/841693-20180305010144808-1350683214.png" alt="img"></p>
<p><strong>mate:</strong></p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/111835zdvcddj8pmd7wp87.jpg" alt="ubuntu_mate_1510"></p>
<p><strong>xfce:</strong></p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/841693-20180305010336904-1794804327.png" alt="img"></p>
<p><strong>lxde:</strong></p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/841693-20180305010502862-1164967659.png" alt="img"></p>
<p>不过上面这前四个体量都不小, 对于寄生于主机的小容器系统而言, 我希望找一个轻量简洁满足正常功能的桌面即可</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/841693-20180305010638218-1272553780.png" alt="img"></p>
<p>于是在<code>lxde</code>和<code>xfec</code>之中进行选择 最后我选择了<code>xfec</code></p>
<h3 id="xfec安装步骤"><a href="#xfec安装步骤" class="headerlink" title="xfec安装步骤"></a><code>xfec</code>安装步骤</h3><ol>
<li><p>更新源</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get update</span><br></pre></td></tr></table></figure>
</li>
<li><p>安装<code>Xfce</code>桌面程序</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get install xfce4</span><br></pre></td></tr></table></figure>


</li>
</ol>
<p>   安装过程中会让你选择显示管理器, 选择<code>gdm3</code>即可</p>
<p>   <img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20210831172358907.png" alt="image-20210831172358907"></p>
<ol start="3">
<li><p>安装<code>VNCServer</code> 用于远程桌面连接</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get install tightvncserver</span><br></pre></td></tr></table></figure>
</li>
<li><p>启动vnc服务</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vncserver</span><br></pre></td></tr></table></figure>

<p>提示我们输入访问密码:</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20210901175901616.png" alt="image-20210901175901616"></p>
<p>这里的密码用于接下来的远程登录用</p>
</li>
</ol>
<h3 id="开始远程访问"><a href="#开始远程访问" class="headerlink" title="开始远程访问"></a>开始远程访问</h3><h5 id="第一种-vnc客户端访问模式"><a href="#第一种-vnc客户端访问模式" class="headerlink" title="第一种 vnc客户端访问模式"></a>第一种 <code>vnc</code>客户端访问模式</h5><p><code>Mac</code>平台可直接执行以下指令安装:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">brew install Caskroom/cask/vnc-viewer</span><br></pre></td></tr></table></figure>

<p>或者下载安装包:</p>
<p><a href="https://url97.ctfile.com/f/21042697-511264719-a281de" target="_blank" rel="noopener">点击下载</a>（访问密码：312306）</p>
<p>安装<code>vnc</code>客户端后在地址栏输入目标<code>ip</code>和端口, 端口默认为<code>5901</code></p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20210901180352068.png" alt="image-20210901180352068"></p>
<p>输入密码登录后发现只有灰屏幕:</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20210901180441212.png" alt="image-20210901180441212"></p>
<p>接下来我们需要配置一下<code>vncserver</code>的环境:</p>
<ol>
<li><p>首先关闭<code>vncserver</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vncserver -kill :1</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改前对配置文件进行备份</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cp ~/.vnc/xstartup ~/.vnc/xstartup.bak</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改配置文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vim ~/.vnc/xstartup</span><br></pre></td></tr></table></figure>

<p>内容替换为如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">xrdb $HOME/.Xresources</span><br><span class="line">startxfce4 &amp;</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改配置文件权限</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">chmod +x ~/.vnc/xstartup</span><br></pre></td></tr></table></figure>
</li>
<li><p>重新启动<code>vnc</code>服务</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vncserver</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>最后重新连接远程桌面, 如下:</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20210901181507448.png" alt="image-20210901181507448"></p>
<h5 id="第二种-浏览器访问模式"><a href="#第二种-浏览器访问模式" class="headerlink" title="第二种 浏览器访问模式"></a>第二种 浏览器访问模式</h5><p>具体参考:</p>
<p>《<a href="https://code.newban.cn/260.html">如何使用Web浏览器访问Ubuntu环境下的vnc桌面</a>》</p>
<h3 id="指令补充"><a href="#指令补充" class="headerlink" title="指令补充"></a>指令补充</h3><ol>
<li><p>如果你需要设置<code>vncserver</code>开机自启动:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systemctl start vncserver@:1.service &amp;&amp; systemctl enable vncserver@:1.service</span><br></pre></td></tr></table></figure>
</li>
<li><p>你想查看<code>vnserver</code>服务是否开启:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systemctl status vncserver@:.service</span><br><span class="line"></span><br><span class="line">或者</span><br><span class="line">systemctl is-enabled vncserver@.service</span><br></pre></td></tr></table></figure>
</li>
<li><p>你想重启<code>vncserver</code>:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systemctl restart vncserver@:1.service</span><br></pre></td></tr></table></figure>
</li>
<li><p>你想设置<code>vnc</code>分辨率:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vncserver -geometry 1280x1024</span><br></pre></td></tr></table></figure>
</li>
<li><p>你想修改<code>vncserver</code>登录密码:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vncpasswd</span><br></pre></td></tr></table></figure>





</li>
</ol>
<p><strong>本文为作者原创 转载时请注明出处 谢谢</strong></p>
<p><a href="https://space.bilibili.com/485691562" target="_blank" rel="noopener">B站入口</a></p>
<p><a href="https://code.newban.cn/0.html">打赏通道</a></p>
<p>微信公众号二维码如下:</p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt="img"></p>
<p><em><a href="https://code.newban.cn/">乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</a></em></p>
]]></content>
      <tags>
        <tag>虚拟机</tag>
      </tags>
  </entry>
  <entry>
    <title>js数组的增删改查总结</title>
    <url>/250.html</url>
    <content><![CDATA[<p>但估计很多小伙伴初学正则时已经被其奇形怪状的字符给劝退了, 今天我们来将其解剖一下</p>
<h3 id="增"><a href="#增" class="headerlink" title="增"></a>增</h3><p><strong>第一种 基于<code>splice</code>封装的扩展函数:</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//首部插入单个元素</span></span><br><span class="line"><span class="built_in">Array</span>.prototype.addFirst = <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.splice(<span class="number">0</span>, <span class="number">0</span>, e);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//尾部插入单个元素</span></span><br><span class="line"><span class="built_in">Array</span>.prototype.addLast = <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.splice(<span class="keyword">this</span>.length, <span class="number">0</span>, e);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//指定角标位置插入单个元素</span></span><br><span class="line"><span class="built_in">Array</span>.prototype.addByIndex = <span class="function"><span class="keyword">function</span> (<span class="params">i,e</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.splice(i,<span class="number">0</span>,e);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>第二种 使用JS自带的函数 :</strong></p>
<p>分别有<code>push</code> <code>unshift</code> <code>concat</code>和<code>splice</code>四个函数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在尾部插入</span></span><br><span class="line"><span class="keyword">var</span> arr = [];</span><br><span class="line"><span class="keyword">var</span> len = arr.push(<span class="number">1</span>); <span class="comment">//插入一个元素</span></span><br><span class="line"><span class="keyword">var</span> len = arr.push(<span class="number">2</span>,<span class="number">3</span>);<span class="comment">//连续插入多个元素</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//在头部插入</span></span><br><span class="line"><span class="keyword">var</span> len = arr.unshift(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">var</span> len = arr.unshift(<span class="number">-2</span>,<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//在尾部插入</span></span><br><span class="line"><span class="keyword">var</span> newArr = arr.concat(<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>);<span class="comment">//返回一个新的数组对象</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//在头部插入多个元素</span></span><br><span class="line">arr.splice(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0.2</span>,<span class="number">0.4</span>,<span class="number">0.6</span>,<span class="number">0.8</span>);</span><br></pre></td></tr></table></figure>

<h3 id="删"><a href="#删" class="headerlink" title="删"></a>删</h3><p><strong>第一种 基于<code>splice</code>封装的扩展函数:</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.remove = <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.splice(<span class="keyword">this</span>.indexOf(e), <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>第二种 使用JS自带函数</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用 pop</span></span><br><span class="line"><span class="keyword">var</span> item = arr.pop(); <span class="comment">//删除最后一个元素并返回该项</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//使用 shift</span></span><br><span class="line"><span class="keyword">var</span> item = arr.shift(); <span class="comment">//删除第一个元素并返回该项</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//使用slice裁剪函数</span></span><br><span class="line"><span class="keyword">var</span> arr2 = arr.slice(<span class="number">2</span>,<span class="number">6</span>);<span class="comment">//取出角标2至6的元素 组成一个新元素</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//使用delete 该方法删除掉数组中的元素后，会把该下标出的值置为undefined,数组的长度不会变</span></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>,<span class="string">'d'</span>]; </span><br><span class="line"><span class="keyword">delete</span> arr[<span class="number">1</span>]; </span><br><span class="line"><span class="comment">//结果为:["a", undefined × 1, "c", "d"]</span></span><br></pre></td></tr></table></figure>

<h3 id="改"><a href="#改" class="headerlink" title="改"></a>改</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.replace = <span class="function"><span class="keyword">function</span> (<span class="params">origin, target</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.splice(<span class="keyword">this</span>.indexOf(origin), <span class="number">1</span>,target);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者使用循环</span></span><br><span class="line"><span class="built_in">Array</span>.prototype.replace = <span class="function"><span class="keyword">function</span> (<span class="params">origin, target</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.map(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (value == origin) &#123;</span><br><span class="line">      <span class="keyword">return</span> target;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      value;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="查"><a href="#查" class="headerlink" title="查"></a>查</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> index = arr.indexOf(<span class="string">"A"</span>);<span class="comment">//查找元素A在数组中的位置 返回-1表示不存在该元素</span></span><br></pre></td></tr></table></figure>

<p>关于查找部分, 更多方法详见:《<a href="https://code.newban.cn/247.html">原生JS中判断数组中是否包含某个元素的若干种方法</a>》</p>
<p><strong>本文为作者原创 转载时请注明出处 谢谢</strong></p>
<p><a href="https://space.bilibili.com/485691562" target="_blank" rel="noopener">B站入口</a></p>
<p><a href="https://code.newban.cn/0.html">打赏通道</a></p>
<p>微信公众号二维码如下:</p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt="img"></p>
<p><em><a href="https://code.newban.cn/">乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</a></em></p>
]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>docker中安装ubuntu桌面环境</title>
    <url>/255.html</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>使用<code>docker</code>, 总会碰到需要桌面环境的时候, 这里介绍<code>docker</code>中安装<code>ubuntu</code>桌面环境的方法, 非常方便, 只需要一个浏览器就能访问</p>
<h3 id="安装步骤"><a href="#安装步骤" class="headerlink" title="安装步骤"></a>安装步骤</h3><ol>
<li><p>拉取镜像</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker pull dorowu/ubuntu-desktop-lxde-vnc</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建并启动容器</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run -id \</span><br><span class="line">-p 6080:80 \</span><br><span class="line">-p 8900:5900 \</span><br><span class="line">-e VNC_PASSWORD=1234 \</span><br><span class="line">--name=c_desktop \</span><br><span class="line">-h c_desktop \</span><br><span class="line">-v $PWD/dev/shm:/dev/shm \</span><br><span class="line">dorowu/ubuntu-desktop-lxde-vnc</span><br></pre></td></tr></table></figure>

<p>参数说明:</p>
<ul>
<li><strong>-p 6080：80 将容器的80端口映射到主机的6080端口 用于浏览器访问</strong></li>
<li><strong>-p 8900：5900 将容器的5900端口映射到主机的8900端口 用于vnc客户端访问</strong></li>
<li><strong>-e VNC_PASSWORD=1234 设置远程登录密码</strong></li>
<li><strong>-v $PWD/dev/shm:/dev/shm将主机中当前目录挂载到容器</strong></li>
<li><strong>-h 设置容器的hostname</strong> </li>
<li><strong>–name=c_desktop 给容器取个名称</strong></li>
<li><strong>$PWD表示当前所在目录</strong></li>
</ul>
</li>
</ol>
<p>容器运行成功后, 接下来可以通过两种方式进入ubuntu桌面:</p>
<h3 id="第一种-浏览器访问"><a href="#第一种-浏览器访问" class="headerlink" title="第一种 浏览器访问"></a>第一种 浏览器访问</h3><p>在浏览器地址栏输入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http://容器ip:6080</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20210901102900618.png" alt="image-20210901102900618"></p>
<p>然后输入密码即可进入</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20210901103136185.png" alt="image-20210901103136185"></p>
<h3 id="第二种-使用VNC客户端访问"><a href="#第二种-使用VNC客户端访问" class="headerlink" title="第二种 使用VNC客户端访问"></a>第二种 使用VNC客户端访问</h3><p>地址栏输入目标<code>ip</code>和端口, 注意这里端口是8900而不是6080</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20210901145352885.png" alt="image-20210901145352885"></p>
<p>输入密码登录后长这样:</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20210901145321808.png" alt="image-20210901145321808"></p>
<p>另外 如果你主机端使用的是<code>mac</code>平台, 还可以直接使用其自带的屏幕共享工具充当<code>VNC</code>工具使</p>
<p>全局搜索<code>Screen Sharing</code> :</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20210901105353641.png" alt="image-20210901105353641"></p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20210901145607320.png" alt="image-20210901145607320"></p>
<p>输入密码登录后界面:</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20210901145708985.png" alt="image-20210901145708985"></p>
<p>相比使用<code>vnc</code>客户端, <code>Mac</code>自带的工具虽然方便 但是流畅度会弱一些</p>
<h3 id="特别注意"><a href="#特别注意" class="headerlink" title="特别注意"></a>特别注意</h3><p><code>vnc</code>连接端口默认是<code>5900</code>我们在外网映射的时候不建议直接使用<code>5900</code>端口映射, 可能会出现连接不上的情况, 本文采用的是<code>8900</code></p>
<p><strong>本文为作者原创 转载时请注明出处 谢谢</strong></p>
<p><a href="https://space.bilibili.com/485691562" target="_blank" rel="noopener">B站入口</a></p>
<p><a href="https://code.newban.cn/0.html">打赏通道</a></p>
<p>微信公众号二维码如下:</p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt="img"></p>
<p><em><a href="https://code.newban.cn/">乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</a></em></p>
]]></content>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>linux中安装vscode实现在线IDE远程开发</title>
    <url>/254.html</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>一台服务器, 一个浏览器 就能实现远程随时随地开发, 无论是在公司 家里 出差 甚至在地铁使用手机</p>
<p>接下来介绍两种在线IDE的实现方式:</p>
<h3 id="第一种-使用docker模式"><a href="#第一种-使用docker模式" class="headerlink" title="第一种 使用docker模式"></a>第一种 使用docker模式</h3><p>首先服务端需要安装Docker环境, 然后拉取相关镜像, 步骤如下:</p>
<ol>
<li><p>拉取镜像</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker pull codercom/code-server</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建并启动容器</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run -id \</span><br><span class="line">-u root \</span><br><span class="line">-p 4001:4000 \</span><br><span class="line">-p 8443:8080 \</span><br><span class="line">--name=code_server \</span><br><span class="line">-e PASSWORD=1234 \</span><br><span class="line">-h code_server \</span><br><span class="line">-v $PWD/coder:/home/coder \</span><br><span class="line">codercom/code-server</span><br></pre></td></tr></table></figure>

<p>参数说明:</p>
<ul>
<li><strong>-u root 表示启用root用户权限 这一步很关键 不然很多文件无法操作</strong></li>
<li><strong>-p 8443：8080 将容器的8080端口映射到主机的8443端口 用于浏览器访问</strong></li>
<li><strong>-p 4001:4000  将容器的4000端口映射到主机的4001端口 用于开发过程中代码修改后实时更新查看</strong></li>
<li><strong>-e PASSWORD=1234 设置远程登录密码</strong></li>
<li><strong>-v  $PWD/coder:/home/coder将主机中当前目录挂载到容器</strong></li>
<li><strong>-h 设置容器的hostname</strong> </li>
<li><strong>–name=code_server 给容器取个名称</strong></li>
<li><strong>$PWD表示当前所在目录</strong></li>
</ul>
</li>
</ol>
<p>容器成功启动后, 直接在浏览器地址栏输入服务端ip和<code>8443</code>端口即可进入<code>ide</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http://ip:8443</span><br></pre></td></tr></table></figure>

<p>输入密码后:</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20210901153731968.png" alt="image-20210901153731968"></p>
<h5 id="远程登录密码修改"><a href="#远程登录密码修改" class="headerlink" title="远程登录密码修改"></a>远程登录密码修改</h5><p><code>code-server</code>中有一个配置文件<code>config.yaml</code>里面存储着登录密码 端口等相关信息:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bind-addr: 127.0.0.1:8080</span><br><span class="line">auth: password</span><br><span class="line">password: 1234</span><br><span class="line">cert: false</span><br></pre></td></tr></table></figure>

<p>该配置文件路径为:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/root/.config/code-server/config.yaml</span><br></pre></td></tr></table></figure>

<p>直接对该文件进行修改即可</p>
<p>为了方便随时修改配置文件, 我们在启动容器的时候可以对容器配置文件进行挂载:</p>
<p>首先将配置文件拷贝至宿主机中:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker cp code_server:/root/.config/code-server/config.yaml $PWD/config</span><br></pre></td></tr></table></figure>

<p>然后创建并启动容器:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run -id \</span><br><span class="line">-u root \</span><br><span class="line">-p 4001:4000 \</span><br><span class="line">-p 8443:8080 \</span><br><span class="line">--name=code_server \</span><br><span class="line">-e PASSWORD=1234 \</span><br><span class="line">-h code_server \</span><br><span class="line">-v $PWD/config/config.yaml:/root/.config/code-server/config.yaml \</span><br><span class="line">-v $PWD/coder:/home/coder \</span><br><span class="line">codercom/code-server</span><br></pre></td></tr></table></figure>

<p>这样 直接在宿主机中修改配置文件就可以了</p>
<h3 id="第二种-使用第三方服务"><a href="#第二种-使用第三方服务" class="headerlink" title="第二种 使用第三方服务"></a>第二种 使用第三方服务</h3><p>第一种方式相对来说比较吃系统资源, 除此之外我们还可以使用第三方的在线IDE服务, 比如使用<code>coding.net</code>提供的<code>CloudStudio</code>工作空间</p>
<p>其实就是在线<code>vscode</code>, 长这样:</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20210901165231064.png" alt="image-20210901165231064"></p>
<p><code>CloudStudio</code>提供了多种环境预设模板, 非常方便, 省下了安装环境的时间</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20210901165820056.png" alt="image-20210901165820056"></p>
<p>而且还支持预览调试:</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/run-react-preview.png" alt="预览窗口"></p>
<p><code>coding.net</code>提供两种服务器环境:</p>
<ul>
<li><strong>一种是官方免费的服务器</strong>: 每天4个小时的使用时间 机器性能还不错 使劲造</li>
<li><strong>一种的使用自己的服务器</strong>: 没有时间限制</li>
</ul>
<p>看个人需求了, 如果临时测试用的话 用免费的就行, 如果开发重心转移到远程的话 建议还是使用自己的服务器:</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20210901170414332.png" alt="image-20210901170414332"></p>
<p>可以通过<code>ssh</code>或者用户名密码的方式连接我们自己的服务器:</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20210901170155859.png" alt="image-20210901170155859"></p>
<p>相比第一种<code>Docker</code>自建<code>IDE</code>, 从体验和便捷度上来说完胜</p>
<p>而且IDE本身程序是托管于<code>coding.net</code>, 不占用我们服务器资源, 对于小型服务器的用户而言, 优先考虑采用<code>CloudStudio</code></p>
<p>唯一让人感觉坑爹的是<code>coding.net</code>改版太频繁, 没过几周估计你连入口都找不到</p>
<h4 id="阿里云在线IDE"><a href="#阿里云在线IDE" class="headerlink" title="阿里云在线IDE"></a>阿里云在线IDE</h4><p>现在阿里云也推出了<code>Web</code>在线编辑器,名叫 <code>DevStudio</code>和<code>CloudStudio</code>类似:</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20220916140455968.png" alt="image-20220916140455968"></p>
<p>针对<code>Java</code>语言, 阿里云这边使用的是在线<code>Idea</code>, 这对<code>Java</code>开发者而言算是非常便利了</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20220916140732637.png" alt="image-20220916140732637"></p>
<p>目前<code>DevStudio</code> 公测周期是<code>2021 年 6 月 23 日 ~ 2022 年 12 月 30 日</code>, 估计公测结束后就开始收费了  坑~</p>
<h4 id="国外的在线IDE"><a href="#国外的在线IDE" class="headerlink" title="国外的在线IDE"></a>国外的在线IDE</h4><ol>
<li><p><strong>Codesandbox</strong></p>
<p>支持多平台, 云端协作, <code>Github</code>仓库拉取等</p>
<p>官网: <a href="https://codesandbox.io/" target="_blank" rel="noopener">点击进入</a></p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20230418152244210.png" alt="image-20230418152244210"></p>
</li>
<li><p><strong>CodeOpen</strong></p>
<p>界面和启动速度一般 只能说能用</p>
<p>官网: <a href="https://codepen.io/pen" target="_blank" rel="noopener">点击进入</a></p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20230427101606222.png" alt="image-20230427101606222"></p>
</li>
<li><p><strong>Stackblitz</strong></p>
<p>以Web开发为主, 支持团队协作和<code>Github</code>仓库拉取, 界面美观, 响应速度快, 个人比较喜欢</p>
<p>官网: <a href="https://stackblitz.com/" target="_blank" rel="noopener">点击进入</a></p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20230427101949813.png" alt="image-20230427101949813"></p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20230427101712754.png" alt="image-20230427101712754"></p>
</li>
</ol>
<p><strong>本文为作者原创 转载时请注明出处 谢谢</strong></p>
<p><a href="https://space.bilibili.com/485691562" target="_blank" rel="noopener">B站入口</a></p>
<p><a href="https://code.newban.cn/0.html">打赏通道</a></p>
<p>微信公众号二维码如下:</p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt="img"></p>
<p><em><a href="https://code.newban.cn/">乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</a></em></p>
]]></content>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu系统安装LXDE+VNC桌面环境</title>
    <url>/259.html</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>在众多<code>linux</code>桌面环境中, <code>LXDE</code>属于非常轻量的一款, 占用系统资源小, 适合小型服务器使用</p>
<p>接下来介绍该桌面环境的安装步骤</p>
<h3 id="快速安装"><a href="#快速安装" class="headerlink" title="快速安装"></a>快速安装</h3><ol>
<li><p>更新源</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get update</span><br></pre></td></tr></table></figure>
</li>
<li><p>安装图形驱动 否则内置和下载的应用无法启动</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get install xorg</span><br></pre></td></tr></table></figure>
</li>
<li><p>安装<code>lxde</code>桌面程序</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get install lxde-core</span><br></pre></td></tr></table></figure>

<p>安装过程中会让你选择显示管理器, 选择<code>gdm3</code>即可</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20210831172358907.png" alt="image-20210831172358907"></p>
</li>
<li><p>安装<code>VNCServer</code> 用于远程桌面连接</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get install tightvncserver</span><br></pre></td></tr></table></figure>

<p>更多关于<code>tightvncserver</code>可参考<a href="https://wiki.archlinux.org/title/TigerVNC_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)" target="_blank" rel="noopener">中文文档</a></p>
</li>
<li><p>启动vnc服务</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vncserver</span><br></pre></td></tr></table></figure>

<p>提示我们输入访问密码:</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20210901175901616.png" alt="image-20210901175901616"></p>
<p>这里的密码用于接下来的远程登录用</p>
</li>
</ol>
<h3 id="开始远程访问"><a href="#开始远程访问" class="headerlink" title="开始远程访问"></a>开始远程访问</h3><h5 id="第一种-vnc客户端访问模式"><a href="#第一种-vnc客户端访问模式" class="headerlink" title="第一种 vnc客户端访问模式"></a>第一种 <code>vnc</code>客户端访问模式</h5><p><code>Mac</code>平台可直接执行以下指令安装:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">brew install Caskroom/cask/vnc-viewer</span><br></pre></td></tr></table></figure>

<p>或者下载安装包:</p>
<p><a href="https://url97.ctfile.com/f/21042697-511264719-a281de" target="_blank" rel="noopener">点击下载</a>（访问密码：312306）</p>
<p>安装<code>vnc</code>客户端后在地址栏输入目标<code>ip</code>和端口, 端口默认为<code>5901</code></p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20210901180352068.png" alt="image-20210901180352068"></p>
<p>输入密码登录后发现只有灰屏幕:</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20210901180441212.png" alt="image-20210901180441212"></p>
<p>接下来我们需要配置一下<code>vncserver</code>的环境:</p>
<ol>
<li><p>首先关闭<code>vncserver</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vncserver -kill :1</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改前对配置文件进行备份</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cp ~/.vnc/xstartup ~/.vnc/xstartup.bak</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改配置文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vim ~/.vnc/xstartup</span><br></pre></td></tr></table></figure>

<p>将以下内容添加至文本末尾:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">lxterminal &amp;</span><br><span class="line">/usr/bin/lxsession -s LXDE &amp;</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改配置文件权限</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">chmod +x ~/.vnc/xstartup</span><br></pre></td></tr></table></figure>
</li>
<li><p>重新启动<code>vnc</code>服务</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vncserver</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>最后重新连接远程桌面, 如下:</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20210902104141960.png" alt="image-20210902104141960"></p>
<h5 id="第二种-浏览器访问模式"><a href="#第二种-浏览器访问模式" class="headerlink" title="第二种 浏览器访问模式"></a>第二种 浏览器访问模式</h5><p>具体参考:</p>
<p>《<a href="https://code.newban.cn/260.html">如何使用Web浏览器访问Ubuntu环境下的vnc桌面</a>》</p>
<h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><ol>
<li><p>如果重复执行<code>vncserver</code>指令会开启多个vnc服务它们并行运行 互不干扰</p>
</li>
<li><p>除了使用<code>tightvncserver</code>搭建vnc服务器之外 还可以使用<code>x11vnc</code>, 详情查看文档:</p>
<p><a href="https://wiki.archlinux.org/title/X11vnc_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)" target="_blank" rel="noopener">点击进入</a></p>
</li>
</ol>
<p><strong>本文为作者原创 转载时请注明出处 谢谢</strong></p>
<p><a href="https://space.bilibili.com/485691562" target="_blank" rel="noopener">B站入口</a></p>
<p><a href="https://code.newban.cn/0.html">打赏通道</a></p>
<p>微信公众号二维码如下:</p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt="img"></p>
<p><em><a href="https://code.newban.cn/">乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</a></em></p>
]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>一个非常强大的网络工具NC使用详解</title>
    <url>/256.html</url>
    <content><![CDATA[<p><code>nc</code>是<code>netcat</code>的简写 是一个非常强大的网络工具</p>
<p>它可以:</p>
<ul>
<li>模拟服务端侦听指定端口</li>
<li>模拟客户端对服务端进行连接</li>
<li>机器之间传输文件</li>
<li>机器之间网络测速 </li>
</ul>
<h5 id="模拟服务端和客户端"><a href="#模拟服务端和客户端" class="headerlink" title="模拟服务端和客户端"></a>模拟服务端和客户端</h5><p>我们在使用阿里云服务器的时候, 除了要在服务器给应用部署端口之外 还需要再阿里云后台安全组中开放端口映射 这样外网才能对服务器程序进行访问</p>
<p>有时候 我们需要测试安全组策略是否打通, 假设我们在安全组中配置外网<code>4001</code>端口映射到服务器<code>80</code>端口, 这个时候我们可以在服务端模拟一个<code>80</code>侦听端口:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nc -l 80</span><br></pre></td></tr></table></figure>

<p>然后外网主机同样使用<code>nc</code>进行模拟访问:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nc -zv 服务器ip 4001</span><br></pre></td></tr></table></figure>

<p>当然你想使用<code>telnet</code>模拟客户端也可以:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">telnet 服务器ip 4001</span><br></pre></td></tr></table></figure>

<p>如果连接成功 表示端口策略打通 连接拒绝则不通 倘若连接超时 有可能服务端程序有问题 </p>
<p><strong>利用<code>nc</code>同时开启多个侦听端口:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nc -l 80 &amp;</span><br></pre></td></tr></table></figure>

<p>只需在尾部加上<code>&amp;</code>重复执行该命令即可</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20210901122029161.png" alt="image-20210901122029161"></p>
<h5 id="文件传输"><a href="#文件传输" class="headerlink" title="文件传输"></a>文件传输</h5><p>首先在服务端启动一个接收文件的监听，格式如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nc -l port &gt;file</span><br></pre></td></tr></table></figure>

<p>意思是把接收到的数据都写到<code>file</code>文件里（这里文件名随意取）</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20210901122707802.png" alt="image-20210901122707802"></p>
<p>然后在主机上将文件发过去:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nc 服务器ip 端口 &lt; 需要传送的文件</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20210901122816765.png" alt="image-20210901122816765"></p>
<p>文件传输完毕后服务端侦听自动断开</p>
<p>当然 我们也可以先发送文件 然后再在服务端接收文件 效果也是一样的</p>
<h5 id="目录传输"><a href="#目录传输" class="headerlink" title="目录传输"></a>目录传输</h5><p>如果需要将目录下多个文件同时传输, 可以采用以下指令</p>
<p>服务端 端口监听到文件后解压操作:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nc -l port | tar xfvz -</span><br></pre></td></tr></table></figure>

<p>主机端 将当前目录下所有文件打包 然后传输:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tar cfz - * | nc 服务器ip 端口</span><br></pre></td></tr></table></figure>

<h5 id="网速测试"><a href="#网速测试" class="headerlink" title="网速测试"></a>网速测试</h5><p>服务端开启文件传输监听:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nc -l 端口 &gt;/dev/null</span><br></pre></td></tr></table></figure>

<p><code>null</code>表示数据都输出给空设备（这样不写磁盘，测试网速更准确）</p>
<p>主机端开始传输数据:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nc 服务器ip 端口 &lt;/dev/zero</span><br></pre></td></tr></table></figure>

<p>把无限个0发送给服务端 模拟真实传输</p>
<p>此时 主机新开一个窗口 使用<code>dstat</code>命令查看当前网速</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20210901143339010.png" alt="image-20210901143339010"></p>
<p><code>dstat</code>可以查看当前cpu，磁盘，网络，内存页和系统的一些当前状态指标 </p>
<p>我们通过关注<code>recv</code> 和<code>send</code>两列即可查看当前接收和发送的网络速率 注意数字后面的单位B，KB，MB</p>
<p><strong>本文为作者原创 转载时请注明出处 谢谢</strong></p>
<p><a href="https://space.bilibili.com/485691562" target="_blank" rel="noopener">B站入口</a></p>
<p><a href="https://code.newban.cn/0.html">打赏通道</a></p>
<p>微信公众号二维码如下:</p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt="img"></p>
<p><em><a href="https://code.newban.cn/">乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</a></em></p>
]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>测试服务器端口是否打通的若干种方法</title>
    <url>/257.html</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>有时候我们会碰到服务端程序连接不上的情况, 要么是<code>ip</code>有问题 要么是端口有问题</p>
<p><code>ip</code>我们可以使用<code>ping</code>的方式检测是否正常</p>
<p>那么端口检测 可以通过以下几种方式检测:</p>
<h3 id="1-使用ssh"><a href="#1-使用ssh" class="headerlink" title="1.使用ssh"></a>1.使用ssh</h3><p>我们知道 连接服务器环境直接使用<code>ssh</code>指令:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh  用户名@ip -p 端口</span><br></pre></td></tr></table></figure>

<p>示例:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh  root@117.21.33.45 -p 22</span><br></pre></td></tr></table></figure>

<p>那么我们可以利用<code>ssh</code>来测试 端口通与不通</p>
<p>比如测试端口<code>5900</code>是否打通:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh -v root@117.21.33.45 -p 5900 //-v表示打印连接日志</span><br></pre></td></tr></table></figure>

<p>如果连接日志中出现<code>Connection established.</code>字样表示端口是通的, 否则不通</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20210901113602398.png" alt="image-20210901113602398"></p>
<h3 id="2-使用wget"><a href="#2-使用wget" class="headerlink" title="2.使用wget"></a>2.使用wget</h3><p><code>wget</code>是<code>linux</code>下的下载工具，需要先安装.</p>
<p>用法: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wget ip:port</span><br></pre></td></tr></table></figure>

<p>如果端口存在 则连接成功:</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20210901114002996.png" alt="image-20210901114002996"></p>
<p>否则 连接失败:</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20210901114035402.png" alt="image-20210901114035402"></p>
<h3 id="3-使用telnet"><a href="#3-使用telnet" class="headerlink" title="3.使用telnet"></a>3.使用telnet</h3><p><code>telnet</code>是<code>windows</code>平台自带指令，<code>windows</code>机器可以直接用 如果是<code>linux</code>机器，需要先安装<code>telnet</code>.</p>
<p>用法:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">telnet ip port</span><br></pre></td></tr></table></figure>

<p>如果端口存在 则连接成功:</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20210901114244225.png" alt="image-20210901114244225"></p>
<p>否则连接失败:</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20210901114304583.png" alt="image-20210901114304583"></p>
<h3 id="4-使用nc"><a href="#4-使用nc" class="headerlink" title="4.使用nc"></a>4.使用nc</h3><p><code>nc</code>是<code>netcat</code>的简写 是一个非常强大的网络工具</p>
<p>直接使用以下指令即可测试端口是否打通:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nc -zv 服务器ip 端口</span><br></pre></td></tr></table></figure>

<p>nc的能力除此之外 它还可以:</p>
<ul>
<li>模拟服务端侦听指定端口</li>
<li>模拟客户端对服务端进行连接</li>
<li>机器之间传输文件</li>
<li>机器之间网络测速 </li>
</ul>
<h5 id="模拟服务端和客户端"><a href="#模拟服务端和客户端" class="headerlink" title="模拟服务端和客户端"></a>模拟服务端和客户端</h5><p>我们在使用阿里云服务器的时候, 除了要在服务器给应用部署端口之外 还需要再阿里云后台安全组中开放端口映射 这样外网才能对服务器程序进行访问</p>
<p>有时候 我们仅仅是需要测试安全组策略是否打通, 假设我们在安全组中配置外网<code>4001</code>端口映射到服务器<code>80</code>端口, 这个时候我们可以在服务端模拟一个<code>80</code>侦听端口:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nc -l 80</span><br></pre></td></tr></table></figure>

<p>然后外网主机同样使用<code>nc</code>进行模拟访问:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nc -zv 服务器ip 4001</span><br></pre></td></tr></table></figure>

<p>当然你想使用<code>telnet</code>模拟客户端也可以:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">telnet 服务器ip 4001</span><br></pre></td></tr></table></figure>

<p>如果连接成功 表示端口策略打通 连接拒绝则不通 倘若连接超时 有可能服务端程序有问题 </p>
<h3 id="5-使用traceroute"><a href="#5-使用traceroute" class="headerlink" title="5.使用traceroute"></a>5.使用<code>traceroute</code></h3><p><code>traceroute</code>可以用来探测主机和目标机的路由节点, 同样可以用来检测端口是否打通 </p>
<p>用法:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">traceroute -n ip -p 端口</span><br></pre></td></tr></table></figure>

<h3 id="6-使用nmap"><a href="#6-使用nmap" class="headerlink" title="6. 使用nmap"></a>6. 使用<code>nmap</code></h3><p><code>nmap</code>可以扫描机器端口</p>
<p>用法:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nmap ip -p 端口</span><br></pre></td></tr></table></figure>

<p>以下状态表示扫描成功:</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20210901121229352.png" alt="image-20210901121229352"></p>
<p><strong>本文为作者原创 转载时请注明出处 谢谢</strong></p>
<p><a href="https://space.bilibili.com/485691562" target="_blank" rel="noopener">B站入口</a></p>
<p><a href="https://code.newban.cn/0.html">打赏通道</a></p>
<p>微信公众号二维码如下:</p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt="img"></p>
<p><em><a href="https://code.newban.cn/">乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</a></em></p>
]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>服务器之间传输文件的方式都有哪些</title>
    <url>/258.html</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>如果有图形界面的话 我们可以直接使用<code>FileZilla</code>或者 <code>SecureCRT</code> 进行文件传输</p>
<p>但<code>Linux</code>服务器都是不带图形界面的, 这个时候我们需要通过相关指令来处理</p>
<p>假设有两台公网的<code>Linux</code>机器A和B, 我们需要从A传输文件至B</p>
<p>可以采用以下几种方式:</p>
<h3 id="第一种-使用nc指令"><a href="#第一种-使用nc指令" class="headerlink" title="第一种 使用nc指令"></a>第一种 使用nc指令</h3><p>操作如下:</p>
<p>服务器B开启文件端口监听:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nc -l 3300 &gt; aaa.tar //将接受的文件取名为aaa.tar</span><br></pre></td></tr></table></figure>

<p>服务器A传输文件:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nc 服务器Bip 3300 &lt; 需要传送的文件</span><br></pre></td></tr></table></figure>

<h3 id="第二种-使用scp指令"><a href="#第二种-使用scp指令" class="headerlink" title="第二种 使用scp指令"></a>第二种 使用scp指令</h3><p>操作如下:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">scp -r 需要传输的目录 root@服务器ip:目标存放目录</span><br></pre></td></tr></table></figure>

<h3 id="第三种-使用rsync指令"><a href="#第三种-使用rsync指令" class="headerlink" title="第三种 使用rsync指令"></a>第三种 使用rsync指令</h3><p>操作如下:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rsync -r 需要传输的目录 root@服务器Bip:目标存放目录</span><br></pre></td></tr></table></figure>

<p>和<code>scp</code>很相似, 比<code>scp</code>多了一个排除子目录的功能:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rsync -r -v --exclude 需要排除不进行传输的子目录 需要传输的目录 root@服务器Bip:目标存放目录</span><br></pre></td></tr></table></figure>

<p>如果要同时排除多个目录 那么需要指定多次<code>--exclude</code> 如下:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rsync -r -v --exclude 排除目录1 --exclude 排除目录2 需要传输的目录 root@服务器Bip:目标存放目录</span><br></pre></td></tr></table></figure>

<h3 id="第四种-使用wget工具"><a href="#第四种-使用wget工具" class="headerlink" title="第四种 使用wget工具"></a>第四种 使用wget工具</h3><p>操作如下:</p>
<p>首先服务器B需要开启<code>http</code>服务, 这里以<code>python</code>为例:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python -m http.server 3300</span><br></pre></td></tr></table></figure>

<p>服务器A开始从B下载文件:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo wget -bc --limit-rate=6M 0.0.0.0:3300/需要下载的文件</span><br></pre></td></tr></table></figure>

<p><strong>参数说明：</strong></p>
<ul>
<li><code>-b</code> : 后台执行</li>
<li><code>-c</code>:  断点续传</li>
<li><code>–limit-rate=6M</code>: 限速6M</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><table>
<thead>
<tr>
<th>工具</th>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody><tr>
<td>nc</td>
<td>采用tcp协议 占用系统资源小 速度快</td>
<td>安全性不高 操作相对繁琐</td>
</tr>
<tr>
<td>wget</td>
<td>采用tcp协议 支持子目录排除 支持限速 断点续传</td>
<td>安全性不高操作相对繁琐</td>
</tr>
<tr>
<td>scp</td>
<td>采用ssh协议 传输安全 支持限速 占用系统资源小</td>
<td>不支持子目录排除</td>
</tr>
<tr>
<td>rsync</td>
<td>采用ssh协议 传输安全 速度比scp快 支持子目录排除 支持限速和本地复制 和断点续传</td>
<td>小文件众多时比较消耗资源</td>
</tr>
</tbody></table>
<h3 id="本地传输"><a href="#本地传输" class="headerlink" title="本地传输"></a>本地传输</h3><p>使用<code>scp</code>和<code>rsync</code>不仅可以对两台服务器上的数据进行相互传输 还可以进行本地数据传输 比如将服务器上的数据下载到本地:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rsync -r root@服务器IP:服务器目录 本地目录</span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">scp -r root@服务器IP:服务器目录 本地目录</span><br></pre></td></tr></table></figure>

<p>还可以将本地的数据上传到服务器  只需将前后两者反过来即可 比如:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rsync  -r  本地目录 root@服务器IP:服务器目录</span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">scp -r  本地目录 root@服务器IP:服务器目录</span><br></pre></td></tr></table></figure>

<h3 id="断点续传"><a href="#断点续传" class="headerlink" title="断点续传"></a>断点续传</h3><p>如果传输的文件比较大 可以采用断点续传的方式 然而<code>scp</code>并不支持断点续传, <code>wget</code>只能实现服务器之间数据传输以及本地从服务器拉取数据 无法做到将本地数据推到服务器</p>
<p>好在<code>rsync</code>工具给我们提供一个用于断点续传的指令, 如下:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rsync -r  --partial --progress 本地目录 root@服务器IP:服务器目录</span><br></pre></td></tr></table></figure>

<p><strong>参数解释:</strong></p>
<ul>
<li><code>--partial</code>：保留因故没有完全传输的文件，以加快随后的再次传输，即断点续传</li>
<li><code>--progress</code> : 在传输时显示传输过程</li>
</ul>
<p><code>rsync</code>还允许我们这样写:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rsync -r  -P 本地目录 root@服务器IP:服务器目录</span><br></pre></td></tr></table></figure>

<p><strong>参数解释:</strong></p>
<ul>
<li><code>-P</code> ：等价于<code>--partial</code>和<code>--progress</code></li>
</ul>
<h3 id="关于rsync目录排除不生效的问题"><a href="#关于rsync目录排除不生效的问题" class="headerlink" title="关于rsync目录排除不生效的问题"></a>关于rsync目录排除不生效的问题</h3><p>这种情况通常是目录路径不对的问题  比如:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rsync -r -P  --exclude=/root/songjian/auto  root@服务器IP:/root/songjian songjian</span><br></pre></td></tr></table></figure>

<p>上面这种写法并不能正确排除目录 正确的写法应该如下:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rsync -r -P  --exclude=/songjian/auto  root@服务器IP:/root/songjian songjian</span><br></pre></td></tr></table></figure>

<p><a href="https://space.bilibili.com/485691562" target="_blank" rel="noopener">B站入口</a></p>
<p><a href="https://code.newban.cn/0.html">打赏通道</a></p>
<p><strong>本文为作者原创 转载时请注明出处 谢谢</strong></p>
<p>微信公众号二维码如下:</p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt="img"></p>
<p><em><a href="https://code.newban.cn/">乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</a></em></p>
]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Git撤销&amp;回滚操作(git reset 和 get revert)</title>
    <url>/26.html</url>
    <content><![CDATA[<p>git的工作流</p>
<p>工作区：即自己当前分支所修改的代码，git add xx 之前的！不包括 git add xx 和 git commit xxx 之后的。</p>
<p>暂存区：已经 git add xxx 进去，且未 git commit xxx 的。</p>
<p>本地分支：已经git commit -m xxx 提交到本地分支的。<br>这里写图片描述</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/20200901152344.png" alt><br>代码回滚</p>
<p>在上传代码到远程仓库的时候，不免会出现问题，任何过程都有可能要回滚代码：</p>
<p>1、在工作区的代码</p>
<p>git checkout – a.txt  # 丢弃某个文件，或者<br>git checkout – .    # 丢弃全部</p>
<p>注意：git checkout – . 丢弃全部，也包括：新增的文件会被删除、删除的文件会恢复回来、修改的文件会回去。这几个前提都说的是，回到暂存区之前的样子。对之前保存在暂存区里的代码不会有任何影响。对commit提交到本地分支的代码就更没影响了。当然，如果你之前压根都没有暂存或commit，那就是回到你上次pull下来的样子了。</p>
<p>2、代码git add到缓存区，并未commit提交</p>
<p>git reset HEAD . 或者<br>git reset HEAD a.txt</p>
<p>这个命令仅改变暂存区，并不改变工作区，这意味着在无任何其他操作的情况下，工作区中的实际文件同该命令运行之前无任何变化</p>
<p>3、git commit到本地分支、但没有git push到远程</p>
<p>git log # 得到你需要回退一次提交的commit id<br>git reset –hard <commit_id> # 回到其中你想要的某个版<br>或者<br>git reset –hard HEAD^ # 回到最新的一次提交<br>或者<br>git reset HEAD^ # 此时代码保留，回到 git add 之前</commit_id></p>
<p>4、git push把修改提交到远程仓库<br>1）通过git reset是直接删除指定的commit</p>
<p>git log # 得到你需要回退一次提交的commit id<br>git reset –hard <commit_id><br>git push origin HEAD –force # 强制提交一次，之前错误的提交就从远程仓库删除</commit_id></p>
<p>2）通过git revert是用一次新的commit来回滚之前的commit</p>
<p>git log # 得到你需要回退一次提交的commit id<br>git revert <commit_id> # 撤销指定的版本，撤销也会作为一次提交进行保存</commit_id></p>
<p>3） git revert 和 git reset的区别<br>- git revert是用一次新的commit来回滚之前的commit，此次提交之前的commit都会被保留；<br>- git reset是回到某次提交，提交及之前的commit都会被保留，但是此commit id之后的修改都会被删除</p>
<p><strong>开发过程中，你肯定会遇到这样的场景：</strong></p>
<p><strong>场景一：</strong></p>
<blockquote>
<p>糟了，我刚把不想要的代码，commit到本地仓库中了，但是还没有做push操作！</p>
</blockquote>
<p><strong>场景二：</strong></p>
<blockquote>
<p>彻底完了，刚线上更新的代码出现问题了，需要还原这次提交的代码！</p>
</blockquote>
<p><strong>场景三：</strong></p>
<blockquote>
<p>刚才我发现之前的某次提交太愚蠢了，现在想要干掉它！</p>
</blockquote>
<h2 id="撤销"><a href="#撤销" class="headerlink" title="撤销"></a>撤销</h2><p>上述<strong>场景一</strong>，在未进行<code>git push</code>前的所有操作，都是在“本地仓库”中执行的。我们暂且将“本地仓库”的代码还原操作叫做“撤销”！</p>
<p><strong>情况一：文件被修改了，但未执行<code>git add</code>操作(working tree内撤销)</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git checkout fileName</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">git checkout .</span><br></pre></td></tr></table></figure>

<p><strong>情况二：同时对多个文件执行了<code>git add</code>操作，但本次只想提交其中一部分文件</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git add *</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">$ git status</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 取消暂存</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">$ git reset HEAD &lt;filename&gt;</span><br></pre></td></tr></table></figure>

<p><strong>情况三：文件执行了<code>git add</code>操作，但想撤销对其的修改（index内回滚）</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 取消暂存</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">git reset HEAD fileName</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 撤销修改</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">git checkout fileName</span><br></pre></td></tr></table></figure>

<p><strong>情况四：修改的文件已被<code>git commit</code>，但想再次修改不再产生新的Commit</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 修改最后一次提交 </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">$ git add sample.txt</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">$ git commit --amend -m&quot;说明&quot;</span><br></pre></td></tr></table></figure>

<p><strong>情况五：已在本地进行了多次<code>git commit</code>操作，现在想撤销到其中某次Commit</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git reset [--hard|soft|mixed|merge|keep] [commit|HEAD]</span><br></pre></td></tr></table></figure>

<p>具体参数和使用说明，请查看：<a href="http://blog.csdn.net/ligang2585116/article/details/51816372#t7" target="_blank" rel="noopener">Git Pro深入浅出（二）中的重置揭秘部分</a></p>
<h2 id="回滚"><a href="#回滚" class="headerlink" title="回滚"></a>回滚</h2><p>上述<strong>场景二</strong>，已进行<code>git push</code>，即已推送到“远程仓库”中。我们将已被提交到“远程仓库”的代码还原操作叫做“回滚”！<strong>注意：对远程仓库做回滚操作是有风险的，需提前做好备份和通知其他团队成员！</strong></p>
<p><em>如果你每次更新线上，都会打<a href="http://blog.csdn.net/ligang2585116/article/details/46468709" target="_blank" rel="noopener">tag</a>，那恭喜你，你可以很快的处理上述<strong>场景二</strong>的情况</em></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git checkout &lt;tag&gt;</span><br></pre></td></tr></table></figure>

<p><em>如果你回到当前HEAD指向</em></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git checkout &lt;branch_name&gt;</span><br></pre></td></tr></table></figure>

<p><strong>情况一：撤销指定文件到指定版本</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 查看指定文件的历史版本</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">git log &lt;filename&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 回滚到指定commitID</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">git checkout &lt;commitID&gt; &lt;filename&gt;</span><br></pre></td></tr></table></figure>

<p><strong>情况二：删除最后一次远程提交</strong></p>
<p><em>方式一：使用revert</em></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git revert HEAD</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">git push origin master</span><br></pre></td></tr></table></figure>

<p><em>方式二：使用reset</em></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git reset --hard HEAD^</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">git push origin master -f</span><br></pre></td></tr></table></figure>

<p><em>二者区别：</em></p>
<ul>
<li><strong>revert</strong>是放弃指定提交的修改，但是会生成一次新的提交，需要填写提交注释，以前的历史记录都在；</li>
<li><strong>reset</strong>是指将HEAD指针指到指定提交，历史记录中不会出现放弃的提交记录。</li>
</ul>
<p><strong>情况三：回滚某次提交</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 找到要回滚的commitID</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">git log</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">git revert commitID</span><br></pre></td></tr></table></figure>

<h2 id="删除某次提交"><a href="#删除某次提交" class="headerlink" title="删除某次提交"></a>删除某次提交</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git log --oneline -n5</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/20200901152520.png" alt></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git rebase -i &quot;commit id&quot;^</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong>需要注意最后的<em>^</em>号，意思是commit id的前一次提交</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git rebase -i &quot;5b3ba7a&quot;^</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/20200901153150.png" alt></p>
<p>在编辑框中删除相关commit，如<code>pick 5b3ba7a test2</code>，然后保存退出（如果遇到冲突需要先解决冲突）！</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git push origin master -f</span><br></pre></td></tr></table></figure>

<p><strong>通过上述操作，如果你想对历史多个commit进行处理或者，可以选择<code>git rebase -i</code>，只需删除对应的记录就好。rebase还可对 commit 消息进行编辑，以及合并多个commit。</strong></p>
<p><strong>本文为作者原创 转载时请注明出处 谢谢</strong></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em>乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</em></p>
]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu系统如何运行exe程序</title>
    <url>/261.html</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p><code>exe</code>文件是<code>windows</code>平台下的应用程序, 需要在<code>Windows</code>环境下才能运行</p>
<p>如果你想在<code>Linux</code>系统运行<code>Windows</code>程序, 那么就要给大家介绍一个工具了</p>
<p>其名为<code>wine</code></p>
<h3 id="关于Wine"><a href="#关于Wine" class="headerlink" title="关于Wine"></a>关于<code>Wine</code></h3><p><code>Wine</code>（“Wine Is Not an Emulator” 的递归缩写）是一个能够在多种 <code>POSIX-compliant</code>操作系统（诸如 <code>Linux</code>，<code>Mac OSX</code>及 <code>BSD</code> 等）上运行 <code>Windows</code> 应用的兼容层</p>
<p>那么 话不多说, 我们直接来实现一下:</p>
<h3 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤"></a>实现步骤</h3><ol>
<li><p>下载并安装<code>Wine</code>:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo dpkg --add-architecture i386 &amp;&amp; sudo apt-get update &amp;&amp;</span><br><span class="line">sudo apt-get install wine32 &amp;&amp; sudo apt-get install wine</span><br></pre></td></tr></table></figure>
</li>
<li><p>运行<code>exe</code>程序, 如果装有桌面环境 那么直接双击, 或者在命名窗口执行以下命令:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wine xxx.exe</span><br></pre></td></tr></table></figure>

<p>如果是64位程序则使用<code>wine64</code>:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wine64 xxx.exe</span><br></pre></td></tr></table></figure>



</li>
</ol>
<h3 id="问题集锦"><a href="#问题集锦" class="headerlink" title="问题集锦"></a>问题集锦</h3><p>如果在桌面环境中双击<code>exe</code>没有反应, 同时命令行执行<code>wine</code>报错<code>Application tried to create a window, but no driver could be loaded.</code></p>
<p>那么可以进入<code>wine</code>配置窗口, 添加相应的依赖库, 具体操作如下:</p>
<p>运行<code>winecfg</code>指令:</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20210902122022293.png" alt="image-20210902122022293"></p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20210902122045500.png" alt="image-20210902122045500"></p>
<p>回车后弹出<code>wine</code>配置窗口, 在<code>Libraries</code>选项中添加一下三个依赖库:</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20210902122005234.png" alt="image-20210902122005234"></p>
<p>添加完成后点击OK, 此时再双击<code>exe</code>文件即可正常运行</p>
<p><strong>本文为作者原创 转载时请注明出处 谢谢</strong></p>
<p><a href="https://space.bilibili.com/485691562" target="_blank" rel="noopener">B站入口</a></p>
<p><a href="https://code.newban.cn/0.html">打赏通道</a></p>
<p>微信公众号二维码如下:</p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt="img"></p>
<p><em><a href="https://code.newban.cn/">乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</a></em></p>
]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Mac系统如何运行exe程序</title>
    <url>/262.html</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>之前给大家介绍了如何在<code>Ubuntu</code>系统运行<code>exe</code>程序, 具体可查看:</p>
<p>《<a href="https://code.newban.cn/261.html">buntu系统如何运行exe程序</a>》</p>
<p>这次, 给大家介绍如何在<code>Mac</code>平台运行<code>exe</code>程序, 本次测试是在<code>Mac 10.15.4</code>环境下进行</p>
<h3 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤"></a>实现步骤</h3><ol>
<li><p>首先下载并安装<code>XQuartz</code>支持库:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">brew install --cask xquartz</span><br></pre></td></tr></table></figure>
</li>
<li><p>下载并安装<code>wine</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">brew install --cask --no-quarantine wine-stable</span><br></pre></td></tr></table></figure>

<p><code>wine</code>给我们提供了很多可用工具:</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20210902142316211.png" alt="image-20210902142316211"></p>
</li>
<li><p>运行<code>exe</code>程序</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wine xxx.exe</span><br></pre></td></tr></table></figure>

<p>如果报错<code>bad CPU type in executable: wine</code>, 则有可能是因为<code>exe</code>文件是64位的, 此时使用<code>wine64</code>执行即可:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wine64 xxx.exe</span><br></pre></td></tr></table></figure>

<p>如果是.net开发的程序, 会提示需要安装支持包, 点击安装即可:</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20210902141949081.png" alt="image-20210902141949081"></p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20210902142203820.png" alt="image-20210902142203820"></p>
</li>
<li><p>如果要卸载<code>wine</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">brew uninstall --cask</span><br></pre></td></tr></table></figure>



</li>
</ol>
<p>更多使用以及其他版本下载可参考<a href="https://wiki.winehq.org/" target="_blank" rel="noopener">wine官网</a></p>
<h3 id="内容补充"><a href="#内容补充" class="headerlink" title="内容补充"></a>内容补充</h3><p>目前<code>mac</code>高版本使用<code>wine</code>会出现报错现象, 如果要运行exe程序的话, 这里给大家推荐另一款产品 <a href="https://www.crossoverchina.com/" target="_blank" rel="noopener">CrossOver</a>, 免费版试用期14天,和谐版在文章尾部</p>
<p>除了内置一些常用软件之外, 可以运行单独的exe程序, 步骤如下:</p>
<ol>
<li><p>双击运行命令选项</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20211105162353517.png" alt="image-20211105162353517"></p>
</li>
<li><p>点击浏览按钮选择相应的程序文件直接运行即可</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20211105162832862.png" alt="image-20211105162832862"></p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20211105162927610.png" alt="image-20211105162927610"></p>
</li>
</ol>
<p><a href="https://url97.ctfile.com/d/21042697-59243365-19e46d?p=312306" target="_blank" rel="noopener">点击下载CrossOver</a> (访问密码: 312306)</p>
<p><strong>本文为作者原创 转载时请注明出处 谢谢</strong></p>
<p><a href="https://space.bilibili.com/485691562" target="_blank" rel="noopener">B站入口</a></p>
<p><a href="https://code.newban.cn/0.html">打赏通道</a></p>
<p>微信公众号二维码如下:</p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt="img"></p>
<p><em><a href="https://code.newban.cn/">乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</a></em></p>
]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>如何使用Web浏览器访问Ubuntu环境下的vnc桌面</title>
    <url>/260.html</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>一般我们在服务端安装后<code>vncserver</code>后, 主机端通过<code>vnc</code>客户端程序输入ip端口和密码后即可远程登录桌面</p>
<p>为了方便使用, 我希望可以使用浏览器直接访问, 那么接下来给大家介绍其实现方法:</p>
<h3 id="实现概述"><a href="#实现概述" class="headerlink" title="实现概述"></a>实现概述</h3><p>想要实现浏览器访问桌面, 首先我们需要安装桌面程序,  至于如何安装<code>ubuntu</code>桌面程序 可以参考以下文章:</p>
<p><a href="https://code.newban.cn/253.html">《给Multipass容器安装桌面环境》</a></p>
<p><a href="https://code.newban.cn/259.html">《Ubuntu系统安装LXDE+VNC桌面环境》</a></p>
<p>在桌面程序安装完毕的前提下, 我们只需要在服务器中安装<code>novnc</code>程序即可</p>
<p><code>novnc</code>相当于是一个中间代理, 充当了<code>vnc viewer</code>的一个角色, 使得我们无需安装本地<code>vnc</code>客户端即可访问桌面</p>
<p>具体操作如下:</p>
<h4 id="安装步骤"><a href="#安装步骤" class="headerlink" title="安装步骤"></a>安装步骤</h4><ol>
<li><p>下载并安装<code>novnc</code>程序:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo snap install novnc</span><br></pre></td></tr></table></figure>
</li>
<li><p>启动<code>novnc</code>连接<code>vncserver</code> 同时设置<code>web</code>访问端口为<code>6081</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo novnc --listen 6081 --vnc localhost:5901</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20210902110019439.png" alt="image-20210902110019439"></p>
</li>
<li><p>浏览器输入以下地址访问</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http://ip:6081/vnc.html</span><br></pre></td></tr></table></figure>

<p>如下:</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20210902105804968.png" alt="image-20210902105804968"></p>
<p>输入密码:</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20210902111100228.png" alt="image-20210902111100228"></p>
<p>进入后长这样:</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20210902111148950.png" alt="image-20210902111148950"></p>
</li>
<li><p>为了保持<code>novnc</code>常驻在后台, 我们可以启动<code>novnc</code>后台服务:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo snap set novnc services.n6082.listen=6082 services.n6082.vnc=localhost:5902</span><br></pre></td></tr></table></figure>

<p><strong>参数说明:</strong></p>
<ul>
<li><strong>services.n6082.listen=6082</strong> :表示名为<code>n6082</code>的服务web监听端口设为6082, 服务名称可以随便起, 但是前后要保持一致</li>
<li><strong>services.n6082.vnc=localhost:5902</strong>: 表示名为<code>n6082</code>的服务连接的<code>vncserver</code>端口设为<code>6082</code></li>
</ul>
<p>那么 也就是说, <code>novnc</code>可以同时连接多个<code>vncserver</code>, 比如这样:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo snap set novnc services.n1.listen=6081 services.n1.vnc=localhost:5901 services.n2.listen=6082 services.n2.vnc=localhost:5902</span><br></pre></td></tr></table></figure>

<p>同时连接了两个<code>vncserver</code>, 对应的端口分别为<code>6081和</code>6082` , 也就是不同的端口访问不同的桌面</p>
</li>
</ol>
<h3 id="novnc指令补充"><a href="#novnc指令补充" class="headerlink" title="novnc指令补充"></a>novnc指令补充</h3><ol>
<li><p>查看当前开启的服务数量:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo snap get novnc services</span><br></pre></td></tr></table></figure>

<p>打印结果长这样:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Key             Value</span><br><span class="line">services.n1  &#123;...&#125;</span><br><span class="line">services.n2  &#123;...&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>关闭服务</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo snap set novnc services.n1.listen=&apos;&apos; services.n1.vnc=&apos;&apos;</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看具体某个服务的信息</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo snap get novnc services.n1</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><ol>
<li><p>如果你需要设置<code>vncserver</code>开机自启动:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systemctl start vncserver@:1.service &amp;&amp; systemctl enable vncserver@:1.service</span><br></pre></td></tr></table></figure>
</li>
<li><p>你想查看<code>vnserver</code>服务是否开启:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systemctl status vncserver@:.service</span><br><span class="line"></span><br><span class="line">或者</span><br><span class="line">systemctl is-enabled vncserver@.service</span><br></pre></td></tr></table></figure>
</li>
<li><p>你想重启<code>vncserver</code>:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systemctl restart vncserver@:1.service</span><br></pre></td></tr></table></figure>
</li>
<li><p>你想设置<code>vnc</code>分辨率:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vncserver -geometry 1280x1024</span><br></pre></td></tr></table></figure>
</li>
<li><p>你想修改<code>vncserver</code>登录密码:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vncpasswd</span><br></pre></td></tr></table></figure>





</li>
</ol>
<p><strong>本文为作者原创 转载时请注明出处 谢谢</strong></p>
<p><a href="https://space.bilibili.com/485691562" target="_blank" rel="noopener">B站入口</a></p>
<p><a href="https://code.newban.cn/0.html">打赏通道</a></p>
<p>微信公众号二维码如下:</p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt="img"></p>
<p><em><a href="https://code.newban.cn/">乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</a></em></p>
]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu系统命令行安装Chrome浏览器</title>
    <url>/263.html</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>Ubuntu桌面搭建好后, 发现啥软件也没有, 此时我们最需要的就是一款浏览器</p>
<p>接下来给大家介绍命令行方式安装谷歌浏览器</p>
<h3 id="安装步骤"><a href="#安装步骤" class="headerlink" title="安装步骤"></a>安装步骤</h3><ol>
<li><p>查看系统是32位还是64位</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">uname -a</span><br></pre></td></tr></table></figure>

<p>执行后打印结构如果带有x86_64字样表示64位系统 , 如果带有类似 i686 i386字样则为32位系统</p>
</li>
<li><p>下载安装包</p>
<p>32位:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wget https://dl.google.com/linux/direct/google-chrome-stable_current_i386.deb</span><br></pre></td></tr></table></figure>

<p>64位:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wget https://dl.google.com/linux/direct/google-chrome-stable_current_amd64.deb</span><br></pre></td></tr></table></figure>
</li>
<li><p>安装程序</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo dpkg -i google-chrome*; sudo apt-get -f install</span><br></pre></td></tr></table></figure>
</li>
<li><p>运行程序</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/usr/bin/google-chrome-stable</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p><strong>本文为作者原创 转载时请注明出处 谢谢</strong></p>
<p><a href="https://space.bilibili.com/485691562" target="_blank" rel="noopener">B站入口</a></p>
<p><a href="https://code.newban.cn/0.html">打赏通道</a></p>
<p>微信公众号二维码如下:</p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt="img"></p>
<p><em><a href="https://code.newban.cn/">乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</a></em></p>
]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Mac平台安装Docker</title>
    <url>/265.html</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p><code>Mac</code>平台安装<code>Docker</code>非常的简单, 直接使用<code>Homebrew</code>工具安装即可, 如果你Mac上没有装<code>Homebrew</code>, 可以在命令窗口执行以下命令安装:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/bin/zsh -c &quot;$(curl -fsSL https://gitee.com/cunkai/HomebrewCN/raw/master/Homebrew.sh)&quot;</span><br></pre></td></tr></table></figure>

<p>有了homebrew工具后, 只需一行指令搞定<code>docker</code>下载安装</p>
<h3 id="具体操作"><a href="#具体操作" class="headerlink" title="具体操作"></a>具体操作</h3><ol>
<li><p>安装<code>docker</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">brew install docker</span><br></pre></td></tr></table></figure>

<p>这里安装的不带图形的命令行版本, 如果想安装图形版<code>docker</code>, 那么加上<code>cask</code>参数:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">brew install --cask --appdir=/Applications docker</span><br></pre></td></tr></table></figure>

<p>图形版长这样:</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20210903122347320.png" alt="image-20210903122347320"></p>
</li>
<li><p>启动docker服务</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">launchctl start docker</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果你想卸载<code>docker</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">brew uninstall docker</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>接下来可以开始使用<code>docker</code>了, 具体<code>docker</code>操作技巧可参考:</p>
<p>《<a href="https://code.newban.cn/7.html">Linux环境下docker常用指令集合</a>》</p>
<p>如果你的<code>mac</code>系统版本是10以上, 建议还是安装图形版<code>docker</code>, 纯命令版在启动服务的时候会出现启动失败的问题</p>
<h3 id="安装包下载"><a href="#安装包下载" class="headerlink" title="安装包下载"></a>安装包下载</h3><p>如果你不通过<code>brew</code>, 想通过下载<code>dmg</code>文件手动安装, 这里提供下载链接:</p>
<p><a href="https://desktop.docker.com/mac/stable/amd64/61853/Docker.dmg" target="_blank" rel="noopener">点击下载</a></p>
<p><strong>本文为作者原创 转载时请注明出处 谢谢</strong></p>
<p><a href="https://space.bilibili.com/485691562" target="_blank" rel="noopener">B站入口</a></p>
<p><a href="https://code.newban.cn/0.html">打赏通道</a></p>
<p>微信公众号二维码如下:</p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt="img"></p>
<p><em><a href="https://code.newban.cn/">乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</a></em></p>
]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Git使用之如何合并多个commit</title>
    <url>/266.html</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>我们在开发的时候, 有时候可能会提交多个业务零散的<code>commit</code>, 这些个<code>commit</code>内容合在一块才算是一个完整的任务</p>
<p>为了使得提交记录美观简洁, 同时缓解强迫症症状, 那么我们需要将这些个<code>commit</code>合并成一个<code>commit</code></p>
<p>如果你要合并的是最近几次<code>commit</code>, 那么可以使用<code>git reset --soft</code>进行<code>commit</code>撤销处理, 如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git reset --soft HEAD^3</span><br></pre></td></tr></table></figure>

<p>如果你要合并的是历史中间几次<code>commit</code>, 那么得用到<code>git rebase -i</code>指令了</p>
<h3 id="具体操作"><a href="#具体操作" class="headerlink" title="具体操作"></a>具体操作</h3><p>假设我们需要将以下最近两个记录进行合并:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">commit def5adef853da4cc05752bdb36577c127be71ba5</span><br><span class="line">Author: xxx</span><br><span class="line">Date:   Thu Dec 28 16:01:36 2017 +0800</span><br><span class="line"></span><br><span class="line">优化代码</span><br><span class="line"></span><br><span class="line">commit f36801544670e00b2f59a28e19017d2786c4085e</span><br><span class="line">Author: xxx</span><br><span class="line">Date:   Thu Dec 28 15:59:46 2017 +0800</span><br><span class="line"></span><br><span class="line">修复</span><br><span class="line"></span><br><span class="line">commit 00b2f59a28e19017d2786c4085e9a28e19017d278</span><br><span class="line">Author: xxx</span><br><span class="line">Date:   Thu Dec 28 16:59:46 2017 +0800</span><br><span class="line"></span><br><span class="line">修复bug</span><br><span class="line">(END)</span><br></pre></td></tr></table></figure>

<p>那么我们执行以下命令:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git rebase -i 00b2f59</span><br><span class="line"></span><br><span class="line">或者 </span><br><span class="line">git rebase -i HEAD~3</span><br></pre></td></tr></table></figure>

<p>这里的<code>commit id</code>是需要进行合并commit的前一个, 命令执行后, 会自动打开<code>vim</code>文本编辑器:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pick f368015 修复</span><br><span class="line">pick def5ade 优化代码</span><br><span class="line"></span><br><span class="line"># Commands:</span><br><span class="line"># p, pick = use commit</span><br><span class="line"># r, reword = use commit, but edit the commit message</span><br><span class="line"># e, edit = use commit, but stop for amending</span><br><span class="line"># s, squash = use commit, but meld into previous commit</span><br><span class="line"># f, fixup = like &quot;squash&quot;, but discard this commit&apos;s log message</span><br><span class="line"># x, exec = run command (the rest of the line) using shell</span><br><span class="line"># d, drop = remove commit</span><br><span class="line">#</span><br><span class="line"># These lines can be re-ordered; they are executed from top to bottom.</span><br><span class="line">#</span><br><span class="line"># If you remove a line here THAT COMMIT WILL BE LOST.</span><br><span class="line">#</span><br><span class="line"># However, if you remove everything, the rebase will be aborted.</span><br><span class="line">#</span><br><span class="line"># Note that empty commits are commented out~</span><br></pre></td></tr></table></figure>

<p>接下来, 我们需要对该内容进行修改, 首先我们需要来了解几个指令含义:</p>
<ul>
<li><strong>pick</strong>: 表示保留该<code>commit</code></li>
<li><strong>reword</strong>: 表示修改该<code>commit</code>的注释</li>
<li><strong>edit</strong>: 表示保留该commit  同时对代码内容进行修改</li>
<li><strong>squash</strong>: 表示将该<code>commit</code>合并到上一个<code>commit</code> </li>
<li><strong>fixup</strong>: 表示将该<code>commit</code>合并到上一个<code>commit</code> 同时丢弃该<code>commit</code>注释</li>
<li><strong>exec</strong>: 执行<code>shell</code></li>
<li><strong>drop</strong>: 删除该<code>commit</code></li>
</ul>
<p>这里我们使用<code>squash</code>指令进行合并, 内容修改如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pick f368015 修复</span><br><span class="line">squash def5ade 优化代码</span><br><span class="line"></span><br><span class="line"># Commands:</span><br><span class="line"># p, pick = use commit</span><br><span class="line"># r, reword = use commit, but edit the commit message</span><br><span class="line"># e, edit = use commit, but stop for amending</span><br><span class="line"># s, squash = use commit, but meld into previous commit</span><br><span class="line"># f, fixup = like &quot;squash&quot;, but discard this commit&apos;s log message</span><br><span class="line"># x, exec = run command (the rest of the line) using shell</span><br><span class="line"># d, drop = remove commit</span><br><span class="line">#</span><br><span class="line"># These lines can be re-ordered; they are executed from top to bottom.</span><br><span class="line">#</span><br><span class="line"># If you remove a line here THAT COMMIT WILL BE LOST.</span><br><span class="line">#</span><br><span class="line"># However, if you remove everything, the rebase will be aborted.</span><br><span class="line">#</span><br><span class="line"># Note that empty commits are commented out~</span><br></pre></td></tr></table></figure>

<p>表示将<code>def5ade</code>合并到<code>f368015</code></p>
<p><code>wq</code>内容保存后, 将进入到注释修改编辑页:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># This is a combination of 2 commits. </span><br><span class="line"># first commit</span><br><span class="line">优化代码</span><br><span class="line"></span><br><span class="line"># second commit</span><br><span class="line">修复</span><br><span class="line"># Please enter the commit message for your changes. Lines starting </span><br><span class="line"></span><br><span class="line"># with &apos;#&apos; will be ignored, and an empty message aborts the commit.</span><br></pre></td></tr></table></figure>

<p>我们可以对注释进行选择, 不需要的就用<code>#</code>号注释掉, 或者修改成别内容, 保存后, 直接开始自动合并</p>
<p>合并完毕后, 如果你想撤销合并 返回到合并前的状态, 可以使用以下指令:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git rebase --abort</span><br></pre></td></tr></table></figure>

<p>通过<code>rebase</code>方式的合并, 会合并生成一个新的<code>commit id</code>, 被合并的<code>commit</code>可以在<code>reflog</code>中找回</p>
<p><strong>本文为作者原创 转载时请注明出处 谢谢</strong></p>
<p><a href="https://space.bilibili.com/485691562" target="_blank" rel="noopener">B站入口</a></p>
<p><a href="https://code.newban.cn/0.html">打赏通道</a></p>
<p>微信公众号二维码如下:</p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt="img"></p>
<p><em><a href="https://code.newban.cn/">乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</a></em></p>
]]></content>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>Git使用之如何修改commit注释</title>
    <url>/267.html</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>我们在开发的时候, 有时候可能会需要对历史<code>commit</code>进行注释的修改, 那么可以采用以下几种方法</p>
<h3 id="详解"><a href="#详解" class="headerlink" title="详解"></a>详解</h3><p>分为以下三种情况:</p>
<h5 id="1-修改最近一次commit"><a href="#1-修改最近一次commit" class="headerlink" title="1. 修改最近一次commit"></a>1. 修改最近一次<code>commit</code></h5><p>如果你只想修改最近一次<code>commit</code>的注释, 那么可以执行以下命令:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git commit --amend</span><br></pre></td></tr></table></figure>

<p>执行后会出现<code>vim</code>编辑窗口, 在里面修改注释然后保存退出即可</p>
<h5 id="2-合并修改最近几次commit"><a href="#2-合并修改最近几次commit" class="headerlink" title="2. 合并修改最近几次commit"></a>2. 合并修改最近几次commit</h5><p>如果我们想对最近几次<code>commit</code>进行合并然后重新注释, 我们可以使用<code>reset --soft</code> 进行提交撤销操作, 比如撤销最近三次提交:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git reset --soft HEAD^3</span><br></pre></td></tr></table></figure>

<p>命令执行后, 前三次提交的内容将全部恢复到未提交状态, 此时我们可以添加注释重新提交</p>
<h5 id="3-修改历史commit"><a href="#3-修改历史commit" class="headerlink" title="3. 修改历史commit"></a>3. 修改历史<code>commit</code></h5><p>如果需要修改的不是最近几次<code>commit</code>, 那么需要用到<code>rebase</code>指令,</p>
<p>假设我们需要将以下第二个记录的注释进行修改:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">commit def5adef853da4cc05752bdb36577c127be71ba5</span><br><span class="line">Author: xxx</span><br><span class="line">Date:   Thu Dec 28 16:01:36 2017 +0800</span><br><span class="line"></span><br><span class="line">优化代码</span><br><span class="line"></span><br><span class="line">commit f36801544670e00b2f59a28e19017d2786c4085e</span><br><span class="line">Author: xxx</span><br><span class="line">Date:   Thu Dec 28 15:59:46 2017 +0800</span><br><span class="line"></span><br><span class="line">修复</span><br><span class="line"></span><br><span class="line">commit 00b2f59a28e19017d2786c4085e9a28e19017d278</span><br><span class="line">Author: xxx</span><br><span class="line">Date:   Thu Dec 28 16:59:46 2017 +0800</span><br><span class="line"></span><br><span class="line">修复bug</span><br><span class="line">(END)</span><br></pre></td></tr></table></figure>

<p>那么我们执行以下命令:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git rebase -i 00b2f59</span><br><span class="line"></span><br><span class="line">或者 </span><br><span class="line">git rebase -i HEAD~3</span><br></pre></td></tr></table></figure>

<p>这里的<code>commit id</code>是需要进行修改<code>commit</code>的前一个, 命令执行后, 会自动打开<code>vim</code>文本编辑器:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pick 00b2f59 修复bug</span><br><span class="line">pick f368015 修复</span><br><span class="line">pick def5ade 优化代码</span><br><span class="line"></span><br><span class="line"># Commands:</span><br><span class="line"># p, pick = use commit</span><br><span class="line"># r, reword = use commit, but edit the commit message</span><br><span class="line"># e, edit = use commit, but stop for amending</span><br><span class="line"># s, squash = use commit, but meld into previous commit</span><br><span class="line"># f, fixup = like &quot;squash&quot;, but discard this commit&apos;s log message</span><br><span class="line"># x, exec = run command (the rest of the line) using shell</span><br><span class="line"># d, drop = remove commit</span><br><span class="line">#</span><br><span class="line"># These lines can be re-ordered; they are executed from top to bottom.</span><br><span class="line">#</span><br><span class="line"># If you remove a line here THAT COMMIT WILL BE LOST.</span><br><span class="line">#</span><br><span class="line"># However, if you remove everything, the rebase will be aborted.</span><br><span class="line">#</span><br><span class="line"># Note that empty commits are commented out~</span><br></pre></td></tr></table></figure>

<p>接下来, 我们需要对该内容进行修改, 首先我们需要来了解几个指令含义:</p>
<ul>
<li><strong>pick</strong>: 表示保留该<code>commit</code></li>
<li><strong>reword</strong>: 表示修改该<code>commit</code>的注释</li>
<li><strong>edit</strong>: 表示保留该commit  同时对代码内容进行修改</li>
<li><strong>squash</strong>: 表示将该<code>commit</code>合并到上一个<code>commit</code> </li>
<li><strong>fixup</strong>: 表示将该<code>commit</code>合并到上一个<code>commit</code> 同时丢弃该<code>commit</code>注释</li>
<li><strong>exec</strong>: 执行<code>shell</code></li>
<li><strong>drop</strong>: 删除该<code>commit</code></li>
</ul>
<p>这里我们使用<code>reword</code>指令进行合并, 内容修改如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pick 00b2f59 修复bug</span><br><span class="line">reword f368015 修复</span><br><span class="line">pick def5ade 优化代码</span><br><span class="line"></span><br><span class="line"># Commands:</span><br><span class="line"># p, pick = use commit</span><br><span class="line"># r, reword = use commit, but edit the commit message</span><br><span class="line"># e, edit = use commit, but stop for amending</span><br><span class="line"># s, squash = use commit, but meld into previous commit</span><br><span class="line"># f, fixup = like &quot;squash&quot;, but discard this commit&apos;s log message</span><br><span class="line"># x, exec = run command (the rest of the line) using shell</span><br><span class="line"># d, drop = remove commit</span><br><span class="line">#</span><br><span class="line"># These lines can be re-ordered; they are executed from top to bottom.</span><br><span class="line">#</span><br><span class="line"># If you remove a line here THAT COMMIT WILL BE LOST.</span><br><span class="line">#</span><br><span class="line"># However, if you remove everything, the rebase will be aborted.</span><br><span class="line">#</span><br><span class="line"># Note that empty commits are commented out~</span><br></pre></td></tr></table></figure>

<p>表示对<code>f368015</code>这个<code>commit</code>进行注释修改</p>
<p><code>wq</code>内容保存后, 将进入到注释修改编辑页:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># This is a combination of 2 commits. </span><br><span class="line"></span><br><span class="line">修复</span><br><span class="line"># Please enter the commit message for your changes. Lines starting </span><br><span class="line"></span><br><span class="line"># with &apos;#&apos; will be ignored, and an empty message aborts the commit.</span><br></pre></td></tr></table></figure>

<p>我们可以对注释进行修改,然后保存退出即可</p>
<p><strong>本文为作者原创 转载时请注明出处 谢谢</strong></p>
<p><a href="https://space.bilibili.com/485691562" target="_blank" rel="noopener">B站入口</a></p>
<p><a href="https://code.newban.cn/0.html">打赏通道</a></p>
<p>微信公众号二维码如下:</p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt="img"></p>
<p><em><a href="https://code.newban.cn/">乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</a></em></p>
]]></content>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu无法运行程序提示No X server at $DISPLAY 或unable to open X display</title>
    <url>/264.html</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>这种情况一般出现在采用<code>vnc</code>远程桌面服务时</p>
<p>桌面中双击应用没有任何反应, 而通过命令窗口启动程序则提示:</p>
<p><code>unable to open display</code>或者<code>Unable to open X display</code>还有可能是<code>No X server at $DISPLAY</code></p>
<p>这个时候我们尝试启动<code>xserver</code> 却发现提示<code>no screens found(EE)</code> 如图:</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20210902173238923.png" alt="image-20210902173238923"></p>
<p>至此 我们推断是没有指定<code>vncserver</code></p>
<h3 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h3><p>我们需要通过<code>export DISPLAY</code>来指定连接哪个<code>vncserver</code></p>
<p>我们在启动<code>vn</code>c服务时可以看到该服务的名称为<code>hitleap:3</code>, 如图:</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20210902174243526.png" alt="image-20210902174243526"></p>
<p>因此 我们执行以下命令:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export DISPLAY=hitleap:3</span><br></pre></td></tr></table></figure>

<p>此时, 我们再重新执行程序, 程序正常启动</p>
<h3 id="关于DISPLAY"><a href="#关于DISPLAY" class="headerlink" title="关于DISPLAY"></a>关于DISPLAY</h3><p>在<code>Linux/Unix</code>类操作系统上, <code>DISPLAY</code>用来设置将图形显示到何处, 上面<code>export DISPLAY=hitleap:3</code>表示将图形显示到<code>vncserver</code></p>
<p>一般默认情况下<code>vncserver</code>名称为<code>:0</code>,比如:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export DISPLAY=:0</span><br></pre></td></tr></table></figure>

<p>也有可能是<code>1</code> 、<code>2</code> 、<code>3</code>甚至<code>137</code></p>
<p>连接成功后可以通过以下指令查看当前显示的详细信息:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">xdpyinfo</span><br></pre></td></tr></table></figure>

<p>查看当前设置的DISPLAY值:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">echo $DISPLA</span><br></pre></td></tr></table></figure>

<p>查看当前设备所有的变量 里面可以查看<code>vnc</code>密码以及当前设置的DISPLAY值:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">printenv</span><br></pre></td></tr></table></figure>

<p><strong>本文为作者原创 转载时请注明出处 谢谢</strong></p>
<p><a href="https://space.bilibili.com/485691562" target="_blank" rel="noopener">B站入口</a></p>
<p><a href="https://code.newban.cn/0.html">打赏通道</a></p>
<p>微信公众号二维码如下:</p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt="img"></p>
<p><em><a href="https://code.newban.cn/">乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</a></em></p>
]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>一个强大的轻量级全文即时搜索工具meilisearch</title>
    <url>/268.html</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p><a href="https://github.com/meilisearch/MeiliSearch" target="_blank" rel="noopener">MeiliSearch</a> 是近两年开源的一个全文搜索引擎，采用Rust语言开发, 主要目标是在小数据规模下实现比 <a href="https://www.elastic.co/cn/elasticsearch/" target="_blank" rel="noopener">ElasticSearch</a> 更加快速和易用的搜索体验。设计目标针对数据在 500GB 左右的搜索需求，极快，单文件，超轻量</p>
<p>目前已支持中文分词</p>
<p><a href="https://github.com/meilisearch/MeiliSearch" target="_blank" rel="noopener">MeiliSearch</a> 支持的功能如下:</p>
<ol>
<li>开源</li>
<li>用户量(开源搜索引擎第二名)</li>
<li>中文分词</li>
<li>同义词</li>
<li>纠错</li>
<li>高亮</li>
<li>全文返回</li>
<li>高级搜索</li>
<li>停用词、停用字段</li>
<li>加权、降权</li>
<li>逻辑搜索</li>
<li>唯一字段聚合</li>
<li>分页</li>
<li>重新索引</li>
</ol>
<p><a href="https://docs.meilisearch.com/" target="_blank" rel="noopener">中文文档</a></p>
<h3 id="快速上手"><a href="#快速上手" class="headerlink" title="快速上手"></a>快速上手</h3><ol>
<li><p>下载安装并运行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">curl -L https://install.meilisearch.com | sh</span><br><span class="line">./meilisearch</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20210910103712092.png" alt="image-20210910103712092"></p>
<p>此时访问浏览器<code>http://localhost:7700/</code>长这样:</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20210910103853046.png" alt="image-20210910103853046"></p>
<p>里面还没有数据, 接下来下载测试数据</p>
</li>
<li><p>下载测试数据</p>
<p><a href="https://docs.meilisearch.com/movies.json" target="_blank" rel="noopener">movie.json</a></p>
</li>
<li><p>将测试数据导入至<code>meilisearch</code>数据库</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">curl \</span><br><span class="line">  -X POST &apos;http://127.0.0.1:7700/indexes/movies/documents&apos; \</span><br><span class="line">  --data @movies.json</span><br></pre></td></tr></table></figure>
</li>
<li><p>访问主页</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http://127.0.0.1:7700</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20210910104053837.png" alt="image-20210910104053837"></p>
</li>
</ol>
<p>搜索速度相当的快</p>
<p><strong>本文为作者原创 转载时请注明出处 谢谢</strong></p>
<p><a href="https://space.bilibili.com/485691562" target="_blank" rel="noopener">B站入口</a></p>
<p><a href="https://code.newban.cn/0.html">打赏通道</a></p>
<p>微信公众号二维码如下:</p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt="img"></p>
<p><em><a href="https://code.newban.cn/">乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</a></em></p>
]]></content>
      <tags>
        <tag>实用工具</tag>
      </tags>
  </entry>
  <entry>
    <title>几款主流的虚拟机软件对比</title>
    <url>/269.html</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>说到虚拟机或者虚拟技术 容器技术, 大家可能会联想到一大堆软件, 诸如VMware、VirtualBox、Parallels 、Hyper-V、OpenVZ、Xen、KVM、Mutilpass、Docker等等</p>
<p>今天我们选取几款比较大众化的虚拟机软件对比分析一下:</p>
<table>
<thead>
<tr>
<th>虚拟软件</th>
<th>优势</th>
<th>劣势</th>
</tr>
</thead>
<tbody><tr>
<td>VMware</td>
<td>跨平台 功能强大 易用性好</td>
<td>收费 仅限 Intel 处理器</td>
</tr>
<tr>
<td>Parallels Desktop</td>
<td>功能丰富 和Mac融合性强, 无需重启即时切换</td>
<td>收费 只支持Mac平台</td>
</tr>
<tr>
<td>VirtualBox</td>
<td>跨平台 开源免费</td>
<td>资源占用相对较大</td>
</tr>
<tr>
<td>Hyper-V</td>
<td>硬虚拟化技术 性能强 稳定性好 部署简单</td>
<td>只支持Windows平台, 不支持USB外设</td>
</tr>
</tbody></table>
<h3 id="附加"><a href="#附加" class="headerlink" title="附加"></a>附加</h3><p>《<a href="https://code.newban.cn/270.html">VPS虚拟化架构OpenVZ、KVM、Xen、Hyper-V的区别</a>》</p>
<p><strong>本文为作者原创 转载时请注明出处 谢谢</strong></p>
<p><a href="https://space.bilibili.com/485691562" target="_blank" rel="noopener">B站入口</a></p>
<p><a href="https://code.newban.cn/0.html">打赏通道</a></p>
<p>微信公众号二维码如下:</p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt="img"></p>
<p><em><a href="https://code.newban.cn/">乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</a></em></p>
]]></content>
      <tags>
        <tag>虚拟机</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux中系统管理我们可能会使用到的指令</title>
    <url>/273.html</url>
    <content><![CDATA[<h3 id="1-systemctl"><a href="#1-systemctl" class="headerlink" title="1. systemctl"></a>1. systemctl</h3><p><code>systemctl</code>是 <code>Systemd</code>的主命令，用于管理系统。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 重启系统</span></span><br><span class="line">$ sudo systemctl reboot</span><br><span class="line"></span><br><span class="line"><span class="comment"># 关闭系统，切断电源</span></span><br><span class="line">$ sudo systemctl poweroff</span><br><span class="line"></span><br><span class="line"><span class="comment"># CPU停止工作</span></span><br><span class="line">$ sudo systemctl halt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 暂停系统</span></span><br><span class="line">$ sudo systemctl <span class="built_in">suspend</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 让系统进入冬眠状态</span></span><br><span class="line">$ sudo systemctl hibernate</span><br><span class="line"></span><br><span class="line"><span class="comment"># 让系统进入交互式休眠状态</span></span><br><span class="line">$ sudo systemctl hybrid-sleep</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动进入救援状态（单用户状态）</span></span><br><span class="line">$ sudo systemctl rescue</span><br></pre></td></tr></table></figure>

<h3 id="2-systemd-analyze"><a href="#2-systemd-analyze" class="headerlink" title="2. systemd-analyze"></a>2. systemd-analyze</h3><p><code>systemd-analyze</code>命令用于查看启动耗时。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看启动耗时</span></span><br><span class="line">$ systemd-analyze                                                                                       </span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看每个服务的启动耗时</span></span><br><span class="line">$ systemd-analyze blame</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示瀑布状的启动过程流</span></span><br><span class="line">$ systemd-analyze critical-chain</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示指定服务的启动流</span></span><br><span class="line">$ systemd-analyze critical-chain atd.service</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20210914154541109.png" alt="image-20210914154541109"></p>
<h3 id="3-hostnamectl"><a href="#3-hostnamectl" class="headerlink" title="3. hostnamectl"></a>3. hostnamectl</h3><p><code>hostnamectl</code>命令用于查看当前主机的信息。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 显示当前主机的信息</span></span><br><span class="line">$ hostnamectl</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置主机名。</span></span><br><span class="line">$ sudo hostnamectl <span class="built_in">set</span>-hostname rhel7</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20210914145006176.png" alt></p>
<h3 id="4-localectl"><a href="#4-localectl" class="headerlink" title="4. localectl"></a>4. localectl</h3><p><code>localectl</code>命令用于查看本地化设置。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看本地化设置</span></span><br><span class="line">$ localectl</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置本地化参数。</span></span><br><span class="line">$ sudo localectl <span class="built_in">set</span>-locale LANG=en_GB.utf8</span><br><span class="line">$ sudo localectl <span class="built_in">set</span>-keymap en_GB</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20210914154511109.png" alt="image-20210914154511109"></p>
<h3 id="5-timedatectl"><a href="#5-timedatectl" class="headerlink" title="5. timedatectl"></a>5. timedatectl</h3><p><code>timedatectl</code>命令用于查看当前时区设置。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看当前时区设置</span></span><br><span class="line">$ timedatectl</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示所有可用的时区</span></span><br><span class="line">$ timedatectl list-timezones                                                                                   </span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置当前时区</span></span><br><span class="line">$ sudo timedatectl <span class="built_in">set</span>-timezone America/New_York</span><br><span class="line">$ sudo timedatectl <span class="built_in">set</span>-time YYYY-MM-DD</span><br><span class="line">$ sudo timedatectl <span class="built_in">set</span>-time HH:MM:SS</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20210914154411820.png" alt="image-20210914154411820"></p>
<h3 id="6-loginctl"><a href="#6-loginctl" class="headerlink" title="6. loginctl"></a>6. loginctl</h3><p><code>loginctl</code>命令用于查看当前登录的用户。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 列出当前session</span></span><br><span class="line">$ loginctl list-sessions</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出当前登录用户</span></span><br><span class="line">$ loginctl list-users</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出显示指定用户的信息</span></span><br><span class="line">$ loginctl show-user</span><br></pre></td></tr></table></figure>

<p><strong>本文为作者原创 转载时请注明出处 谢谢</strong></p>
<p><a href="https://space.bilibili.com/485691562" target="_blank" rel="noopener">B站入口</a></p>
<p><a href="https://code.newban.cn/0.html">打赏通道</a></p>
<p>微信公众号二维码如下:</p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt="img"></p>
<p><em><a href="https://code.newban.cn/">乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</a></em></p>
]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo Process Out of Memory解决文章过多 内存溢出问题</title>
    <url>/27.html</url>
    <content><![CDATA[<h2 id="hexo内存溢出问题"><a href="#hexo内存溢出问题" class="headerlink" title="hexo内存溢出问题"></a>hexo内存溢出问题</h2><p>当hexo生成文章大概在1000以上的时候,便有可能出现该问题.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">FATAL ERROR: CALL_AND_RETRY_LAST Allocation failed - process out of memory</span><br></pre></td></tr></table></figure>

<h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法:"></a>解决方法:</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 找到hexo 命令的位置</span></span><br><span class="line"><span class="built_in">which</span> hexo</span><br></pre></td></tr></table></figure>

<p>编辑hexo命令的bin文件的第一行为以下内容.</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env node --max_old_space_size=8192</span></span><br></pre></td></tr></table></figure>

<p>便暂时解决内存溢出的问题.</p>
<h2 id="hexo的性能"><a href="#hexo的性能" class="headerlink" title="hexo的性能"></a>hexo的性能</h2><p>hexo的性能相对hugo确实差太多,同样1000+的页面,用hugo却只用了不到2s. 这让我开始开始犹豫是否要放弃使用hexo.</p>
<p><strong>本文为作者原创 转载时请注明出处 谢谢</strong></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em>乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</em></p>
]]></content>
      <tags>
        <tag>hexo技巧</tag>
      </tags>
  </entry>
  <entry>
    <title>免费稳定的PHP虚拟主机</title>
    <url>/271.html</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>想验证网站项目是否可盈利, 如果购买服务器的话太贵, 怎么办, 那就用免费的吧</p>
<p>国内基本上已经没有免费的虚拟主机可用了, 即便有也是套路你</p>
<p>只好把目标转向国外服务器供应商, 先是找到一家日本的厂商<a href="https://www.xrea.com/" target="_blank" rel="noopener">XREA</a>, 主页长这样:</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20210910145415910.png" alt></p>
<p>决定试试申请一个, <code>xrea</code>需要注册两个账户, 一个是<code>xrea</code>账户, 另一个是<code>value-admin</code>账户</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20210910150342841.png" alt="image-20210910150342841"></p>
<p>首先注册<code>value-admin</code>账户:</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20210910150514615.png" alt="image-20210910150514615"></p>
<p>这一步 国内的邮箱无法注册, 谷歌邮箱可以  但是居然一直收不到验证码, 最后只好作罢</p>
<h4 id="Awardspace"><a href="#Awardspace" class="headerlink" title="Awardspace"></a>Awardspace</h4><h5 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h5><p>随后有找了一家欧美的厂商<a href="https://www.awardspace.com/" target="_blank" rel="noopener">Awardspace</a>, 经过尝试, 发现可行, 主页长这样:</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20210910163000949.png" alt="image-20210910163000949"></p>
<p>我直接使用第三方谷歌登录, 国内的小伙伴有可能需要搭个梯子才能访问哦</p>
<p>登录成功后进入到控制台界面:</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20210910163254548.png" alt="image-20210910163254548"></p>
<p>该有的功能全都有, 这个免费虚拟主机给我们提供了:</p>
<ul>
<li><strong>1G的储存空间</strong></li>
<li><strong>每月5G的流量</strong></li>
<li><strong>1个Mysql数据库</strong></li>
<li><strong>可绑定一个顶级域名和三个子域名</strong></li>
<li><strong>一个邮箱账户</strong></li>
</ul>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20210910163214377.png" alt="image-20210910163214377"></p>
<h5 id="安装或者上传应用"><a href="#安装或者上传应用" class="headerlink" title="安装或者上传应用"></a>安装或者上传应用</h5><p>各种博客程序一键安装:</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20210910163756104.png" alt="image-20210910163756104"></p>
<p>或者上传已有的程序文件, 可以网站直接上传或者使用FTP上传, 如果使用FTP会提示你设置FTP密码:</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20210910164648342.png" alt="image-20210910164648342"></p>
<p>我这里为了演示 直接一键安装的<code>JOOMLA</code>博客程序</p>
<h5 id="域名绑定"><a href="#域名绑定" class="headerlink" title="域名绑定"></a>域名绑定</h5><p>如果你已经有自己的域名了, 可以直接绑定:</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20210910163953692.png" alt="image-20210910163953692"></p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20210910164215330.png" alt="image-20210910164215330"></p>
<p>然后在你的域名服务上, 进行域名解析, 可以直接使用A记录解析到<code>185.176.43.108</code>这个IP, 或者更改<code>DNS</code>记录为<code>ns5.awardspace.com,ns6.awardspace.com</code></p>
<p>我这里直接用的是IP解析</p>
<h5 id="访问主页"><a href="#访问主页" class="headerlink" title="访问主页"></a>访问主页</h5><p>最后浏览器输入绑定的域名进行测试, 我这边正常访问, 而且速度还不错:</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20210910164940227.png" alt="image-20210910164940227"></p>
<h3 id="freehostia"><a href="#freehostia" class="headerlink" title="freehostia"></a>freehostia</h3><p>这个网站也提供免费的虚拟主机, 时长一年, 可以选择预制的PHP程序:</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20210910165958993.png" alt="image-20210910165958993"></p>
<p><a href="https://www.freehostia.com/" target="_blank" rel="noopener">点击进入官网</a></p>
<p><code>freehostia</code>给我们提供了:</p>
<ul>
<li><strong>250MB存储空间</strong></li>
<li><strong>每月6G流量</strong></li>
<li><strong>1个10MBMySQL</strong></li>
<li><strong>3个邮箱账户</strong></li>
</ul>
<h3 id="蓝队云"><a href="#蓝队云" class="headerlink" title="蓝队云"></a>蓝队云</h3><p>提供免费的PHP虚拟主机</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20220707153444030.png" alt="image-20220707153444030"></p>
<p><a href="https://www.landui.com/" target="_blank" rel="noopener">点击进入官网</a></p>
<p><code>蓝队云</code>给我们提供了:</p>
<ul>
<li><strong>1Gb存储空间</strong></li>
<li><strong>不限流量</strong></li>
<li><strong>1个300MBMySQL</strong></li>
</ul>
<h3 id="灰狼云"><a href="#灰狼云" class="headerlink" title="灰狼云"></a>灰狼云</h3><p>免费PHP虚拟空间 一月一续期</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20220707154001659.png" alt="image-20220707154001659"></p>
<p>该空间可以用于CDN反代, 具体可参见: 《<a href="https://hin.cool/posts/jsdfandai.html" target="_blank" rel="noopener">无成本反向代理Jsdelivr</a>》</p>
<p><strong>本文为作者原创 转载时请注明出处 谢谢</strong></p>
<p><a href="https://space.bilibili.com/485691562" target="_blank" rel="noopener">B站入口</a></p>
<p><a href="https://code.newban.cn/0.html">打赏通道</a></p>
<p>微信公众号二维码如下:</p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt="img"></p>
<p><em><a href="https://code.newban.cn/">乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</a></em></p>
]]></content>
      <tags>
        <tag>服务器</tag>
      </tags>
  </entry>
  <entry>
    <title>VPS虚拟化架构OpenVZ、KVM、Xen、Hyper-V的区别</title>
    <url>/270.html</url>
    <content><![CDATA[<h4 id="1、OpenVZ"><a href="#1、OpenVZ" class="headerlink" title="1、OpenVZ"></a><strong>1、OpenVZ</strong></h4><p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/20210910120718.png" alt></p>
<p>OpenVZ（简称OVZ）采用SWsoft的Virutozzo虚拟化服务器软件产品的内核，是基于Linux平台的操作系统级服务器虚拟化架构。这个架构直接调用宿主机（俗称：母机）中的内核，模拟生成出子服务器（俗称：VPS，小机），所以，它经过虚拟化后相对于母服务器，性能损失大概只有的1-3%。 当然OpenVZ可以超售，意思味着一台服务器总共16G内存，他可以开出配置为1G内存×17台或以上的子服务器。因为他的虚拟架构关系属于：不是你分配给客户多少资源，就扣除宿主机多少资源；而是客户用多少资源，就扣除宿主机多少资源，所以OpenVZ架构的VPS较为便宜。但由于存在超售因素，如果服务商毫无休止的超售会导致服务器的性能急剧下降。 OpenVZ另一个特点是，它是直接调用宿主机的内核，所以会导致部分软件无法使用，以及部分内核文件是无法修改。</p>
<h4 id="2、KVM"><a href="#2、KVM" class="headerlink" title="2、KVM"></a><strong>2、KVM</strong></h4><p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/20210910120750.png" alt></p>
<p>KVM是Linux下的全功能虚拟化架构，基于KVM架构的VPS，默认是没有系统的，可自己上传ISO或调用服务商自带的ISO手动安装系统或使用服务商提供的官方的KVM模板。这个非常适合热爱DIY自己VPS的客户。 由于KVM架构全功能虚拟化架构，甚至拥有独立的BIOS控制，所以对宿主机性能影响较大，所以基于KVM的VPS较贵，但KVM VPS相对其它架构的VPS较为自由。</p>
<h4 id="3-Xen"><a href="#3-Xen" class="headerlink" title="3.Xen"></a><strong>3.Xen</strong></h4><p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/20210910121041.png" alt></p>
<p>Xen 由剑桥大学开发，它是基于硬件的完全分割，物理上有多少的资源就只能分配多少资源，因此很难超售。可分为Xen-PV（半虚拟化），和Xen-HVM（全虚拟化）。 Xen是不能超售的，当宿主机只有16G内存以及100G硬盘时，当开Xen架构（任意一个虚拟化）的1G内存、25G硬盘的子机时，会直接占用宿主机1G内存，以及25G硬盘，所以Xen的性能，相比OpenVZ在超售的情况下要好。 Xen-PV：半虚拟化，所以它仅仅适用于linux系列VPS，但它的性能损失比较少，大概相对于宿主机的4%-8%左右。 Xen-HVM：全虚拟化，可以安装Windows或自由挂载ISO文件安装任意系统，由于是全虚拟化，所以性能损失较大，大概相对于宿主机性能损失8%-20%左右。</p>
<h4 id="4-Hyper-V"><a href="#4-Hyper-V" class="headerlink" title="4.Hyper-V"></a><strong>4.Hyper-V</strong></h4><p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/20210910121019.png" alt></p>
<p>Hyper-V是微软的一款虚拟化产品，大部分国内的VPS服务商使用这个架构（包括标准互联?），主要是因为其转为Windows定制，管理起来较为方便。目前的Hyper-V也支持Linux，只不过性能损失比较严重。 Hyper-V完美支持Windows系统，包括32位和64位。如果大家选购Hyper-V架构的VPS，强烈建议使用Windows。 Hyper-V目前不能超售内存，但可超售硬盘，硬盘是根据客户使用情况扣除。一般来说，宿主机的硬盘不会100%用完，这点不用担心。</p>
<p><strong>总结：</strong></p>
<p>总的来说，Xen和Hyper-V见的比较少，对于OpenVZ、KVM推荐选择KVM虚拟化。</p>
<p><strong>本文为转载自</strong>:<a href="https://www.cnblogs.com/ydwzhang/p/10080380.html" target="_blank" rel="noopener">https://www.cnblogs.com/ydwzhang/p/10080380.html</a></p>
<p><a href="https://space.bilibili.com/485691562" target="_blank" rel="noopener">B站入口</a></p>
<p><a href="https://code.newban.cn/0.html">打赏通道</a></p>
<p>微信公众号二维码如下:</p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt="img"></p>
<p><em><a href="https://code.newban.cn/">乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</a></em></p>
]]></content>
      <tags>
        <tag>虚拟机</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux中关于前台任务和后台任务的相关操作</title>
    <url>/272.html</url>
    <content><![CDATA[<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>以下概念以终端操作为前提</p>
<ul>
<li><strong>前台任务</strong>: 在前台执行的任务, 任务一旦执行则占用终端窗口, 同一窗口内 无法进行其他操作</li>
<li><strong>后台任务</strong>: 在后台执行的任务, 任务执行不占用终端窗口, 同一窗口内 可一边执行任务 一边进行其他操作</li>
</ul>
<p>无论是前台任务还是后台任务, 终端一旦被关闭, 任务会立即终止</p>
<h3 id="前台任务"><a href="#前台任务" class="headerlink" title="前台任务"></a>前台任务</h3><ol>
<li><p><strong>终止前台任务</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Ctrl+C</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>暂停前台任务</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Ctrl+Z</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>查看当前暂停的任务和所有后台任务信息</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">jobs -l</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>将前台任务切换成后台任务</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.输入ctrl + z 暂停任务</span><br><span class="line">2.输入jobs查看任务号</span><br><span class="line">3.使用 bg %任务号 将该任务号放入后台</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>终端关闭 保持前台任务继续运行</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nohup xxxx</span><br></pre></td></tr></table></figure>

<p><strong>nohup:</strong> 表示忽略<code>hup</code>信号, 终端关闭任务进程也不销毁</p>
</li>
</ol>
<h3 id="后台任务"><a href="#后台任务" class="headerlink" title="后台任务"></a>后台任务</h3><ol>
<li><p><strong>以后台方式启动任务, 命令末尾加<code>&amp;</code>即可</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">watch  -n 10 sh  test.sh  &amp;  #每10s在后台执行一次test.sh脚本</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>终止后台任务</strong></p>
<p>方式一:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.输入jobs查看任务号</span><br><span class="line">2.kill %任务编号</span><br></pre></td></tr></table></figure>

<p>方式二:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.使用ps指令查看任务进程pid</span><br><span class="line">2.kill pid</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>将后台任务切换成前台任务</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.输入jobs查看任务号</span><br><span class="line">2.fg %任务编号</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>终端关闭 保持后台任务继续运行</strong></p>
<p>如果后台任务还未启动, 指令前面加<code>nohup</code>:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nohup watch  -n 10 sh  test.sh  &amp;</span><br></pre></td></tr></table></figure>

<p>如果后台任务已经启动:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.输入jobs查看任务号</span><br><span class="line">2.使用 disown -h %任务号</span><br></pre></td></tr></table></figure>

<p><code>disown</code>指令用于对<code>jobs</code>任务的移除移出操作, 常见参数有:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">disown -a //删除全部作业</span><br><span class="line">disown -r //删除正在运行的作业</span><br><span class="line">disown -h %任务号 //移出(非删除)指定作业, 同时忽略hup信号</span><br></pre></td></tr></table></figure>



</li>
</ol>
<h3 id="实现后台任务的另一种方式"><a href="#实现后台任务的另一种方式" class="headerlink" title="实现后台任务的另一种方式"></a>实现后台任务的另一种方式</h3><p>除了使用<code>nuhup</code>+<code>&amp;</code>的方式使得任务在后台运行且不受终端关闭影响外, 还有一种方式那就是使用<code>systemd</code></p>
<p>创建<code>systemd</code>服务步骤如下:</p>
<ol>
<li><p><strong>创建服务配置文件</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vim xxx.service</span><br></pre></td></tr></table></figure>

<p>将以下内容填入配置文件中:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=Foo</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">ExecStart=/usr/sbin/foo-daemon</span><br><span class="line">Restart=always</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>Description</strong>: 表示服务描述</li>
<li><strong>ExecStart</strong>: 表示需要执行的程序指令, 需要填入程序的完整路径</li>
<li><strong>Restart</strong>: 表示是否自动重启, 可选参数有<code>no</code>、<code>always</code>、<code>on-success</code>、<code>on-failure</code>、<code>on-abnormal</code>、<code>on-abort</code>、<code>on-watchdog</code>等</li>
<li><strong>WantedBy</strong>: 表示用户权限</li>
</ul>
<p>更多配置, 可参考<a href="https://www.freedesktop.org/software/systemd/man/systemd.service.html" target="_blank" rel="noopener">官方文档</a> 或者<a href="https://www.ruanyifeng.com/blog/2016/03/systemd-tutorial-commands.html" target="_blank" rel="noopener">博客介绍</a></p>
</li>
<li><p><strong>将服务配置文件拷贝至<code>/lib/systemd/system/</code>目录下</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo cp xxx.service /lib/systemd/system/</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>启动服务</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo systemctl start xxx</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h5 id="关于服务的其他操作指令"><a href="#关于服务的其他操作指令" class="headerlink" title="关于服务的其他操作指令"></a>关于服务的其他操作指令</h5><ol>
<li><p><strong>停止服务</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo systemctl stop xxx</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>查看服务运行状态</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo systemctl status xxx</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>设置服务开机自启动</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo systemctl enable xxx</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>禁止服务开启自启动</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo systemctl disable xxx</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>服务重启</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo systemctl restart xxx</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>查看<code>systemd</code>的版本</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo systemctl --version</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>查看配置文件</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systemctl cat xxx.service</span><br></pre></td></tr></table></figure>



</li>
</ol>
<h3 id="systemd和nohup-amp-之间的对比"><a href="#systemd和nohup-amp-之间的对比" class="headerlink" title="systemd和nohup+&amp;之间的对比"></a><code>systemd</code>和<code>nohup+&amp;</code>之间的对比</h3><p><code>systemd</code>可以满足以下需求:</p>
<ul>
<li>方便分析问题的服务运行日志记录</li>
<li>服务管理的日志</li>
<li>异常退出时可以根据需要重新启动</li>
</ul>
<p>而<code>nohup</code> 只能记录服务运行时的输出和出错日志, 根据我们实际的需求进行选择即可</p>
<p><strong>本文为作者原创 转载时请注明出处 谢谢</strong></p>
<p><a href="https://space.bilibili.com/485691562" target="_blank" rel="noopener">B站入口</a></p>
<p><a href="https://code.newban.cn/0.html">打赏通道</a></p>
<p>微信公众号二维码如下:</p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt="img"></p>
<p><em><a href="https://code.newban.cn/">乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</a></em></p>
]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>docker容器相互通信的实现</title>
    <url>/274.html</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p><code>docker</code>容器处在宿主内部的局域网络之中, 一般来说, 我们直接使用局域网<code>ip</code>即可访问, 但考虑到容器重启后<code>ip</code>可能会发生变化, 所以这种直接使用容器的<code>ip</code>的方案并不稳妥</p>
<p>那如果使用公网<code>ip</code>, 映射访问的话, 似乎稳定一些, 但是也存在问题, 比如<code>docker</code>跨服迁移, 那么<code>ip</code>还得手动修改, 同时公网访问速度上肯定不如内网</p>
<p>所以还得另寻他法</p>
<p>事实上 <code>Docker</code>官方已经给我们提供了解决办法, 那就是使用<code>Bridge</code>桥接网络, 这样 我们可以直接使用容器名充当局域网<code>ip</code>进行容器间相互访问</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/1608824-20190920010803495-1744046885.png" alt="img"></p>
<h3 id="操作步骤"><a href="#操作步骤" class="headerlink" title="操作步骤"></a>操作步骤</h3><ol>
<li><p><strong>创建bridge网络</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker network create -d bridge 自定义网络名称</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>创建容器时指定<code>bridge</code>网络</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run -id --name=first --network 网络名 ubuntu:latest</span><br><span class="line"></span><br><span class="line">docker run -id --name=second --network 网络名 ubuntu:latest</span><br></pre></td></tr></table></figure>

<p>这样两个容器就处在了同一个桥接网络下, 容器间自动link, 彼此可以相互访问</p>
</li>
<li><p><strong>访问测试</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 进入第一个容器</span><br><span class="line">docker exec -it first bash</span><br><span class="line"># 使用容器名ping</span><br><span class="line">ping second</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="其他操作"><a href="#其他操作" class="headerlink" title="其他操作"></a>其他操作</h3><ol>
<li><p><strong>如果要查看当前已经存在的桥接网络列表</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker network ls</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h3><p>除了方便容器间通信外, 结合<code>Nginx</code>还可以减少服务器端口开放数量, 消除不必要的安全隐患</p>
<p>比如不使用桥接网络时, <code>Nginx</code>反向代理配置是这样的:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http&#123;</span><br><span class="line">upstream wordpress_sex&#123;</span><br><span class="line">server 服务器公网IP:7778;</span><br><span class="line">&#125;</span><br><span class="line">server&#123;</span><br><span class="line">        listen       80;</span><br><span class="line">    server_name sex.newban.cn;</span><br><span class="line">    location / &#123;</span><br><span class="line">            proxy_redirect off;</span><br><span class="line">            proxy_set_header Host $host;</span><br><span class="line">            proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line">            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">            proxy_pass http://wordpress_sex;</span><br><span class="line">            break;</span><br><span class="line">                 &#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用桥接网络后:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http&#123;</span><br><span class="line">upstream wordpress_sex&#123;</span><br><span class="line">server 容器名:80;</span><br><span class="line">&#125;</span><br><span class="line">server&#123;</span><br><span class="line">        listen       80;</span><br><span class="line">    server_name sex.newban.cn;</span><br><span class="line">    location / &#123;</span><br><span class="line">            proxy_redirect off;</span><br><span class="line">            proxy_set_header Host $host;</span><br><span class="line">            proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line">            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">            proxy_pass http://wordpress_sex;</span><br><span class="line">            break;</span><br><span class="line">                 &#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>无论是移植性和安全性都得到了大大的提升</p>
<p><strong>但是有一点需要注意</strong>, <code>nginx</code>配置文件在<code>nginx</code>启动成功之前会检测<code>server</code>节点下的<code>host</code>地址是否可通, 如果存在无法接通的<code>host</code>, 则<code>nginx</code>无法启动,</p>
<p>也就是说我们使用<code>server 容器名:80</code>这种配置 当我们的<code>docker</code>容器挂了或者停止运行时, 如果此时重启<code>nginx</code>则会启动失败, 这一点我们需要提前知晓, 避免到时重启时出了问题摸不着头脑</p>
<p><strong>本文为作者原创 转载时请注明出处 谢谢</strong></p>
<p><a href="https://space.bilibili.com/485691562" target="_blank" rel="noopener">B站入口</a></p>
<p><a href="https://code.newban.cn/0.html">打赏通道</a></p>
<p>微信公众号二维码如下:</p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt="img"></p>
<p><em><a href="https://code.newban.cn/">乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</a></em></p>
]]></content>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>推荐一个谷歌浏览器下的护眼小插件</title>
    <url>/275.html</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>作为IT工作者, 长时间对着电脑屏幕, 眼睛实在是疲惫不堪, 即便我将电脑屏幕亮度调至非常低 也无济于事</p>
<p>唯独 夜间模式能稍加缓解, 但是浏览器依旧是白花花一片 太过扎眼, 于是乎找了个暗黑小插件, 就此拯救了我的双眼</p>
<p>话不多说 如下:</p>
<h3 id="DARK-READER"><a href="#DARK-READER" class="headerlink" title="DARK READER"></a>DARK READER</h3><p>名为<code>DARK READER</code>的插件, 配置如下:</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20210917122822225.png" alt></p>
<p>效果如下:</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20210917123155838.png" alt="image-20210917123155838"></p>
<h3 id="插件下载"><a href="#插件下载" class="headerlink" title="插件下载"></a>插件下载</h3><p><a href="https://chrome.google.com/webstore/detail/dark-reader/eimadpbcbfnmbkopoojfekhnkhdbieeh" target="_blank" rel="noopener">谷歌官方商店下载</a></p>
<p>考虑到大部分国内用户无法访问谷歌网站, 这里给大家推荐两个国内下载站点:</p>
<ol>
<li><p><a href="https://chrome.zzzmh.cn/" target="_blank" rel="noopener">极简插件</a></p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20210917141518519.png" alt="image-20210917141518519"></p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20210917141441356.png" alt="image-20210917141441356"></p>
</li>
<li><p><a href="https://www.crxsoso.com/" target="_blank" rel="noopener">CRX搜搜</a></p>
<p>不仅支持名称搜索, 还支持扩展地址搜索</p>
<p>比如插件官方扩展地址：<code>https://chrome.google.com/webstore/detail/dhdgffkkebhmkfjojejmpbldmpobfkfo</code></p>
<p><img src="https://cdn.jsdelivr.net/gh/youxiaohou/img/20210715161332.png" alt="img"></p>
<p><img src="https://gitee.com/songjianzaina/site_img/raw/master/img/image-20240418185205986.png" alt="image-20240418185205986"></p>
<p>根据名称关键字搜索下载:</p>
<p><img src="https://cdn.jsdelivr.net/gh/youxiaohou/img/20210715161537.png" alt="img"></p>
<p><img src="https://gitee.com/songjianzaina/site_img/raw/master/img/image-20240418185348662.png" alt="image-20240418185348662"></p>
</li>
</ol>
<p><strong>本文为作者原创 转载时请注明出处 谢谢</strong></p>
<p><a href="https://space.bilibili.com/485691562" target="_blank" rel="noopener">B站入口</a></p>
<p><a href="https://code.newban.cn/0.html">打赏通道</a></p>
<p>微信公众号二维码如下:</p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt="img"></p>
<p><em><a href="https://code.newban.cn/">乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</a></em></p>
]]></content>
      <tags>
        <tag>实用工具</tag>
      </tags>
  </entry>
  <entry>
    <title>使用docker部署Django项目</title>
    <url>/277.html</url>
    <content><![CDATA[<h2 id="部署Django项目"><a href="#部署Django项目" class="headerlink" title="部署Django项目"></a>部署Django项目</h2><ol>
<li><p>搜索<code>python</code>镜像</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker search python</span><br></pre></td></tr></table></figure>
</li>
<li><p>拉取<code>python</code>镜像</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker pull python</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建并运行容器</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run -id \</span><br><span class="line">--name=c_django \</span><br><span class="line">-p 8000:8000 \</span><br><span class="line">-v /root/app:/root/app</span><br><span class="line">-h c_django \</span><br><span class="line"> python:latest</span><br></pre></td></tr></table></figure>
</li>
<li><p>将源程序上传至服务器</p>
<p>可以使用<code>FTP</code>工具或者<code>scp</code>指令上传 其他也可</p>
</li>
<li><p>进入程序目录 安装依赖包</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip install -r requirements.txt</span><br></pre></td></tr></table></figure>
</li>
<li><p>启动程序</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python manage.py runserver 0.0.0.0:8000</span><br></pre></td></tr></table></figure>
</li>
<li><p>网站访问</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http://服务器ip:8000</span><br></pre></td></tr></table></figure>













</li>
</ol>
<p><strong>本文为作者原创 转载时请注明出处 谢谢</strong></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em>乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</em></p>
]]></content>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>记录一次504 Gateway Time-out的解决</title>
    <url>/276.html</url>
    <content><![CDATA[<h3 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h3><p>今早起来, 突然发现网站挂了, 直接报<code>504 Gateway Time-out</code></p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20210918111428739.png" alt="image-20210918111428739"></p>
<h3 id="经过"><a href="#经过" class="headerlink" title="经过"></a>经过</h3><p>我立马联想是否是<code>docker</code>挂了或者数据库容器出了问题</p>
<p>进入终端 使用<code>docker ps</code> 所有容器都在正常运行 没问题, 然后<code>docker logs --tail=10 mysql</code>数据库也没报错</p>
<p>我怀疑是不是docker内部哪里卡住了, 于是<code>systemctl restart docker</code>立马重启<code>docker</code>, 然后重新访问网站 还是不行</p>
<p>有点懵了, 到底哪里出了问题呢? 网上说是<code>Nginx</code>配置问题, 可是我<code>nginx</code>配置一直都没动过, 而且查看<code>nginx</code>容器日志也是正常, 难道是<code>docker</code>容器间通信不正常?</p>
<p>紧接着我又进入<code>nginx</code>容器, 使用<code>nc -zv wordpress 80</code>指令进行容器间通信测试, 也是正常打通的</p>
<p>这问题到底是出在哪了?</p>
<p>难道真的只是超时?  我给的时间太短了不成? 于是乎 我干脆将<code>nginx</code>反向代理超时时间调大, 死马当活马医, 不试试怎么知道呢</p>
<p>我将以下三行配置加入到代理块中:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">proxy_connect_timeout 300s;</span><br><span class="line">    proxy_send_timeout 300s;</span><br><span class="line">    proxy_read_timeout 300s;</span><br></pre></td></tr></table></figure>

<p>具体配置如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">location /foo &#123;</span><br><span class="line">     proxy_pass http://xxx.xxx.xxx.xxx:8080/foo;</span><br><span class="line">     proxy_set_header Host $host;</span><br><span class="line">     proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line">     proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">     </span><br><span class="line">     proxy_connect_timeout 300s;</span><br><span class="line">     proxy_send_timeout 300s;</span><br><span class="line">     proxy_read_timeout 300s;</span><br><span class="line">     break;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后重启<code>nginx</code>, 这时访问网站 次数<code>504 Gateway Time-out</code>消失了, 换成了<code>Error establishing a database connection</code></p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20210918111216604.png" alt="image-20210918111216604"></p>
<p>我靠, 原来还是数据库的问题</p>
<h3 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h3><p>我开始回忆, 前段时间刚进行<code>docker</code>跨服务器迁移, 昨天旧服务器刚好到期停机, 今天就突然访问不上了, 难道我的程序此时访问的还是原来旧服务器的数据库</p>
<p>对了 我的源码目录是直接从旧服务器拷贝过来的, 虽然<code>docker</code>容器是新建的, 但是因为存在旧目录 所以<code>docker run</code>配置的数据库参数全部无法重写, 也就是说程序配置文件中的数据库连接参数没有被重写</p>
<p>恍然大悟, 立马进入源程序目录找到配置文件打开查看, 果真如此, 然后将其修改为新的</p>
<p>此时重新访问, 网站正常显示</p>
<h1 id><a href="#" class="headerlink" title></a></h1><p><strong>本文为作者原创 转载时请注明出处 谢谢</strong></p>
<p><a href="https://space.bilibili.com/485691562" target="_blank" rel="noopener">B站入口</a></p>
<p><a href="https://code.newban.cn/0.html">打赏通道</a></p>
<p>微信公众号二维码如下:</p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt="img"></p>
<p><em><a href="https://code.newban.cn/">乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</a></em></p>
]]></content>
      <tags>
        <tag>运维</tag>
      </tags>
  </entry>
  <entry>
    <title>Kindle传书的几种便捷方式</title>
    <url>/279.html</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>给使用<code>kindle</code>的小伙伴介绍几种好用的传书方法</p>
<h3 id="第一种-使用网页传书"><a href="#第一种-使用网页传书" class="headerlink" title="第一种 使用网页传书"></a>第一种 使用网页传书</h3><p>以轻松传这个网站为例:</p>
<p>官方网址: <a href="https://easychuan.cn/" target="_blank" rel="noopener">https://easychuan.cn/</a></p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20210930094805282.png" alt="image-20210930094805282"></p>
<p>我们只需要将文件上传, 得到一个取件码, 然后在kindle中打开体验版浏览器, 同样输入<code>https://easychuan.cn/</code></p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20210930095755229.png" alt="image-20210930095755229"></p>
<p>填入相应的取件码就可以直接下载了</p>
<p>类似这样的网站除了<strong>轻松传</strong>之外, 还有<strong>快牙</strong>:</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20211223145143645.png" alt="image-20211223145143645"></p>
<p><a href="https://yun.kuaiya.cn/" target="_blank" rel="noopener"><strong>点击进入快牙传输网站</strong></a></p>
<p>还有就是<code>Feem</code>的<code>WebShare</code>功能也可以传输文件, 直接通过一个<code>ip</code>和端口号进行访问下载, 不过仅限于局域网内:</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20211223145420896.png" alt="image-20211223145420896"></p>
<p><a href="https://www.feem.io/" target="_blank" rel="noopener"><strong>点击进入Feem官网</strong></a></p>
<h3 id="第二种-使用邮箱传书"><a href="#第二种-使用邮箱传书" class="headerlink" title="第二种 使用邮箱传书"></a>第二种 使用邮箱传书</h3><p><code>kindle</code>亚马逊账号登录后会自动分配一个邮箱账号, 这个账号可以在<code>kindle</code>设置中进行查看获取</p>
<p>我们只需要将文件发送到这个邮箱账号上即可</p>
<p>注意<strong>使用的是邮件附件 而不是超大附件</strong></p>
<h3 id="第三种-使用Kindle-App"><a href="#第三种-使用Kindle-App" class="headerlink" title="第三种 使用Kindle App"></a>第三种 使用Kindle App</h3><p><code>Kindle App</code> 是亚马逊开发出的阅读 App，可用于同步我们在亚马逊 Kindle 书城购买中购买的书到各个客户端（Windows、OSX、Android 以及 iOS）</p>
<p>可以看成是<code>App</code>版的<code>Kindle</code>, 除了可以用来看书外, 还可以用来传书</p>
<p>只需登录<code>kindle</code>账号然后直接上传发送即可</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20210930101514103.png" alt="image-20210930101514103"></p>
<h3 id="第四种-USB传书"><a href="#第四种-USB传书" class="headerlink" title="第四种 USB传书"></a>第四种 USB传书</h3><p>简单粗暴, 快捷高效, 这个不用多说, 一根数据线的事</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li><code>EasyChuan网页</code>: 支持电脑和手机, 无需登录, 如果文件不多的话推荐使用该方法</li>
<li><code>USB传书</code>: 文件大小无限制, 如果批量传书推荐该方法</li>
</ul>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20210930101639592.png" alt="image-20210930101639592"></p>
<p><strong>本文为作者原创 转载时请注明出处 谢谢</strong></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em><a href="https://code.newban.cn/">乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</a></em></p>
]]></content>
      <tags>
        <tag>kindle</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo 设置新建文章时自动打开md编辑器</title>
    <url>/28.html</url>
    <content><![CDATA[<p>在<code>Hexo</code>中新建一篇博文非常简单，只需要在命令行中键入以下命令然后回车即可：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo new &quot;The title of your blog&quot;</span><br></pre></td></tr></table></figure>

<p>然后hexo就会在hexo的根目录下的<code>source</code>目录下的<code>_post</code>目录下自动创建相对应的md文件。然后我们只需要找到刚刚生成的文件进行编辑就可以了。</p>
<p>但是一旦文章比较多的情况下，我们就需要在成堆的md文件中找刚刚创建的博文，这就比较麻烦。</p>
<hr>
<p>好在hexo的github上有类似的issue，然后hexo作者也可给出了解决方法：</p>
<blockquote>
<p>ou can try to listen to the new event. For example:</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var exec = require(&apos;child_process&apos;).exec;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">hexo.on(&apos;new&apos;, function(path)&#123;</span><br><span class="line">  exec(&apos;vi&apos;, [path]);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// Hexo 3</span><br><span class="line">hexo.on(&apos;new&apos;, function(data)&#123;</span><br><span class="line">  exec(&apos;vi&apos;, [data.path]);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>根据作者给的示例给出了下列的解决方法：</p>
<ul>
<li><p>首先在<code>hexo</code>目录下的<code>script</code>目录下创建一个js脚本（没有的这个目录的话自己创建一个）。</p>
</li>
<li><p>js脚本的命名自定义，然后在脚本中写入以下代码。</p>
</li>
<li><p>windows端:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var spawn = require(&apos;child_process&apos;).exec;</span><br><span class="line"></span><br><span class="line">// Hexo 2.x 用户复制这段</span><br><span class="line">hexo.on(&apos;new&apos;, function(path)&#123;</span><br><span class="line">  spawn(&apos;start  &quot;markdown编辑器绝对路径.exe&quot; &apos; + path);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// Hexo 3 用户复制这段</span><br><span class="line">hexo.on(&apos;new&apos;, function(data)&#123;</span><br><span class="line">  spawn(&apos;start  &quot;markdown编辑器绝对路径.exe&quot; &apos; + data.path);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>mac os端：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var exec = require(&apos;child_process&apos;).exec;</span><br><span class="line"></span><br><span class="line">// Hexo 2.x 用户复制这段</span><br><span class="line">hexo.on(&apos;new&apos;, function(path)&#123;</span><br><span class="line">    exec(&apos;open -a &quot;markdown编辑器绝对路径.app&quot; &apos; + path);</span><br><span class="line">&#125;);</span><br><span class="line">// Hexo 3 用户复制这段</span><br><span class="line">hexo.on(&apos;new&apos;, function(data)&#123;</span><br><span class="line">    exec(&apos;open -a &quot;markdown编辑器绝对路径.app&quot; &apos; + data.path);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>不过我在网上找了很久都没有发现有<code>linux</code>端的操作脚本，然后自己试着改了下，能在我的电脑(<code>debian/ubuntu</code>试过了没问题)上成功跑起来了，po下代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var exec = require(&apos;child_process&apos;).exec;</span><br><span class="line"></span><br><span class="line">// Hexo 2.x 用户复制这段</span><br><span class="line">hexo.on(&apos;new&apos;, function(path)&#123;</span><br><span class="line">    exec(&apos;vim &apos; + path);</span><br><span class="line">&#125;);</span><br><span class="line">// Hexo 3 用户复制这段</span><br><span class="line">hexo.on(&apos;new&apos;, function(data)&#123;</span><br><span class="line">    exec(&apos;vim &apos; + data.path);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><strong>本文为作者原创 转载时请注明出处 谢谢</strong></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em>乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</em></p>
]]></content>
      <tags>
        <tag>hexo技巧</tag>
      </tags>
  </entry>
  <entry>
    <title>Vim文本编辑器快速上手操作指南</title>
    <url>/278.html</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>做开发的小伙伴对<code>vim</code>编辑器肯定不陌生, 无论你是使用<code>Linux</code>终端, 还是使用<code>Git</code>操作仓库的时候都经常会碰的上</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20210918161103435.png" alt="image-20210918161103435"></p>
<p>刚开始接触的时候肯定是感觉非常费劲, 毕竟我们已经习惯了用鼠标定位操作的编辑器</p>
<p>而<code>VIM</code>编辑器, 可以说是纯靠键盘定位和编辑, 你想快速编辑某一处的内容, 鼠标根本帮不了你, 只能依靠键盘</p>
<p>如此反人类的操作, 对于开发者的你来说, 却不得不学</p>
<p>既然如此, 一些常用的操作指令 我们需要掌握</p>
<h3 id="操作指令"><a href="#操作指令" class="headerlink" title="操作指令"></a>操作指令</h3><ol>
<li><p><strong>用<code>vim</code>编辑器打开文本文件</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vim 文件名</span><br></pre></td></tr></table></figure>

<p>打开文件后进入默认模式, 该模式下文本可以查看但不能编辑</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">shift+冒号</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>进入文本编辑模式</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">敲键盘上的字母 i 或者 a</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>进入命令输入模式</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">敲键盘上的 :</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>进入全局可视化模式</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">敲键盘上的字母 v</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>恢复到默认模式</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">敲键盘上的 ESC</span><br></pre></td></tr></table></figure>
</li>
<li><p>保存文本内容</p>
<p>命令模式下输入以下字母并且回车:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">w 保存内容</span><br><span class="line">w &lt;文件路径&gt; 另存为</span><br><span class="line">saveas 文件路径 另存为</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="7">
<li><p><strong>退出编辑器</strong></p>
<p>命令模式下输入以下字母并且回车:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">q  退出编辑器</span><br><span class="line">q! 强制退出编辑器</span><br><span class="line">wq 保存文本内容 并退出编辑器</span><br><span class="line">wq! 保存文本内容 并强制退出编辑器</span><br><span class="line">x 保存文本内容 并退出编辑器</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h5 id="在默认模式下可以进行的操作"><a href="#在默认模式下可以进行的操作" class="headerlink" title="在默认模式下可以进行的操作"></a>在默认模式下可以进行的操作</h5><p>默认模式下可以使用键盘上的上下左右键移动光标查看文本内容, 除此之外, 还可以:</p>
<ol>
<li><p><strong>删除内容</strong></p>
<table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>x</code></td>
<td>删除游标所在的字符</td>
</tr>
<tr>
<td><code>X</code></td>
<td>删除游标所在前一个字符</td>
</tr>
<tr>
<td><code>Delete</code></td>
<td>同<code>x</code></td>
</tr>
<tr>
<td><code>dd</code></td>
<td>删除整行</td>
</tr>
<tr>
<td><code>dj</code></td>
<td>删除当前行和下一行</td>
</tr>
<tr>
<td><code>dk</code></td>
<td>删除当前行和上一行</td>
</tr>
<tr>
<td><code>dh</code></td>
<td>删除光标左边的一个字符</td>
</tr>
<tr>
<td><code>dl</code></td>
<td>删除光标右边的一个字符</td>
</tr>
<tr>
<td><code>dw</code></td>
<td>删除一个单词（不适用中文）</td>
</tr>
<tr>
<td><code>d$</code>或<code>D</code></td>
<td>删除至行尾</td>
</tr>
<tr>
<td><code>d^</code></td>
<td>删除至行首</td>
</tr>
<tr>
<td><code>dG</code></td>
<td>删除到文档结尾处</td>
</tr>
<tr>
<td><code>d1G</code></td>
<td>删至文档首部</td>
</tr>
<tr>
<td><code>ndd</code></td>
<td>一次性向下删除n行</td>
</tr>
</tbody></table>
</li>
<li><p><strong>光标移动</strong></p>
<p>除了使用上下左右键之外还可用字母:</p>
<p>方向键或者<code>h</code>,<code>j</code>,<code>k</code>,<code>l</code>键可以移动游标。</p>
<table>
<thead>
<tr>
<th>按键</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>h</code></td>
<td>左</td>
</tr>
<tr>
<td><code>l</code></td>
<td>右（小写L）</td>
</tr>
<tr>
<td><code>j</code></td>
<td>下</td>
</tr>
<tr>
<td><code>k</code></td>
<td>上</td>
</tr>
<tr>
<td><code>w</code></td>
<td>移动到下一个单词</td>
</tr>
<tr>
<td><code>b</code></td>
<td>移动到上一个单词</td>
</tr>
<tr>
<td><code>gg</code></td>
<td>移动到文本头部</td>
</tr>
<tr>
<td><code>G</code></td>
<td>移动到文本末尾</td>
</tr>
</tbody></table>
</li>
<li><p><strong>不同位置插入内容</strong></p>
<table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>i</code></td>
<td>在当前光标处进行编辑</td>
</tr>
<tr>
<td><code>I</code></td>
<td>在行首插入</td>
</tr>
<tr>
<td><code>A</code></td>
<td>在行末插入</td>
</tr>
<tr>
<td><code>a</code></td>
<td>在光标后插入编辑</td>
</tr>
<tr>
<td><code>o</code></td>
<td>在当前行后插入一个新行</td>
</tr>
<tr>
<td><code>O</code></td>
<td>在当前行前插入一个新行</td>
</tr>
<tr>
<td><code>cw</code></td>
<td>替换从光标所在位置后到一个单词结尾的字符</td>
</tr>
</tbody></table>
</li>
<li><p><strong>复制当前行</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">y</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>粘贴到下一行</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">p</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>撤销操作</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">u</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>回滚操作</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ctrl+r</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>退出编辑器</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">shirt+zz</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h5 id="在可视化模式下可以进行的操作"><a href="#在可视化模式下可以进行的操作" class="headerlink" title="在可视化模式下可以进行的操作"></a>在可视化模式下可以进行的操作</h5><p>可视化模式下可以快速对内容进行选中, 选中的内容会高亮显示</p>
<ol>
<li><p><strong>选中全部内容</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 普通模式下敲gg（把关标定位到最上面）</span><br><span class="line">2. 普通模式下敲v（进入VISUAL模式）</span><br><span class="line">3. 然后敲 shift+g（选中整篇文本）</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>复制文本全部内容</strong></p>
<p>选中全部内容后输入以下字符:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">y 复制到vim编辑器中</span><br><span class="line">+y 复制到系统剪贴板中</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>对内容进行格式化</strong></p>
<p>选中全部内容后输入以下字符:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">＝</span><br></pre></td></tr></table></figure>







</li>
</ol>
<p><strong>本文为作者原创 转载时请注明出处 谢谢</strong></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em><a href="https://code.newban.cn/">乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</a></em></p>
]]></content>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>如何撤销上一次 Git add 的内容</title>
    <url>/280.html</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>有时候, 我们使用<code>git add .</code>不小心误添加了某些个文件到本地暂存库中, 如果我们需要撤销该<code>add</code>记录, 可以通过以下方式</p>
<h3 id="撤销指令"><a href="#撤销指令" class="headerlink" title="撤销指令"></a>撤销指令</h3><ol>
<li><p>撤销上次<code>add</code>的指定文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git reset HEAD &lt;路径/文件名&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>撤销上次<code>add</code>的所有文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git reset HEAD</span><br></pre></td></tr></table></figure>





</li>
</ol>
<p><strong>本文为作者原创 转载时请注明出处 谢谢</strong></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em><a href="https://code.newban.cn/">乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</a></em></p>
]]></content>
      <tags>
        <tag>kindle</tag>
      </tags>
  </entry>
  <entry>
    <title>关于Android中adjustResize属性不生效的问题</title>
    <url>/284.html</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>写聊天布局的时候需要给<code>Activity</code>用上<code>adjustResize</code>属性来保证输入框不会被软键盘遮盖住</p>
<p>如果该属性不生效, 那么一般情况是没有给布局添加<code>fitsSystemWindows</code>属性, 那么给布局根控件添加该属性即可:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">android:fitsSystemWindows=&quot;true&quot;</span><br></pre></td></tr></table></figure>

<p>此时<code>adjustResize</code>属性生效, 但是新问题又出现了, 布局上方出现了一块间隔区域</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20211122135418218.png" alt="image-20211122135418218"></p>
<h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><p>重写根控件的<code>onApplyWindowInsets</code>方法, 如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class ChatLayout @JvmOverloads constructor(</span><br><span class="line"></span><br><span class="line">    context: Context,</span><br><span class="line">    attrs: AttributeSet? = null,</span><br><span class="line">    defStyleAttr: Int = 0</span><br><span class="line">) : ConstraintLayout(context, attrs, defStyleAttr) &#123;</span><br><span class="line">		</span><br><span class="line">    override fun onApplyWindowInsets(insets: WindowInsets): WindowInsets &#123;</span><br><span class="line">        return super.onApplyWindowInsets(insets.replaceSystemWindowInsets(0, 0, 0,</span><br><span class="line">            insets.systemWindowInsetBottom</span><br><span class="line">        ));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>问题解决</p>
<p><strong>本文为作者原创 转载时请注明出处 谢谢</strong></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em><a href="https://code.newban.cn/">乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</a></em></p>
]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>YouTube视频和字幕下载以及合并的工具推荐</title>
    <url>/282.html</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>最近有一个视频下载的需求, 需要将视频以及中英文字幕下载下来, 于是乎用到了一些工具, 有些使用体验还不错, 在此推荐给大家</p>
<h3 id="视频下载"><a href="#视频下载" class="headerlink" title="视频下载"></a>视频下载</h3><p>以下以YouTube视频网站为例: </p>
<p><a href="https://www.y2mate.com/" target="_blank" rel="noopener">YouTube视频或音频在线下载</a> :这个需要梯子</p>
<p><a href="https://youtube.iiilab.com/" target="_blank" rel="noopener">YouTube视频在线下载</a> :这个不需要梯子 而且支持手机端</p>
<p><a href="https://www.jihosoft.cn/tubeget/" target="_blank" rel="noopener">YouTue视频下载软件</a> 免费用户每天可以下载5个不带字幕视频 格式转换和视频与字幕合并功需要付费能 支持<code>Windows</code>和<code>Mac</code>平台</p>
<p><a href="https://saveyt.cc/" target="_blank" rel="noopener">国外视频在线下载</a>: 支持下载<code>YouTube</code>、<code>TikTok</code>、<code>Facebook</code>、<code>Twitter</code>、<code>Instagram</code>等视频</p>
<p><img src="https://gitee.com/songjianzaina/site_img/raw/master/img/image-20240404184925016.png" alt="image-20240404184925016"></p>
<p>如果你是Mac用户, 那么有一个网站推荐给大家:</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20220805174904728.png" alt="image-20220805174904728"></p>
<p>网站官网: <a href="https://www.imacso.com/" target="_blank" rel="noopener">点击进入</a></p>
<h3 id="字幕下载"><a href="#字幕下载" class="headerlink" title="字幕下载"></a>字幕下载</h3><p><a href="https://downsub.com/" target="_blank" rel="noopener">YouTube字幕在线下载</a> 支持多种语言和双语字幕</p>
<h3 id="视频和字幕合并"><a href="#视频和字幕合并" class="headerlink" title="视频和字幕合并"></a>视频和字幕合并</h3><p>这个就得使用软件了, 免费的有:</p>
<ul>
<li>格式工厂</li>
<li>诸如pr、剪映、比剪等剪辑工具</li>
<li><a href="https://maruko.appinn.me/" target="_blank" rel="noopener">小丸工具箱</a> 目前只支持Windows平台</li>
<li><a href="https://subler.org/" target="_blank" rel="noopener">Subler</a> 目前只支持Mac平台</li>
<li><a href="https://url97.ctfile.com/f/21042697-518765173-9ada39" target="_blank" rel="noopener">tipard_video_converter_ultimate</a> 提供Mac下载 （访问密码：312306）</li>
<li><a href="https://handbrake.fr/" target="_blank" rel="noopener">HandBrake</a> 支持Windows和Mac  推荐使用</li>
</ul>
<p>如果非要在线合并的话, 推荐使用<a href="https://member.bilibili.com/studio/bs-editor" target="_blank" rel="noopener">B站的云剪辑</a></p>
<p>其界面长这样:</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20211026171444006.png" alt="image-20211026171444006"></p>
<p>如果你刚好是UP主, 需要合并完视频后直接投稿, 可以使用这种方式, 挺方便的</p>
<p>然而最后我选择了<code>tipard_video_converter_ultimate</code>这个软件处理字幕和视频的合并, 界面如下:</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20211026170010642.png" alt="image-20211026170010642"></p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20211026171217226.png" alt="image-20211026171217226"></p>
<p>这个软件不仅可以添加字幕 同时也可以移除字幕或者音频</p>
<p>就是转换的速度不是很快, 导出的视频文件体积过大 两百多M的视频, 花了快十分钟 最后视频体积高达2个G , 如果对视频体积有要求话, 建议大家直接使用<code>HandBrake</code>, 输出的体积和原文件差不多, 甚至更小</p>
<p>值得欣慰的是字幕合成的质量不错:</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20211026175323771.png" alt="image-20211026175323771"></p>
<p>我还尝试了使用B站云端剪辑合成, 没有对比就没有伤害:</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20211026175441786.png" alt="image-20211026175441786"></p>
<p><strong>本文为作者原创 转载时请注明出处 谢谢</strong></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em><a href="https://code.newban.cn/">乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</a></em></p>
]]></content>
      <tags>
        <tag>PC工具</tag>
      </tags>
  </entry>
  <entry>
    <title>解决Mac平台USB移动硬盘无法写入和删除数据的问题</title>
    <url>/281.html</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>使用Mac的小伙伴应该会碰到相关问题</p>
<p>我们在接入移动硬盘时只能读取数据却不能写入或者删除数据</p>
<p>这是移动硬盘格式不兼容导致的, 可以通过格式化硬盘的方式来实现Mac和Windows平台双端兼容, 但格式化意味着移动硬盘数据全部被清除</p>
<p>这肯定不是我们想要的</p>
<p>为了解决这个问题, 网上也出了相关的NTFS读写, 但是都是收费的</p>
<p>后来找到一款免费的NTFS移动硬盘读写工具 名为Omi NTFS, 体验还不错 这里推荐给大家使用</p>
<h3 id="工具下载地址"><a href="#工具下载地址" class="headerlink" title="工具下载地址"></a>工具下载地址</h3><p><a href="https://url97.ctfile.com/f/21042697-518378723-46d038" target="_blank" rel="noopener">点击下载</a></p>
<p>（访问密码：312306）</p>
<p><strong>本文为作者原创 转载时请注明出处 谢谢</strong></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em><a href="https://code.newban.cn/">乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</a></em></p>
]]></content>
      <tags>
        <tag>Mac工具</tag>
      </tags>
  </entry>
  <entry>
    <title>android中获取控件坐标的几种api区分</title>
    <url>/285.html</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>我们经常会看到以下几个方法:</p>
<ul>
<li><p>getGlobalVisibleRect()</p>
</li>
<li><p>getLocalVisibleRect()</p>
</li>
<li><p>getLocationOnScreen()</p>
</li>
<li><p>getLocationInWindow()</p>
</li>
</ul>
<p>傻傻分不清?  今天我们简单介绍一下它们各自的作用</p>
<h3 id="getGlobalVisibleRec"><a href="#getGlobalVisibleRec" class="headerlink" title="getGlobalVisibleRec"></a>getGlobalVisibleRec</h3><p>方法作用:</p>
<p><strong>其一</strong>: 用于判断控件是否可见, 以屏幕为参考 如果可见返回true, 不可见返回false, 我们可以借助该方法检测控件是否被滑出屏幕外</p>
<p><strong>其二</strong>: 用于获取控件可见区域的坐标, 这个坐标是相对于屏幕而言</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/20200518140750458.png" alt="在这里插入图片描述"></p>
<p>坐标存放在了<code>Rect</code>对象中, 以参数的形式传入:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">getGlobalVisibleRect(new Rect)</span><br></pre></td></tr></table></figure>

<h3 id="getLocalVisibleRect"><a href="#getLocalVisibleRect" class="headerlink" title="getLocalVisibleRect"></a>getLocalVisibleRect</h3><p>这个方法和上面的<code>getGlobalVisibleRec</code>方法类似, 唯一区别是参考系不同, 这个方法参考系是控件本身</p>
<p>以下是这两个方法的坐标打印:</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/100911016491372.gif" alt="getRect"></p>
<h3 id="getLocationOnScreen"><a href="#getLocationOnScreen" class="headerlink" title="getLocationOnScreen"></a>getLocationOnScreen</h3><p>获取控件相对于屏幕而言的坐标位置, 与可不可见无关</p>
<h3 id="getLocationInWindow"><a href="#getLocationInWindow" class="headerlink" title="getLocationInWindow"></a>getLocationInWindow</h3><p>获取控件相对于父控件而言的坐标位置, 与可不可见无关</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/20200518144313585.png" alt="在这里插入图片描述"></p>
<h3 id="坐标补充"><a href="#坐标补充" class="headerlink" title="坐标补充"></a>坐标补充</h3><p>我们在进行自定义控件绘制的时候, 总是容易被一些参数给绕的头晕脑涨, 什么<code>top right, left, bottom</code>, 四条边与屏幕的距离等等, 想想就觉得费劲, 再加上<code>Android</code>中坐标系和我们数学中的坐标系不一致 使得我们在进行计算的时候难免有点吃不消</p>
<p>实际上对于一些规则的图形绘制, 比如矩形, 我们需要明白的一点, 那就是只需要两个点的坐标即可绘制出来, 也就是两个对角点</p>
<p>那我们在进行图形绘制的时候, 将计算范围缩小, 焦点集中在两个对角坐标位置计算上即可</p>
<p>这两个对角可以使左上角右下角, 也可以是左下角和右上角</p>
<p>这样一想, 那么所谓的<code>left</code>和<code>top</code>实际就是左上角的<code>xy</code>坐标, 而<code>right</code>和 <code>bottom</code>就是右下角的坐标</p>
<p><strong>本文为作者原创 转载时请注明出处 谢谢</strong></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em><a href="https://code.newban.cn/">乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</a></em></p>
]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>关于继承和接口的形象理解</title>
    <url>/283.html</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>很多<code>Java</code>初学者对于继承和接口的作用区分总是很模糊, 如果不是因为回调需要接口, 估计能用继承实现的都用了继承</p>
<p>继承和接口有很多相似的地方, 比如抽象实现</p>
<p>但是它们的不同点呢 这个就得考虑到实际应用场景了, 脱离了业务研究 啥也不是</p>
<p>今天我们只说一个形象比喻</p>
<h3 id="继承是先天-接口是后天"><a href="#继承是先天-接口是后天" class="headerlink" title="继承是先天 接口是后天"></a>继承是先天 接口是后天</h3><p>何为先天, 一生下来就有, 不要也得要, 说的高端一点这叫天赋</p>
<p>何为后天, 和父母无关 全靠自己</p>
<p>比如 父母有个好嗓子, 你继承了这个优点, 不用努力就比别人强</p>
<p>随着年龄的增长, 你发现干IT能促进植发行业的发展, 于是乎通过后天努力掌握了编程技能</p>
<p>那么</p>
<p><strong>好嗓子–继承而来–继承</strong></p>
<p><strong>编程技能–后天获取–接口</strong></p>
<p>似乎还是有点抽象 哈哈, 具体一点, 比如我们想让所有的子类都有相同的一个功能, 那我们可以使用继承</p>
<p>如果我们想让其中一部分子类有某个功能, 而剩下一些没有, 则可以使用接口, 实现差异化处理</p>
<p>也就是说接口的功能 可要可不要, 想要什么样的就接什么样的 比较自由 而继承的话全部子类必须都得有 没得选</p>
<p><strong>后天可以弥补先天的不足, 接口可以弥补继承的不全面</strong></p>
<p>不知道能不能理解</p>
<p>无妨 , 编程这东西 就是编程来的  慢慢就都明白了, 以上也只是个人的小小想法罢了</p>
<p><strong>本文为作者原创 转载时请注明出处 谢谢</strong></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em><a href="https://code.newban.cn/">乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</a></em></p>
]]></content>
      <tags>
        <tag>编程基础</tag>
      </tags>
  </entry>
  <entry>
    <title>android中获取控件宽高的几种方式总结</title>
    <url>/286.html</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>我们知道, 在<code>Activity</code>的<code>onCreate</code>中通过<code>width</code>和<code>height</code>方法是通常是无法获取到控件的宽高的</p>
<p>因为控件还未测量完毕</p>
<p>如果想要获取到值, 那么有以下几种方式可选</p>
<h3 id="第一种-获取前调用一次measure方法"><a href="#第一种-获取前调用一次measure方法" class="headerlink" title="第一种 获取前调用一次measure方法"></a>第一种 获取前调用一次<code>measure</code>方法</h3><p>示例如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int width = View.MeasureSpec.makeMeasureSpec(0,</span><br><span class="line">        View.MeasureSpec.UNSPECIFIED);</span><br><span class="line">int height = View.MeasureSpec.makeMeasureSpec(0,</span><br><span class="line">        View.MeasureSpec.UNSPECIFIED);</span><br><span class="line">view.measure(width, height);</span><br><span class="line">view.getMeasuredWidth(); // 获取宽度</span><br><span class="line">view.getMeasuredHeight(); // 获取高度</span><br></pre></td></tr></table></figure>

<h3 id="第二种-使用ViewTreeObserver-OnPreDrawListener进行绘制前事件监听"><a href="#第二种-使用ViewTreeObserver-OnPreDrawListener进行绘制前事件监听" class="headerlink" title="第二种 使用ViewTreeObserver. OnPreDrawListener进行绘制前事件监听"></a>第二种 使用<code>ViewTreeObserver. OnPreDrawListener</code>进行绘制前事件监听</h3><p>示例如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">view.getViewTreeObserver().addOnPreDrawListener(</span><br><span class="line">        new ViewTreeObserver.OnPreDrawListener() &#123;</span><br><span class="line"> </span><br><span class="line">    @Override</span><br><span class="line">    public boolean onPreDraw() &#123;</span><br><span class="line">        view.getViewTreeObserver().removeOnPreDrawListener(this);</span><br><span class="line">        view.getWidth(); // 获取宽度</span><br><span class="line">        view.getHeight(); // 获取高度</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>该方法会被调用多次，因此获取到视图的宽度和高度后要移除该监听事件</p>
<h3 id="第三种-使用ViewTreeObserver-OnGlobalLayoutListener"><a href="#第三种-使用ViewTreeObserver-OnGlobalLayoutListener" class="headerlink" title="第三种 使用ViewTreeObserver. OnGlobalLayoutListener"></a>第三种 使用<code>ViewTreeObserver. OnGlobalLayoutListener</code></h3><p>在布局发生改变或者某个视图的可视状态发生改变时调用该事件</p>
<p>示例如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">view.getViewTreeObserver().addOnGlobalLayoutListener(</span><br><span class="line">        new ViewTreeObserver.OnGlobalLayoutListener() &#123;</span><br><span class="line"> </span><br><span class="line">    @Override</span><br><span class="line">    public void onGlobalLayout() &#123;</span><br><span class="line">        if (Build.VERSION.SDK_INT &gt;= 16) &#123;</span><br><span class="line">            view.getViewTreeObserver()</span><br><span class="line">                    .removeOnGlobalLayoutListener(this);</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            view.getViewTreeObserver()</span><br><span class="line">                    .removeGlobalOnLayoutListener(this);</span><br><span class="line">        &#125;</span><br><span class="line">        view.getWidth(); // 获取宽度</span><br><span class="line">        view.getHeight(); // 获取高度</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>该方法会被多次调用，因此需要在获取到视图的宽度和高度后执行 remove 方法移除该监听事件。</p>
<h3 id="第四种-使用View-OnLayoutChangeListener"><a href="#第四种-使用View-OnLayoutChangeListener" class="headerlink" title="第四种 使用View.OnLayoutChangeListener"></a>第四种 使用<code>View.OnLayoutChangeListener</code></h3><p>在视图的 layout 改变时调用该事件, <code>API&gt;=11</code>才能使用</p>
<p>示例如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">view.addOnLayoutChangeListener(</span><br><span class="line">        new View.OnLayoutChangeListener() &#123;</span><br><span class="line"> </span><br><span class="line">    @Override</span><br><span class="line">    public void onLayoutChange(View v, int l, int t, int r, int b,</span><br><span class="line">            int oldL, int oldT, int oldR, int oldB) &#123;</span><br><span class="line">        view.removeOnLayoutChangeListener(this);</span><br><span class="line">        view.getWidth(); // 获取宽度</span><br><span class="line">        view.getHeight(); // 获取高度</span><br><span class="line">     &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>该方法同样会被多次调用，因此需要在获取到视图的宽度和高度后执行 remove 方法移除该监听事件。</p>
<h3 id="第五种-View-post-方法"><a href="#第五种-View-post-方法" class="headerlink" title="第五种 View.post() 方法"></a>第五种 View.post() 方法</h3><p>方法会在 View 的 measure、layout 等事件完成后触发</p>
<p>示例如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">view.post(new Runnable() &#123;</span><br><span class="line"> </span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        view.getWidth(); // 获取宽度</span><br><span class="line">        view.getHeight(); // 获取高度</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>该方法只会执行一次，且逻辑简单，建议使用</p>
<h3 id="第六种-重写-View-的-onSizeChanged-方法"><a href="#第六种-重写-View-的-onSizeChanged-方法" class="headerlink" title="第六种 重写 View 的 onSizeChanged 方法"></a>第六种 重写 View 的 onSizeChanged 方法</h3><p>在视图的大小发生改变时调用该方法，会被多次调用，因此获取到宽度和高度后需要考虑禁用掉代码</p>
<p>示例如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">protected void onSizeChanged(int w, int h, int oldw, int oldh) &#123;</span><br><span class="line">    super.onSizeChanged(w, h, oldw, oldh);</span><br><span class="line"> </span><br><span class="line">    view.getWidth(); // 获取宽度</span><br><span class="line">    view.getHeight(); // 获取高度</span><br></pre></td></tr></table></figure>

<p>该实现方法需要继承 View，且多次被调用，不建议使用</p>
<h3 id="第七种-重写-View-的-onLayout-方法"><a href="#第七种-重写-View-的-onLayout-方法" class="headerlink" title="第七种 重写 View 的 onLayout 方法"></a>第七种 重写 View 的 onLayout 方法</h3><p>示例如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">protected void onLayout(boolean changed, int l, int t, int r, int b) &#123;</span><br><span class="line">    super.onLayout(changed, l, t, r, b);</span><br><span class="line"> </span><br><span class="line">    view.getWidth(); // 获取宽度</span><br><span class="line">    view.getHeight(); // 获取高度</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该实现方法需要继承 View，且多次被调用，不建议使用</p>
<h3 id="实际场景"><a href="#实际场景" class="headerlink" title="实际场景"></a>实际场景</h3><p>目前有个业务需求, 我需要在<code>addView</code>之后获取到被<code>add</code>子控件的宽高, 此时最好的方法就是使用<code>View.post</code>, 如下:</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20211126123723329.png" alt="image-20211126123723329"></p>
<p><strong>本文为作者原创转载时请注明出处 谢谢</strong></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em><a href="https://code.newban.cn/">乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</a></em></p>
]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>越来越火的网络请求Fetch和Axios到底有什么区别</title>
    <url>/288.html</url>
    <content><![CDATA[<p>在这几天由于编写脚本等一系列原因，<strong>不知怎么的突然发现现在很多主流的网站已经大量开始使用Fetch进行网络请求</strong>，感觉再不学习Fetch就要Out了，所以我花了一些时间专门去研究了一下关于Fetch的相关知识，发现Fetch被讨论的并不多，很多都是一年前甚至两年前的文章，大多数文章最后得出来的结论几乎都是<strong>Axios比Fetch好用。</strong></p>
<p>事实确实如此，<strong>就我个人的体验来讲，Axios使用体验确实优于Fetch</strong>，那么为什么目前在很多大公司的网站上面都开始使用Fetch进行网络请求，带着这个疑问，我又去查找了很多资料，同时又自行将同样的请求使用Axios和Fetch进行尝试，最后得出一个结论：<strong>Fetch的优势仅仅在于浏览器原生支持。</strong></p>
<p>对的，其实<strong>Fetch比起Axios来讲几乎没有任何优势（除了浏览器原生支持）</strong>，Axios各个方面都比Fetch好用，Fetch要想实现Axios的一些功能还需要手动进行封装。</p>
<p>我截取了几个比较大的网站的请求图：</p>
<p>掘金：</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/v2-edffec624c2fbec0b489ddaf59613ff3_720w.jpg" alt="img"></p>
<p>YouTube：</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/v2-9670a0136a47e08acfda806feeb44521_720w.png" alt="img"></p>
<p>知乎：</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/v2-2c408cf91f7d6daf8721b341c60c7d6c_720w.jpg" alt="img"></p>
<p>需要注意的是：<strong>Axios是对XMLHttpRequest的封装，而Fetch是一种新的获取资源的接口方式，并不是对XMLHttpRequest的封装。</strong></p>
<p>它们<strong>最大的不同点在于Fetch是浏览器原生支持，而Axios需要引入Axios库。</strong></p>
<h2 id="1-火热程度"><a href="#1-火热程度" class="headerlink" title="1. 火热程度"></a><strong>1. 火热程度</strong></h2><p>虽然无法进行直观的比较，但是我们可以从npm包下载量来看：</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/v2-2a3d77bebd30d21187c5830a11a0c9c3_720w.jpg" alt="img"></p>
<p>因为Node环境下默认是不支持Fetch的，所以必须要使用<code>node-fetch</code>这个包，而这个包的周下载量一路攀升，可以看到已经来到了每周2千多万的下载量。这还仅仅是Node环境下，浏览器则是默认支持不需要第三方包。</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/v2-36007b64d9682fb5b6ad9cb8418c1a0e_720w.jpg" alt="img"></p>
<p>上面是Axios的下载量，可以看到也是一路攀升，Axios封装的各种方法确实非常的好用。</p>
<hr>
<p>本篇文章着重会从下面几项内容进行比较：</p>
<ul>
<li>兼容性</li>
<li>基本语法</li>
<li>响应超时</li>
<li>对数据的转化</li>
<li>HTTP拦截器</li>
<li>同时请求</li>
</ul>
<h2 id="2-兼容性问题"><a href="#2-兼容性问题" class="headerlink" title="2. 兼容性问题"></a><strong>2. 兼容性问题</strong></h2><p>Axios可以兼容IE浏览器，而<strong>Fetch在IE浏览器和一些老版本浏览器上没有受到支持</strong>，但是有一个库可以让老版本浏览器支持Fetch即它就是<code>whatwg-fetch</code>，它可以让你在老版本的浏览器中也可以使用Fetch，并且现在很多网站的开发都为了减少成本而选择不再兼容IE浏览器。</p>
<p><strong>注意：在比较旧的浏览器上面可能还需要使用promise兼容库。</strong></p>
<p>各个浏览器对Fetch的兼容：</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/v2-f4f89efd5bd6aa15a9d30b0b298a0f1f_720w.jpg" alt="img"></p>
<h2 id="3-请求方式"><a href="#3-请求方式" class="headerlink" title="3. 请求方式"></a><strong>3. 请求方式</strong></h2><p>下面我们来看一下如何使用Axios和Fetch进行请求。</p>
<p>Axios：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> options = &#123;</span><br><span class="line">  url: <span class="string">"http://example.com/"</span>,</span><br><span class="line">  method: <span class="string">"POST"</span>,</span><br><span class="line">  headers: &#123;</span><br><span class="line">    Accept: <span class="string">"application/json"</span>,</span><br><span class="line">    <span class="string">"Content-Type"</span>: <span class="string">"application/json;charset=UTF-8"</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  data: &#123;</span><br><span class="line">    a: <span class="number">10</span>,</span><br><span class="line">    b: <span class="number">20</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">axios(options).then(<span class="function">(<span class="params">response</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(response.status);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>Fetch：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> url = <span class="string">"http://example.com/"</span>;</span><br><span class="line"><span class="keyword">const</span> options = &#123;</span><br><span class="line">  method: <span class="string">"POST"</span>,</span><br><span class="line">  headers: &#123;</span><br><span class="line">    Accept: <span class="string">"application/json"</span>,</span><br><span class="line">    <span class="string">"Content-Type"</span>: <span class="string">"application/json;charset=UTF-8"</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  body: <span class="built_in">JSON</span>.stringify(&#123;</span><br><span class="line">    a: <span class="number">10</span>,</span><br><span class="line">    b: <span class="number">20</span>,</span><br><span class="line">  &#125;),</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">fetch(url, options).then(<span class="function">(<span class="params">response</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(response.status);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>其中最大的不同之处在于<strong>传递数据的方式不同</strong>，Axios是放到<code>data</code>属性里，以对象的方式进行传递，而Fetch则是需要放在<code>body</code>属性中，以字符串的方式进行传递。</p>
<h2 id="4-响应超时"><a href="#4-响应超时" class="headerlink" title="4. 响应超时"></a><strong>4. 响应超时</strong></h2><p>Axios的相应超时设置是非常简单的，直接设置<code>timeout</code>属性就可以了，而Fetch设置起来就远比Axios麻烦，这也是很多人更喜欢Axios而不太喜欢Fetch的原因之一。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">axios(&#123;</span><br><span class="line">  method: <span class="string">"post"</span>,</span><br><span class="line">  url: <span class="string">"http://example.com/"</span>,</span><br><span class="line">  timeout: <span class="number">4000</span>, <span class="comment">// 请求4秒无响应则会超时</span></span><br><span class="line">  data: &#123;</span><br><span class="line">    firstName: <span class="string">"David"</span>,</span><br><span class="line">    lastName: <span class="string">"Pollock"</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br><span class="line">  .then(<span class="function">(<span class="params">response</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">/* 处理响应 */</span></span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function">(<span class="params">error</span>) =&gt;</span> <span class="built_in">console</span>.error(<span class="string">"请求超时"</span>));</span><br></pre></td></tr></table></figure>

<p>Fetch提供了<code>AbortController</code>属性，但是使用起来不像Axios那么简单。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> controller = <span class="keyword">new</span> AbortController();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> options = &#123;</span><br><span class="line">  method: <span class="string">"POST"</span>,</span><br><span class="line">  signal: controller.signal,</span><br><span class="line">  body: <span class="built_in">JSON</span>.stringify(&#123;</span><br><span class="line">    firstName: <span class="string">"David"</span>,</span><br><span class="line">    lastName: <span class="string">"Pollock"</span>,</span><br><span class="line">  &#125;),</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> promise = fetch(<span class="string">"http://example.com/"</span>, options);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果4秒钟没有响应则超时</span></span><br><span class="line"><span class="keyword">const</span> timeoutId = setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> controller.abort(), <span class="number">4000</span>);</span><br><span class="line"></span><br><span class="line">promise</span><br><span class="line">  .then(<span class="function">(<span class="params">response</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">/* 处理响应 */</span></span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function">(<span class="params">error</span>) =&gt;</span> <span class="built_in">console</span>.error(<span class="string">"请求超时"</span>));</span><br></pre></td></tr></table></figure>

<h2 id="5-对数据的转化"><a href="#5-对数据的转化" class="headerlink" title="5. 对数据的转化"></a><strong>5. 对数据的转化</strong></h2><p>Axios还有非常好的一点就是会自动对数据进行转化，而Fetch则不同，它需要使用者进行手动转化。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// axios</span></span><br><span class="line">axios.get(<span class="string">"http://example.com/"</span>).then(</span><br><span class="line">  (response) =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(response.data);</span><br><span class="line">  &#125;,</span><br><span class="line">  (error) =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(error);</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// fetch</span></span><br><span class="line">fetch(<span class="string">"http://example.com/"</span>)</span><br><span class="line">  .then(<span class="function">(<span class="params">response</span>) =&gt;</span> response.json()) <span class="comment">// 需要对响应数据进行转换</span></span><br><span class="line">  .then(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data);</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function">(<span class="params">error</span>) =&gt;</span> <span class="built_in">console</span>.error(error));</span><br></pre></td></tr></table></figure>

<p>Fetch提供的转化API有下面几种：</p>
<ul>
<li>arrayBuffer()</li>
<li>blob()</li>
<li>json()</li>
<li>text()</li>
<li>formData()</li>
</ul>
<p>使用Fetch时你需要清楚请求后的数据类型是什么，然后再用对应的方法将它进行转换。</p>
<p>Fetch可以通过一些封装实现Axios的自动转化功能，至于如何实现由于我没有去研究过所以就不再这里多嘴，不过实现起来应该不难，但是要将实现过程写的健壮就需要花费一定的时间。</p>
<h2 id="6-HTTP拦截器"><a href="#6-HTTP拦截器" class="headerlink" title="6. HTTP拦截器"></a><strong>6. HTTP拦截器</strong></h2><p>Axios的一大卖点就是它提供了拦截器，可以统一对请求或响应进行一些处理，相信如果看过一个比较完整的项目的请求封装的话，一定对Axios的拦截器有一定的了解，它是一个非常重要的功能。</p>
<p>使用它可以为请求附加token、为请求增加时间戳防止请求缓存，以及拦截响应，一旦状态码不符合预期则直接将响应消息通过弹框的形式展示在界面上，比如密码错误、服务器内部错误、表单验证不通过等问题。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">axios.interceptors.request.use(<span class="function">(<span class="params">config</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 在请求之前对请求参数进行处理</span></span><br><span class="line">  <span class="keyword">return</span> config;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发送GET请求</span></span><br><span class="line">axios.get(<span class="string">"http://example.com/"</span>).then(<span class="function">(<span class="params">response</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(response.data);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>而Fetch没有拦截器功能，但是要实现该功能并不难，直接重写全局Fetch方法就可以办到。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">fetch = <span class="function">(<span class="params">(originalFetch</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">...<span class="built_in">arguments</span></span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> result = originalFetch.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">    <span class="keyword">return</span> result.then(<span class="built_in">console</span>.log(<span class="string">"请求已发送"</span>));</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;)(fetch);</span><br><span class="line"></span><br><span class="line">fetch(<span class="string">"http://example.com/"</span>)</span><br><span class="line">  .then(<span class="function">(<span class="params">response</span>) =&gt;</span> response.json())</span><br><span class="line">  .then(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>

<h2 id="7-同时请求"><a href="#7-同时请求" class="headerlink" title="7. 同时请求"></a><strong>7. 同时请求</strong></h2><p>同时请求在项目中用的不多，但是偶尔可能会用到。</p>
<p>Axios：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">axios</span><br><span class="line">  .all([</span><br><span class="line">    axios.get(<span class="string">"https://api.github.com/users/iliakan"</span>),</span><br><span class="line">    axios.get(<span class="string">"https://api.github.com/users/taylorotwell"</span>),</span><br><span class="line">  ])</span><br><span class="line">  .then(</span><br><span class="line">    axios.spread(<span class="function">(<span class="params">obj1, obj2</span>) =&gt;</span> &#123;</span><br><span class="line">      ...</span><br><span class="line">    &#125;)</span><br><span class="line">  );</span><br></pre></td></tr></table></figure>

<p>Fetch：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.all([</span><br><span class="line">  fetch(<span class="string">"https://api.github.com/users/iliakan"</span>),</span><br><span class="line">  fetch(<span class="string">"https://api.github.com/users/taylorotwell"</span>),</span><br><span class="line">])</span><br><span class="line">  .then(<span class="keyword">async</span> ([res1, res2]) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> a = <span class="keyword">await</span> res1.json();</span><br><span class="line">    <span class="keyword">const</span> b = <span class="keyword">await</span> res2.json();</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(error);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>

<h2 id="8-浏览器原生支持"><a href="#8-浏览器原生支持" class="headerlink" title="8. 浏览器原生支持"></a><strong>8. 浏览器原生支持</strong></h2><p>Fetch唯一碾压Axios的一点就是现代浏览器的原生支持。</p>
<p>本着负责的态度（其实是因为这篇文章写得比较困难…因为我对Fetch的研究不深）在这几天，我多次尝试使用Fetch，习惯后觉得还挺好用的，最主要是浏览器原生就支持，不像Axios需要引入一个包，而且需要即时测试某些接口直接在Chrome浏览器中使用Fetch进行请求，尤其是编写爬虫或脚本的时候，你在当前网页打开Chrome的控制台使用Fetch几乎不需要什么配置就可以直接进行请求。</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/v2-7273fe165ca8d4558a9e7539c2fcb280_720w.png" alt="img"></p>
<p>上图是在知乎打开Chrome控制台然后调用知乎个人数据API，可以看到能够成功的拿到数据。</p>
<h2 id="9-最后"><a href="#9-最后" class="headerlink" title="9. 最后"></a><strong>9. 最后</strong></h2><p>Fetch可以实现所有Axios能够实现的功能，但是需要自行进行封装，如果不喜欢折腾直接在项目中使用Axios是一个非常明智的选择，这完全取决于你是否愿意使用浏览器内置API。</p>
<p>有时候新技术逐渐取代老技术是一个必然趋势，所以Fetch有一天终将会取代<code>XMLHttpRequest</code>，也许之后Axios库会改为使用Fetch请求</p>
<p><strong>本文为转载文章</strong> <a href="https://zhuanlan.zhihu.com/p/353492075" target="_blank" rel="noopener">点击进入原文</a></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em><a href="https://code.newban.cn/">乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</a></em></p>
]]></content>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>海底掘金自动化挖矿实现</title>
    <url>/287.html</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>最近掘金出了一款小游戏叫做海底掘金, 挖取矿石可以兑换周边礼品</p>
<p>我眼馋那款游戏机已久, 于是乎就玩起了这款游戏, 不过每天手动操作实在太过劳神, 于是, 我打算将其流程自动化</p>
<p>所有的数据都是离不开接口, 我们只需要模拟接口请求即可</p>
<p>那么首先要做的就是分析游戏中每一个动作都发送了什么数据</p>
<h3 id="动作分析"><a href="#动作分析" class="headerlink" title="动作分析"></a>动作分析</h3><ol>
<li><p>上移</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;<span class="attr">"command"</span>:[<span class="string">"U"</span>]&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20211129115453501.png" alt="image-20211129115453501"></p>
</li>
<li><p>下移</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;<span class="attr">"command"</span>:[<span class="string">"D"</span>]&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20211129115518866.png" alt="image-20211129115518866"></p>
</li>
<li><p>左移</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;<span class="attr">"command"</span>:[<span class="string">"L"</span>]&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20211129115538071.png" alt="image-20211129115538071"></p>
</li>
<li><p>右移</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;<span class="attr">"command"</span>:[<span class="string">"R"</span>]&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20211129115556431.png" alt="image-20211129115556431"></p>
</li>
<li><p>跳跃</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">//上跳跃</span><br><span class="line">&#123;command: ["8"]&#125;</span><br><span class="line">//下跳跃</span><br><span class="line">&#123;command: ["2"]&#125;</span><br><span class="line">//左跳跃</span><br><span class="line">&#123;command: ["4"]&#125;</span><br><span class="line">//右跳跃</span><br><span class="line">&#123;command: ["6"]&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20211129120520331.png" alt="image-20211129120520331"></p>
</li>
<li><p>一层循环2次上移</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&#123;command: [&#123;times: 2, command: ["U"]&#125;]&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>times: 表示循环次数</li>
</ul>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20211129115642187.png" alt="image-20211129115642187"></p>
</li>
<li><p>两层循环</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&#123;command: [&#123;times: 2, command: [&#123;times: 3, command: ["D"]&#125;]&#125;]&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20211129115708099.png" alt="image-20211129115708099"></p>
<p><strong>多层循环则多层嵌套</strong></p>
</li>
</ol>
<h3 id="接口分析"><a href="#接口分析" class="headerlink" title="接口分析"></a>接口分析</h3><ol>
<li><p>动作接口</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https://juejin-game.bytedance.com/game/sea-gold/game/command?uid=xxx&amp;time=xxx</span><br></pre></td></tr></table></figure>
</li>
<li><p>游戏结束接口</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https://juejin-game.bytedance.com/game/sea-gold/game/over?uid=xxx&amp;time=xxx</span><br></pre></td></tr></table></figure>
</li>
<li><p>游戏开始接口</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https://juejin-game.bytedance.com/game/sea-gold/game/start?uid=xxx&amp;time=xxx</span><br></pre></td></tr></table></figure>
</li>
<li><p>Token获取接口</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https://juejin.cn/get/token</span><br></pre></td></tr></table></figure>

<p>这个接口获取到的值其实就是其他接口中请求头<code>authorization</code>的值, 具体往下看</p>
</li>
<li><p>获取矿石数量相关信息</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https://juejin-game.bytedance.com/game/sea-gold/home/info?uid=xxx&amp;time=xxx</span><br></pre></td></tr></table></figure>



</li>
</ol>
<h3 id="浏览器控台自动化实现"><a href="#浏览器控台自动化实现" class="headerlink" title="浏览器控台自动化实现"></a>浏览器控台自动化实现</h3><p>我们跳过登录验证操作, 先从简单的控台自动化入手, 实现动作的自动化, 有效避免作弊检测</p>
<p>比如我们想要实现以下动作的反复执行</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20211129121755381.png" alt="image-20211129121755381"></p>
<p>那么发送的数据如下:</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;<span class="attr">"command"</span>:[&#123;<span class="attr">"times"</span>:<span class="number">10</span>,<span class="attr">"command"</span>:[<span class="string">"L"</span>,<span class="string">"2"</span>,<span class="string">"R"</span>,&#123;<span class="attr">"times"</span>:<span class="number">10</span>,<span class="attr">"command"</span>:[<span class="string">"L"</span>,<span class="string">"4"</span>,<span class="string">"D"</span>,&#123;<span class="attr">"times"</span>:<span class="number">10</span>,<span class="attr">"command"</span>:[<span class="string">"R"</span>,<span class="string">"D"</span>,<span class="string">"2"</span>]&#125;]&#125;]&#125;]&#125;</span><br></pre></td></tr></table></figure>

<p>这一步我们可以直接从浏览器控制台里拷贝出来, 不用自己计算, 方便快捷准确</p>
<p>然后结合动作接口和请求头进行模拟请求即可</p>
<p><strong>如下请求头</strong></p>
<ul>
<li>Content-type</li>
<li>authorization (关键) </li>
<li>x-tt-gameid (关键)</li>
<li>accept</li>
</ul>
<p>以上请求头数据直接从控制台拷贝</p>
<p>代码实现如下:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">await</span> (<span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">autoRun</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"> <span class="comment">//以下三个字段值替换成你自己的就行</span></span><br><span class="line">  <span class="keyword">let</span> uid = <span class="string">'xxx'</span>;<span class="comment">// 你的uid</span></span><br><span class="line">  <span class="keyword">let</span> authorization = <span class="string">'xxx'</span>; <span class="comment">// request headers中的authorization</span></span><br><span class="line">  <span class="keyword">let</span> gameid = <span class="string">'xxx'</span>; <span class="comment">// request headers中的x-tt-gameid</span></span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  <span class="keyword">let</span> params = &#123;<span class="string">"command"</span>:[&#123;<span class="string">"times"</span>:<span class="number">10</span>,<span class="string">"command"</span>:[<span class="string">"L"</span>,<span class="string">"2"</span>,<span class="string">"R"</span>,&#123;<span class="string">"times"</span>:<span class="number">10</span>,<span class="string">"command"</span>:[<span class="string">"L"</span>,<span class="string">"4"</span>,<span class="string">"D"</span>,&#123;<span class="string">"times"</span>:<span class="number">10</span>,<span class="string">"command"</span>:[<span class="string">"R"</span>,<span class="string">"D"</span>,<span class="string">"2"</span>]&#125;]&#125;]&#125;]&#125;;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">let</span> datarus = <span class="keyword">await</span> fetch(<span class="string">'https://juejin-game.bytedance.com/game/sea-gold/game/command?uid='</span> + uid + <span class="string">'&amp;time='</span> + <span class="built_in">Date</span>.parse(<span class="keyword">new</span> <span class="built_in">Date</span>()), &#123;</span><br><span class="line">  method: <span class="string">'POST'</span>,</span><br><span class="line">  credentials: <span class="string">"include"</span>,</span><br><span class="line">  headers: &#123;</span><br><span class="line">	<span class="string">'Content-type'</span>: <span class="string">'application/json; charset=UTF-8'</span>,</span><br><span class="line">	<span class="string">'authorization'</span>: authorization,</span><br><span class="line">	<span class="string">'accept'</span>: <span class="string">'application/json, text/plain, */*'</span>,</span><br><span class="line">	<span class="string">'content-length'</span>: <span class="built_in">JSON</span>.stringify(params).length,</span><br><span class="line">	<span class="string">'x-tt-gameid'</span>: gameid,</span><br><span class="line">  &#125;,</span><br><span class="line">  body: <span class="built_in">JSON</span>.stringify(params)</span><br><span class="line">&#125;).then(<span class="keyword">async</span> (res) =&gt; &#123;</span><br><span class="line">	<span class="keyword">return</span> res.json();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> datarus;</span><br><span class="line"></span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>

<p>注意, 每一局的<code>gameId</code>是不一样的, 使用相同的<code>gameId</code>会报游戏异常, 这种操作大家要尽量避免, 谁知道官方有没有利用这个来判定玩家是否作弊呢, 谨慎为上</p>
<p>请求成功后响应数据如下:</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;<span class="attr">"data"</span>:&#123;<span class="attr">"appendMapData"</span>:[<span class="number">0</span>,<span class="number">0</span>,<span class="number">133</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">27</span>,<span class="number">122</span>,<span class="number">6</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">22</span>,<span class="number">6</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">6</span>,<span class="number">135</span>,<span class="number">6</span>,<span class="number">0</span>,<span class="number">21</span>,<span class="number">21</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">122</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">23</span>,<span class="number">0</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">6</span>,<span class="number">0</span>,<span class="number">25</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">121</span>,<span class="number">0</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">0</span>,<span class="number">29</span>,<span class="number">0</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">0</span>,<span class="number">151</span>,<span class="number">6</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">6</span>,<span class="number">27</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">6</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">125</span>,<span class="number">6</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">5</span>,<span class="number">0</span>,<span class="number">135</span>,<span class="number">113</span>,<span class="number">143</span>,<span class="number">0</span>,<span class="number">6</span>,<span class="number">131</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">102</span>,<span class="number">101</span>,<span class="number">151</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">3</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">6</span>,<span class="number">0</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">122</span>,<span class="number">0</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">0</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">29</span>,<span class="number">0</span>,<span class="number">6</span>,<span class="number">0</span>,<span class="number">6</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">101</span>,<span class="number">6</span>,<span class="number">0</span>,<span class="number">24</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">6</span>,<span class="number">0</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">132</span>,<span class="number">0</span>,<span class="number">6</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">6</span>,<span class="number">0</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">131</span>,<span class="number">114</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">0</span>,<span class="number">6</span>,<span class="number">0</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">0</span>,<span class="number">104</span>,<span class="number">0</span>,<span class="number">6</span>,<span class="number">0</span>,<span class="number">4</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">6</span>,<span class="number">125</span>,<span class="number">6</span>,<span class="number">113</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">6</span>,<span class="number">0</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">6</span>,<span class="number">0</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">121</span>,<span class="number">28</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">24</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">6</span>,<span class="number">151</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">141</span>,<span class="number">6</span>,<span class="number">0</span>,<span class="number">24</span>,<span class="number">0</span>,<span class="number">6</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">131</span>,<span class="number">6</span>,<span class="number">105</span>,<span class="number">6</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">27</span>,<span class="number">113</span>,<span class="number">6</span>,<span class="number">0</span>,<span class="number">6</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">143</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">101</span>,<span class="number">0</span>,<span class="number">29</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">6</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">133</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">25</span>,<span class="number">24</span>,<span class="number">151</span>,<span class="number">29</span>,<span class="number">6</span>,<span class="number">104</span>,<span class="number">6</span>,<span class="number">0</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">131</span>,<span class="number">6</span>,<span class="number">131</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">6</span>,<span class="number">0</span>,<span class="number">28</span>,<span class="number">133</span>,<span class="number">0</span>,<span class="number">124</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">131</span>,<span class="number">0</span>,<span class="number">22</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">22</span>,<span class="number">131</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">0</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">24</span>,<span class="number">124</span>,<span class="number">6</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">101</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">103</span>,<span class="number">0</span>,<span class="number">6</span>,<span class="number">26</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">103</span>,<span class="number">0</span>,<span class="number">6</span>,<span class="number">0</span>,<span class="number">6</span>,<span class="number">131</span>,<span class="number">0</span>,<span class="number">6</span>,<span class="number">0</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">0</span>,<span class="number">141</span>,<span class="number">6</span>,<span class="number">29</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">6</span>,<span class="number">0</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">0</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">114</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">6</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">6</span>,<span class="number">0</span>,<span class="number">6</span>,<span class="number">0</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">28</span>,<span class="number">23</span>,<span class="number">6</span>,<span class="number">102</span>,<span class="number">0</span>,<span class="number">115</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">0</span>,<span class="number">6</span>,<span class="number">27</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">0</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">24</span>,<span class="number">0</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">143</span>,<span class="number">0</span>,<span class="number">29</span>,<span class="number">0</span>,<span class="number">26</span>,<span class="number">0</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">105</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">6</span>,<span class="number">0</span>,<span class="number">21</span>,<span class="number">132</span>,<span class="number">21</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">103</span>,<span class="number">6</span>,<span class="number">0</span>,<span class="number">27</span>,<span class="number">6</span>,<span class="number">0</span>,<span class="number">24</span>,<span class="number">24</span>,<span class="number">0</span>,<span class="number">6</span>,<span class="number">104</span>,<span class="number">0</span>,<span class="number">104</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">152</span>,<span class="number">6</span>,<span class="number">0</span>,<span class="number">6</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">6</span>,<span class="number">24</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">23</span>,<span class="number">143</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">24</span>,<span class="number">0</span>,<span class="number">6</span>,<span class="number">0</span>,<span class="number">6</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">151</span>,<span class="number">0</span>,<span class="number">26</span>,<span class="number">0</span>,<span class="number">6</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">6</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">6</span>,<span class="number">135</span>,<span class="number">0</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">29</span>,<span class="number">6</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">6</span>,<span class="number">0</span>,<span class="number">24</span>,<span class="number">25</span>,<span class="number">6</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">6</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">6</span>,<span class="number">0</span>,<span class="number">6</span>,<span class="number">152</span>,<span class="number">28</span>,<span class="number">6</span>,<span class="number">25</span>,<span class="number">6</span>,<span class="number">0</span>,<span class="number">6</span>,<span class="number">0</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">25</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">6</span>,<span class="number">122</span>,<span class="number">6</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">6</span>,<span class="number">112</span>,<span class="number">6</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">124</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">25</span>,<span class="number">0</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">27</span>,<span class="number">112</span>,<span class="number">24</span>,<span class="number">121</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">0</span>,<span class="number">6</span>,<span class="number">0</span>,<span class="number">6</span>,<span class="number">0</span>,<span class="number">6</span>,<span class="number">115</span>,<span class="number">0</span>,<span class="number">22</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">115</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">101</span>,<span class="number">0</span>,<span class="number">27</span>,<span class="number">5</span>,<span class="number">105</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">6</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">6</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">26</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">0</span>,<span class="number">6</span>,<span class="number">0</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">6</span>,<span class="number">0</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">104</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">122</span>,<span class="number">27</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">23</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">4</span>,<span class="number">23</span>,<span class="number">25</span>,<span class="number">6</span>,<span class="number">0</span>,<span class="number">153</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">6</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">0</span>,<span class="number">6</span>,<span class="number">0</span>,<span class="number">4</span>,<span class="number">0</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">0</span>,<span class="number">3</span>,<span class="number">0</span>,<span class="number">112</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">6</span>,<span class="number">0</span>,<span class="number">113</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">21</span>,<span class="number">0</span>,<span class="number">6</span>,<span class="number">124</span>,<span class="number">0</span>,<span class="number">6</span>,<span class="number">115</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">23</span>,<span class="number">132</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">6</span>,<span class="number">0</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">0</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">0</span>,<span class="number">6</span>,<span class="number">0</span>,<span class="number">6</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">0</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">26</span>,<span class="number">0</span>,<span class="number">134</span>,<span class="number">0</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">113</span>,<span class="number">111</span>,<span class="number">0</span>,<span class="number">6</span>,<span class="number">0</span>,<span class="number">6</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">124</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">6</span>,<span class="number">0</span>,<span class="number">22</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">24</span>,<span class="number">22</span>,<span class="number">6</span>,<span class="number">104</span>,<span class="number">0</span>,<span class="number">125</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">0</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">121</span>,<span class="number">6</span>,<span class="number">0</span>,<span class="number">6</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">6</span>,<span class="number">0</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">25</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">6</span>,<span class="number">0</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">111</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">6</span>,<span class="number">0</span>,<span class="number">5</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">0</span>,<span class="number">6</span>,<span class="number">0</span>,<span class="number">123</span>,<span class="number">6</span>,<span class="number">0</span>,<span class="number">6</span>,<span class="number">25</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">6</span>,<span class="number">113</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">6</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">6</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">6</span>,<span class="number">122</span>,<span class="number">6</span>,<span class="number">134</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">6</span>,<span class="number">0</span>,<span class="number">134</span>,<span class="number">0</span>,<span class="number">6</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">6</span>,<span class="number">103</span>,<span class="number">0</span>,<span class="number">24</span>,<span class="number">0</span>,<span class="number">6</span>,<span class="number">0</span>,<span class="number">6</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">0</span>,<span class="number">132</span>,<span class="number">6</span>,<span class="number">0</span>,<span class="number">6</span>,<span class="number">103</span>,<span class="number">6</span>,<span class="number">0</span>,<span class="number">6</span>,<span class="number">28</span>,<span class="number">26</span>,<span class="number">6</span>,<span class="number">0</span>,<span class="number">111</span>,<span class="number">6</span>,<span class="number">131</span>,<span class="number">0</span>,<span class="number">27</span>,<span class="number">27</span>,<span class="number">0</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">0</span>,<span class="number">102</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">6</span>,<span class="number">0</span>,<span class="number">6</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">6</span>,<span class="number">21</span>,<span class="number">6</span>,<span class="number">0</span>,<span class="number">6</span>,<span class="number">0</span>,<span class="number">6</span>,<span class="number">121</span>,<span class="number">26</span>,<span class="number">0</span>,<span class="number">6</span>,<span class="number">0</span>,<span class="number">6</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">6</span>,<span class="number">0</span>,<span class="number">24</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">6</span>,<span class="number">0</span>,<span class="number">4</span>,<span class="number">0</span>,<span class="number">22</span>,<span class="number">23</span>,<span class="number">28</span>,<span class="number">0</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">111</span>,<span class="number">153</span>,<span class="number">131</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">6</span>,<span class="number">27</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">23</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">6</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">104</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">104</span>,<span class="number">6</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">6</span>,<span class="number">29</span>,<span class="number">6</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">23</span>,<span class="number">6</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">6</span>,<span class="number">0</span>,<span class="number">113</span>,<span class="number">6</span>,<span class="number">0</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">29</span>,<span class="number">152</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">153</span>,<span class="number">0</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">0</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">0</span>,<span class="number">26</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">151</span>,<span class="number">21</span>,<span class="number">0</span>,<span class="number">21</span>,<span class="number">6</span>,<span class="number">0</span>,<span class="number">21</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">0</span>,<span class="number">6</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">22</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">0</span>,<span class="number">6</span>,<span class="number">0</span>,<span class="number">21</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">0</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">22</span>,<span class="number">0</span>,<span class="number">5</span>,<span class="number">0</span>,<span class="number">6</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">28</span>,<span class="number">6</span>,<span class="number">0</span>,<span class="number">6</span>,<span class="number">114</span>,<span class="number">0</span>,<span class="number">6</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">6</span>,<span class="number">0</span>,<span class="number">23</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">6</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">114</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">6</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">6</span>,<span class="number">0</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">24</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">6</span>,<span class="number">134</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">131</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">25</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">0</span>,<span class="number">104</span>,<span class="number">0</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">6</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">6</span>,<span class="number">0</span>,<span class="number">6</span>,<span class="number">101</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">6</span>,<span class="number">0</span>,<span class="number">6</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">125</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">6</span>,<span class="number">134</span>,<span class="number">0</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">27</span>,<span class="number">0</span>,<span class="number">6</span>,<span class="number">0</span>,<span class="number">131</span>,<span class="number">6</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">6</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">6</span>,<span class="number">0</span>,<span class="number">123</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">6</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">0</span>,<span class="number">6</span>,<span class="number">0</span>,<span class="number">6</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">25</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">6</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">6</span>,<span class="number">0</span>,<span class="number">6</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">6</span>,<span class="number">0</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">114</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">6</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">6</span>,<span class="number">124</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">154</span>,<span class="number">6</span>,<span class="number">0</span>,<span class="number">152</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">22</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">0</span>,<span class="number">6</span>,<span class="number">26</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">111</span>,<span class="number">0</span>,<span class="number">133</span>,<span class="number">29</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">104</span>,<span class="number">133</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">6</span>,<span class="number">26</span>],<span class="attr">"curPos"</span>:&#123;<span class="attr">"x"</span>:<span class="number">5</span>,<span class="attr">"y"</span>:<span class="number">210</span>&#125;,<span class="attr">"blockData"</span>:&#123;<span class="attr">"moveUp"</span>:<span class="number">29</span>,<span class="attr">"moveDown"</span>:<span class="number">30</span>,<span class="attr">"moveLeft"</span>:<span class="number">14</span>,<span class="attr">"moveRight"</span>:<span class="number">27</span>,<span class="attr">"jump"</span>:<span class="number">7</span>,<span class="attr">"loop"</span>:<span class="number">15</span>&#125;,<span class="attr">"gameDiamond"</span>:<span class="number">112</span>&#125;,<span class="attr">"code"</span>:<span class="number">0</span>,<span class="attr">"message"</span>:<span class="string">"success"</span>,<span class="attr">"logId"</span>:<span class="string">"xxxx"</span>,<span class="attr">"serviceTime"</span>:<span class="number">1638159487113</span>&#125;</span><br></pre></td></tr></table></figure>

<p>注意看返回的<code>gameDiamond</code>这个字段, 我们执行一次接口立马就获取了<code>112</code>个矿石, 也就是说我们掉完接口立马结束游戏, 那么这矿石就到手了, 省去了游戏执行的时间</p>
<p>在同一局中, 我们可以反复调接口, 直到道具不足为止, 如果道具不足就重开一局再过一遍之前的代码</p>
<p>到这里 问题就来了, 每一局的<code>x-tt-gameid</code>都不一样, 每新开一局都要拷贝一次太繁琐了,接下来我们解决<code>x-tt-gameid</code>的问题</p>
<h4 id="签名破解"><a href="#签名破解" class="headerlink" title="签名破解"></a>签名破解</h4><p>接下来全局翻找源码, 从<code>js</code>源码中, 我大致猜测这个<code>x-tt-gameid</code>是由<code>ES256</code>算法生成<code>accessToken</code>, 找到如下代码:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">h.default.sign(&#123;<span class="attr">gameId</span>:<span class="keyword">this</span>.gameId,<span class="attr">time</span>:t&#125;,<span class="string">"-----BEGIN EC PARAMETERS-----\nBggqhkjOPQMBBw==\n-----END EC PARAMETERS-----\n-----BEGIN EC PRIVATE KEY-----\nMHcCAQEEIDB7KMVQd+eeKt7AwDMMUaT7DE3Sl0Mto3LEojnEkRiAoAoGCCqGSM49\nAwEHoUQDQgAEEkViJDU8lYJUenS6IxPlvFJtUCDNF0c/F/cX07KCweC4Q/nOKsoU\nnYJsb4O8lMqNXaI1j16OmXk9CkcQQXbzfg==\n-----END EC PRIVATE KEY-----\n"</span>,&#123;<span class="attr">algorithm</span>:<span class="string">"ES256"</span>,<span class="attr">expiresIn</span>:<span class="number">2592e3</span>,<span class="attr">header</span>:&#123;<span class="attr">alg</span>:<span class="string">"ES256"</span>,<span class="attr">typ</span>:<span class="string">"JWT"</span>&#125;&#125;);<span class="keyword">return</span> <span class="built_in">console</span>.log(<span class="string">"token"</span>,e)</span><br></pre></td></tr></table></figure>

<p>当然也只是猜测, 需要进行验证</p>
<p>为了方便测试, 我将代码测试从控台转移到<code>nodejs</code>环境中</p>
<p>对于<code>nodejs</code>不太熟悉的朋友, 我这里简单介绍一下:</p>
<p> <code>nodejs</code>可以通俗理解为是模拟了一个浏览器的环境, 相当于<code>java</code>中的<code>jre</code>, 以前<code>js</code>代码只能在浏览器中执行, 有了<code>nodejs</code>环境, 我们就可以脱离浏览器随处运行<code>js</code>代码啦</p>
<p><a href="http://nodejs.cn/" target="_blank" rel="noopener">Nodejs官网</a></p>
<p>好了 下载安装完<code>nodejs</code>之后, 安装<code>jsonwebtoken</code>模块用于<code>jwt</code>的生成</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">npm install jsonwebtoken</span><br></pre></td></tr></table></figure>

<p>然后运行以下代码测试:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> jwt = <span class="built_in">require</span>(<span class="string">'jsonwebtoken'</span>);</span><br><span class="line"><span class="keyword">const</span> privatekey = <span class="string">"-----BEGIN EC PARAMETERS-----\nBggqhkjOPQMBBw==\n-----END EC PARAMETERS-----\n-----BEGIN EC PRIVATE KEY-----\nMHcCAQEEIDB7KMVQd+eeKt7AwDMMUaT7DE3Sl0Mto3LEojnEkRiAoAoGCCqGSM49\nAwEHoUQDQgAEEkViJDU8lYJUenS6IxPlvFJtUCDNF0c/F/cX07KCweC4Q/nOKsoU\nnYJsb4O8lMqNXaI1j16OmXk9CkcQQXbzfg==\n-----END EC PRIVATE KEY-----\n"</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(jwt.decode(<span class="string">"eyJhbGciOiJFUzI1NiIsInR5cCI6IkpXVCJ9.eyJnYW1lSWQiOiIyMDIxLTExLTI2IDA5OjUwOjIwIiwidGltZSI6IjE2Mzc5MTMyNjIwMTkiLCJpYXQiOjE2Mzc5MTMyNjIsImV4cCI6MTY0MDUwNTI2Mn0.2SWFcrvSMGzRIhsZe6ny0ugj5eoJnb4DlGGudFzUgvwPTqbeZaSa2FG5jYF5VPOXfv7Ye0TlYPt3VmviclOGKQ"</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>解码得到:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  gameId: <span class="string">'2021-11-26 09:50:20'</span>,</span><br><span class="line">  time: <span class="string">'1637913262019'</span>,</span><br><span class="line">  iat: <span class="number">1637913262</span>,</span><br><span class="line">  exp: <span class="number">1640505262</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至此, 我们既验证了密钥的正确性, 同时得到了加密参数, 而这个<code>time</code>则是当前时间毫秒值</p>
<p>那接下来我们需要在游戏中实际验证一下才行, 验证步骤如下:</p>
<ol>
<li>调用游戏开始接口获取返回的<code>gameId</code></li>
<li>将<code>gameId</code>进行<code>ES256</code>加密得到签名</li>
<li>调用动作接口, 并将签名放入<code>x-tt-gameid</code>请求头中</li>
<li>请求成功, 验证ok</li>
</ol>
<p>好了 我们的第一阶段的破解工作已完毕, 接下来就是对代码进行整理, 实现自动化运行</p>
<p>由于代码转移到<code>nodejs</code>上之后使用<code>fetch</code>进行网络请求代码一直报错, 因此请求方式改为<code>axios</code></p>
<p>这里多一嘴, 虽然<code>nodejs</code>模拟了浏览器的环境, 但是浏览器内置的一些<code>API</code>, <code>nodejs</code>上不一定也内置了, 要用的话的<code>npm</code>手动安装, 比如<code>fetch</code>是浏览器内置的API, 控台直接可以使用, 如果要在<code>node</code>上用的话可以执行以下指令安装:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install node-fetch</span><br></pre></td></tr></table></figure>

<p>然后代码中引用:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fetch = <span class="built_in">require</span>(<span class="string">'node-fetch'</span>);</span><br></pre></td></tr></table></figure>

<p>同样<code>axios</code>也是:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install axios</span><br></pre></td></tr></table></figure>

<p>代码引用:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> axios = <span class="built_in">require</span>(<span class="string">'axios'</span>);</span><br></pre></td></tr></table></figure>

<p>关于<code>fetch</code>和<code>axios</code>两者的实现原理和区别, 有兴趣的可自行百度, 这里就不展开介绍了</p>
<p>回过头来, 整理后的代码如下:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> jwt = <span class="built_in">require</span>(<span class="string">'jsonwebtoken'</span>);</span><br><span class="line"><span class="keyword">const</span> axios = <span class="built_in">require</span>(<span class="string">'axios'</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> uid = <span class="string">'xxx'</span>;<span class="comment">// 你的uid</span></span><br><span class="line"><span class="keyword">let</span> authorization = <span class="string">'xxx'</span>; <span class="comment">// request headers中的authorization</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> currentTime = <span class="built_in">Date</span>.parse(<span class="keyword">new</span> <span class="built_in">Date</span>())</span><br><span class="line"><span class="keyword">let</span> gameId = <span class="string">"2021-11-30 10:36:12"</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getAccesssToken</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> privatekey = <span class="string">"-----BEGIN EC PARAMETERS-----\nBggqhkjOPQMBBw==\n-----END EC PARAMETERS-----\n-----BEGIN EC PRIVATE KEY-----\nMHcCAQEEIDB7KMVQd+eeKt7AwDMMUaT7DE3Sl0Mto3LEojnEkRiAoAoGCCqGSM49\nAwEHoUQDQgAEEkViJDU8lYJUenS6IxPlvFJtUCDNF0c/F/cX07KCweC4Q/nOKsoU\nnYJsb4O8lMqNXaI1j16OmXk9CkcQQXbzfg==\n-----END EC PRIVATE KEY-----\n"</span></span><br><span class="line">    currentTime = <span class="built_in">Date</span>.parse(<span class="keyword">new</span> <span class="built_in">Date</span>())</span><br><span class="line">    <span class="keyword">const</span> payload = &#123; <span class="string">"gameId"</span>: gameId, <span class="string">"time"</span>: currentTime &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> accessToken = jwt.sign(payload, privatekey, &#123;</span><br><span class="line">        expiresIn: <span class="string">"240h"</span>,</span><br><span class="line">        algorithm: <span class="string">"ES256"</span>,</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">//console.log(accessToken)</span></span><br><span class="line">    <span class="keyword">return</span> accessToken</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//游戏开始</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">gameStart</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//选择 click这个角色 钻石有加成</span></span><br><span class="line">    <span class="keyword">let</span> params = &#123; <span class="string">"roleId"</span>: <span class="number">2</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> options = &#123;</span><br><span class="line">        url: <span class="string">'https://juejin-game.bytedance.com/game/sea-gold/game/start?uid='</span> + uid + <span class="string">'&amp;time='</span> + <span class="built_in">Date</span>.parse(<span class="keyword">new</span> <span class="built_in">Date</span>()),</span><br><span class="line">        method: <span class="string">"POST"</span>,</span><br><span class="line">        credentials: <span class="string">"include"</span>,</span><br><span class="line">        headers: &#123;</span><br><span class="line">            <span class="string">'Content-type'</span>: <span class="string">'application/json; charset=UTF-8'</span>,</span><br><span class="line">            <span class="string">'authorization'</span>: authorization,</span><br><span class="line">            <span class="string">'accept'</span>: <span class="string">'application/json, text/plain, */*'</span>,</span><br><span class="line">            <span class="string">'content-length'</span>: <span class="built_in">JSON</span>.stringify(params).length,</span><br><span class="line">            <span class="string">'x-tt-gameid'</span>: <span class="string">''</span>,</span><br><span class="line">            <span class="string">'user-agent'</span>: <span class="string">'Mozilla/5.0 (Linux; Android 6.0; Nexus 5 Build/MRA58N) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/96.0.4664.55 Mobile Safari/537.36'</span></span><br><span class="line">        &#125;,</span><br><span class="line">        data: params,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">await</span> axios(options).then(<span class="function">(<span class="params">response</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(response.data);</span><br><span class="line">        <span class="keyword">if</span> (response.data.code == <span class="number">4007</span>) &#123;</span><br><span class="line">            <span class="comment">//游戏正在执行 则结束游戏</span></span><br><span class="line">            <span class="comment">// gameOver()</span></span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (response.data.code == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//成功开始</span></span><br><span class="line">            gameId = response.data.data.gameId</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//执行游戏动作</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">gameRun</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> gameid = getAccesssToken(); <span class="comment">// request headers中的x-tt-gameid</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> paramsList = [&#123; <span class="string">"command"</span>: [&#123; <span class="string">"times"</span>: <span class="number">10</span>, <span class="string">"command"</span>: [<span class="string">"L"</span>, <span class="string">"2"</span>, <span class="string">"R"</span>, &#123; <span class="string">"times"</span>: <span class="number">10</span>, <span class="string">"command"</span>: [<span class="string">"L"</span>, <span class="string">"4"</span>, <span class="string">"D"</span>, &#123; <span class="string">"times"</span>: <span class="number">10</span>, <span class="string">"command"</span>: [<span class="string">"R"</span>, <span class="string">"D"</span>, <span class="string">"2"</span>] &#125;] &#125;] &#125;] &#125;,</span><br><span class="line">    &#123; <span class="string">"command"</span>: [&#123; <span class="string">"times"</span>: <span class="number">10</span>, <span class="string">"command"</span>: [<span class="string">"L"</span>, <span class="string">"D"</span>, <span class="string">"R"</span>, &#123; <span class="string">"times"</span>: <span class="number">10</span>, <span class="string">"command"</span>: [<span class="string">"L"</span>, <span class="string">"4"</span>, <span class="string">"D"</span>, &#123; <span class="string">"times"</span>: <span class="number">10</span>, <span class="string">"command"</span>: [<span class="string">"R"</span>, <span class="string">"D"</span>, <span class="string">"2"</span>] &#125;] &#125;] &#125;] &#125;,</span><br><span class="line">    &#123; <span class="string">"command"</span>: [&#123; <span class="string">"times"</span>: <span class="number">10</span>, <span class="string">"command"</span>: [<span class="string">"U"</span>, <span class="string">"4"</span>, <span class="string">"L"</span>, &#123; <span class="string">"times"</span>: <span class="number">10</span>, <span class="string">"command"</span>: [<span class="string">"L"</span>, <span class="string">"4"</span>, <span class="string">"D"</span>, &#123; <span class="string">"times"</span>: <span class="number">10</span>, <span class="string">"command"</span>: [<span class="string">"R"</span>, <span class="string">"D"</span>, <span class="string">"2"</span>] &#125;] &#125;] &#125;] &#125;</span><br><span class="line">    ];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> params = paramsList[<span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * paramsList.length)];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> options = &#123;</span><br><span class="line">        url: <span class="string">'https://juejin-game.bytedance.com/game/sea-gold/game/command?uid='</span> + uid + <span class="string">'&amp;time='</span> + currentTime,</span><br><span class="line">        method: <span class="string">"POST"</span>,</span><br><span class="line">        credentials: <span class="string">"include"</span>,</span><br><span class="line">        headers: &#123;</span><br><span class="line">            <span class="string">'Content-type'</span>: <span class="string">'application/json; charset=UTF-8'</span>,</span><br><span class="line">            <span class="string">'authorization'</span>: authorization,</span><br><span class="line">            <span class="string">'accept'</span>: <span class="string">'application/json, text/plain, */*'</span>,</span><br><span class="line">            <span class="string">'content-length'</span>: <span class="built_in">JSON</span>.stringify(params).length,</span><br><span class="line">            <span class="string">'x-tt-gameid'</span>: gameid,</span><br><span class="line">        &#125;,</span><br><span class="line">        data: params,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">await</span> axios(options).then(<span class="function">(<span class="params">response</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(response.data);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (response.data.code == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//成功</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> response.data.data.gameDiamond</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//4009 代码块不足</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//结束游戏</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">gameOver</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> params = &#123; <span class="string">"isButton"</span>: <span class="number">1</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> options = &#123;</span><br><span class="line">        url: <span class="string">'https://juejin-game.bytedance.com/game/sea-gold/game/over?uid='</span> + uid + <span class="string">'&amp;time='</span> + <span class="built_in">Date</span>.parse(<span class="keyword">new</span> <span class="built_in">Date</span>()),</span><br><span class="line">        method: <span class="string">"POST"</span>,</span><br><span class="line">        credentials: <span class="string">"include"</span>,</span><br><span class="line">        headers: &#123;</span><br><span class="line">            <span class="string">'Content-type'</span>: <span class="string">'application/json; charset=UTF-8'</span>,</span><br><span class="line">            <span class="string">'authorization'</span>: authorization,</span><br><span class="line">            <span class="string">'accept'</span>: <span class="string">'application/json, text/plain, */*'</span>,</span><br><span class="line">            <span class="string">'content-length'</span>: <span class="built_in">JSON</span>.stringify(params).length,</span><br><span class="line">        &#125;,</span><br><span class="line">        data: params,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">await</span> axios(options).then(<span class="function">(<span class="params">response</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(response.data);</span><br><span class="line">     <span class="keyword">if</span> (response.data.code == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//成功</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> response.data.data.todayDiamond&gt;=response.data.data.todayLimitDiamond</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">delay</span>(<span class="params">time</span>) </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> start = <span class="built_in">Number</span>(<span class="keyword">new</span> <span class="built_in">Date</span>());</span><br><span class="line">    <span class="keyword">while</span> (start + time * <span class="number">200</span> &gt; <span class="built_in">Number</span>(<span class="keyword">new</span> <span class="built_in">Date</span>())) &#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">start</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//开始游戏--&gt;游戏执行--&gt;游戏结束</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> index = <span class="number">0</span>; index &lt; <span class="number">100</span>; index++) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"倒计时:"</span> + index)</span><br><span class="line">        <span class="keyword">await</span> gameStart()</span><br><span class="line">        <span class="keyword">let</span> time = <span class="keyword">await</span> gameRun()</span><br><span class="line">        </span><br><span class="line">       </span><br><span class="line">        <span class="comment">//同步延迟结束游戏 根据获取的金币而定 金币越多 延迟时间越长</span></span><br><span class="line">        <span class="keyword">await</span> delay(time)</span><br><span class="line">        <span class="keyword">let</span> info=<span class="keyword">await</span> gameOver()</span><br><span class="line">        <span class="comment">//金币达到上限 停止游戏</span></span><br><span class="line">        <span class="keyword">if</span>(info)&#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">start()</span><br></pre></td></tr></table></figure>

<p>将以上代码拷贝到你的本地文件中, 填入你的游戏<code>authorization</code>和<code>uid</code>, 然后每天用<code>node</code>运行一遍即可</p>
<p>到这里, 第一阶段的自动化已然实现</p>
<h3 id="程序定时执行"><a href="#程序定时执行" class="headerlink" title="程序定时执行"></a>程序定时执行</h3><p>每天手动跑代码太费事, 稍不留神就有可能某天给漏了, 尤其是周六日不开电脑的时候岂不是没法执行脚本了</p>
<p>这时 我们可以考虑放到服务器中每天定时执行, 365天风雨无阻, 推荐大家使用<code>github</code>或者<code>travis ci</code>免费服务部署</p>
<p>我这里手上刚好有一台阿里云的服务器, 因此直接用服务器跑, 这里我使用的是<code>crontab</code>定时程序, 关于<code>crontab</code>的用法, 可参见《<a href="https://code.newban.cn/1.html">Linux Crontab 命令安装和使用教程：在 VPS 上设置定时任务</a>》</p>
<p>以<code>ubuntu</code>为例具体操作步骤如下:</p>
<ol>
<li><p><strong>将本地脚本拷贝至服务器</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">scp 脚本文件 root@服务器IP:/root</span><br></pre></td></tr></table></figure>

<p>注意:冒号前后不能有空格, 否则会提示目录不存在</p>
</li>
<li><p><strong>登录服务器配置<code>crontab</code>任务</strong></p>
<p>执行<code>crontab -e</code>进入<code>cron</code>编辑界面, 将以下定时代码写入</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">0 8 * * *  /usr/bin/node /root/jwt_test &gt;&gt;/root//log/jwt_test_$(date +\%Y-\%m-\%d-\%H).log 2&gt;&amp;</span><br></pre></td></tr></table></figure>

<p>表示每天8点执行该脚本</p>
</li>
<li><p><strong>安装<code>nodejs</code>及相关依赖</strong></p>
<p>如果服务器已经安装nodejs可忽略该步操作</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">//更新源</span><br><span class="line">sudo apt-get update</span><br><span class="line">//安装nodejs</span><br><span class="line">sudo apt-get install -y nodejs</span><br><span class="line">//安装npm包管理器</span><br><span class="line">sudo apt-get install npm</span><br><span class="line">//安装脚本依赖</span><br><span class="line">npm install jsonwebtoken</span><br><span class="line">npm install axios</span><br></pre></td></tr></table></figure>
</li>
<li><p>配置完毕</p>
</li>
</ol>
<p><strong>本文为作者原创转载时请注明出处 谢谢</strong></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em><a href="https://code.newban.cn/">乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</a></em></p>
]]></content>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>使用python对博客网站的文章进行爬取</title>
    <url>/289.html</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>说到爬取文章啥的, 最好使的肯定是python, python中有很多爬虫库可供我们使用, 方便快捷, 虽然工具很多, 但是大同小异, 我们只需要用好一个库就够了</p>
<p>接下来以掘金为例, 给大家演示一下如何爬取网站中的文章:</p>
<h3 id="网站结构分析"><a href="#网站结构分析" class="headerlink" title="网站结构分析"></a>网站结构分析</h3><p>调出浏览器控制台, 通过分析, 我们发现掘金和简书不同, 其网站中的文章链接全部都是通过接口动态请求的, 而非以<code>Nginx</code>容器静态存放</p>
<p>由于我们需要获取多篇文章,而不是单篇, 所以文章链接我们必须先拿到手, 然后再根据链接挨个将文章爬出来</p>
<h4 id="文章链接获取"><a href="#文章链接获取" class="headerlink" title="文章链接获取"></a>文章链接获取</h4><p>在推荐一栏通过上拉加载我们很轻松就能获取到请求的接口和参数, 我们只需要将其拷贝出来用<code>python</code>模拟请求即可</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20211201163303973.png" alt="image-20211201163303973"></p>
<p><strong>请求接口:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https://api.juejin.cn/recommend_api/v1/article/recommend_cate_feed?aid=xxx&amp;uuid=xxx</span><br></pre></td></tr></table></figure>

<p><strong>请求参数:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;&quot;id_type&quot;:2,&quot;sort_type&quot;:200,&quot;cate_id&quot;:&quot;6809637769959178254&quot;,&quot;cursor&quot;:&quot;1&quot;,&quot;limit&quot;:20&#125;</span><br></pre></td></tr></table></figure>

<p>其中<code>cursor</code>字段表示页数, 我们可以循环递增这个字段的值来源源不断地获取数据</p>
<p><strong>响应数据:</strong></p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20211201163627506.png" alt="image-20211201163627506"></p>
<p>这个<code>article_id</code>就是我们需要获取的值, 将这个值和<code>https://juejin.cn/post/</code>进行拼接就得到了文章的实际地址, 如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https://juejin.cn/post/7016520448204603423</span><br></pre></td></tr></table></figure>

<p>好了, 分析完毕后, 直接上代码实现:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># coding:utf-8</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">import codecs</span><br><span class="line">import time</span><br><span class="line">import requests</span><br><span class="line">import json</span><br><span class="line">import sys</span><br><span class="line"># 增加try except嵌套层数 避免</span><br><span class="line">sys.setrecursionlimit(10000)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">cache_file_name = &apos;temp_juejin.txt&apos;</span><br><span class="line"></span><br><span class="line">cache = []</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">def loadCache():</span><br><span class="line">    with codecs.open(cache_file_name, &quot;r&quot;, &quot;utf-8&quot;) as fr:</span><br><span class="line">        for line in fr:</span><br><span class="line">            cache.append(line)</span><br><span class="line">        #print(cache)</span><br><span class="line">        #return cache[len(cache)-1]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def startScrape():</span><br><span class="line">    </span><br><span class="line">    apiUrl=&apos;https://api.juejin.cn/recommend_api/v1/article/recommend_cate_feed?aid=2608&amp;uuid=7023196943133656589&apos;</span><br><span class="line">    HEADERS = &#123;</span><br><span class="line">        &apos;User-Agent&apos;		: &apos;Mozilla/5.0 (Macintosh; Intel Mac OS X 10.7; rv:11.0) Gecko/20100101 Firefox/11.0&apos;,</span><br><span class="line">       </span><br><span class="line">        &apos;Accept-Encoding&apos;	: &apos;gzip,deflate,sdch&apos;,</span><br><span class="line">        &apos;Accept-Language&apos;	: &apos;zh-CN,zh;q=0.8&apos;,</span><br><span class="line">         &apos;Content-type&apos;: &apos;application/json; charset=UTF-8&apos;,</span><br><span class="line">       &apos;accept&apos;: &apos;application/json, text/plain, */*&apos;,</span><br><span class="line">          </span><br><span class="line">        &#125;</span><br><span class="line">    for index in range(1000):</span><br><span class="line">        body = &#123;&quot;id_type&quot;:2,&quot;sort_type&quot;:200,&quot;cate_id&quot;:&quot;6809637769959178254&quot;,&quot;cursor&quot;:&quot;1&quot;,&quot;limit&quot;:20&#125;</span><br><span class="line">        body[&quot;cursor&quot;]=str(index+1)</span><br><span class="line">        print(body)</span><br><span class="line">        r = requests.post(url=apiUrl, headers=HEADERS,data=json.dumps(body))</span><br><span class="line">        print(r.status_code)</span><br><span class="line">        </span><br><span class="line">        res=json.loads(r.content)</span><br><span class="line">       </span><br><span class="line">        with codecs.open(cache_file_name, &quot;a&quot;, &quot;utf-8&quot;) as f:</span><br><span class="line">            for item in res[&quot;data&quot;]:</span><br><span class="line">                print()</span><br><span class="line">                id=item[&quot;article_info&quot;][&quot;article_id&quot;]</span><br><span class="line">                link = &quot;https://juejin.cn/post/&quot;+id</span><br><span class="line">                print(link)</span><br><span class="line">                #if link not in cache: #判断存在或者不存在</span><br><span class="line">                if not any(link in s for s in cache):</span><br><span class="line">                    cache.append(link)</span><br><span class="line">                    f.write(link+&quot;\n&quot;)</span><br><span class="line">                    print(&quot;新增一条连接&quot;)</span><br><span class="line">                    #time.sleep(10)</span><br><span class="line">                    #切记 url不要加入换行 否则404</span><br><span class="line">            f.close()  </span><br><span class="line">        time.sleep(2)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def job():</span><br><span class="line"></span><br><span class="line">    loadCache()</span><br><span class="line">    startScrape()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    job()</span><br></pre></td></tr></table></figure>

<p>执行该代码前先在同级目录下新建一个<code>temp_juejin.txt</code>文件, 用于存放获取到的所有文章链接, 对于初学者, 这里需要注意的是<code>json</code>的转换处理和请求头的设置, 如果没有使用<code>json.dumps</code>进行转换, 那么请求会失败, 如果请求头不加<code>Content-type</code>和<code>accept</code>或者没填对, 请求正常但是返回的不是正常的数据, 这一块是很多人极易忽视的地方</p>
<p>代码运行后爬取的结果如下:</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20211201164332262.png" alt="image-20211201164332262"></p>
<p>好了, 有了文章链接, 下一步我们就开始挨个文章的爬取</p>
<h3 id="文章爬取"><a href="#文章爬取" class="headerlink" title="文章爬取"></a>文章爬取</h3><p>爬虫框架, 我这里使用的是<code>PyQuery</code>, 关于<code>PyQuery</code>的用法, 可参见《<a href="https://code.newban.cn/291.html">Python爬虫框架之PyQuery的使用</a>》</p>
<p>接下来我们爬取文章的标题和内容, 代码如下:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> pyquery <span class="keyword">import</span> PyQuery <span class="keyword">as</span> pq</span><br><span class="line"><span class="keyword">import</span> codecs</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sys.setrecursionlimit(<span class="number">1000000</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 当前文件路径</span></span><br><span class="line">current_path = os.path.abspath(__file__)</span><br><span class="line"><span class="comment"># 父目录</span></span><br><span class="line">father_path = os.path.abspath(os.path.dirname(current_path) + os.path.sep + <span class="string">"."</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">headers = &#123;</span><br><span class="line">    <span class="string">'user-agent'</span>: <span class="string">'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.110 Safari/537.36'</span>,</span><br><span class="line">    <span class="string">'cookie'</span>: <span class="string">'__cfduid=d89ead99eeea979ea1f2a1a6243d186461600935008; Hm_lvt_2374bfdfe14a279e4a045267051b54e1=1600935010,1601459114; __yjsv3_shitong=1.0_7_8b1bac638e380ca12f87734ab2405afe2e94_300_1601470572844_223.104.3.46_aaa564dc; cf_chl_1=04a386244ad8d71; cf_chl_prog=x17; cf_clearance=f4af2dbdded649a7cf11a5a52d168289e98e68c6-1601470577-0-1zd4e21871z8a534313z279abd70-150; Hm_lpvt_2374bfdfe14a279e4a045267051b54e1=1601470578'</span>,</span><br><span class="line">    <span class="string">'accept'</span>: <span class="string">'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8'</span>,</span><br><span class="line">   </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">session = requests.Session()</span><br><span class="line">session.headers.update(headers)</span><br><span class="line"></span><br><span class="line">origin_url_cache_file_name=<span class="string">"temp_juejin.txt"</span></span><br><span class="line"></span><br><span class="line">originUrlCache = []</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将文件中内容按行加载至列表中</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">loadCache</span><span class="params">(filename, filter_text)</span>:</span></span><br><span class="line">    cache = []</span><br><span class="line">    <span class="keyword">with</span> codecs.open(filename, <span class="string">"r"</span>, <span class="string">"utf-8"</span>) <span class="keyword">as</span> fr:</span><br><span class="line">        <span class="keyword">if</span> filter_text:</span><br><span class="line">            <span class="keyword">for</span> line <span class="keyword">in</span> fr:</span><br><span class="line">                <span class="keyword">if</span> filter_text <span class="keyword">in</span> line:</span><br><span class="line">                    cache.append(line.replace(<span class="string">"\n"</span>, <span class="string">""</span>))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">for</span> line <span class="keyword">in</span> fr:</span><br><span class="line">                cache.append(line.replace(<span class="string">"\n"</span>, <span class="string">""</span>))</span><br><span class="line">        <span class="keyword">return</span> cache</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_article_by_url</span><span class="params">(url)</span>:</span></span><br><span class="line">    rep = session.get(url)</span><br><span class="line">    d=pq(rep.text)</span><br><span class="line">    title = d(<span class="string">'h1'</span>).text()</span><br><span class="line">    content = d(<span class="string">'.markdown-body'</span>).html()</span><br><span class="line">    <span class="keyword">return</span> title, content</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">startScrape</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">for</span> link <span class="keyword">in</span> originUrlCache:</span><br><span class="line">   </span><br><span class="line">        print(link + <span class="string">"\n"</span>)</span><br><span class="line">        title, content = get_article_by_url(link)</span><br><span class="line">        print(title + <span class="string">"\n"</span>)</span><br><span class="line">        print(content)</span><br><span class="line">        </span><br><span class="line">          </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line"></span><br><span class="line">    <span class="comment">#将需要爬取的url加载到内存中</span></span><br><span class="line">    originUrlCache=loadCache(<span class="string">"&#123;parent&#125;/&#123;filename&#125;"</span>.format(parent=father_path,filename=origin_url_cache_file_name), <span class="literal">None</span>)</span><br><span class="line">    <span class="comment">#开始爬取文章</span></span><br><span class="line">    startScrape()</span><br></pre></td></tr></table></figure>

<p>但是打印结果全部为<code>None</code>, 去控台一查发现掘金文章页面内容是通过<code>js</code>动态渲染的, 如果直接获取<code>html</code>是无法通过<code>PyQuery</code>获取到我们想要的内容的, 那这咋办?</p>
<p>想一下, 如果我们能拿到渲染完成后的<code>html</code>, 然后再通过<code>PyQuery</code>进行查找, 不就完事了</p>
<p>问题在于如何获取到渲染完成后的页面源码, 单纯的<code>Get</code>请求肯定是不行的, 我们需要模拟浏览器渲染才行,</p>
<p>这个时候我们就需要用到一个<code>Web</code>自动化框架, 也就是大名鼎鼎的<code>selenium</code>, 它可以模拟真实的浏览器访问和查找甚至是点击操作, 这里我们只需要利用它得到页面源码即可, 关于<code>selenium</code>的详细使用, 可参见《<a href="https://code.newban.cn/292.html">Web自动化框架selenium的介绍与使用</a>》</p>
<p>于是代码修改成如下模样:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> pyquery <span class="keyword">import</span> PyQuery <span class="keyword">as</span> pq</span><br><span class="line"><span class="keyword">import</span> codecs</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">chrome_options = webdriver.ChromeOptions()</span><br><span class="line"><span class="comment"># 使用headless无界面浏览器模式</span></span><br><span class="line">chrome_options.add_argument(<span class="string">'--headless'</span>) <span class="comment">#增加无界面选项</span></span><br><span class="line">chrome_options.add_argument(<span class="string">'--disable-gpu'</span>) <span class="comment">#如果不加这个选项，有时定位会出现问题</span></span><br><span class="line"></span><br><span class="line">browser = webdriver.Chrome(chrome_options=chrome_options)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sys.setrecursionlimit(<span class="number">1000000</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 当前文件路径</span></span><br><span class="line">current_path = os.path.abspath(__file__)</span><br><span class="line"><span class="comment"># 父目录</span></span><br><span class="line">father_path = os.path.abspath(os.path.dirname(current_path) + os.path.sep + <span class="string">"."</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">origin_url_cache_file_name=<span class="string">"temp_juejin.txt"</span></span><br><span class="line"></span><br><span class="line">originUrlCache = []</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将文件中内容按行加载至列表中</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">loadCache</span><span class="params">(filename, filter_text)</span>:</span></span><br><span class="line">    cache = []</span><br><span class="line">    <span class="keyword">with</span> codecs.open(filename, <span class="string">"r"</span>, <span class="string">"utf-8"</span>) <span class="keyword">as</span> fr:</span><br><span class="line">        <span class="keyword">if</span> filter_text:</span><br><span class="line">            <span class="keyword">for</span> line <span class="keyword">in</span> fr:</span><br><span class="line">                <span class="keyword">if</span> filter_text <span class="keyword">in</span> line:</span><br><span class="line">                    cache.append(line.replace(<span class="string">"\n"</span>, <span class="string">""</span>))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">for</span> line <span class="keyword">in</span> fr:</span><br><span class="line">                cache.append(line.replace(<span class="string">"\n"</span>, <span class="string">""</span>))</span><br><span class="line">        <span class="keyword">return</span> cache</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_article_by_url</span><span class="params">(url)</span>:</span></span><br><span class="line">    browser.get(url)</span><br><span class="line">    d = pq(browser.page_source)</span><br><span class="line">    title = d(<span class="string">'h1'</span>).text()</span><br><span class="line">    content = d(<span class="string">'.markdown-body'</span>).html()</span><br><span class="line">    <span class="keyword">return</span> title, content</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">startScrape</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">for</span> link <span class="keyword">in</span> originUrlCache:</span><br><span class="line">   </span><br><span class="line">        print(link + <span class="string">"\n"</span>)</span><br><span class="line">        title, content = get_article_by_url(link)</span><br><span class="line">        print(title + <span class="string">"\n"</span>)</span><br><span class="line">        print(content)</span><br><span class="line">        </span><br><span class="line">          </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line"></span><br><span class="line">    <span class="comment">#将需要爬取的url加载到内存中</span></span><br><span class="line">    originUrlCache=loadCache(<span class="string">"&#123;parent&#125;/&#123;filename&#125;"</span>.format(parent=father_path,filename=origin_url_cache_file_name), <span class="literal">None</span>)</span><br><span class="line">    <span class="comment">#开始爬取文章</span></span><br><span class="line">    startScrape()</span><br></pre></td></tr></table></figure>

<p>该代码运行的前提是需要安装谷歌浏览器</p>
<p>运行时如果提示<code>This version of ChromeDriver only supports Chrome version</code>, 那么说明浏览器版本和驱动版本不一致, 需要下载与浏览器相匹配的驱动</p>
<p>查看谷歌浏览器版本:</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjMwODkwNA==,size_16,color_FFFFFF,t_70.png" alt="在这里插入图片描述"></p>
<p>然后下载驱动:</p>
<p><a href="http://chromedriver.storage.googleapis.com/index.html" target="_blank" rel="noopener">ChromeDriver下载地址</a></p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjMwODkwNA==,size_16,color_FFFFFF,t_70-20211202135554142.png" alt="在这里插入图片描述"></p>
<p>将下载的驱动解压到以下目录:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Win：复制webdriver到Python安装目录下</span><br><span class="line">Mac：复制webdriver到/usr/local/bin目录下</span><br></pre></td></tr></table></figure>

<p>至此, 我们成功爬取到指定文章地址的标题和内容</p>
<p>既然获取到了想要的数据, 那么接下来你可以考虑将其存放到本地, 或者上传到你的<code>wordpress</code></p>
<p>关于<code>wordpress</code>文章的上传,可参考文章《<a href="https://code.newban.cn/29.html">如何将python采集到的文章保存到wordpress</a>》</p>
<h3 id="文章上传到wordpress"><a href="#文章上传到wordpress" class="headerlink" title="文章上传到wordpress"></a>文章上传到wordpress</h3><p>秉着善始善终的原则, 以上面的代码为例给大家补充上上传<code>wordpress</code>后的最终代码:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> lxml <span class="keyword">import</span> html</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> pyquery <span class="keyword">import</span> PyQuery <span class="keyword">as</span> pq</span><br><span class="line"><span class="keyword">import</span> codecs</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">from</span> wordpress_xmlrpc <span class="keyword">import</span> Client, WordPressPost</span><br><span class="line"><span class="keyword">from</span> wordpress_xmlrpc.methods.posts <span class="keyword">import</span> GetPosts,NewPost</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">import</span> time  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">chrome_options = webdriver.ChromeOptions()</span><br><span class="line"><span class="comment"># 使用headless无界面浏览器模式</span></span><br><span class="line">chrome_options.add_argument(<span class="string">'--headless'</span>) <span class="comment">#增加无界面选项</span></span><br><span class="line">chrome_options.add_argument(<span class="string">'--disable-gpu'</span>) <span class="comment">#如果不加这个选项，有时定位会出现问题</span></span><br><span class="line"></span><br><span class="line">browser = webdriver.Chrome(chrome_options=chrome_options)</span><br><span class="line"></span><br><span class="line">sys.setrecursionlimit(<span class="number">1000000</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 当前文件路径</span></span><br><span class="line">current_path = os.path.abspath(__file__)</span><br><span class="line"><span class="comment"># 父目录</span></span><br><span class="line">father_path = os.path.abspath(os.path.dirname(current_path) + os.path.sep + <span class="string">"."</span>)</span><br><span class="line"></span><br><span class="line">pushed_cache_file_name=<span class="string">"temp_juejin_pushed_url.txt"</span></span><br><span class="line">origin_url_cache_file_name=<span class="string">"temp_juejin.txt"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">pushedCache = []</span><br><span class="line">originUrlCache = []</span><br><span class="line">wp = Client(<span class="string">'http://您的域名/xmlrpc.php'</span>, <span class="string">'wordpress用户名'</span>, <span class="string">'wordpress登录密码'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将文件中内容按行加载至列表中</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">loadCache</span><span class="params">(filename, filter_text)</span>:</span></span><br><span class="line">    cache = []</span><br><span class="line">    <span class="keyword">with</span> codecs.open(filename, <span class="string">"r"</span>, <span class="string">"utf-8"</span>) <span class="keyword">as</span> fr:</span><br><span class="line">        <span class="keyword">if</span> filter_text:</span><br><span class="line">            <span class="keyword">for</span> line <span class="keyword">in</span> fr:</span><br><span class="line">                <span class="keyword">if</span> filter_text <span class="keyword">in</span> line:</span><br><span class="line">                    cache.append(line.replace(<span class="string">"\n"</span>, <span class="string">""</span>))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">for</span> line <span class="keyword">in</span> fr:</span><br><span class="line">                cache.append(line.replace(<span class="string">"\n"</span>, <span class="string">""</span>))</span><br><span class="line">        <span class="keyword">return</span> cache</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">push_article</span><span class="params">(post_title,post_content_html)</span>:</span></span><br><span class="line">    post = WordPressPost()</span><br><span class="line">    post.title = post_title</span><br><span class="line">    post.slug = post_title</span><br><span class="line">    post.content = post_content_html</span><br><span class="line">    post.terms_names = &#123;</span><br><span class="line">      <span class="string">'post_tag'</span>: post_title.split(<span class="string">" "</span>),</span><br><span class="line">      <span class="string">'category'</span>: [<span class="string">"itarticle"</span>]</span><br><span class="line">        &#125;</span><br><span class="line">    post.post_status = <span class="string">'publish'</span></span><br><span class="line">    wp.call(NewPost(post))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_article_by_url</span><span class="params">(url)</span>:</span></span><br><span class="line">    browser.get(url)</span><br><span class="line">    d = pq(browser.page_source)</span><br><span class="line">    browser.quit</span><br><span class="line">    title = d(<span class="string">'h1'</span>).text()</span><br><span class="line">    content = d(<span class="string">'.markdown-body'</span>).html()</span><br><span class="line">    <span class="keyword">return</span> title, content</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">startScrape</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">for</span> link <span class="keyword">in</span> originUrlCache:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> any(link <span class="keyword">in</span> s <span class="keyword">for</span> s <span class="keyword">in</span> pushedCache):</span><br><span class="line">            print(link + <span class="string">"\n"</span>)</span><br><span class="line">            title, content = get_article_by_url(link)</span><br><span class="line">            print(title + <span class="string">"\n"</span>)</span><br><span class="line">            print(content)</span><br><span class="line">            push_article(title,content)</span><br><span class="line">            time.sleep(<span class="number">2</span>)</span><br><span class="line">            <span class="keyword">with</span> codecs.open(<span class="string">"&#123;parent&#125;/&#123;filename&#125;"</span>.format(parent=father_path,filename=pushed_cache_file_name), <span class="string">'a'</span>, <span class="string">"utf-8"</span>) <span class="keyword">as</span> fw:</span><br><span class="line">                fw.write(link + <span class="string">"\n"</span>)</span><br><span class="line">                fw.close()</span><br><span class="line">          </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="comment">#将已经爬取过的url加载到内存中</span></span><br><span class="line">    pushedCache=loadCache(<span class="string">"&#123;parent&#125;/&#123;filename&#125;"</span>.format(parent=father_path,filename=pushed_cache_file_name), <span class="literal">None</span>)</span><br><span class="line">    <span class="comment">#将需要爬取的url加载到内存中</span></span><br><span class="line">    originUrlCache=loadCache(<span class="string">"&#123;parent&#125;/&#123;filename&#125;"</span>.format(parent=father_path,filename=origin_url_cache_file_name), <span class="literal">None</span>)</span><br><span class="line">    <span class="comment">#开始爬取文章</span></span><br><span class="line">    startScrape()</span><br></pre></td></tr></table></figure>

<p>只要将域名, 用户名和密码替换成你自己的就行</p>
<p>注意<code>wordpress_xmlrpc</code>库的安装:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip install python-wordpress-xmlrpc</span><br></pre></td></tr></table></figure>

<h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><p>另外 上面获取文章链接环节也可以直接使用<code>selenium</code>进行获取, 虽然不如调接口来的快, 但是碰上接口被加密的情况, 那么<code>selenium</code>的方式能快速解决 </p>
<p><strong>本文为作者原创转载时请注明出处 谢谢</strong></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em><a href="https://code.newban.cn/">乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</a></em></p>
]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Android原生格斗游戏开发</title>
    <url>/290.html</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>昨天晚上做了个梦, 梦见我在沙…</p>
<p>梦里的事已经记不得了, 不过大半夜醒来后大脑异常清醒活跃, 居然在构思着一款格斗游戏</p>
<p>也不知道这灵光从何而来, 近大半年都没有玩游戏, 也没有做游戏相关的开发</p>
<p>不过在我内心深处 确实是有一个3A游戏梦, 话说格斗游戏, 算是我童年最爱吧 </p>
<p>不管怎么着, 反正当时是越想越起劲, 心跳加速, 鼻子发痒, 差点误以为流了鼻血</p>
<p>既然这么刺激, 那么 就将想法变成现实吧, 开始着手进行游戏的开发, 这次平台我选择用Android原生, 为什么不直接使用第三方引擎, 主要还是想着把基础的东西捋一遍, 地基打好了, 上层建筑也就没什么难的</p>
<h3 id="游戏架构设计"><a href="#游戏架构设计" class="headerlink" title="游戏架构设计"></a>游戏架构设计</h3><p>无论游戏还是普通应用, 都是由两个大部分组成的, 一个是场景界面, 另一个则是事件处理</p>
<p>我们只需要从这两个方面着手即可</p>
<h4 id="场景界面"><a href="#场景界面" class="headerlink" title="场景界面"></a>场景界面</h4><p>这款游戏的场景很简单, 只有一个场景, 和拳皇类似, 一个背景, 左右各一人, 就这么简单</p>
<h3 id="事件处理"><a href="#事件处理" class="headerlink" title="事件处理"></a>事件处理</h3><p>移动端的游戏, 我们肯定是需要在屏幕上加上触控的游戏摇杆, 来操作角色的行动</p>
<p>说到动作, 所有的角色都具备左右上下跑跳滑铲的动作, 因此这部分我们在代码实现的时候, 可以将其进行抽象到父类中, 让所有子类角色与生俱来</p>
<p><strong>本文为作者原创转载时请注明出处 谢谢</strong></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em><a href="https://code.newban.cn/">乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</a></em></p>
]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>如何将python采集到的文章保存到wordpress</title>
    <url>/29.html</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p><code>wordpress</code>算是比较流行的博客网站框架, 我本人也一直在使用, 关于<code>python</code>采集文章的上传, 有以下几种方法:</p>
<ol>
<li><strong>直接操作数据库</strong></li>
<li><strong>使用<code>wordpress</code>的<code>rest api</code></strong></li>
<li><strong>使用<code>wordpress_xmlrpc</code>第三方模块</strong></li>
</ol>
<p>其中第三种的体验最为舒适, 对新手友好, 推荐使用</p>
<p>好了 接下来挨个介绍一下这几种方法的使用</p>
<h3 id="直接操作数据库"><a href="#直接操作数据库" class="headerlink" title="直接操作数据库"></a>直接操作数据库</h3><p>我们可以使用<code>python</code>的<code>pymysql</code>库进行<code>mysql</code>数据库的直连操作, 具体不过多介绍, 直接上示例代码:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pymysql.cursors</span><br><span class="line"></span><br><span class="line"><span class="comment"># 连接数据库</span></span><br><span class="line">connect = pymysql.Connect(</span><br><span class="line">    host=<span class="string">'数据库IP'</span>,</span><br><span class="line">    port=<span class="number">3306</span>,</span><br><span class="line">    user=<span class="string">'root'</span>,</span><br><span class="line">    passwd=<span class="string">'xxxx'</span>,</span><br><span class="line">    db=<span class="string">'数据库名称'</span>,</span><br><span class="line">    charset=<span class="string">'utf8mb4'</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取游标</span></span><br><span class="line">cursor = connect.cursor()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 插入数据</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">insert</span><span class="params">(post_author, post_date, post_date_gmt,post_content,post_title,post_status,comment_status,ping_status,post_type,menu_order,post_excerpt,to_ping)</span>:</span></span><br><span class="line">    cursor.execute(<span class="string">'INSERT INTO wp_posts (post_author, post_date, post_date_gmt,post_content,post_title,post_status,comment_status,ping_status,post_type,menu_order,post_excerpt)VALUES ( %d, %s,%s, %s,%s, %s,%s, %s,%s,%s, %s, %s)'</span>, (<span class="number">1</span>, post_date, post_date_gmt,post_content,post_title,post_status,comment_status,ping_status,post_type,menu_order,post_excerpt,to_ping))</span><br><span class="line"></span><br><span class="line">    connect.commit()</span><br><span class="line">    print(<span class="string">'成功插入'</span>, cursor.rowcount, <span class="string">'条数据'</span>)</span><br></pre></td></tr></table></figure>

<h3 id="使用wordpress的rest-api"><a href="#使用wordpress的rest-api" class="headerlink" title="使用wordpress的rest api"></a>使用wordpress的rest api</h3><p>关于<code>rest api</code>官方文档如下:</p>
<p><a href="https://developer.wordpress.org/rest-api/" target="_blank" rel="noopener">https://developer.wordpress.org/rest-api/</a></p>
<p><strong>我们先试一下api的威力 格式为</strong>:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http://&#123;域名&#125;/index.php/wp-json/wp/v2/posts</span><br></pre></td></tr></table></figure>

<p>比如:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http://www.jhcms.net/index.php/wp-json/wp/v2/posts</span><br></pre></td></tr></table></figure>

<p>我们能看到几乎大部分文章的信息</p>
<p><strong>那么如何创建一个新文章</strong></p>
<p>我们参考官方文档 <a href="https://developer.wordpress.org/rest-api/reference/posts/#create-a-post" target="_blank" rel="noopener">https://developer.wordpress.org/rest-api/reference/posts/#create-a-post</a></p>
<p>得到重要信息如下:</p>
<h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><table>
<thead>
<tr>
<th><code>date</code></th>
<th>The date the object was published, in the site’s timezone.</th>
</tr>
</thead>
<tbody><tr>
<td><code>date_gmt</code></td>
<td>The date the object was published, as GMT.</td>
</tr>
<tr>
<td><code>slug</code></td>
<td>An alphanumeric identifier for the object unique to its type.</td>
</tr>
<tr>
<td><code>status</code></td>
<td>A named status for the object. One of: <code>publish</code>, <code>future</code>, <code>draft</code>, <code>pending</code>, <code>private</code></td>
</tr>
<tr>
<td><code>password</code></td>
<td>A password to protect access to the content and excerpt.</td>
</tr>
<tr>
<td><code>title</code></td>
<td>The title for the object.</td>
</tr>
<tr>
<td><code>content</code></td>
<td>The content for the object.</td>
</tr>
<tr>
<td><code>author</code></td>
<td>The ID for the author of the object.</td>
</tr>
<tr>
<td><code>excerpt</code></td>
<td>The excerpt for the object.</td>
</tr>
<tr>
<td><code>featured_media</code></td>
<td>The ID of the featured media for the object.</td>
</tr>
<tr>
<td><code>comment_status</code></td>
<td>Whether or not comments are open on the object. One of: <code>open</code>, <code>closed</code></td>
</tr>
<tr>
<td><code>ping_status</code></td>
<td>Whether or not the object can be pinged. One of: <code>open</code>, <code>closed</code></td>
</tr>
<tr>
<td><code>format</code></td>
<td>The format for the object. One of: <code>standard</code>, <code>aside</code>, <code>chat</code>, <code>gallery</code>, <code>link</code>, <code>image</code>, <code>quote</code>, <code>status</code>, <code>video</code>, <code>audio</code></td>
</tr>
<tr>
<td><code>meta</code></td>
<td>Meta fields.</td>
</tr>
<tr>
<td><code>sticky</code></td>
<td>Whether or not the object should be treated as sticky.</td>
</tr>
<tr>
<td><code>template</code></td>
<td>The theme file to use to display the object. One of:``</td>
</tr>
<tr>
<td><code>categories</code></td>
<td>The terms assigned to the object in the category taxonomy.</td>
</tr>
<tr>
<td><code>tags</code></td>
<td>The terms assigned to the object in the post_tag taxonomy.</td>
</tr>
</tbody></table>
<p><code>POST /wp/v2/posts</code> 意为要用<code>post</code>方法提交到<code>/wp/v2/posts</code>这个地址</p>
<p>默认是只读<code>api</code>, 要实现提交数据需要安装插件<code>jwt</code>，安装了<code>jwt</code>后可以请求到<code>token</code>了，然后在<code>rest api</code>中传入<code>token</code>信息，系统就不会拒绝你的发布文章的操作了</p>
<h3 id="操作步骤"><a href="#操作步骤" class="headerlink" title="操作步骤"></a>操作步骤</h3><ol>
<li><p>第一步 在<code>wordpress</code>管理后台安装 <code>JWT Auth</code> 插件</p>
</li>
<li><p>第二部 在网站根目录  <strong>.htaccess</strong> 文件中添加如下内容</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">RewriteEngine on</span><br><span class="line">RewriteCond %&#123;HTTP:Authorization&#125; ^(.*)</span><br><span class="line">RewriteRule ^(.*) - [E=HTTP_AUTHORIZATION:%1]</span><br><span class="line"></span><br><span class="line">SetEnvIf Authorization &quot;(.*)&quot; HTTP_AUTHORIZATION=$1</span><br></pre></td></tr></table></figure>
</li>
<li><p>在 <strong>wp-config.php</strong> 文件中添加如下内容：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">define(&apos;JWT_AUTH_SECRET_KEY&apos;, &apos;your-top-secret-key&apos;);//随便填写一个密码</span><br><span class="line">define(&apos;JWT_AUTH_CORS_ENABLE&apos;, true);</span><br></pre></td></tr></table></figure>
</li>
<li><p>Post请求调用<code>http://{你的域名}/wp-json/jwt-auth/v1/token</code>接口获取token</p>
</li>
<li><p>根据token进行文章的发布</p>
</li>
</ol>
<h4 id="核心代码如下"><a href="#核心代码如下" class="headerlink" title="核心代码如下:"></a>核心代码如下:</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> numpy <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_token</span><span class="params">()</span>:</span></span><br><span class="line">    session = requests.Session()</span><br><span class="line">    url = <span class="string">'http://sex.newban.cn/wp-json/jwt-auth/v1/token'</span></span><br><span class="line">    data = &#123;</span><br><span class="line">        <span class="string">'username'</span>:<span class="string">"son3g"</span>,</span><br><span class="line">        <span class="string">'password'</span>:<span class="string">"123456"</span></span><br><span class="line">        &#125;</span><br><span class="line">    headers = &#123;<span class="string">'user-agent'</span>: <span class="string">'Mozolla/5.0'</span>,</span><br><span class="line">               &#125;</span><br><span class="line">    resp = session.post(url, data=data, headers=headers, timeout=<span class="number">3335</span>)  <span class="comment"># 请求</span></span><br><span class="line">    r = json.loads(resp.content)</span><br><span class="line">    <span class="keyword">return</span> r</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_do_post</span><span class="params">( token =<span class="string">''</span>)</span>:</span></span><br><span class="line">        session = requests.Session()</span><br><span class="line">        url = <span class="string">'http://sex.newban.cn/wp-json/wp/v2/posts'</span></span><br><span class="line">        data = &#123;</span><br><span class="line">                <span class="string">'date'</span>: time.strftime(<span class="string">'%Y-%m-%d %H:%M:%S'</span>, time.localtime()),</span><br><span class="line">                <span class="string">'date_gmt'</span>: time.strftime(<span class="string">'%Y-%m-%d %H:%M:%S'</span>, time.gmtime()),</span><br><span class="line">                <span class="string">'slug'</span>: <span class="string">'xx'</span>,</span><br><span class="line">                <span class="string">'status'</span>: <span class="string">'publish'</span>,</span><br><span class="line">                <span class="string">'password'</span>: <span class="string">''</span>,</span><br><span class="line">                <span class="string">'title'</span>: <span class="string">'rest api发布post测试'</span>,</span><br><span class="line">                <span class="string">'content'</span>: <span class="string">'系统测试我想我是海冬天的大海'</span>,</span><br><span class="line">                <span class="string">'author	'</span>: <span class="string">'121852835@qq.com'</span>,</span><br><span class="line">                <span class="string">'excerpt'</span>: <span class="string">''</span>,</span><br><span class="line">                <span class="string">'featured_media'</span>: <span class="string">'0'</span>,</span><br><span class="line">                <span class="string">'comment_status'</span>: <span class="string">'open'</span>,</span><br><span class="line">                <span class="string">'ping_status'</span>: <span class="string">'closed'</span>,</span><br><span class="line">                <span class="string">'format'</span>: <span class="string">'standard'</span>,</span><br><span class="line">                <span class="string">'meta'</span>: [],</span><br><span class="line">                <span class="string">'sticky'</span>: <span class="literal">False</span>,  <span class="comment"># 置顶</span></span><br><span class="line">                <span class="string">'template'</span>: <span class="string">''</span>,</span><br><span class="line">                <span class="string">'categories'</span>: <span class="string">'1'</span>,  <span class="comment"># 1 未分类</span></span><br><span class="line">                <span class="string">'tags'</span>: <span class="string">''</span></span><br><span class="line">        &#125;</span><br><span class="line">        headers = &#123;<span class="string">'user-agent'</span>: <span class="string">'Mozolla/5.0'</span>,</span><br><span class="line">                   <span class="string">'Authorization'</span>: <span class="string">'Bearer '</span> + token</span><br><span class="line">                   &#125;</span><br><span class="line">        resp = session.post(url, data=data, headers=headers, timeout=<span class="number">3335</span>)  <span class="comment"># 请求</span></span><br><span class="line">        <span class="keyword">print</span> (resp.text)</span><br><span class="line">        <span class="comment"># r = json.loads(resp.content, 'utf-8')</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># if r["code"] == 400:</span></span><br><span class="line">        <span class="comment">#         print r["code"]</span></span><br><span class="line">        <span class="comment">#         print r["message"]</span></span><br><span class="line">        <span class="comment">#         print r["data"]</span></span><br><span class="line">        <span class="comment">#         print r["data"]["status"]</span></span><br><span class="line">        <span class="comment">#</span></span><br><span class="line">        <span class="comment">#</span></span><br><span class="line">        <span class="comment">#         # print r["data"]["params"]</span></span><br><span class="line">        <span class="comment">#         for key in r["data"]["params"]:</span></span><br><span class="line">        <span class="comment">#             print ("%s=&gt; %s" % (key, r["data"]["params"][key]))</span></span><br><span class="line">        <span class="comment">#         # print 'resp.text=&gt;' + resp.text</span></span><br><span class="line">        <span class="comment">#</span></span><br><span class="line">        <span class="comment">#         # print time.strftime('%Y-%m-%d %H:%M:%S',time.localtime(time.time()))</span></span><br><span class="line">        <span class="comment">#         # print time.strftime('%a, %d %b %Y %H:%M:%S GMT+0800 (CST)',time.localtime(time.time())),</span></span><br><span class="line">        <span class="comment">#         dt = formatdate(None, usegmt=True)</span></span><br><span class="line">        <span class="comment">#         dt1 = formatdate(None, usegmt=False)</span></span><br><span class="line">        <span class="comment">#         dt3 = formatdate()</span></span><br><span class="line">        <span class="comment">#         print(dt)</span></span><br><span class="line">        <span class="comment">#         print(dt1)</span></span><br><span class="line">        <span class="comment"># else:</span></span><br><span class="line">        <span class="comment">#         print r["code"]</span></span><br><span class="line">        <span class="comment">#         print r["message"]</span></span><br><span class="line">        <span class="comment">#         print resp.status_code</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">'__main__'</span>:</span><br><span class="line">        r = get_token()</span><br><span class="line">        <span class="keyword">print</span> (r)</span><br><span class="line">        _do_post(r[<span class="string">"data"</span>][<span class="string">'token'</span>])</span><br></pre></td></tr></table></figure>

<h3 id="使用wordpress-xmlrpc第三方模块"><a href="#使用wordpress-xmlrpc第三方模块" class="headerlink" title="使用wordpress_xmlrpc第三方模块"></a>使用<code>wordpress_xmlrpc</code>第三方模块</h3><p>操作步骤如下:</p>
<ol>
<li><p>安装<code>wordpress_xmlrpc</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip install python-wordpress-xmlrpc</span><br></pre></td></tr></table></figure>
</li>
<li><p>模块引入</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> wordpress_xmlrpc <span class="keyword">import</span> Client, WordPressPost</span><br><span class="line"><span class="keyword">from</span> wordpress_xmlrpc.methods.posts <span class="keyword">import</span> GetPosts,NewPost</span><br></pre></td></tr></table></figure>
</li>
<li><p>发布新文章</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">push_article</span><span class="params">(post_title,post_content_html)</span>:</span></span><br><span class="line">    post = WordPressPost()</span><br><span class="line">    post.title = post_title</span><br><span class="line">    post.slug = post_title</span><br><span class="line">    post.content = post_content_html</span><br><span class="line">    post.terms_names = &#123;</span><br><span class="line">      <span class="string">'post_tag'</span>: post_title.split(<span class="string">" "</span>),</span><br><span class="line">      <span class="string">'category'</span>: [<span class="string">"itarticle"</span>]</span><br><span class="line">        &#125;</span><br><span class="line">    post.post_status = <span class="string">'publish'</span></span><br><span class="line">    wp.call(NewPost(post))</span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    push_article(<span class="string">"文章标题"</span>,<span class="string">"文章内容"</span>)</span><br></pre></td></tr></table></figure>

<p>属性介绍:</p>
<ul>
<li><strong>title</strong>: 文章标题</li>
<li><strong>content</strong>: 文章正文</li>
<li><strong>post_status</strong>: 文章状态，不写默认是草稿，private表示私密的，draft表示草稿，publish表示发布</li>
<li><strong>terms_names</strong>: 设置文章的标签 tag等</li>
<li><strong>slug</strong>: 文章别名</li>
</ul>
</li>
</ol>
<p>完整代码如下:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="keyword">from</span> wordpress_xmlrpc <span class="keyword">import</span> Client, WordPressPost</span><br><span class="line"><span class="keyword">from</span> wordpress_xmlrpc.methods.posts <span class="keyword">import</span> GetPosts,NewPost</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">push_article</span><span class="params">(post_title,post_content_html)</span>:</span></span><br><span class="line">    post = WordPressPost()</span><br><span class="line">    post.title = post_title</span><br><span class="line">    post.slug = post_title</span><br><span class="line">    post.content = post_content_html</span><br><span class="line">    post.terms_names = &#123;</span><br><span class="line">      <span class="string">'post_tag'</span>: post_title.split(<span class="string">" "</span>),</span><br><span class="line">      <span class="string">'category'</span>: [<span class="string">"itarticle"</span>]</span><br><span class="line">        &#125;</span><br><span class="line">    post.post_status = <span class="string">'publish'</span></span><br><span class="line">    wp.call(NewPost(post))</span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    push_article(<span class="string">"文章标题"</span>,<span class="string">"文章内容"</span>)</span><br></pre></td></tr></table></figure>

<p>是不是很简单呢, 如果是批量上传的话, 直接一个循环调用即可</p>
<p><strong>本文为作者原创 转载时请注明出处 谢谢</strong></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em>乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</em></p>
]]></content>
      <tags>
        <tag>python自动化</tag>
      </tags>
  </entry>
  <entry>
    <title>2021年终总结 这要从我抽中了小爱音响开始说起</title>
    <url>/294.html</url>
    <content><![CDATA[<p>最近参加了掘金的年终总结活动, 临时起意写了一篇文章, <a href="https://juejin.cn/post/7041383701292253214" target="_blank" rel="noopener">点击进入掘金</a>, 为了礼品我也是够拼了 哈哈  以下是原稿:</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/pexels-photo-1321909.jpeg" alt="站立和倾斜在树上的女人"></p>
<p>「时光不负，创作不停，本文正在参加<a href="https://juejin.cn/post/7034786723137585188/" target="_blank" rel="noopener">2021年终总结征文大赛</a>」</p>
<p>所谓无图不丈夫 XDM喜欢否?</p>
<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>今天办公室异常闷热 热得我一看屏幕就眼睛发肿， 导致无法正常工作</p>
<p>于是乎 原本没打算参加年终总结活动的我写起了总结</p>
<p>唯一的动力就是掘金的大礼 哈哈</p>
<p>说到大礼 昨天不小心抽中了一个小爱音响 还在活动群炫耀了一番:</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20211214100831346.png" alt="image-20211214100831346"></p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20211214100925150.png" alt="image-20211214100925150"></p>
<p>说到抽奖 作为一个在年会经常抽中一等奖的我 在这给大家分享一下个人的心得:</p>
<ul>
<li><p><strong>首先 你要有一个抽奖资格 …</strong> </p>
</li>
<li><p><strong>然后 在抽奖的这段时间里 内心一定要保持非常开心的状态 让自己兴奋起来 男同胞们如果不够兴奋可以多看几遍上面那张大图, 也就是让抽奖机感受到你的激情 让对方明白你非常想要 哈哈</strong> </p>
</li>
<li><p><strong>这听起来似乎有点玄 不过没关系 不用太在意这些细节  你要想象成这奖品已经到了手</strong> </p>
</li>
<li><p><strong>一切准备好后 开始抽奖 那么中奖概率能大幅提升一个档次 咳咳</strong></p>
</li>
</ul>
<p>如果抱着无所谓的态度 那么抽中的概率会大大降低 , 所谓心心念念 必有回响嘛</p>
<p>以上只是个人经验瞎扯 无科学根据 仅供参考哈哈</p>
<p>下面附上我16年公司年会抽中的一个<code>ipad mini</code>:</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20211214100209725.png" alt="image-20211214100209725"></p>
<p>目前将其当做第二屏使用, 提升生产力的同时, 还能缓解颈椎不适, 嘿嘿</p>
<h3 id="今年收获"><a href="#今年收获" class="headerlink" title="今年收获"></a>今年收获</h3><p>今年收获很大, 话不多说, 直接看下面:</p>
<ul>
<li><strong>SKG颈椎按摩器时尚语音款 一台</strong></li>
<li><strong>瑞视达T1手机投影仪 一台</strong></li>
<li><strong>小霸王D99增强版游戏机 一台</strong></li>
<li><strong>小熊咖啡机全自动滴漏式0.7L 一个</strong></li>
<li><strong>多元兼容黑色帆布双肩包 一个</strong></li>
<li><strong>未来星乐园”定制积木 一座</strong></li>
<li><strong>字节跳动智能感温保温杯 一只</strong></li>
<li><strong>掘金 T 恤 一件</strong></li>
<li><strong>掘金棒球帽 两顶</strong></li>
<li><strong>掘金搪瓷杯 两只</strong></li>
<li><strong>字节跳动空调毯 一床</strong></li>
<li><strong>小册优惠码 两个</strong></li>
<li><strong>掘金Bug 52个</strong></li>
</ul>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20211214103132112.png" alt="image-20211214103132112"></p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20211214103224187.png" alt="image-20211214103224187"></p>
<h3 id="明年Flag"><a href="#明年Flag" class="headerlink" title="明年Flag"></a>明年Flag</h3><p>明年我打算把Q400游戏机拿下 ​​</p>
<h3 id="未来五年"><a href="#未来五年" class="headerlink" title="未来五年"></a>未来五年</h3><p>争取把任天堂 NS 拿下</p>
<p>我已经做好了打持久战的准备了 哈哈哈</p>
<h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>再次感谢掘金, 让我收获了这么多的礼品</p>
<h3 id="另外"><a href="#另外" class="headerlink" title="另外"></a>另外</h3><p>近期 我的第三张个人原创音乐专辑已经全网上线了, 欢迎大家前来捧场, 以下是网易云试听链接:</p>
<p><a href="https://music.163.com/#/album?id=137142351" target="_blank" rel="noopener">茶余饭后</a></p>
<p>​    </p>
<p><strong>本文为作者原创转载时请注明出处 谢谢</strong></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em><a href="https://code.newban.cn/">乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</a></em></p>
]]></content>
      <tags>
        <tag>杂谈</tag>
      </tags>
  </entry>
  <entry>
    <title>Python爬虫框架之PyQuery的使用</title>
    <url>/291.html</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p><code>Python</code>之所以很适合写爬虫, 其中一个原因是拥有丰富的解析器Lib</p>
<p>以<code>HTML</code>解析为例就有<code>XPATH</code>，<code>Beautiful Soup</code>和<code>PyQuery</code>等等</p>
<p>想用哪个用哪个</p>
<p>那么今天我们就来介绍其中<code>PyQuery</code>这个解析器的用法, <code>PyQuery</code>的语法和<code>jquery</code>大同小异, 如果你熟悉<code>jquery</code>的使用, 那么这款解析器绝对适合你</p>
<h3 id="组件安装"><a href="#组件安装" class="headerlink" title="组件安装"></a>组件安装</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip install pyquery</span><br></pre></td></tr></table></figure>

<h3 id="组件引入"><a href="#组件引入" class="headerlink" title="组件引入"></a>组件引入</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from pyquery import PyQuery as pq</span><br></pre></td></tr></table></figure>

<h3 id="三个小示例"><a href="#三个小示例" class="headerlink" title="三个小示例"></a>三个小示例</h3><p>假设我们有这么一个<code>HTML</code>文本:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div id=&quot;wrap&quot;&gt;</span><br><span class="line">        &lt;ul class=&quot;s_from&quot;&gt;</span><br><span class="line">            我是测试文本</span><br><span class="line">            &lt;link href=&quot;http://aaa.com&quot;&gt;aaa&lt;/link&gt;</span><br><span class="line">            &lt;link href=&quot;http://bbb.com&quot;&gt;bbb&lt;/link&gt;</span><br><span class="line">            &lt;link href=&quot;http://ccc.com&quot;&gt;ccc&lt;/link&gt;</span><br><span class="line">        &lt;/ul&gt;</span><br><span class="line">    &lt;/div&gt;</span><br></pre></td></tr></table></figure>

<p>如果我们要获取<code>div</code>标签下的所有内容(<strong>包含div标签</strong>), 那么我们可以这样:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pyquery <span class="keyword">import</span> PyQuery <span class="keyword">as</span> pq</span><br><span class="line">html = <span class="string">'''</span></span><br><span class="line"><span class="string"> &lt;div id="wrap"&gt;</span></span><br><span class="line"><span class="string">        &lt;ul class="s_from"&gt;</span></span><br><span class="line"><span class="string">            我是测试文本</span></span><br><span class="line"><span class="string">            &lt;link href="http://aaa.com"&gt;aaa&lt;/link&gt;</span></span><br><span class="line"><span class="string">            &lt;link href="http://bbb.com"&gt;bbb&lt;/link&gt;</span></span><br><span class="line"><span class="string">            &lt;link href="http://ccc.com"&gt;ccc&lt;/link&gt;</span></span><br><span class="line"><span class="string">        &lt;/ul&gt;</span></span><br><span class="line"><span class="string">    &lt;/div&gt;</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line">doc = pq(html)</span><br><span class="line">result=doc(<span class="string">"#wrap"</span>)</span><br><span class="line">print(result)</span><br></pre></td></tr></table></figure>

<p>得到的结果为:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div id=&quot;wrap&quot;&gt;</span><br><span class="line">       &lt;ul class=&quot;s_from&quot;&gt;</span><br><span class="line">           我是测试文本</span><br><span class="line">           &lt;link href=&quot;http://aaa.com&quot;&gt;aaa&lt;/link&gt;</span><br><span class="line">           &lt;link href=&quot;http://bbb.com&quot;&gt;bbb&lt;/link&gt;</span><br><span class="line">           &lt;link href=&quot;http://ccc.com&quot;&gt;ccc&lt;/link&gt;</span><br><span class="line">       &lt;/ul&gt;</span><br><span class="line">   &lt;/div&gt;</span><br></pre></td></tr></table></figure>

<p>如果我们要获取<code>div</code>标签下的所有<strong>元素</strong>(<strong>不包含div标签</strong>),, 那么我们可以使用<code>children()</code>函数, 如下:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pyquery <span class="keyword">import</span> PyQuery <span class="keyword">as</span> pq</span><br><span class="line">html = <span class="string">'''</span></span><br><span class="line"><span class="string"> &lt;div id="wrap"&gt;</span></span><br><span class="line"><span class="string">        &lt;ul class="s_from"&gt;</span></span><br><span class="line"><span class="string">            我是测试文本</span></span><br><span class="line"><span class="string">            &lt;link href="http://aaa.com"&gt;aaa&lt;/link&gt;</span></span><br><span class="line"><span class="string">            &lt;link href="http://bbb.com"&gt;bbb&lt;/link&gt;</span></span><br><span class="line"><span class="string">            &lt;link href="http://ccc.com"&gt;ccc&lt;/link&gt;</span></span><br><span class="line"><span class="string">        &lt;/ul&gt;</span></span><br><span class="line"><span class="string">    &lt;/div&gt;</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line">doc = pq(html)</span><br><span class="line">result=doc(<span class="string">"#wrap"</span>).children()</span><br><span class="line">print(result)</span><br></pre></td></tr></table></figure>

<p>那么得到的结果为:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;ul class=&quot;s_from&quot;&gt;</span><br><span class="line">         我是测试文本</span><br><span class="line">         &lt;link href=&quot;http://aaa.com&quot;&gt;aaa&lt;/link&gt;</span><br><span class="line">         &lt;link href=&quot;http://bbb.com&quot;&gt;bbb&lt;/link&gt;</span><br><span class="line">         &lt;link href=&quot;http://ccc.com&quot;&gt;ccc&lt;/link&gt;</span><br><span class="line">     &lt;/ul&gt;</span><br></pre></td></tr></table></figure>

<p>如果我们要获取<code>ul</code>标签下的所有内容, 我们可以这样:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pyquery <span class="keyword">import</span> PyQuery <span class="keyword">as</span> pq</span><br><span class="line">html = <span class="string">'''</span></span><br><span class="line"><span class="string"> &lt;div id="wrap"&gt;</span></span><br><span class="line"><span class="string">        &lt;ul class="s_from"&gt;</span></span><br><span class="line"><span class="string">            我是测试文本</span></span><br><span class="line"><span class="string">            &lt;link href="http://aaa.com"&gt;aaa&lt;/link&gt;</span></span><br><span class="line"><span class="string">            &lt;link href="http://bbb.com"&gt;bbb&lt;/link&gt;</span></span><br><span class="line"><span class="string">            &lt;link href="http://ccc.com"&gt;ccc&lt;/link&gt;</span></span><br><span class="line"><span class="string">        &lt;/ul&gt;</span></span><br><span class="line"><span class="string">    &lt;/div&gt;</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line">doc = pq(html)</span><br><span class="line">result=doc(<span class="string">"ul"</span>).html()</span><br><span class="line">print(result)</span><br></pre></td></tr></table></figure>

<p>那么得到的结果为:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">我是测试文本</span><br><span class="line">         &lt;link href=&quot;http://aaa.com&quot;&gt;aaa&lt;/link&gt;</span><br><span class="line">         &lt;link href=&quot;http://bbb.com&quot;&gt;bbb&lt;/link&gt;</span><br><span class="line">         &lt;link href=&quot;http://ccc.com&quot;&gt;ccc&lt;/link&gt;</span><br></pre></td></tr></table></figure>

<p>通过上面三个小例子示范我们大致感受了一下<code>PyQuery</code>的使用, 但是依然无法深入了解, 接下来我们对其用法进行总结</p>
<h3 id="使用总结"><a href="#使用总结" class="headerlink" title="使用总结"></a>使用总结</h3><ol>
<li><p>通过<code>id</code>获取<code>html</code>使用<code>#</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pq(html)(<span class="string">"#xxx"</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>通过<code>class</code>获取<code>html</code>使用’.`</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pq(html)(<span class="string">".xxx"</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>通过标签名获取<code>html</code>直接使用标签</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pq(html)(<span class="string">"div"</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>查找父元素使用<code>parent()</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pq(html)(<span class="string">"#xxx"</span>).parent()</span><br></pre></td></tr></table></figure>
</li>
<li><p>获取目标位置下包裹的所有的元素</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pq(html)(<span class="string">"#xxx"</span>).children()</span><br></pre></td></tr></table></figure>
</li>
<li><p>获取目标位置下包裹的所有的<code>html</code>内容</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pq(html)(<span class="string">"#xxx"</span>).html()</span><br></pre></td></tr></table></figure>
</li>
<li><p>获取目标位置下包裹的所有的文本内容</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pq(html)(<span class="string">"#xxx"</span>).text()</span><br></pre></td></tr></table></figure>

<p>注意: 我们要和<code>html()</code>与<code>children()</code>进行区分, 我们用一个例子来解释:</p>
<p>如果使用<code>html()</code>:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># coding:utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pyquery <span class="keyword">import</span> PyQuery <span class="keyword">as</span> pq</span><br><span class="line">html = <span class="string">'''</span></span><br><span class="line"><span class="string"> &lt;div id="wrap"&gt;</span></span><br><span class="line"><span class="string">        &lt;ul class="s_from"&gt;</span></span><br><span class="line"><span class="string">            我是测试文本</span></span><br><span class="line"><span class="string">            &lt;link href="http://aaa.com"&gt;aaa&lt;/link&gt;</span></span><br><span class="line"><span class="string">            &lt;link href="http://bbb.com"&gt;bbb&lt;/link&gt;</span></span><br><span class="line"><span class="string">            &lt;link href="http://ccc.com"&gt;ccc&lt;/link&gt;</span></span><br><span class="line"><span class="string">        &lt;/ul&gt;</span></span><br><span class="line"><span class="string">    &lt;/div&gt;</span></span><br><span class="line"><span class="string">     &lt;link href="http://ddd.com"&gt;ccc&lt;/link&gt;</span></span><br><span class="line"><span class="string">        &lt;/ul&gt;</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line">doc = pq(html)</span><br><span class="line">result=doc(<span class="string">"#wrap"</span>).html()</span><br><span class="line">print(result)</span><br></pre></td></tr></table></figure>

<p>得到的结果为:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">我是测试文本</span><br><span class="line">      &lt;link href=&quot;http://aaa.com&quot;/&gt;&lt;p&gt;aaa&lt;/p&gt;</span><br><span class="line">      &lt;link href=&quot;http://bbb.com&quot;/&gt;bbb</span><br><span class="line">      &lt;link href=&quot;http://ccc.com&quot;/&gt;ccc</span><br></pre></td></tr></table></figure>

<p>如果使用<code>children()</code>:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">doc = pq(html)</span><br><span class="line">result=doc(<span class="string">".s_from"</span>).children()</span><br><span class="line">print(result)</span><br></pre></td></tr></table></figure>

<p>得到结果为:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;link href=&quot;http://aaa.com&quot;/&gt;&lt;p&gt;aaa&lt;/p&gt;</span><br><span class="line">            &lt;link href=&quot;http://bbb.com&quot;/&gt;bbb</span><br><span class="line">            &lt;link href=&quot;http://ccc.com&quot;/&gt;ccc</span><br></pre></td></tr></table></figure>

<p>如果使用<code>text()</code>:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">doc = pq(html)</span><br><span class="line">result=doc(<span class="string">".s_from"</span>).text()</span><br><span class="line">print(result)</span><br></pre></td></tr></table></figure>

<p>得到结果为:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">我是测试文本</span><br><span class="line">aaa</span><br><span class="line">bbb</span><br><span class="line">ccc</span><br></pre></td></tr></table></figure>

<p>一目了然</p>
</li>
<li><p>查找兄弟元素使用<code>siblings()</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pq(html)(<span class="string">"#xxx"</span>).siblings()</span><br></pre></td></tr></table></figure>
</li>
<li><p>将所有获取到的元素组成数组<code>items()</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pq(html)(<span class="string">"#xxx"</span>).items()</span><br></pre></td></tr></table></figure>

<p>比如:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># coding:utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pyquery <span class="keyword">import</span> PyQuery <span class="keyword">as</span> pq</span><br><span class="line">html = <span class="string">'''</span></span><br><span class="line"><span class="string"> &lt;div id="wrap"&gt;</span></span><br><span class="line"><span class="string">        &lt;ul class="s_from"&gt;</span></span><br><span class="line"><span class="string">            我是测试文本</span></span><br><span class="line"><span class="string">            &lt;link href="http://aaa.com"&gt;aaa&lt;/link&gt;</span></span><br><span class="line"><span class="string">            &lt;link href="http://bbb.com"&gt;bbb&lt;/link&gt;</span></span><br><span class="line"><span class="string">            &lt;link href="http://ccc.com"&gt;ccc&lt;/link&gt;</span></span><br><span class="line"><span class="string">        &lt;/ul&gt;</span></span><br><span class="line"><span class="string">    &lt;/div&gt;</span></span><br><span class="line"><span class="string">     &lt;link href="http://ddd.com"&gt;ccc&lt;/link&gt;</span></span><br><span class="line"><span class="string">        &lt;/ul&gt;</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line">doc = pq(html)</span><br><span class="line">result=doc(<span class="string">"link"</span>)</span><br><span class="line">print(result)</span><br></pre></td></tr></table></figure>

<p>那么得到的结果为:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;link href=&quot;http://aaa.com&quot;/&gt;aaa</span><br><span class="line">            &lt;link href=&quot;http://bbb.com&quot;/&gt;bbb</span><br><span class="line">            &lt;link href=&quot;http://ccc.com&quot;/&gt;ccc</span><br><span class="line">        &lt;link href=&quot;http://ddd.com&quot;/&gt;ccc</span><br></pre></td></tr></table></figure>

<p>如果我们想对其进行遍历获取其中某一个元素, 那么可以这样:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># coding:utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pyquery <span class="keyword">import</span> PyQuery <span class="keyword">as</span> pq</span><br><span class="line">html = <span class="string">'''</span></span><br><span class="line"><span class="string"> &lt;div id="wrap"&gt;</span></span><br><span class="line"><span class="string">        &lt;ul class="s_from"&gt;</span></span><br><span class="line"><span class="string">            我是测试文本</span></span><br><span class="line"><span class="string">            &lt;link href="http://aaa.com"&gt;aaa&lt;/link&gt;</span></span><br><span class="line"><span class="string">            &lt;link href="http://bbb.com"&gt;bbb&lt;/link&gt;</span></span><br><span class="line"><span class="string">            &lt;link href="http://ccc.com"&gt;ccc&lt;/link&gt;</span></span><br><span class="line"><span class="string">        &lt;/ul&gt;</span></span><br><span class="line"><span class="string">    &lt;/div&gt;</span></span><br><span class="line"><span class="string">     &lt;link href="http://ddd.com"&gt;ccc&lt;/link&gt;</span></span><br><span class="line"><span class="string">        &lt;/ul&gt;</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line">doc = pq(html)</span><br><span class="line">result=doc(<span class="string">"link"</span>).items()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> result:</span><br><span class="line">    print(i)</span><br></pre></td></tr></table></figure>
</li>
<li><p>获取标签属性信息使用<code>attr()</code></p>
<p>还是上面的例子, 如果我们要获取<code>link</code>标签中<code>href</code>的值, 那么可以这样:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># coding:utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pyquery <span class="keyword">import</span> PyQuery <span class="keyword">as</span> pq</span><br><span class="line">html = <span class="string">'''</span></span><br><span class="line"><span class="string"> &lt;div id="wrap"&gt;</span></span><br><span class="line"><span class="string">        &lt;ul class="s_from"&gt;</span></span><br><span class="line"><span class="string">            我是测试文本</span></span><br><span class="line"><span class="string">            &lt;link href="http://aaa.com"&gt;aaa&lt;/link&gt;</span></span><br><span class="line"><span class="string">            &lt;link href="http://bbb.com"&gt;bbb&lt;/link&gt;</span></span><br><span class="line"><span class="string">            &lt;link href="http://ccc.com"&gt;ccc&lt;/link&gt;</span></span><br><span class="line"><span class="string">        &lt;/ul&gt;</span></span><br><span class="line"><span class="string">    &lt;/div&gt;</span></span><br><span class="line"><span class="string">     &lt;link href="http://ddd.com"&gt;ccc&lt;/link&gt;</span></span><br><span class="line"><span class="string">        &lt;/ul&gt;</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line">doc = pq(html)</span><br><span class="line">result=doc(<span class="string">"link"</span>).items()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> result:</span><br><span class="line">    print(i.attr(<span class="string">'href'</span>)) </span><br><span class="line">    <span class="comment">#或者</span></span><br><span class="line">    print(i.attr.href) </span><br><span class="line">    <span class="comment"># 上面两种获取href的方法任选其一</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>精确查找使用空格</p>
<p>啥意思呢, 我们还是用一个例子来说明:</p>
<p>如果我们要利用层级关系精确查找, 那么可以这样:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># coding:utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pyquery <span class="keyword">import</span> PyQuery <span class="keyword">as</span> pq</span><br><span class="line">html = <span class="string">'''</span></span><br><span class="line"><span class="string"> &lt;div id="wrap"&gt;</span></span><br><span class="line"><span class="string">        &lt;ul class="s_from"&gt;</span></span><br><span class="line"><span class="string">            我是测试文本</span></span><br><span class="line"><span class="string">            &lt;link id="first" "href="http://aaa.com"&gt;111&lt;p&gt;aaa&lt;/p&gt;&lt;/link&gt;</span></span><br><span class="line"><span class="string">            &lt;link href="http://bbb.com"&gt;bbb&lt;/link&gt;</span></span><br><span class="line"><span class="string">            &lt;link href="http://ccc.com"&gt;ccc&lt;/link&gt;</span></span><br><span class="line"><span class="string">        &lt;/ul&gt;</span></span><br><span class="line"><span class="string">    &lt;/div&gt;</span></span><br><span class="line"><span class="string">     &lt;link href="http://ddd.com"&gt;ccc&lt;/link&gt;</span></span><br><span class="line"><span class="string">        &lt;/ul&gt;</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line">doc = pq(html)</span><br><span class="line">result=doc(<span class="string">"#wrap .s_from #first"</span>)</span><br><span class="line">print(result)</span><br></pre></td></tr></table></figure>

<p>层级之间使用空格进行分隔, 得到的结果为:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;link id=&quot;first&quot;/&gt;111</span><br></pre></td></tr></table></figure>

<p>我们惊奇地发现, 查找到的内容有缺失,居然没有打印<code>&lt;p&gt;aaa&lt;/p&gt;</code>, 如果我们将<code>link</code>标签改为<code>a</code>标签:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># coding:utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pyquery <span class="keyword">import</span> PyQuery <span class="keyword">as</span> pq</span><br><span class="line">html = <span class="string">'''</span></span><br><span class="line"><span class="string"> &lt;div id="wrap"&gt;</span></span><br><span class="line"><span class="string">        &lt;ul class="s_from"&gt;</span></span><br><span class="line"><span class="string">            我是测试文本</span></span><br><span class="line"><span class="string">            &lt;a id="first" "href="http://aaa.com"&gt;111&lt;p&gt;aaa&lt;/p&gt;&lt;/a&gt;</span></span><br><span class="line"><span class="string">            &lt;link href="http://bbb.com"&gt;bbb&lt;/link&gt;</span></span><br><span class="line"><span class="string">            &lt;link href="http://ccc.com"&gt;ccc&lt;/link&gt;</span></span><br><span class="line"><span class="string">        &lt;/ul&gt;</span></span><br><span class="line"><span class="string">    &lt;/div&gt;</span></span><br><span class="line"><span class="string">     &lt;link href="http://ddd.com"&gt;ccc&lt;/link&gt;</span></span><br><span class="line"><span class="string">        &lt;/ul&gt;</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line">doc = pq(html)</span><br><span class="line">result=doc(<span class="string">"#wrap .s_from #first"</span>)</span><br><span class="line">print(result)</span><br></pre></td></tr></table></figure>

<p>则结果为:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;a id=&quot;first&quot;&gt;111&lt;p&gt;aaa&lt;/p&gt;&lt;/a&gt;</span><br></pre></td></tr></table></figure>

<p>你可能会说之前写的语法有问题 <code>link</code>标签怎么能又嵌套其他标签呢, 事实上, 你也难保会碰上诸如此类的情况, 毕竟前端鱼龙混杂, 当我们获取不到值的时候, 需要特殊注意一下</p>
</li>
</ol>
<ol start="12">
<li><p>根据标签属性精确查找</p>
<p>比如 我们要查找<code>itemprop</code>属性值为<code>keywords</code>的<code>meta</code>标签, 可以这样写:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">doc = pq(html)</span><br><span class="line">doc(<span class="string">'meta[itemprop="keywords"]'</span>)</span><br></pre></td></tr></table></figure>

<p>如果需要嵌套查找 比如查找<code>itemprop</code>属性值为<code>author</code>的<code>div</code>标签下的<code>itemprop</code>属性值为<code>name</code>的<code>meta</code>标签  可以这样写:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">doc = pq(html)</span><br><span class="line">d(<span class="string">'div[itemprop="author"]'</span>)(<span class="string">'meta[itemprop="name"]'</span>)</span><br></pre></td></tr></table></figure>

<p>更多层级的嵌套也是类的写法</p>
</li>
<li><p>给元素添加<code>class</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pq(html)(<span class="string">"#xxx"</span>).addClass(<span class="string">'active'</span>)</span><br></pre></td></tr></table></figure>

<p>​    如果<code>class</code>已经存在, 则不重复添加</p>
</li>
<li><p>移除元素的<code>class</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pq(html)(<span class="string">"#xxx"</span>).removeClass(<span class="string">'active'</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>给元素添加<code>css</code>样式</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pq(html)(<span class="string">"#xxx"</span>).css(<span class="string">'font-size'</span>,<span class="string">'14px'</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>移除某个标签</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pq(html)(<span class="string">"#xxx"</span>).remove(<span class="string">'ul'</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>伪类选择器</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pyquery <span class="keyword">import</span> PyQuery <span class="keyword">as</span> pq</span><br><span class="line">html = <span class="string">'''</span></span><br><span class="line"><span class="string">    &lt;div href="wrap"&gt;</span></span><br><span class="line"><span class="string">        hello nihao</span></span><br><span class="line"><span class="string">        &lt;ul class="s_from"&gt;</span></span><br><span class="line"><span class="string">            asdasd</span></span><br><span class="line"><span class="string">            &lt;link class='active1 a123' href="http://asda.com"&gt;&lt;a&gt;helloasdadasdad12312&lt;/a&gt;&lt;/link&gt;</span></span><br><span class="line"><span class="string">            &lt;link class='active2' href="http://asda1.com"&gt;asdadasdad12312&lt;/link&gt;</span></span><br><span class="line"><span class="string">            &lt;link class='movie1' href="http://asda2.com"&gt;asdadasdad12312&lt;/link&gt;</span></span><br><span class="line"><span class="string">        &lt;/ul&gt;</span></span><br><span class="line"><span class="string">    &lt;/div&gt;</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line">doc = pq(html)</span><br><span class="line">its=doc(<span class="string">"link:first-child"</span>)</span><br><span class="line">print(<span class="string">'第一个标签:%s'</span>%its)</span><br><span class="line">its=doc(<span class="string">"link:last-child"</span>)</span><br><span class="line">print(<span class="string">'最后一个标签:%s'</span>%its)</span><br><span class="line">its=doc(<span class="string">"link:nth-child(2)"</span>)</span><br><span class="line">print(<span class="string">'第二个标签:%s'</span>%its)</span><br><span class="line">its=doc(<span class="string">"link:gt(0)"</span>) <span class="comment">#从零开始</span></span><br><span class="line">print(<span class="string">"获取0以后的标签:%s"</span>%its)</span><br><span class="line">its=doc(<span class="string">"link:nth-child(2n-1)"</span>)</span><br><span class="line">print(<span class="string">"获取奇数标签:%s"</span>%its)</span><br><span class="line">its=doc(<span class="string">"link:contains('hello')"</span>)</span><br><span class="line">print(<span class="string">"获取文本包含hello的标签:%s"</span>%its)</span><br></pre></td></tr></table></figure>
</li>
<li><p>多选查找, 用逗号分隔</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pq(html)(<span class="string">"h1,h2"</span>) <span class="comment">#表示查找h1和h2标签</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>过滤查找<code>filter</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pq(html).filter(<span class="string">".fisrt"</span>) <span class="comment">#过滤出class为.fisrt的内容</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>使用<code>find</code>方法查找</p>
<p>上面我们介绍的查找都是<code>pq(html)(&quot;xxx&quot;)</code> 列表形式, 除此之外我们还可以用使用调用函数的形式进行查找, 效果也是一样的:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pq(html)(<span class="string">"#xxx"</span>) </span><br><span class="line"><span class="comment">#或者用</span></span><br><span class="line">pq(html).find(<span class="string">"#xxx"</span>)</span><br></pre></td></tr></table></figure>



</li>
</ol>
<h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>以上只是该库的一部分使用方法, 一边用一边掌握, 我个人还是比较喜欢使用这一套解析库, 能解决大部分的应用场景</p>
<p>​    </p>
<p>​    </p>
<p>​    </p>
<p><strong>本文为作者原创转载时请注明出处 谢谢</strong></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em><a href="https://code.newban.cn/">乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</a></em></p>
]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>关于机场订阅链接转换</title>
    <url>/295.html</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>一直在用免费的梯子, 虽然不是太稳定, 但是也够用了 , 平常外网需求并不是太多 </p>
<p>给大家推荐一个机场订阅链接在线转换工具:</p>
<p><a href="https://subconverter.speedupvpn.com/" target="_blank" rel="noopener">点击进入</a></p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20211216113509711.png" alt="image-20211216113509711"></p>
<p>该项目已经开源, 源码地址如下:</p>
<p><a href="https://github.com/tindy2013/subconverter/releases" target="_blank" rel="noopener">GitHub</a></p>
<h3 id="哪里找梯子"><a href="#哪里找梯子" class="headerlink" title="哪里找梯子"></a>哪里找梯子</h3><p>我个人平常的梯子需求基本上都是在<code>Github</code>上找的, 比如 <a href="https://git.io/v2free" target="_blank" rel="noopener">V2Free</a></p>
<p>其他的大家可以自行搜索</p>
<p>另外以下这个网站每天也会更新<code>ssr</code>和<code>TG</code>节点:</p>
<ul>
<li><p><a href="https://www.tang-seo.com/zixun/jishuhaowen" target="_blank" rel="noopener">SSR</a></p>
</li>
<li><p><a href="https://mtproto.cc/" target="_blank" rel="noopener">免费TG代理</a></p>
</li>
</ul>
<p>目前在用的是<code>V2free</code>的免费服务, 每天签到可以获取免费流量, 配合<code>ClashX</code>使用, 速度还不错哦</p>
<p>如下图:</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20211216115040948.png" alt="image-20211216115040948"></p>
<p>具体参见: <a href="https://github.com/bannedbook/fanqiang/wiki/%E8%8B%B9%E6%9E%9C%E7%94%B5%E8%84%91MAC%E7%BF%BB%E5%A2%99" target="_blank" rel="noopener">点击进入</a></p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20211216114733195.png" alt="image-20211216114733195"></p>
<p>具体参见: <a href="https://w1.v2dns.xyz/auth/register?code=cd79" target="_blank" rel="noopener">点击进入</a>, <a href="https://cdn.v2free.net/auth/register?code=cd79" target="_blank" rel="noopener">备用地址</a></p>
<h3 id="附加"><a href="#附加" class="headerlink" title="附加"></a>附加</h3><ul>
<li><a href="https://telegram.im/tools/index.php" target="_blank" rel="noopener">Telegram频道在线搜索</a></li>
</ul>
<h3 id="梯子试用"><a href="#梯子试用" class="headerlink" title="梯子试用"></a>梯子试用</h3><p>如果你不想花钱, 只是紧急临时用一下, 可以考虑一些提供试用的梯子软件, 比如:</p>
<ul>
<li><p><strong>西柚加速器</strong>: <a href="https://hzpcp.com//" target="_blank" rel="noopener">官网链接</a></p>
<p>一个手机号可以试用一天, 如果你有多个手机号, 那么 嘿嘿</p>
</li>
<li><p><strong>auVPN</strong>: <a href="https://auspeed.xyz/zh-CN" target="_blank" rel="noopener">官网链接</a></p>
<p>0.9美元试用7天, 支持支付宝付款</p>
</li>
<li><p><strong>v2free</strong>: <a href="https://v2free.org" target="_blank" rel="noopener">官网链接</a> <a href="https://git.io/v2free" target="_blank" rel="noopener">GitHub</a></p>
<p>3元试用三天</p>
</li>
</ul>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p>如果打算长期使用某一款梯子, 切记不要选择那种用手机号注册的, 尽量选择用邮箱注册, 邮箱也最好使用国外的, 至于为什么, 大家都懂的哈哈</p>
<p><strong>本文为作者原创转载时请注明出处 谢谢</strong></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em><a href="https://code.newban.cn/">乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</a></em></p>
]]></content>
      <tags>
        <tag>墙里墙外</tag>
      </tags>
  </entry>
  <entry>
    <title>一个简单的在线制作 lrc 文件的小工具</title>
    <url>/293.html</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>最近音乐专辑上线, 需要给歌曲制作<code>lrc</code>滚动歌词, <code>Mac</code>平台这方好使的软件不多, 于是尝试找个能在线通过网页制作歌词的网站, 最后找到了这个:</p>
<p>网站地址: <a href="https://judes.me/lrc_editor/" target="_blank" rel="noopener">https://judes.me/lrc_editor/</a>   </p>
<p>用了一下 感觉还不错, 而且项目是开源的, 源码地址如下:</p>
<p><a href="https://github.com/songjianzaina/lrc_editor" target="_blank" rel="noopener">GitHub链接</a></p>
<h3 id="音乐专辑"><a href="#音乐专辑" class="headerlink" title="音乐专辑"></a>音乐专辑</h3><p>我的第三张个人原创音乐专辑《茶余饭后》大部分歌曲歌词都是用这个工具制作的, 以下是网易试听链接:</p>
   <iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="450" src="//music.163.com/outchain/player?type=1&id=137142351&auto=1&height=430"></iframe>

<p>   专辑已经全网上架, 欢迎大家来捧场哦~</p>
<p>​    </p>
<p><strong>本文为作者原创转载时请注明出处 谢谢</strong></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em><a href="https://code.newban.cn/">乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</a></em></p>
]]></content>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>Web自动化框架selenium的介绍与使用</title>
    <url>/292.html</url>
    <content><![CDATA[<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p><code>selenium</code> 是一个 web 的自动化测试工具，可以模拟人工<code>Web</code>浏览,, 适合用于自动化处理和爬虫任务, 该框架支持<code>C、 java、ruby、python</code>等多种语言, 支持三大操作系统和各种常见浏览器</p>
<p>官方文档：</p>
<ul>
<li><a href="https://selenium-python.readthedocs.io/index.html" target="_blank" rel="noopener">https://selenium-python.readthedocs.io/index.html</a></li>
<li><a href="https://seleniumhq.github.io/selenium/docs/api/py/api.html" target="_blank" rel="noopener">https://seleniumhq.github.io/selenium/docs/api/py/api.html</a></li>
</ul>
<p>接下来以<code>python</code>为例, 给大家介绍<code>selenium</code> 的具体使用</p>
<h3 id="selenium使用前准备"><a href="#selenium使用前准备" class="headerlink" title="selenium使用前准备"></a><code>selenium</code>使用前准备</h3><ol>
<li><p>框架安装</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip install selenium</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>web</code>驱动安装</p>
<p>推荐下载使用谷歌或火狐浏览器, 然后根据浏览器版本安装与之对应版本的驱动, 这里我使用的是谷歌浏览器</p>
<p>打开浏览器设置, 查看浏览器版本:</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjMwODkwNA==,size_16,color_FFFFFF,t_70.png" alt="在这里插入图片描述"></p>
<p>然后下载驱动:</p>
<p><a href="http://chromedriver.storage.googleapis.com/index.html" target="_blank" rel="noopener">ChromeDriver下载地址</a></p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjMwODkwNA==,size_16,color_FFFFFF,t_70-20211202135554142.png" alt="在这里插入图片描述"></p>
<p><a href="https://googlechromelabs.github.io/chrome-for-testing/#canary" target="_blank" rel="noopener">谷歌123之后的版本驱动下载地址</a></p>
<p><img src="https://gitee.com/songjianzaina/site_img/raw/master/img/image-20240417115034597.png" alt="image-20240417115034597"></p>
<p>将下载的驱动解压到以下目录:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Win：复制webdriver到Python安装目录下</span><br><span class="line">Mac：复制webdriver到/usr/local/bin目录下</span><br></pre></td></tr></table></figure>

<p>如果是火狐浏览器同理,以下是两大类浏览器驱动下载备用链接:</p>
<table>
<thead>
<tr>
<th>Chrome ( chromedriver )</th>
<th>Firefox ( geckodriver )</th>
</tr>
</thead>
<tbody><tr>
<td><a href="http://chromedriver.storage.googleapis.com/index.html" target="_blank" rel="noopener">官方下载</a></td>
<td><a href="https://github.com/mozilla/geckodriver/releases" target="_blank" rel="noopener">官方下载</a></td>
</tr>
<tr>
<td><a href="https://npm.taobao.org/mirrors/chromedriver/" target="_blank" rel="noopener">淘宝镜像</a></td>
<td><a href="https://npm.taobao.org/mirrors/geckodriver/" target="_blank" rel="noopener">淘宝镜像</a></td>
</tr>
<tr>
<td><a href="http://image.mariojd.cn/chromedriver.exe" target="_blank" rel="noopener">备用下载</a></td>
<td><a href="http://image.mariojd.cn/geckodriver.exe" target="_blank" rel="noopener">备用下载</a></td>
</tr>
</tbody></table>
<p>接下来 我们开始引入框架并使用</p>
</li>
<li><p>框架引入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from selenium import webdriver</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="开始使用"><a href="#开始使用" class="headerlink" title="开始使用"></a>开始使用</h3><ol>
<li><p><strong>自动打开浏览器访问某个网页</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"></span><br><span class="line">browser = webdriver.Chrome()</span><br><span class="line">browser.get(<span class="string">'http://www.baidu.com/'</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>获取网页的源码</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"></span><br><span class="line">browser = webdriver.Chrome()</span><br><span class="line">browser.get(<span class="string">'http://www.baidu.com/'</span>)</span><br><span class="line">print(browser.page_source)</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>不打开浏览器获取网页源码</strong></p>
<p>很多情况下我们只需要让程序在后台静默执行就行, 不需要频繁开启浏览器, 那么我们需要对驱动进行相关设置, 如下:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line">chrome_options = webdriver.ChromeOptions()</span><br><span class="line"><span class="comment"># 使用headless无界面浏览器模式</span></span><br><span class="line">chrome_options.add_argument(<span class="string">'--headless'</span>) <span class="comment">#增加无界面选项</span></span><br><span class="line">chrome_options.add_argument(<span class="string">'--disable-gpu'</span>) <span class="comment">#如果不加这个选项，有时定位会出现问题</span></span><br><span class="line"></span><br><span class="line">browser = webdriver.Chrome(chrome_options=chrome_options)</span><br><span class="line">browser.get(<span class="string">'http://www.baidu.com/'</span>)</span><br><span class="line">print(browser.page_source)</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>以指定配置启动浏览器</strong></p>
<p>常用浏览器有常用的一些设置, 如果我们想在自动化的过程中加载进来可以使用<code>add_argument</code>方法, 如下:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line">option = webdriver.ChromeOptions()</span><br><span class="line">option.add_argument(<span class="string">'--user-data-dir=C:\Users\Administrator\AppData\Local\Google\Chrome\User Data'</span>) <span class="comment">#指定数据目录</span></span><br><span class="line">driver=webdriver.Chrome(chrome_options=option)</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>指定驱动的目录</strong></p>
<p>除了将下载的驱动存放到系统指定目录使用之外, 我们还可以直接指定驱动的存放路径, 方便我们临时测试多个不同的驱动效果, 配置方法如下:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">driver_path = <span class="string">r'D:\ProgramApp\chromedriver\chromedriver.exe'</span></span><br><span class="line"><span class="comment"># 初始化一个driver，并且指定chromedriver的路径</span></span><br><span class="line">driver = webdriver.Chrome(executable_path=driver_path)</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong><code>webdriver</code>常用a<code>pi</code>汇总</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">browser = webdriver.Chrome()</span><br><span class="line"></span><br><span class="line">browser.get_cookies() <span class="comment">#获取所有的cookies</span></span><br><span class="line">browser.page_source <span class="comment">#获取网页源码</span></span><br><span class="line">browser.delete_all_cookies() <span class="comment">#删除所有cookies</span></span><br><span class="line">browser.delete_cookie(key) <span class="comment">#删除某个cookies</span></span><br><span class="line">browser.implicitly_wait(<span class="number">10</span>) <span class="comment">#设置超时时间</span></span><br><span class="line">browser.execute_script(<span class="string">"window.open('https://www.douban.com/')"</span>) <span class="comment">#打开一个新页面</span></span><br><span class="line">browser.title <span class="comment">#获取网页标题</span></span><br><span class="line">browser.current_url <span class="comment">#获取当前网页url</span></span><br><span class="line">browser.capabilities[<span class="string">'version'</span>] <span class="comment">#获取浏览器版本号</span></span><br><span class="line">browser.maximize_window() <span class="comment">#浏览器最大化</span></span><br><span class="line">browser.minimize_window() <span class="comment">#浏览器最小化</span></span><br><span class="line">browser.set_window_size(<span class="number">480</span>, <span class="number">800</span>) <span class="comment">#设置浏览器宽高</span></span><br><span class="line">browser.forword() <span class="comment"># 页面前进</span></span><br><span class="line">browser.back() <span class="comment">#页面后退</span></span><br><span class="line">browser.close() <span class="comment">#关闭当前页面</span></span><br><span class="line">browser.quit() <span class="comment">#退出整个浏览器</span></span><br></pre></td></tr></table></figure>

<p>注意: 如果访问一些需要有<code>cookie</code>验证的页面，我们可以先访问主页，然后再访问详情页，<code>webdriver</code>会自动携带<code>cookie</code></p>
</li>
<li><p><strong><code>ChromeOptions</code>常用函数汇总</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#设置代理ip</span></span><br><span class="line">options.add_argument(<span class="string">"--proxy-server=http://110.73.2.248:8123"</span>)</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="8">
<li><p><strong>网页元素定位查找</strong></p>
<ul>
<li><p>通过元素ID进行定位</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">browser.find_element_by_id()</span><br></pre></td></tr></table></figure>
</li>
<li><p>通过标签名的方式进行定位</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">browser.find_element_by_tag_name(<span class="string">"input"</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>通过<code>class</code>的方式进行定位</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">browser.find_element_by_class_name(<span class="string">"xxx"</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>通过<code>css</code>方式定位</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">browser.find_element_by_css_selector(<span class="string">"xxx"</span>)</span><br></pre></td></tr></table></figure>



</li>
</ul>
</li>
</ol>
<ol start="9">
<li><p><strong>事件模拟</strong></p>
<p>主要分为键盘事件和鼠标事件</p>
<ol>
<li><p><strong>键盘事件</strong></p>
<p>通过 <code>send_keys()</code>调用键盘按键, 比如:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium.webdriver.common.keys <span class="keyword">import</span> Keys</span><br><span class="line"></span><br><span class="line">send_keys(Keys.TAB) <span class="comment"># TAB</span></span><br><span class="line">send_keys(Keys.ENTER) <span class="comment"># 回车</span></span><br></pre></td></tr></table></figure>

<p>参考代码如下:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8 </span></span><br><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver </span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.common.keys <span class="keyword">import</span> Keys <span class="comment">#需要引入 keys 包</span></span><br><span class="line"><span class="keyword">import</span> os,time</span><br><span class="line"></span><br><span class="line">driver = webdriver.Firefox() </span><br><span class="line">driver.get(<span class="string">"http://passport.kuaibo.com/login/?referrer=http%3A%2F%2Fwebcloud .kuaibo.com%2F"</span>)</span><br><span class="line"></span><br><span class="line">time.sleep(<span class="number">3</span>) </span><br><span class="line">driver.maximize_window() <span class="comment"># 浏览器全屏显示</span></span><br><span class="line"></span><br><span class="line">driver.find_element_by_id(<span class="string">"user_name"</span>).clear() </span><br><span class="line">driver.find_element_by_id(<span class="string">"user_name"</span>).send_keys(<span class="string">"fnngj"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#tab 的定位相相于清除了密码框的默认提示信息，等同上面的 clear() </span></span><br><span class="line">driver.find_element_by_id(<span class="string">"user_name"</span>).send_keys(Keys.TAB) </span><br><span class="line">time.sleep(<span class="number">3</span>) </span><br><span class="line">driver.find_element_by_id(<span class="string">"user_pwd"</span>).send_keys(<span class="string">"123456"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#通过定位密码框，enter（回车）来代替登陆按钮</span></span><br><span class="line">driver.find_element_by_id(<span class="string">"user_pwd"</span>).send_keys(Keys.ENTER)</span><br><span class="line"></span><br><span class="line"><span class="comment">#也可定位登陆按钮，通过 enter（回车）代替 click() </span></span><br><span class="line">driver.find_element_by_id(<span class="string">"login"</span>).send_keys(Keys.ENTER) </span><br><span class="line">time.sleep(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">driver.quit()</span><br></pre></td></tr></table></figure>

<p>键盘组合键的用法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#ctrl+a 全选输入框内容 </span></span><br><span class="line">driver.find_element_by_id(<span class="string">"kw"</span>).send_keys(Keys.CONTROL,<span class="string">'a'</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#ctrl+x 剪切输入框内容 </span></span><br><span class="line">driver.find_element_by_id(<span class="string">"kw"</span>).send_keys(Keys.CONTROL,<span class="string">'x'</span>)</span><br></pre></td></tr></table></figure>



</li>
</ol>
</li>
</ol>
<ol start="2">
<li><p><strong>鼠标事件</strong></p>
<p>  鼠标事件一般包括鼠标右键、双击、拖动、移动鼠标到某个元素上等等。 需要引入<code>ActionChains</code>类</p>
<p> 引入方法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium.webdriver.common.action_chains <span class="keyword">import</span> ActionChains</span><br></pre></td></tr></table></figure>

<p><code>ActionChains</code> 常用方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">perform()  执行所有ActionChains 中存储的行为；</span><br><span class="line">context_click()  右击；</span><br><span class="line">double_click()   双击；</span><br><span class="line">drag_and_drop()  拖动；</span><br><span class="line">move_to_element()  鼠标悬停。</span><br></pre></td></tr></table></figure>

<p>鼠标双击示例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#定位到要双击的元素</span></span><br><span class="line"> qqq =driver.find_element_by_xpath(<span class="string">"xxx"</span>) </span><br><span class="line"><span class="comment">#对定位到的元素执行鼠标双击操作 </span></span><br><span class="line"> ActionChains(driver).double_click(qqq).perform()</span><br></pre></td></tr></table></figure>

<p>鼠标拖放示例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#定位元素的原位置 </span></span><br><span class="line">element = driver.find_element_by_name(<span class="string">"source"</span>) </span><br><span class="line"><span class="comment">#定位元素要移动到的目标位置 </span></span><br><span class="line">target = driver.find_element_by_name(<span class="string">"target"</span>)</span><br><span class="line"><span class="comment">#执行元素的移动操作 </span></span><br><span class="line">ActionChains(driver).drag_and_drop(element, target).perform()</span><br></pre></td></tr></table></figure>

</li>
</ol>
<ol start="10">
<li><p><strong>特殊定位</strong></p>
<ol>
<li><p><code>iframe</code>定位</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#先找到到 ifrome1（id = f1）</span></span><br><span class="line">browser.switch_to_frame(<span class="string">"f1"</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>内嵌窗口定位：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">browser.switch_to_window(<span class="string">"f1"</span>)</span><br></pre></td></tr></table></figure>







</li>
</ol>
</li>
</ol>
<h3 id="附加内容"><a href="#附加内容" class="headerlink" title="附加内容"></a>附加内容</h3><ol>
<li><p><strong>Python Webdriver Exception速查表</strong></p>
<p>webdriver在使用过程中可能会出现各种异常，我们需要了解该异常并知道如何进行异常处理。</p>
<table>
<thead>
<tr>
<th>异常</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>WebDriverException</td>
<td>所有webdriver异常的基类，当有异常且不属于下列异常时抛出</td>
</tr>
<tr>
<td>InvalidSwitchToTargetException</td>
<td>下面两个异常的父类，当要switch的目标不存在时抛出</td>
</tr>
<tr>
<td>NoSuchFrameException</td>
<td>当你想要用switch_to.frame()切入某个不存在的frame时抛出</td>
</tr>
<tr>
<td>NoSuchWindowException</td>
<td>当你想要用switch_to.window()切入某个不存在的window时抛出</td>
</tr>
<tr>
<td>NoSuchElementException</td>
<td>元素不存在，一般由find_element与find_elements抛出</td>
</tr>
<tr>
<td>NoSuchAttributeException</td>
<td>一般你获取不存在的元素属性时抛出，要注意有些属性在不同浏览器里是有不同的属性名的</td>
</tr>
<tr>
<td>StaleElementReferenceException</td>
<td>指定的元素过时了，不在现在的DOM树里了，可能是被删除了或者是页面或iframe刷新了</td>
</tr>
<tr>
<td>UnexpectedAlertPresentException</td>
<td>出现了意料之外的alert，阻碍了指令的执行时抛出</td>
</tr>
<tr>
<td>NoAlertPresentException</td>
<td>你想要获取alert，但实际没有alert出现时抛出</td>
</tr>
<tr>
<td>InvalidElementStateException</td>
<td>下面两个异常的父类，当元素状态不能进行想要的操作时抛出</td>
</tr>
<tr>
<td>ElementNotVisibleException</td>
<td>元素存在，但是不可见，不可以与之交互</td>
</tr>
<tr>
<td>ElementNotSelectableException</td>
<td>当你想要选择一个不可被选择的元素时抛出</td>
</tr>
<tr>
<td>InvalidSelectorException</td>
<td>一般当你xpath语法错误的时候抛出这个错</td>
</tr>
<tr>
<td>InvalidCookieDomainException</td>
<td>当你想要在非当前url的域里添加cookie时抛出</td>
</tr>
<tr>
<td>UnableToSetCookieException</td>
<td>当driver无法添加一个cookie时抛出</td>
</tr>
<tr>
<td>TimeoutException</td>
<td>当一个指令在足够的时间内没有完成时抛出</td>
</tr>
<tr>
<td>MoveTargetOutOfBoundsException</td>
<td>actions的move操作时抛出，将目标移动出了window之外</td>
</tr>
<tr>
<td>UnexpectedTagNameException</td>
<td>获取到的元素标签不符合要求时抛出，比如实例化Select，你传入了非select标签的元素时</td>
</tr>
<tr>
<td>ImeNotAvailableException</td>
<td>输入法不支持的时候抛出，这里两个异常不常见，ime引擎据说是仅用于linux下对中文/日文支持的时候</td>
</tr>
<tr>
<td>ImeActivationFailedException</td>
<td>激活输入法失败时抛出</td>
</tr>
<tr>
<td>ErrorInResponseException</td>
<td>不常见，server端出错时可能会抛</td>
</tr>
<tr>
<td>RemoteDriverServerException</td>
<td>不常见，好像是在某些情况下驱动启动浏览器失败的时候会报这个错</td>
</tr>
</tbody></table>
<hr>
</li>
<li><p><strong>Xpath&amp;Css定位方法速查表</strong></p>
<table>
<thead>
<tr>
<th>描述</th>
<th>Xpath</th>
<th>Css</th>
</tr>
</thead>
<tbody><tr>
<td>直接子元素</td>
<td>//div/a</td>
<td>div &gt; a</td>
</tr>
<tr>
<td>子元素或后代元素</td>
<td>//div//a</td>
<td>div a</td>
</tr>
<tr>
<td>以id定位</td>
<td>//div[@id=’idValue’]//a</td>
<td>div#idValue a</td>
</tr>
<tr>
<td>以class定位</td>
<td>//div[@class=’classValue’]//a</td>
<td>div.classValue a</td>
</tr>
<tr>
<td>同级弟弟元素</td>
<td>//ul/li[@class=’first’]/following-</td>
<td>ul&gt;li.first + li</td>
</tr>
<tr>
<td>属性</td>
<td>//form/input[@name=’username’]</td>
<td>form input[name=’username’]</td>
</tr>
<tr>
<td>多个属性</td>
<td>//input[@name=’continue’ and</td>
<td>input[name=’continue’][type=’button</td>
</tr>
<tr>
<td>第4个子元素</td>
<td>//ul[@id=’list’]/li[4]</td>
<td>ul#list li:nth-child(4)</td>
</tr>
<tr>
<td>第1个子元素</td>
<td>//ul[@id=’list’]/li[1]</td>
<td>ul#list li:first-child</td>
</tr>
<tr>
<td>最后1个子元素</td>
<td>//ul[@id=’list’]/li[last()]</td>
<td>ul#list li:last-child</td>
</tr>
<tr>
<td>属性包含某字段</td>
<td>//div[contains(@title,’Title’)]</td>
<td>div[title*=”Title”]</td>
</tr>
<tr>
<td>属性以某字段开头</td>
<td>//input[starts-with(@name,’user’)]</td>
<td>input[name^=”user”]</td>
</tr>
<tr>
<td>属性以某字段结尾</td>
<td>//input[ends-with(@name,’name’)]</td>
<td>input[name$=”name”]</td>
</tr>
<tr>
<td>text中包含某字段</td>
<td>//div[contains(text(), ‘text’)]</td>
<td>无法定位</td>
</tr>
<tr>
<td>元素有某属性</td>
<td>//div[@title]</td>
<td>div[title]</td>
</tr>
<tr>
<td>父节点</td>
<td>//div/..</td>
<td>无法定位</td>
</tr>
<tr>
<td>同级哥哥节点</td>
<td>//li/preceding-sibling::div[1]</td>
<td>无法定位</td>
</tr>
</tbody></table>
</li>
</ol>
<p>​    </p>
<p>​    </p>
<p>​    </p>
<p><strong>本文为作者原创转载时请注明出处 谢谢</strong></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em><a href="https://code.newban.cn/">乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</a></em></p>
]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Android中关于设置屏幕是否休眠的几种方法介绍</title>
    <url>/296.html</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>我们在做视频播放的放得时候 , 肯定会有这样的一个需求, 那就是视频播放时禁止锁屏息屏, 视频暂停或者退出时恢复锁屏息屏</p>
<p>那么, 有以下几种方法供大家参考</p>
<h3 id="方法一：持有WakeLock"><a href="#方法一：持有WakeLock" class="headerlink" title="方法一：持有WakeLock"></a><strong>方法一：</strong>持有WakeLock</h3><p>添加休眠锁，休眠锁必须成对出现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> WakeLock mWakeLock = <span class="keyword">null</span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">acquireWakeLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(mWakeLock == <span class="keyword">null</span>) &#123;</span><br><span class="line">  </span><br><span class="line">    PowerManager pm = (PowerManager)getSystemService(Context.POWER_SERVICE);</span><br><span class="line">    </span><br><span class="line">    mWakeLock = pm.newWakeLock(</span><br><span class="line">      PowerManager.PARTIAL_WAKE_LOCK | </span><br><span class="line">      PowerManager.ACQUIRE_CAUSES_WAKEUP, </span><br><span class="line">       <span class="keyword">this</span>.getClass().getCanonicalName());</span><br><span class="line">       </span><br><span class="line">    mWakeLock.acquire();</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onResume</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">super</span>.onResume();</span><br><span class="line">   acquireWakeLock();</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onPause</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">super</span>.onPause();</span><br><span class="line">   releaseWakeLock();</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">acquireWakeLock</span><span class="params">()</span></span>&#123;</span><br><span class="line"> <span class="keyword">if</span>(mWakeLock != <span class="keyword">null</span>) &#123;</span><br><span class="line"> mWakeLock.acquire();</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">releaseWakeLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(mWakeLock != <span class="keyword">null</span>) &#123;</span><br><span class="line">    mWakeLock.release();</span><br><span class="line">    <span class="comment">///mWakeLock = null;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<strong>onResume</strong>以及<strong>onPause</strong>执行相应操作</p>
<p><code>AndroidManifest.xml</code> 文件中添加权限：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;uses-permission android:name=<span class="string">"android.permission.WAKE_LOCK"</span>/&gt;</span><br><span class="line">&lt;uses-permission android:name=<span class="string">"android.permission.DEVICE_POWER"</span> /&gt;</span><br></pre></td></tr></table></figure>

<p><code>WakeLock</code>获取时相关的<code>flag</code>如下所示：</p>
<ul>
<li><strong>PARTIAL_WAKE_LOCK</strong> :保持CPU 运转，屏幕和键盘灯有可能是关闭的。</li>
<li><strong>SCREEN_DIM_WAKE_LOCK</strong> ：保持CPU 运转，允许保持屏幕显示但有可能是灰的，允许关闭键盘灯</li>
<li><strong>SCREEN_BRIGHT_WAKE_LOCK</strong> ：保持CPU 运转，允许保持屏幕高亮显示，允许关闭键盘灯</li>
<li><strong>FULL_WAKE_LOCK</strong> ：保持CPU 运转，保持屏幕高亮显示，键盘灯也保持亮度</li>
</ul>
<p>PS：现在官方已经不推荐使用这种方式保持亮屏了，推荐改为以下两种方式</p>
<h3 id="方法二：在Window设置flag"><a href="#方法二：在Window设置flag" class="headerlink" title="方法二：在Window设置flag"></a><strong>方法二：</strong>在Window设置flag</h3><p>在<code>Activity</code>布局中设置<code>Windows</code>属性进行控制，但是一定要在加载布局之前执行，此种方法的局限性是只有在<code>Activity</code>类中有效，<code>Activity</code>退出时失效。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">getWindow().setFlags(WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON, </span><br><span class="line">     WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON); </span><br><span class="line">setContentView(R.layout.***);  </span><br><span class="line"></span><br><span class="line"><span class="comment">//或者设置下面的也一样        </span></span><br><span class="line"><span class="comment">//getWindow().addFlags(WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON);</span></span><br></pre></td></tr></table></figure>

<p>这种方式不需要申请权限，也是官方推荐的做法</p>
<p>这个方法的好处是，与wakelocks不同 ,它不需要具体的权限，并且在换不同应用程序的操作中，系统会管理，不必担心没有释放的未使用的资源。</p>
<p>你并不需要清除<strong>FLAG_KEEP_SCREEN_ON</strong>标志，除非你不再需要在屏幕上停留在你运行应用程序。当应用程序进入后台或返回到前台发生，窗口管理器负责保障正常的事件处理，但是如果你明确的想要清除这个标致，从而允许屏幕熄灭，可以使用 <strong>clearFlags()</strong> 方法</p>
<p>如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">getWindow().clearFlags(WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON)</span><br></pre></td></tr></table></figure>

<p>就可以控制屏幕熄灭了</p>
<h3 id="方法三：在界面布局xml中顶层添加属性"><a href="#方法三：在界面布局xml中顶层添加属性" class="headerlink" title="*方法三：在界面布局xml中顶层添加属性"></a><em>*方法三：在界面布局xml中顶层添加属性</em></h3><p>在View布局中添加属性，此种方法的好处是不一定非要在Activity界面运行时屏幕常亮才有效，View启动后可以自主设置。</p>
<p><code>View</code>的<code>xml</code>布局中加入：</p>
<p>在<code>XML</code>文件中，使用<code>android:keepScreenOn</code>属性</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;relativelayout xmlns:android=<span class="string">"http://schemas.android.com/apk/res/android"</span></span><br><span class="line">android:layout_width=<span class="string">"match_parent"</span></span><br><span class="line">android:layout_height=<span class="string">"match_parent"</span></span><br><span class="line">android:keepScreenOn=<span class="string">"true"</span>&gt;</span><br><span class="line"> ...</span><br><span class="line">&lt;/relativelayout&gt;</span><br></pre></td></tr></table></figure>

<p>这个设置 <strong>android:keepScreenOn=“true”</strong> 等同于<strong>FLAG_KEEP_SCREEN_ON</strong>。</p>
<p>代码中执行是否保持屏幕常亮：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">View.setKeepScreenOn(<span class="keyword">true</span>);</span><br><span class="line">View.setKeepScreenOn(<span class="keyword">false</span>);</span><br></pre></td></tr></table></figure>

<p><strong>转载自</strong>:<a href="https://blog.csdn.net/CLinuxF/article/details/103273411" target="_blank" rel="noopener">https://blog.csdn.net/CLinuxF/article/details/103273411</a></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em><a href="https://code.newban.cn/">乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</a></em></p>
]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>Mac平台对Chrome浏览器进行多开操作实现</title>
    <url>/297.html</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>对于老司机而言, 浏览器多开是个常规必备的需求, 这种多开并非指的的开一个新的窗口, 而是一个新的应用, 这样我们就能在某个网站登录多个小号, 避免反反复复的来回繁琐登录 嘿嘿</p>
<p>接下来 以<code>Mac</code>平台为例, 介绍下如何对谷歌浏览器进行多开操作</p>
<h3 id="操作步骤"><a href="#操作步骤" class="headerlink" title="操作步骤"></a>操作步骤</h3><ol>
<li><p><strong>首先打开终端输入以下命令, 创建小号浏览器数据存放目录</strong></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">mkdir ~/Documents/NewChrome</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>然后复制应用, 并对新应用进行重新命名 这里命名为New Chrome</strong></p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20211223153504315.png" alt="image-20211223153504315"></p>
</li>
<li><p><strong>进入到程序目录 找到执行文件所在目录</strong></p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20211223153815748.png" alt="image-20211223153815748"></p>
</li>
<li><p><strong>在该目录下新建一个文本文件, 然后将以下代码写入该文件</strong></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo /Applications/New\ Chrome.app/Contents/MacOS/Google\ Chrome --user-data-dir=<span class="string">"/Users/Documents/NewChrome"</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>在终端执行以下命令将文本文件转成可执行文件</strong></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">chmod 775 文件名</span><br></pre></td></tr></table></figure>

<p>执行该命令前先将文本文件后缀删掉</p>
<p>最后变成这个样子:</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20211223154717658.png" alt="image-20211223154717658"></p>
</li>
<li><p><strong>双击该文件即可运行</strong></p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20211223154754427.png" alt="image-20211223154754427"></p>
</li>
</ol>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><code>Chrome</code>多开的核心在于数据文件的指定, 也就是在启动浏览器时只要指定一个新的数据目录就相当于多开了, 这个数据目录保存了浏览器所有的数据信息 包括了<code>Cookie</code> 用户密码 插件信息等等</p>
<p>因此, 实际上只需要执行以下命令就可以快速多开:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo /Applications/Google\ Chrome.app/Contents/MacOS/Google\ Chrome --user-data-dir=<span class="string">"小号浏览器数据存放目录"</span></span><br></pre></td></tr></table></figure>

<p>上面的步骤中之所以复制一个新的应用, 是为了避免误操作毁了原来的应用, 建议大家在使用时也复制一份, 这样怎么折腾都无妨了</p>
<p>如果我们要多开好几个那么创建多个数据目录即可:</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20211223164554218.png" alt="image-20211223164554218"></p>
<p><strong>本文为作者原创转载时请注明出处 谢谢</strong></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em><a href="https://code.newban.cn/">乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</a></em></p>
]]></content>
      <tags>
        <tag>使用技巧</tag>
      </tags>
  </entry>
  <entry>
    <title>V2free for Android使用教程</title>
    <url>/299.html</url>
    <content><![CDATA[<h3 id="应用概述"><a href="#应用概述" class="headerlink" title="应用概述"></a>应用概述</h3><p>V2free 是在<code>Android</code> 平台上的客户端软件，支持 <code>VMess/Vless</code> 及 <code>Shadowsocks</code>协议。</p>
<h3 id="应用下载"><a href="#应用下载" class="headerlink" title="应用下载"></a>应用下载</h3><p><a href="https://w1.v2dns.xyz/ssr-download/v2free.apk" target="_blank" rel="noopener">V2free 本站下载</a>  <a href="https://url97.ctfile.com/d/21042697-41429184-6115da" target="_blank" rel="noopener">国内快速下载通道</a>（访问密码：312306）</p>
<h3 id="通过订阅链接将V2ray节点导入V2free"><a href="#通过订阅链接将V2ray节点导入V2free" class="headerlink" title="通过订阅链接将V2ray节点导入V2free"></a>通过订阅链接将V2ray节点导入V2free</h3><h3 id="订阅模式"><a href="#订阅模式" class="headerlink" title="订阅模式"></a>订阅模式</h3><p>以下面这个订阅链接为例, 给大家做个示范:<br><code>https://v1.ddnsgo.xyz/link/11111?clash=1</code></p>
<h4 id="导入订阅链接"><a href="#导入订阅链接" class="headerlink" title="导入订阅链接"></a>导入订阅链接</h4><p>打开 <code>V2free</code> 点击左上角的菜单图标打开侧边栏，随后点击 <strong>订阅</strong> （如下图）。</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/v2free1.png" alt="1"> <img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/v2free2.png" alt="2"></p>
<p>点击右上角的加号按钮，在 编辑订阅 的 地址输入框中粘贴上方 <strong>获取订阅</strong> 中的订阅链接，然后点确定按钮（如下图）。</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/v2free3.png" alt="3"> <img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/v2free4.png" alt="4"></p>
<p>随后从侧边栏回到 <strong>服务器</strong> 页面，点击右上角的 刷新图标 更新订阅（节点不定期更新，发现不好用时请更新订阅）（如下图）</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/v2free5.png" alt="5"> <img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/v2free6.png" alt="6"></p>
<h3 id="节点测速"><a href="#节点测速" class="headerlink" title="节点测速"></a>节点测速</h3><p>点右上角的 三个点 按钮，再点 测试全部配置真连接（如下图）。</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/v2free7.png" alt="7"> <img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/v2free8.png" alt="8"></p>
<h3 id="路由设置"><a href="#路由设置" class="headerlink" title="路由设置"></a>路由设置</h3><p>V2free APP的全局路由默认选项为：代理所有流量。如需设置国内外分流，请从侧边栏进入 <strong>设置选项</strong> 页面，点击 <strong>V2ray路由</strong> 和 <strong>Shadowsocks路由</strong> ，将其更改为 <strong>绕过局域网及中国大陆地址</strong>。（如下图）</p>
<p>路由设置分为V2ray路由和SS路由2个选项，新添加/更新的服务器的路由选项将采用全局路由设置值；改变全局路由设置时会重置所有相关类型节点的路由选项，即改变全局V2ray路由设置将重置所有v2ray节点，改变全局SS路由设置将重置所有SS节点。</p>
<p>单个节点的路由设置（点节点右侧的铅笔图标设置）可以覆盖全局路由设置。</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/v2free9.png" alt="9"> <img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/v2free10.png" alt="10"> <img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/v2free11.png" alt="11"></p>
<h3 id="分应用设置"><a href="#分应用设置" class="headerlink" title="分应用设置"></a>分应用设置</h3><p>也可以使用分应用设置进行分流，点节点右侧的铅笔图标，打开节点编辑界面，往下拉，点击：<strong>分应用VPN</strong> 进行设置。（如下图） 在分应用设置界面，点右上角三个点，可批量设置所有节点的分应用设置。</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/v2free12.png" alt="12"></p>
<h3 id="开始使用"><a href="#开始使用" class="headerlink" title="开始使用"></a>开始使用</h3><p>点击选择您中意的节点，点击主界面底部的小飞机按钮即可启动VPN连接。（如下图） 如操作系统提示添加 VPN 配置，请点击 <strong>允许</strong> 并验证您的 密码、指纹等。 启动vpn后，点选另一节点即可切换节点；再次点小飞机按钮可断开vpn。</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/v2free13.png" alt="12"></p>
<p><strong>本文转载自</strong>:<a href="https://w1.v2dns.xyz/doc/#/Android/v2free" target="_blank" rel="noopener">https://w1.v2dns.xyz/doc/#/Android/v2free</a></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em><a href="https://code.newban.cn/">乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</a></em></p>
]]></content>
      <tags>
        <tag>墙里墙外</tag>
      </tags>
  </entry>
  <entry>
    <title>Clash for Android使用教程</title>
    <url>/298.html</url>
    <content><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p><code>Clash for Android</code>是安卓系统上的一款综合<code>FQ</code>软件，支持<code>v2ray/vmess</code>、<code>SS</code>和<code>SSR</code>协议。</p>
<p><strong>特性：</strong></p>
<ul>
<li>可随时切换<code>DL</code>模式及节点</li>
<li>支持节点批量延迟测试</li>
<li>通过订阅链接一键配置</li>
<li>规则命中分析</li>
<li>日志输出</li>
</ul>
<p><strong>系统要求：</strong></p>
<ul>
<li>Android 5.0+ (minimum)</li>
<li>Android 7.0+ (recommend)</li>
<li><code>armeabi-v7a</code> , <code>arm64-v8a</code>, <code>x86</code> or <code>x86_64</code> Architecture</li>
</ul>
<h3 id="下载安装"><a href="#下载安装" class="headerlink" title="下载安装"></a>下载安装</h3><p><code>Clash for Android</code>为免费 app ，已于 2019.12.10 上架 <code>Google Play</code> 。</p>
<p><code>Clash for Android</code>下载：<a href="https://w1.v2dns.xyz/ssr-download/clash.apk" target="_blank" rel="noopener">本站下载</a> 、<a href="https://play.google.com/store/apps/details?id=com.github.kr328.clash" target="_blank" rel="noopener">Google Play</a>  <a href="https://url97.ctfile.com/d/21042697-41429184-6115da" target="_blank" rel="noopener">国内快速下载通道</a>（访问密码：312306）</p>
<p>安卓手机使用 <code>Chrome</code> 浏览器可能遇到无法下载的情况，可复制教程链接到其它浏览器尝试下载。</p>
<p>语言设置路径：<code>Settings</code> → <code>Interface</code> → <code>Language</code> → <code>Simplified Chinese</code><br><code>设置</code> 👉 <code>界面</code> 👉 <code>语言</code> 👉 <code>简体中文</code></p>
<h3 id="快速上手"><a href="#快速上手" class="headerlink" title="快速上手"></a>快速上手</h3><p><code>Clash for Android</code>支持两种导入节点及配置文档的方式：</p>
<ul>
<li>URL （订阅）</li>
<li>本地导入</li>
</ul>
<h3 id="快速订阅"><a href="#快速订阅" class="headerlink" title="快速订阅"></a>快速订阅</h3><p>以下面这个订阅链接为例, 给大家做个示范:<br><code>https://v1.ddnsgo.xyz/link/11111?clash=1</code></p>
<p>复制好了<code>Clash</code>订阅之后打开<code>Clash for Android</code>应用程序。请点击<strong>配置</strong>。</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/1072376875.jpg" alt="IMG_7843.JPG"></p>
<p>请在新弹出的窗口中点击<strong>新配置</strong>。<br><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/1118270140.jpg" alt="IMG_7844.JPG"><br>然后选择<code>从URL导入</code>。在对应地方填写订阅地址并保存。<br><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/2169466048.jpg" alt="IMG_7845.JPG"><br><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/3843008539.jpg" alt="IMG_7847.JPG"><br><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/932669651.jpg" alt="IMG_7849.JPG"><br>点击节点右侧的三个点按钮，可以修改订阅设置。如图：<br><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/1168337143.jpg" alt="IMG_7850.JPG"><br><strong>提示</strong>：机场服务器信息可能会不定时更新，若出现大面积节点超时现象，可尝试刷新订阅。<br>返回首页。点击开关，即可进行DL。会提示是否同意创建连线，请点击<code>允许</code>。<br><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/2409469823.jpg" alt="IMG_7851.JPG"><br>开启DL后，可以点击中间的DL选项卡，进入策略组面板，在这里可以切换节点。直接点击你想要的节点即可进行切换。<br><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/2753500055.jpg" alt="IMG_7852.JPG"><br>点击⚡图标可以进行延迟测试，测试结果将显示在节点名称右侧。</p>
<p><code>Clash for Android</code> 测试延迟的方法为从目标 <code>policy</code> 返回 <code>http response header</code> 数据包的时间，并不是简单的<code>ping</code> 。<br>测试延迟会导致机场网页上显示的在线设备数异常飙升，这是正常现象，等一等就好了。</p>
<p>点击右上角的三个点按钮，可以进入更多设置：</p>
<ul>
<li>刷新订阅</li>
<li>更改DL模式</li>
<li>改变DL组（策略组）排序</li>
<li>改变DL（节点）排序</li>
<li>前缀合并（即节点名字前缀相同的进行归类显示）<br><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/550116317.jpg" alt="IMG_7853.JPG"><br><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/838427780.jpg" alt="IMG_7854.JPG"></li>
</ul>
<h3 id="本地文件导入"><a href="#本地文件导入" class="headerlink" title="本地文件导入"></a>本地文件导入</h3><p>点击 <code>配置</code> 👉 <code>新配置</code> 👉 <code>从文件导入</code>，然后从本地文件夹选择自己要导入的配置文档。<br>某些厂商的ROM可能报如下错误，请选择其他文件管理器导入。<br><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/romfault.png" alt="10"></p>
<h3 id="查询日志"><a href="#查询日志" class="headerlink" title="查询日志"></a>查询日志</h3><p>点击<code>日志</code>面板，然后选择<code>Clash日志捕捉工具</code>即可抓取日志。默认是关闭日志的，以防内存溢出。<br><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/1404728428.jpg" alt="IMG_7857.JPG"><br><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/1836797657.jpg" alt="IMG_7858.JPG"><br><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/2336060890.jpg" alt="IMG_7859.JPG"></p>
<h3 id="其他设置"><a href="#其他设置" class="headerlink" title="其他设置"></a>其他设置</h3><p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/3789481771.jpg" alt="IMG_7860.JPG"><br><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/454476014.jpg" alt="IMG_7862.JPG"></p>
<h3 id="分应用DL"><a href="#分应用DL" class="headerlink" title="分应用DL"></a>分应用DL</h3><p>点击<code>设置</code> 👉 <code>网络</code>，最下方可以设置<code>分应用DL</code>。<br>点击<code>访问控制模式</code>可以切换黑白名单。自行理解即可。<br>点击<code>访问控制应用包列表</code>即可选择应用。<br><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/1278124387.jpg" alt="IMG_7863.JPG"></p>
<h3 id="切换DL模式"><a href="#切换DL模式" class="headerlink" title="切换DL模式"></a>切换DL模式</h3><p>如果是2.0.18及之前的版本，DL模式设置路径为<code>DL</code> → <code>模式</code>，如图：<br><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/550116317-20211224102137744.jpg" alt="IMG_7853.JPG"><br><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/838427780-20211224102149244.jpg" alt="IMG_7854.JPG"></p>
<h4 id="3-6-2-2-1-1之后的版本"><a href="#3-6-2-2-1-1之后的版本" class="headerlink" title="3.6.2 2.1.1之后的版本"></a><a href="https://w1.v2dns.xyz/doc/#/Android/clash?id=_362-211之后的版本" target="_blank" rel="noopener">3.6.2 2.1.1之后的版本</a></h4><p>如果是2.1.1之后的版本，DL模式设置路径为<code>设置</code> → <code>覆写</code> → <code>模式</code>，如图：<br><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/1118590743.jpg" alt="IMG_4577.JPG"><br><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/3855851416.jpg" alt="IMG_4579.JPG"><br><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/1753717891.jpg" alt="IMG_4578.JPG"></p>
<h3 id="语言设置"><a href="#语言设置" class="headerlink" title="语言设置"></a>语言设置</h3><p>语言设置路径：<code>Settings</code> → <code>Interface</code> → <code>Language</code> → <code>Simplified Chinese</code><br><code>设置</code> 👉 <code>界面</code> 👉 <code>语言</code> 👉 <code>简体中文</code><br><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/3362312117.jpg" alt="IMG_7864.JPG"><br>若当前系统语言为简体中文，则软件默认显示简体中文。<br>若当前系统语言为繁體中文或其它语言，则默认显示English。</p>
<h3 id="暗黑模式"><a href="#暗黑模式" class="headerlink" title="暗黑模式"></a>暗黑模式</h3><p>Clash for Android现已适配暗黑模式。<br>入口：<code>设置</code> 👉 <code>界面</code> 👉 <code>暗黑模式</code><br>开启后效果如图：<br><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/59156606.jpg" alt="IMG_7865.JPG"><br><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/382223072.jpg" alt="IMG_7866.JPG"></p>
<h2 id="常见的订阅错误报告"><a href="#常见的订阅错误报告" class="headerlink" title="常见的订阅错误报告"></a>常见的订阅错误报告</h2><p>如果遇到以下提示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Invalid Config:yaml:unmarshal errors: line 1:cannot unmarshal !!str c3M6Ly9...点击拷贝拷贝失败拷贝成功</span><br></pre></td></tr></table></figure>

<p>说明用错了订阅链接，请检查自己是不是复制错了或者多了空格之类的。</p>
<p>如果遇到此类提示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Invalid Config:Value for &apos;Proxy&apos; is invalid:Unexpected null or empty点击拷贝拷贝失败拷贝成功</span><br></pre></td></tr></table></figure>

<p>说明你还没买套餐，或者订阅为空。请联系你所在机场的管理员。</p>
<h2 id="易用性设置"><a href="#易用性设置" class="headerlink" title="易用性设置"></a>易用性设置</h2><p>大部分安卓ROM都会因为电池策略导致<code>Clash for Andorid</code>应用程序被杀掉导致无法连接网络。出现这种情况的特征是通知栏中连接仍然存在，但实际上无法访问网络（有时也包括国内网络）。这是因为<code>Clash for Android</code>主程序和梯子框架是独立存在的，主程序被系统清理后会导致流量仍然通过梯子路由到本地，但此时没有应用程序来处理这些流量，导致无法上网。</p>
<h3 id="始终开启梯子"><a href="#始终开启梯子" class="headerlink" title="始终开启梯子"></a>始终开启梯子</h3><p>以<code>RealmeX(Android 10)</code>为例，点击<code>设定</code> 👉 <code>其他无线连接</code> 👉 <code>VVN</code>,打开<code>一律保持连线</code>。<br><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/1483525553.jpg" alt="IMG_7868.JPG"><br><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/2937852562.jpg" alt="IMG_7869.JPG"><br><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/2475363784.jpg" alt="IMG_7872.JPG"><br><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/1266218543.jpg" alt="IMG_7873.JPG"></p>
<h3 id="省电策略-允许后台运行"><a href="#省电策略-允许后台运行" class="headerlink" title="省电策略/允许后台运行"></a>省电策略/允许后台运行</h3><p>长按<code>Clash</code>图标，选择<code>应用程式资讯</code>。<br>勾选<code>允许自动啓动</code>和<code>允许其他应用程式关联啓动</code>。<br>点击<code>耗电保护</code>,选择<code>允许背景执行</code>。<br><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/722228769.jpg" alt="IMG_7874.JPG"><br><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/1110606495.jpg" alt="IMG_7875.JPG"><br><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/74665642.jpg" alt="IMG_7876.JPG"></p>
<h3 id="通知栏快速启动"><a href="#通知栏快速启动" class="headerlink" title="通知栏快速启动"></a>通知栏快速启动</h3><p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/1192405662.jpg" alt="IMG_7878.JPG"><br><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/2936823915.jpg" alt="IMG_7879.JPG"></p>
<p>注意：<code>Clash</code>使用 <code>HTTP HEAD</code> 方法对测试网址（server_check_url）进行网页相应测试，以确认节点的可用性。数值在5000以内均为正常值，超出则显示为超时。数值大小和网速快慢没太大关系。</p>
<p><strong>本文转载自</strong>:<a href="https://w1.v2dns.xyz/doc/#/Android/clash" target="_blank" rel="noopener">https://w1.v2dns.xyz/doc/#/Android/clash</a></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em><a href="https://code.newban.cn/">乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</a></em></p>
]]></content>
      <tags>
        <tag>墙里墙外</tag>
      </tags>
  </entry>
  <entry>
    <title>使用docker安装mysql</title>
    <url>/3.html</url>
    <content><![CDATA[<h2 id="部署MySql"><a href="#部署MySql" class="headerlink" title="部署MySql"></a>部署MySql</h2><ol>
<li>搜索mysql镜像</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker search mysql</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>拉取mysql镜像</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker pull mysql</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>在/root目录下创建mysql目录用于存储mysql数据信息</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mkdir ~/mysql</span><br><span class="line">cd ~/mysql</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>创建容器 设置端口映射</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run -id \</span><br><span class="line">-p 3306:3306 \</span><br><span class="line">--name=c_mysql \</span><br><span class="line">-h c_mysql \</span><br><span class="line">-v $PWD/conf:/etc/mysql/conf.d \</span><br><span class="line">-v $PWD/logs:/logs \</span><br><span class="line">-v $PWD/data:/var/lib/mysql \</span><br><span class="line">-e MYSQL_ROOT_PASSWORD=12345 \</span><br><span class="line">mysql:latest</span><br></pre></td></tr></table></figure>

<ul>
<li>参数说明<ul>
<li><strong>-p 3306：3306将容器的3306端口映射到主机的3306端口</strong></li>
<li><strong>-v $PWD/conf:/etc/mysql/conf.d 将容器中配置文件目录与主机挂载</strong></li>
<li><strong>-h 设置容器的hostname</strong> </li>
<li><strong>$PWD表示当前所在目录</strong></li>
</ul>
</li>
</ul>
<p><strong>本文为作者原创 转载时请注明出处 谢谢</strong></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em>乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</em></p>
]]></content>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Potatso Lite for IOS 使用教程</title>
    <url>/300.html</url>
    <content><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p><code>Potatso Lite</code> 是一款免费的iOS梯子工具，功能简单，稳定性尚可，支持的代理协议有：<code>Shadowsocks</code>,<code>ShadowsocksR</code>，适合新手入门使用。</p>
<h3 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h3><p>需要使用非中国大陆区<code>AppleID</code>下载。没有的话可以点击： <a href="https://code.newban.cn/301.html">注册苹果美区 Apple ID 帐号并购买APP指南</a></p>
<p><a href="https://apps.apple.com/us/app/potatso-lite/id1239860606" target="_blank" rel="noopener">https://apps.apple.com/us/app/potatso-lite/id1239860606</a></p>
<h3 id="本教程所用的系统环境"><a href="#本教程所用的系统环境" class="headerlink" title="本教程所用的系统环境"></a>本教程所用的系统环境</h3><ul>
<li><p><strong>iOS 14</strong></p>
</li>
<li><p><strong>Potatso Lite 2.5.0</strong></p>
</li>
</ul>
<p>本文中的某些内容可能会随软件版本迭代而失效。</p>
<h3 id="快速上手"><a href="#快速上手" class="headerlink" title="快速上手"></a>快速上手</h3><ol>
<li><p><strong>添加节点</strong></p>
<p>首次打开软件时，启动页会出现“添加代理”的选项。软件首页右上角也有“+”号，点击即可添加节点。我们可以看到<code>Potatso Lite</code>支持的导入方式有：<strong>扫描二维码</strong>、<strong>节点链接</strong>、<strong>订阅</strong>。</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/2252186481.jpg" alt="IMG_4605.jpg"><br><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/1558299922.jpg" alt="IMG_4592.jpg"></p>
</li>
<li><p><strong>扫描二维码</strong></p>
<p>点击“添加代理”（或右上角+号），再点击“二维码”即可扫描SS节点二维码添加节点。</p>
</li>
<li><p><strong>节点链接</strong></p>
<p>拷贝全部SS节点URL， 注意不要拷贝错了，是<code>SS</code>节点<code>URL</code>，<strong><code>Potatso Lite</code>不支持`V2ray</strong>`.</p>
<p>点击“添加代理”（或右上角+号），再点击“代理地址”。在新的窗口里粘贴节点链接（ss://或ssr://开头的那种）。</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/2897544874.png" alt="IMG_4601.PNG"></p>
<p>当软件检测到已经复制好了节点链接，也会提示是否需要自动导入，如图：</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/131924680.png" alt="IMG_4600.PNG"></p>
</li>
<li><p><strong>订阅链接配置</strong></p>
<p>点击“添加代理”（或右上角+号），再点击“订阅”。然后在新的窗口里粘贴订阅链接并输入订阅名称（为了区分不同的订阅链接，可以随便起名字）。点击“完成”以保存设置。</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/3732450977.png" alt="IMG_4594.PNG"></p>
<p>添加后会从订阅链接加载节点，如图：</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/2308989632.png" alt="IMG_4595.PNG"></p>
</li>
<li><p><strong>更新订阅</strong></p>
<p>有时节点提供商（机场）可能会修改节点配置信息，此时可以通过更新订阅链接来同步更改。<br>点击软件主界面右上角的“管理”，进入“管理代理”界面。</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/2284973646.png" alt="IMG_4597.PNG"></p>
<p>点开你添加的订阅，然后在右上角点击“完成”，即可更新。<br>也可以在添加订阅的时候就选择“自动更新”。</p>
</li>
<li><p><strong>其他设置</strong></p>
<p>如果需要分流功能，可以点击软件右下角的“设置”，然后启用“智能路由”。</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/2559756792.png" alt="IMG_4599.PNG"></p>
</li>
<li><p><strong>启用代理</strong></p>
<p>设置完毕后在软件主页选一个节点，然后点击右下角的圆形按钮即可开启代理。首次启动代理时软件会申请创建本地VPN隧道，请选择允许。</p>
</li>
</ol>
<p><strong>本文转载自</strong>:<a href="https://w1.v2dns.xyz/doc/#/iOS/PotatsoLite" target="_blank" rel="noopener">https://w1.v2dns.xyz/doc/#/iOS/PotatsoLite</a></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em><a href="https://code.newban.cn/">乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</a></em></p>
]]></content>
      <tags>
        <tag>墙里墙外</tag>
      </tags>
  </entry>
  <entry>
    <title>Iphone/iPad通过电脑局域网共享梯子</title>
    <url>/302.html</url>
    <content><![CDATA[<h3 id="准备环境"><a href="#准备环境" class="headerlink" title="准备环境"></a>准备环境</h3><ul>
<li><strong>Windows电脑</strong></li>
<li><strong>V2rayN</strong></li>
<li><strong>IOS设备</strong></li>
</ul>
<p>如果是MACOS，参考：<a href="https://code.newban.cn/304.html">ClashX 局域网代理共享</a>、<a href="https://code.newban.cn/303.html">v2rayu-实现局域网共享</a></p>
<h3 id="操作步骤"><a href="#操作步骤" class="headerlink" title="操作步骤"></a>操作步骤</h3><ol>
<li><p><code>Windows</code>打开电脑上的<code>V2rayN</code>，把“允许来自局域网的连接”打钩，然后确保选择正常工作的节点。</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/v2rayn1.jpg" alt="img"></p>
</li>
<li><p>查看你的局域网地址</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/bg2dvj4l-2.jpg" alt="img"></p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/e07azw0k-2.jpg" alt="img"></p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/20211224134919.png" alt></p>
</li>
<li><p>打开iphone的无线和网络，点开感叹号</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/kp3hujth-3.jpg" alt="img"></p>
<p>在<code>http</code>代理那里选择手动，填入电脑的ip地址(根据自己的地址更改)和<code>V2rayN</code>的<code>HTTP</code>端口: 10809，点 存储</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/o_vezkpg-4.jpg" alt="img"></p>
</li>
</ol>
<p>设置完毕，打开浏览器或<code>youtube</code>客户端试试</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/r4zbexmr-3.jpg" alt="img"></p>
<p><strong>本文转载自</strong>:<a href="https://w1.v2dns.xyz/doc/#/iOS/fqByLan.html" target="_blank" rel="noopener">https://w1.v2dns.xyz/doc/#/iOS/fqByLan.html</a></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em><a href="https://code.newban.cn/">乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</a></em></p>
]]></content>
      <tags>
        <tag>墙里墙外</tag>
      </tags>
  </entry>
  <entry>
    <title>如何设置通过Postman实现API网关的请求签名与调试</title>
    <url>/30.html</url>
    <content><![CDATA[<blockquote>
<p>前言<br>Postman是一个非常强大的HTTP发包测试工具, 目前Postman已经提供了Windows/Mac/Linux系统的客户端的下载，使用很方便。不过API网关的调试，需要对HTTP请求进行签名才能调用，无法使用简单的curl等发包工具完成，但我们可以使用Postman工具提供的Pre-request Script脚本来实现API网关的签名功能，实现API的调试功能，本文主要介绍如何使用Postman调试API网关接口。</p>
</blockquote>
<h4 id="核心代码如下"><a href="#核心代码如下" class="headerlink" title="核心代码如下"></a>核心代码如下</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var appKey = &quot;&lt;YOUR APP KEY&gt;&quot;;</span><br><span class="line">var appSecret = &quot;&lt;YOUR APP SECRET&gt;&quot;;</span><br><span class="line"></span><br><span class="line">var md5 = calcMd5();</span><br><span class="line">var date = new Date().toString();</span><br><span class="line">var nonce = createUuid();</span><br><span class="line"></span><br><span class="line">var textToSign = &quot;&quot;;</span><br><span class="line">textToSign += request.method + &quot;\n&quot;;</span><br><span class="line">textToSign += request.headers[&quot;accept&quot;] + &quot;\n&quot;;</span><br><span class="line">textToSign += md5 + &quot;\n&quot;;</span><br><span class="line">textToSign += request.headers[&quot;content-type&quot;] + &quot;\n&quot;;</span><br><span class="line">textToSign += date + &quot;\n&quot;;</span><br><span class="line"></span><br><span class="line">var headers = headersToSign();</span><br><span class="line">var signatureHeaders;</span><br><span class="line">var sortedKeys = Array.from(headers.keys()).sort()</span><br><span class="line">for (var headerName of sortedKeys) &#123;</span><br><span class="line">    textToSign += headerName + &quot;:&quot; + headers.get(headerName) + &quot;\n&quot;;</span><br><span class="line">    signatureHeaders = signatureHeaders ? signatureHeaders + &quot;,&quot; + headerName : headerName;</span><br><span class="line">&#125;</span><br><span class="line">textToSign += urlToSign();</span><br><span class="line">console.log(&quot;textToSign\n&quot; + textToSign.replace(/\n/g, &quot;#&quot;));</span><br><span class="line">var hash = CryptoJS.HmacSHA256(textToSign, appSecret)</span><br><span class="line">console.log(&quot;hash:&quot; + hash)</span><br><span class="line">var signature = hash.toString(CryptoJS.enc.Base64)</span><br><span class="line">console.log(&quot;signature:&quot; + signature)</span><br><span class="line"></span><br><span class="line">pm.globals.set(&apos;AppKey&apos;, appKey);</span><br><span class="line">pm.globals.set(&apos;Md5&apos;, md5);</span><br><span class="line">pm.globals.set(&quot;Date&quot;, date);</span><br><span class="line">pm.globals.set(&quot;Signature&quot;, signature);</span><br><span class="line">pm.globals.set(&quot;SignatureHeaders&quot;, signatureHeaders);</span><br><span class="line">pm.globals.set(&quot;Nonce&quot;, nonce);</span><br><span class="line"></span><br><span class="line">function headersToSign() &#123;</span><br><span class="line">    var headers = new Map();</span><br><span class="line">    for (var name in request.headers) &#123;</span><br><span class="line">        name = name.toLowerCase();</span><br><span class="line">        if (!name.startsWith(&apos;x-ca-&apos;)) &#123;</span><br><span class="line">            continue;</span><br><span class="line">        &#125; </span><br><span class="line">        if (name === &quot;x-ca-signature&quot; || name === &quot;x-ca-signature-headers&quot; || name == &quot;x-ca-key&quot; || name === &apos;x-ca-nonce&apos;) &#123;</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line">        var value = request.headers[name];</span><br><span class="line">        headers.set(name, value);</span><br><span class="line">    &#125;</span><br><span class="line">    headers.set(&apos;x-ca-key&apos;, appKey);</span><br><span class="line">    headers.set(&apos;x-ca-nonce&apos;, nonce);</span><br><span class="line">    return headers;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function urlToSign() &#123;</span><br><span class="line">    var params = new Map();</span><br><span class="line">    var contentType = request.headers[&quot;content-type&quot;];</span><br><span class="line">    if (contentType &amp;&amp; contentType.startsWith(&apos;application/x-www-form-urlencoded&apos;)) &#123;</span><br><span class="line">        const formParams = request.data.split(&quot;&amp;&quot;);</span><br><span class="line">        formParams.forEach((p) =&gt; &#123;</span><br><span class="line">            const ss = p.split(&apos;=&apos;);</span><br><span class="line">            params.set(ss[0], ss[1]);</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    const ss = request.url.split(&apos;?&apos;);</span><br><span class="line">if (ss.length &gt; 1 &amp;&amp; ss[1]) &#123;</span><br><span class="line">    const queryParams = ss[1].split(&apos;&amp;&apos;);</span><br><span class="line">    queryParams.forEach((p) =&gt; &#123;</span><br><span class="line">        const ss = p.split(&apos;=&apos;);</span><br><span class="line">        params.set(ss[0], ss[1]);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var sortedKeys = Array.from(params.keys())</span><br><span class="line">sortedKeys.sort();</span><br><span class="line"></span><br><span class="line">var l1 = ss[0].lastIndexOf(&apos;/&apos;);</span><br><span class="line">var url = ss[0].substring(l1);</span><br><span class="line">var first = true;</span><br><span class="line">var qs</span><br><span class="line">for (var k of sortedKeys) &#123;</span><br><span class="line">    var s = k + &quot;=&quot; + params.get(k);</span><br><span class="line">    qs = qs ? qs + &quot;&amp;&quot; + s : s;</span><br><span class="line">    console.log(&quot;key=&quot; + k + &quot; value=&quot; + params.get(k));</span><br><span class="line">&#125;</span><br><span class="line">return qs ? url + &quot;?&quot; + qs : url;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function calcMd5() &#123;</span><br><span class="line">    var contentType = request.headers[&quot;content-type&quot;];</span><br><span class="line">    if (request.data &amp;&amp; !contentType.startsWith(&apos;application/x-www-form-urlencoded&apos;)) &#123;</span><br><span class="line">        var data = request.data;</span><br><span class="line">        var md5 = CryptoJS.MD5(data);</span><br><span class="line">        var md5String = md5.toString(CryptoJS.enc.Base64);</span><br><span class="line">        console.log(&quot;data:&quot; + data + &quot;\nmd5:&quot; + md5String);</span><br><span class="line">        return md5String;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return &quot;&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function createUuid() &#123;</span><br><span class="line">    return &apos;xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx&apos;.replace(/[xy]/g, function(c) &#123;</span><br><span class="line">        var r = Math.random()*16|0, v = c == &apos;x&apos; ? r : (r&amp;0x3|0x8);</span><br><span class="line">        return v.toString(16);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em>乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</em></p>
]]></content>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>V2RayU For Mac使用教程</title>
    <url>/303.html</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>推荐首选使用<a href="https://code.newban.cn/304.html">ClashX软件</a> ，此软件在实际使用中根据用户反馈，问题比较多，比较难用。</p>
<h3 id="软件下载"><a href="#软件下载" class="headerlink" title="软件下载"></a>软件下载</h3><p>以下是<code>V2RayU For Mac</code>的下载地址。</p>
<ul>
<li>本站下载：<a href="https://w1.v2dns.xyz/ssr-download/V2rayU.dmg" target="_blank" rel="noopener">V2RayU</a></li>
<li>国内下载:  <a href="https://url97.ctfile.com/d/21042697-41429184-6115da" target="_blank" rel="noopener">V2RayU</a>（访问密码：312306）</li>
</ul>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/20211224144352.png" alt></p>
<p>下载文件一般放置于用户的”下载”文件夹，使用 Finder找到下载文件，然后双击运行：</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/20211224145106.png" alt></p>
<p>此时，桌面上会生成一个虚拟光盘，并将下载的镜像文件装载到该光盘，并弹出一个窗口，提示拖拽完成安装。</p>
<p>按照提示将窗口左侧的”V2rayU”图标拖拽到窗口右侧的”Applications”文件夹，即完成了 V2rayU 的安装：</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/20211224145910.png" alt></p>
<p><em>图：拷贝 V2rayU 至应用程序目录</em></p>
<p>安装过程其实就相当于把 V2rayU 的程序文件夹复制到 Mac 电脑中，放置在”Applicationes”目录是方便应用程序的访问和使用。</p>
<p>复制完成后，就可以在应用程序中看到 V2rayU 应用图标，表示安装已经成功。我们就可以把虚拟光盘弹出，然后删除下载目录中的 dmg 文件。</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/20211224145943.png" alt></p>
<p><em>图：V2rayU 完成安装</em></p>
<p><code>mac OS</code> 安装应用程序相比<code>Windows</code> 程序就容易的多，每个应用可以理解为 <code>Windows</code> 的绿色软件，可以直接执行而不需要过多配置。</p>
<p>在”应用程序”目录看到<code>V2rayU</code> 图标，就完成了软件安装。</p>
<h3 id="启动运行"><a href="#启动运行" class="headerlink" title="启动运行"></a>启动运行</h3><p><code>mac OS</code> 的每个程序都可以理解为独立的应用，需要使用的话直接双击即运行了该应用。</p>
<p>现在双击 V2rayU 图标打开该应用，如果打开程序打不开，请参考：<a href="https://support.apple.com/zh-cn/guide/mac-help/mh40616/mac" target="_blank" rel="noopener">打开来自身份不明开发者的 Mac App1</a>或<a href="https://www.jianshu.com/p/3a5ceb412f15" target="_blank" rel="noopener">https://www.jianshu.com/p/3a5ceb412f15</a></p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/20211224150131.png" alt></p>
<p><em>图：确认运行 V2rayU 应用</em></p>
<p>由于应用不是从苹果应用商店获得的，所以在运行 V2rayU 前系统会提示用户确认。不用过分纠结这个提示，直接点击打开运行 V2rayU 应用。</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/20211224150535.png" alt></p>
<p><em>图：输入管理员用户及密码</em></p>
<p>之后，输入mac OS 的管理员用户名及密码，就可以真正打开 V2rayU 应用了。</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/20211224150551.png" alt></p>
<p><em>图：V2rayU 应用运行界面</em></p>
<p>可以看到，V2rayU 已经成功运行。</p>
<p>但是此时还不能代理上网，因为并没有给 V2rayU 配置服务器。</p>
<h3 id="配置V2RayU应用"><a href="#配置V2RayU应用" class="headerlink" title="配置V2RayU应用"></a>配置V2RayU应用</h3><p>点击任务栏该应用图标-打开服务器设置(如下图)</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/20211224150649.png" alt></p>
<h4 id="订阅链接配置"><a href="#订阅链接配置" class="headerlink" title="订阅链接配置"></a>订阅链接配置</h4><p>以下面这个订阅链接为例, 给大家做个示范:<br><code>https://v1.ddnsgo.xyz/link/11111?clash=1</code></p>
<p><strong>如果订阅链接无法更新节点,请按下文方法二:vmess url导入 先导入1、2个节点，启用节点能翻后再用订阅链接更新节点。</strong></p>
<p>右键点击出现在顶部栏中的「V2RayU」图标，在弹出菜单中选择「订阅设置」。</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/20211224150705.png" alt></p>
<p>将订阅链接粘贴到「地址」栏中，点击「添加」，待订阅地址中出现订阅后，点击「更新」获取节点。</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/20211224150733.png" alt></p>
<h4 id="vmess-url导入"><a href="#vmess-url导入" class="headerlink" title="vmess url导入"></a>vmess url导入</h4><p>这种方式只能一个一个节点的导入，比较麻烦，推荐首选上面的订阅链接方式。如果订阅网址被封，则可以用这种方法先导入一两个节点，启用节点后成功后，再用订阅链接导入节点。 从<a href="https://w1.v2dns.xyz/user/node" target="_blank" rel="noopener">V2free节点列表</a>，点任一节点的问号图标，然后复制vmess链接 然后参考下图导入服务器 </p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/20211224150748.png" alt></p>
<h3 id="链接上网"><a href="#链接上网" class="headerlink" title="链接上网"></a>链接上网</h3><p>点击任务栏应用图标 — 服务器列表–勾选刚配置的服务器</p>
<p>选择”Pac模式”</p>
<h3 id="V2rayU的几种代理模式"><a href="#V2rayU的几种代理模式" class="headerlink" title="V2rayU的几种代理模式"></a>V2rayU的几种代理模式</h3><ul>
<li><strong>pac模式</strong>，根据pac文件里的网站列表判断是否走代理</li>
<li><strong>manual</strong> 顾名思义，手动模式，不配置系统级代理。可以自行使用浏览器插件或其他软件配置需要的代理模式</li>
<li><strong>globle 全局模式</strong>，不管哪国域名，不管哪国ip，统统走代理</li>
</ul>
<p>点击 “Turn v2ray-core On” ，这时候就可以使用VPN上网了</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/20211224150809.png" alt></p>
<p>最后，通过浏览器验证代理是否成功即可。</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/20211224150825.png" alt></p>
<p>图：验证 V2rayU 代理效果。</p>
<h3 id="V2rayU崩溃的解决办法"><a href="#V2rayU崩溃的解决办法" class="headerlink" title="V2rayU崩溃的解决办法"></a>V2rayU崩溃的解决办法</h3><p>V2RayU 更新订阅 之后打不开了，打开终端，输入下面的命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rm -rf ~/Library/LaunchAgents/yanue.v2rayu.v2ray-core.plist</span><br><span class="line">rm -rf ~/Library/Preferences/net.yanue.V2rayU.plist点击拷贝拷贝失败拷贝成功</span><br></pre></td></tr></table></figure>

<h3 id="V2rayU-端口被占用的问题"><a href="#V2rayU-端口被占用的问题" class="headerlink" title="V2rayU 端口被占用的问题"></a>V2rayU 端口被占用的问题</h3><p>错误信息：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">failed to listen on address: 127.0.0.1:1087 &gt; listen tcp 127.0.0.1![1087](https://github.githubassets.com/images/icons/emoji/1087.png) bind: address already in use</span><br></pre></td></tr></table></figure>

<p>解决方法参考(换个端口)：</p>
<p><a href="https://github.com/yanue/V2rayU/issues/380" target="_blank" rel="noopener">https://github.com/yanue/V2rayU/issues/380</a></p>
<h3 id="V2rayU-实现局域网共享"><a href="#V2rayU-实现局域网共享" class="headerlink" title="V2rayU 实现局域网共享"></a>V2rayU 实现局域网共享</h3><p>打开 偏好设置 <code>– Advance</code> 选项，找到 本机<code>http</code>监听<code>Host</code> 项，将 <code>127.0.0.1</code>改成 <code>0.0.0.0</code> 就可以了。</p>
<p><strong>本文转载自</strong>:<a href="https://w1.v2dns.xyz/doc/#/macOS/V2RayU" target="_blank" rel="noopener">https://w1.v2dns.xyz/doc/#/macOS/V2RayU</a></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em><a href="https://code.newban.cn/">乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</a></em></p>
]]></content>
      <tags>
        <tag>墙里墙外</tag>
      </tags>
  </entry>
  <entry>
    <title>ClashX For Mac使用教程</title>
    <url>/304.html</url>
    <content><![CDATA[<h2 id="应用概述"><a href="#应用概述" class="headerlink" title="应用概述"></a>应用概述</h2><p><code>ClashX</code> 是一个拥有 <code>GUI</code>界面基于<code>Clash</code> 可自定义规则的 <code>macOS</code>代理应用。</p>
<p>支持<code>Shadowsocks</code>协议和其 <code>simple-obfs</code>插件、<code>v2ray-plugin</code> 插件以及 <code>VMess</code> 协议和其 <code>TCP</code>、<code>WebSocket</code> 等传输方式。</p>
<h2 id="应用下载"><a href="#应用下载" class="headerlink" title="应用下载"></a>应用下载</h2><p>以下是<code>ClashX</code>的下载地址。</p>
<ul>
<li>官方下载：<a href="https://github.com/yichengchen/clashX/releases" target="_blank" rel="noopener">ClashX</a></li>
<li>本站下载：<a href="https://w1.v2dns.xyz/ssr-download/ClashX.dmg" target="_blank" rel="noopener">ClashX</a></li>
<li>国内下载:  <a href="https://url97.ctfile.com/d/21042697-41429184-6115da" target="_blank" rel="noopener">ClashX</a>（访问密码：312306）</li>
</ul>
<p>下载<code>ClashX</code>的安装文件，文件格式为<strong>”dmg”</strong>格式，相当于一个光盘镜像文件。 下载的文件一般放置于用户的<strong>”下载</strong>”文件夹，使用 <code>Finder</code>找到下载文件。</p>
<h2 id="订阅链接配置"><a href="#订阅链接配置" class="headerlink" title="订阅链接配置"></a>订阅链接配置</h2><p>以下面这个订阅链接为例, 给大家做个示范:<br><code>https://v1.ddnsgo.xyz/link/11111?clash=1</code></p>
<p>首先 双击<code>ClashX.dmg</code>，打开 <code>ClashX</code>安装程序</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/ClashX-1.png" alt="1"></p>
<p>图：运行<code>ClashX</code> 安装程序</p>
<p>此时，桌面上会生成一个虚拟光盘，并将下载的镜像文件装载到该光盘，并弹出一个窗口，按照提示将窗口左侧的”ClashX”图标拖拽到窗口右侧的”Applications”文件夹，即完成了 <code>ClashX</code> 的安装。</p>
<p>安装过程其实就相当于把 <code>ClashX</code>的程序文件夹复制到 <code>Mac</code>电脑中，放置在”Applicationes”目录是方便应用程序的访问和使用。</p>
<p>复制完成后，就可以在应用程序中看到 <code>ClashX</code> 应用图标，表示安装已经成功。我们就可以把虚拟光盘弹出，然后删除下载目录中的<code>dmg</code>文件。</p>
<p>第一次启动<code>ClashX</code>时，依次点击：打开、安装、输入密码，点击“安装帮助程序”，即可启动<code>ClashX</code>了（如下图）。</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/clashx1.jpg" alt="1"></p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/clashx2.jpg" alt="1"></p>
<p>点击菜单栏中<code>ClashX</code>的图标，选择 配置 =&gt; 托管配置 =&gt; 管理，</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/ClashX-2.png" alt="2"></p>
<p>然后点击 添加 ，粘贴上方 拷贝的订阅链接（注意，粘贴后如果看不到<code>url</code>，可能是因为多了一个空行，按一次“Backspace删除键”即可）。</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/20211224141156.png" alt></p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/ClashX-3a.png" alt="3"></p>
<p>点击菜单栏中 ClashX 的图标，出站模式选择 <strong>规则</strong>，勾选下方的 <strong>设置为系统代理</strong> 以及 <strong>开机启动（可选）</strong>。</p>
<p>注意，<code>ClashX</code>目前不支持<code>v2ray</code>的<code>vless</code>协议，所以<code>vless</code>节点显示为失败。</p>
<p><img src="https://w1.v2dns.xyz/docs/SSPanel/macOS/images/ClashX-4.png" alt="4"></p>
<h2 id="开始使用"><a href="#开始使用" class="headerlink" title="开始使用"></a>开始使用</h2><p>点击菜单栏中 ClashX 的图标，然后在下方的 <strong>Proxy 策略组</strong> 中 节点选择 选 自动选择 或者你中意的节点即可。</p>
<p>注意：<code>Clash</code>使用 <code>HTTP HEAD</code>方法对测试网址（server_check_url）进行网页相应测试，以确认节点的可用性。数值在5000以内均为正常值，超出则显示为超时。数值大小和网速快慢没太大关系。</p>
<h2 id="其他注意事项"><a href="#其他注意事项" class="headerlink" title="其他注意事项"></a>其他注意事项</h2><p>请不要修改 <code>~/.config/clash/config.yml</code> 中的端口配置，否则会导致应用异常。</p>
<h2 id="ClashX-局域网代理共享"><a href="#ClashX-局域网代理共享" class="headerlink" title="ClashX 局域网代理共享"></a>ClashX 局域网代理共享</h2><p>1、在 <code>mac</code> 终端上使用<code>ifconfig</code>命令获取本地<code>IP</code>地址。</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/Clashx-5.png" alt="5"></p>
<p>2、打开<code>ClashX</code> 控制台，在「设置」选项卡中打开「允许来自局域网的连接」，并获取 <code>HTTP/SOCKS</code>代理端口号。</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/Clashx-6.png" alt="6"></p>
<p><strong>本文转载自</strong>:<a href="https://w1.v2dns.xyz/doc/#/macOS/ClashX" target="_blank" rel="noopener">https://w1.v2dns.xyz/doc/#/macOS/ClashX</a></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em><a href="https://code.newban.cn/">乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</a></em></p>
]]></content>
      <tags>
        <tag>墙里墙外</tag>
      </tags>
  </entry>
  <entry>
    <title>注册苹果美区 Apple ID 帐号并购买APP指南</title>
    <url>/301.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>如果有美区<code>AppleID</code>的话，可以直接上<code>AppStore</code>下载或购买 <code>Shadowrocket</code>、<code>Potatso Lite</code> 等 APP。</p>
<p>美区<code>AppleID</code>可以从淘宝购买，也可以自己注册，本教程介绍如何注册美区id。</p>
<p>当然如果是付费APP，比如小火箭<code>Shadowrocket</code>，则需要购买美区礼品卡，可以到<a href="http://www.offgamers.com" target="_blank" rel="noopener">www.offgamers.com</a>  购买支持微信、银联卡，或淘宝购买。</p>
<p><code>shadowrocket</code>正版美区商店2.99美元，<code>offgamers.com</code>美区礼品卡最低3美元，这点比淘宝好，淘宝礼品卡最低5美元 。</p>
<p>注册美区<code>AppleID</code>教程开始</p>
<h2 id="第一步-准备工作，无需信用卡！"><a href="#第一步-准备工作，无需信用卡！" class="headerlink" title="第一步 准备工作，无需信用卡！"></a>第一步 准备工作，无需信用卡！</h2><p>1、一个没有注册过AppleID的邮箱，建议最好是如Gmail自己的邮箱</p>
<p>2、一个苹果手机，当然这个是必须的</p>
<p>3、需要代理上网，使用注册对应地区的节点，我们注册美区苹果账号使用美国节点</p>
<h2 id="第二步-先到苹果网站注册账号"><a href="#第二步-先到苹果网站注册账号" class="headerlink" title="第二步 先到苹果网站注册账号"></a>第二步 先到苹果网站注册账号</h2><p>首选启用科学上网软件（手机电脑均可，请参考：<a href="https://code.newban.cn/302.html">Iphone/iPad通过电脑局域网共享梯子</a>，选择美国节点，选择代理/全局模式，使目前网络使用了美国代理。</p>
<p>打开此网站创建您的AppleID： <a href="https://appleid.apple.com/account#!&amp;page=create" target="_blank" rel="noopener">https://appleid.apple.com/account#!&amp;page=create</a></p>
<p>可以是中文界面，但注意的是国家或地区，必须选择 【美国】</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/apid1.jpg" alt="img"></p>
<p>按要求填写完整，这步骤就不需要多讲，一步步填写，自己务必记住就行，找回密码或者解锁账号会用到这些问题答案。</p>
<p>然后会给你注册邮箱发一个6位数的验证码，输入后就完成了注册。若你是用来共享的账户，登陆后不推荐启用两步验证，这个共享的话会很麻烦，每次都需要进行登陆验证。</p>
<p>电脑端注册账号就结束，然后下面是使用手机登陆<code>App Store</code>。</p>
<h2 id="第三步-苹果手机App-Store登陆"><a href="#第三步-苹果手机App-Store登陆" class="headerlink" title="第三步 苹果手机App Store登陆"></a>第三步 苹果手机App Store登陆</h2><p>手机必须是代理模式，节点选择美国。首先退出原来的账户，登陆新注册的账户。</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/apid2.jpg" alt="img"></p>
<p>会出现提示按提示选择Review，地区仍然是需选择美国United States，并操作同意下一步。</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/apid3.jpg" alt="img"></p>
<p>这个是关键的一步，下面会让你选择付款方式，若没有出现None，那么就你的手机网络不是美国IP，重新选择代理美国IP后，然后付款方式选择None。</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/apid4.jpg" alt="img"></p>
<p>对于<code>Shadowrocket</code>小火箭设置里面 【全局路由】 必须选择 【代理】；<code>V2rayN</code>软件的话代理选择全局模式。</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/apid5.jpg" alt="img"></p>
<p>填写美国人信息，这个建议谷歌搜索【美国个人信息生成】关键字获取。</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/apid6.jpg" alt="img"></p>
<p>需要注意的是，美区 <code>App Store</code> 中的应用是需要交税的，如果你希望以较低的价格购买一些付费 app，建议在地址处填入税率较低的州，比如 Oregon（俄勒冈州）、Alaska（阿拉斯加州）、Delaware（特拉华州）、Montana（蒙大拿州）、New Hampshire（新罕布什尔州）等。</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/apid7.jpg" alt="img"></p>
<p>填写后完成后，你的美区<code>Apple ID</code>账号就已注册完成了！</p>
<h2 id="其他-如何在App-Store购买苹果付费APP"><a href="#其他-如何在App-Store购买苹果付费APP" class="headerlink" title="其他 如何在App Store购买苹果付费APP"></a>其他 如何在App Store购买苹果付费APP</h2><p>你需要购买礼品卡，这个网上到处都可以购买的到，步骤如下：</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/apid8.jpg" alt="img"></p>
<p>获取后登陆账号信息输入即可，但是我这边测试了几次对于新号礼品卡冲进去后，苹果ID容易被苹果公司锁住，建议养号一段时间再充值购买，并且不要频繁使用不同ip地址！自己使用的话你可以开启双重认证，这样被苹果锁的概率就很低。</p>
<p><strong>本文转载自</strong>:<a href="https://w1.v2dns.xyz/doc/#/iOS/AppleID.html" target="_blank" rel="noopener">https://w1.v2dns.xyz/doc/#/iOS/AppleID.html</a></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em><a href="https://code.newban.cn/">乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</a></em></p>
]]></content>
      <tags>
        <tag>墙里墙外</tag>
      </tags>
  </entry>
  <entry>
    <title>Surge For IOS使用教程</title>
    <url>/306.html</url>
    <content><![CDATA[<h3 id="应用简介"><a href="#应用简介" class="headerlink" title="应用简介"></a>应用简介</h3><p><code>Surge</code> 是在 <code>iOS</code>平台上的客户端软件，支持 <code>Shadowsocks</code>协议。</p>
<p>目前 <code>Surge</code>已经被 <code>Apple</code> 根据政府要求从中国大陆区的 <code>App Store</code> 移除，之前在中国大陆商店购买此软件的用户将不能获得更新或重新下载。</p>
<p><code>Surge</code> 目前最新版本为 <code>Surge 4</code>，可直接在非中国大陆区的 <code>AppStore</code>搜到，免费下载安装。<code>Surge</code>的网络代理功能需要解锁<code>Pro</code> 授权，可通过 <code>AppStore</code> 内购或<a href="https://nssurge.com/buy_now" target="_blank" rel="noopener">访问其官网进行购买</a>。 iOS 3个设备的授权价格49.99美元。</p>
<p><strong>免费版无法进行科学上网，无购买意愿的朋友可以忽略此APP。</strong></p>
<h3 id="应用下载"><a href="#应用下载" class="headerlink" title="应用下载"></a>应用下载</h3><p>以下是该应用的下载地址。</p>
<ul>
<li>Apple iOS：<a href="https://apps.apple.com/us/app/surge-4/id1442620678" target="_blank" rel="noopener">App Store</a></li>
</ul>
<h3 id="配置-Surge"><a href="#配置-Surge" class="headerlink" title="配置 Surge"></a>配置 Surge</h3><p>接下来以下面这个订阅链接为例个大家介绍</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https://v1.ddnsgo.xyz/link/fcsdfsf?surge=2</span><br></pre></td></tr></table></figure>

<p>打开 <code>Surge 3</code> 点击左上角的<code>「Default」</code>进入配置管理页面。</p>
<p>或打开<code>Surge 2</code>点击底部导航栏的「配置」进入配置页面，随后点击左上角的图标进入配置管理页面。</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/20211224164015.png" alt></p>
<p>点击下方的「从 URL 下载配置」，在弹出的输入框中粘贴上方的订阅链接并点击 <strong>好的</strong>，此时 APP 会自动下载并切换到该配置。</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/20211224164028.png" alt></p>
<p>下图是已完成下载并切换到新配置。</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/20211224164039.png" alt></p>
<p><code>Surge 3</code> 请 <strong>回到首页</strong>，选择「规则模式」并打开「Rewrite」的开关。</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/20211224164049.png" alt></p>
<h3 id="开始使用"><a href="#开始使用" class="headerlink" title="开始使用]"></a>开始使用]</h3><p><code>Surge 3</code> 点击底部导航栏中的「策略组」进入策略组页面。</p>
<p>或打开 <code>Surge 2</code>点击底部导航栏的「配置」进入配置页面。</p>
<p>在 🍃 Proxy 策略组中选择 🏃 Auto。</p>
<p>随后回到首页点击 <strong>开关</strong> 或 <strong>启动</strong>。</p>
<p><code>Surge 2</code> 如提示下载外置模块请点击下载。</p>
<p>如提示添加 <code>VPN</code> 配置，请点击<code>Allow</code>并验证您的 密码、Touch ID、Face ID 。</p>
<p><strong>本文转载自</strong>:<a href="https://w1.v2dns.xyz/doc/#/iOS/Surge" target="_blank" rel="noopener">https://w1.v2dns.xyz/doc/#/iOS/Surge</a></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em><a href="https://code.newban.cn/">乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</a></em></p>
]]></content>
      <tags>
        <tag>墙里墙外</tag>
      </tags>
  </entry>
  <entry>
    <title>Kitsunebi For IOS使用教程</title>
    <url>/307.html</url>
    <content><![CDATA[<h3 id="应用简介"><a href="#应用简介" class="headerlink" title="应用简介"></a>应用简介</h3><p><code>Kitsunebi</code>是在<code>iOS</code>平台上的客户端软件，支持<code>Shadowsocks</code> 以及<code>VMess</code> 协议。</p>
<p>目前 <code>Kitsunebi</code>已经被 <code>Apple</code> 根据政府要求从中国大陆区的<code>App Store</code> 移除，之前在中国大陆商店购买此软件的用户将不能获得更新或重新下载。</p>
<p><strong>这是一个付费软件，你需要购买才能使用。</strong></p>
<h3 id="应用下载"><a href="#应用下载" class="headerlink" title="应用下载"></a>应用下载</h3><p>以下是各平台该应用的下载地址。</p>
<ul>
<li>Apple iOS：<a href="https://itunes.apple.com/us/app/kitsunebi-proxy-utility/id1446584073?ls=1&mt=8" target="_blank" rel="noopener">App Store</a></li>
<li>…</li>
</ul>
<h3 id="获取订阅"><a href="#获取订阅" class="headerlink" title="获取订阅"></a>获取订阅</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https://v1.ddnsgo.xyz/link/gdfdsgdsg?list=kitsunebi</span><br></pre></td></tr></table></figure>

<p>接下来以上面这个订阅链接为例个大家介绍</p>
<h3 id="配置-Kitsunebi"><a href="#配置-Kitsunebi" class="headerlink" title="配置 Kitsunebi"></a>配置 Kitsunebi</h3><p>打开 <code>Kitsunebi</code>，点击底部导航栏的「服务器」进入服务器页面。</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/20211224164424.png" alt></p>
<p>点击右上角的加号，从弹出菜单中选择第四个「订阅」。</p>
<p>在「备注」中输入本站名称，随后在「URL」中粘贴上方订阅链接, 打开自动更新的开关，随后点击右上角储存。</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/20211224164434.png" alt></p>
<p>点击本站订阅名称旁的感叹号进入订阅页面，随后点击「从 URL 更新」，此时会自动更新获取服务器。</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/20211224164449.png" alt></p>
<p>将上方「操作模式」更改为 <strong>Rule</strong>。</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/20211224164502.png" alt></p>
<h3 id="开始使用"><a href="#开始使用" class="headerlink" title="开始使用"></a>开始使用</h3><p>在下方订阅组中选择您需要的节点，随后点击底部导航栏的「状态」进入状态页面，打开开关即可。</p>
<p>如提示添加 <code>VPN</code>配置，请点击 <code>Allow</code>并验证您的 密码、Touch ID、Face ID 。</p>
<p><strong>本文转载自</strong>:<a href="https://w1.v2dns.xyz/doc/#/iOS/Kitsunebi" target="_blank" rel="noopener">https://w1.v2dns.xyz/doc/#/iOS/Kitsunebi</a></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em><a href="https://code.newban.cn/">乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</a></em></p>
]]></content>
      <tags>
        <tag>墙里墙外</tag>
      </tags>
  </entry>
  <entry>
    <title>Quantumult For IOS使用教程</title>
    <url>/309.html</url>
    <content><![CDATA[<h2 id="应用概述"><a href="#应用概述" class="headerlink" title="应用概述"></a>应用概述</h2><p><code>Quantumult</code> 是在<code>iOS</code>平台上的客户端软件，支持<code>Shadowsocks</code>、<code>ShadowsocksR</code> 以及 <code>VMess</code> 协议。</p>
<p>目前 <code>Quantumult</code>已经被<code>Apple</code>根据政府要求从中国大陆区的 <code>App Store</code>移除，之前在中国大陆商店购买此软件的用户将不能获得更新或重新下载。</p>
<p><strong>这是一个付费软件，你需要购买才能使用。</strong></p>
<h2 id="应用下载"><a href="#应用下载" class="headerlink" title="应用下载"></a>应用下载</h2><p>以下是各平台该应用的下载地址。</p>
<ul>
<li>Apple iOS：<a href="https://itunes.apple.com/us/app/quantumult/id1252015438?ls=1&mt=8" target="_blank" rel="noopener">App Store</a></li>
<li>…</li>
</ul>
<h2 id="配置方案"><a href="#配置方案" class="headerlink" title="配置方案"></a>配置方案</h2><p>此文中讲述在 Quantumult 中配置 SSR、V2ray、分流规则订阅。</p>
<p>如您需要更细化的配置，如使用策略组等，请 <strong><a href="https://w1.v2dns.xyz/doc/#/iOS/Quantumult_conf" target="_blank" rel="noopener">点此查阅</a></strong> 相关的使用方案，否则请往下继续。</p>
<h2 id="获取订阅"><a href="#获取订阅" class="headerlink" title="获取订阅"></a>获取订阅</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https://v1.ddnsgo.xyz/link/gdfdsgdsg?list=Quantumult</span><br></pre></td></tr></table></figure>

<p>接下来以上面这个订阅链接为例个大家介绍</p>
<h2 id="配置-Quantumult"><a href="#配置-Quantumult" class="headerlink" title="配置 Quantumult"></a>配置 Quantumult</h2><p>打开<code>Quantumult</code>，点击底部导航栏的「设置」进入设置页面。</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/quantumult_sub-1.jpg" alt="1"></p>
<p>进入「订阅」子页面并点击右上角的加号，从弹出菜单中选择第一个「服务器」。</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/quantumult_sub-2.jpg" alt="2"></p>
<p>在「名称」中输入本站名称并保存，随后在「链接」中粘贴上方 订阅链接 并保存。</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/quantumult_sub-3.jpg" alt="3"></p>
<p>随后点击右上角保存，此时会自动更新获取服务器。</p>
<h3 id="分流规则"><a href="#分流规则" class="headerlink" title="分流规则"></a>分流规则</h3><p>同样在「订阅」页面，点击右上角加号，从弹出菜单中选择第二个「分流」。</p>
<p>在名称中输入「Hackl0us Rules」，链接中输入 <a href="https://w1.v2dns.xyz/Quantumult.conf" target="_blank" rel="noopener">此链接网址</a> 【电脑：右键点链接-&gt;复制链接地址；手机长按链接，然后复制链接地址；或点击打开链接后从浏览器地址栏复制链接地址】。</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/quantumult_sub-4.jpg" alt="4"></p>
<p>随后左划「Hackl0us Rules」分流规则并点击替换。</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/quantumult_sub-5.jpg" alt="5"></p>
<h2 id="开始使用"><a href="#开始使用" class="headerlink" title="开始使用"></a>开始使用</h2><p>回到 Quantumult 主页，点击底部导航栏的 <strong>圆 logo</strong> 图标，选择您需要的节点，随后打开右上角开关即可。</p>
<p>如提示添加 VPN 配置，请点击 Allow 并验证您的 密码、Touch ID、Face ID 。</p>
<p><strong>本文转载自</strong>:<a href="https://w1.v2dns.xyz/doc/#/iOS/Quantumult_sub" target="_blank" rel="noopener">https://w1.v2dns.xyz/doc/#/iOS/Quantumult_sub</a></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em><a href="https://code.newban.cn/">乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</a></em></p>
]]></content>
      <tags>
        <tag>墙里墙外</tag>
      </tags>
  </entry>
  <entry>
    <title>小火箭 For IOS使用教程</title>
    <url>/305.html</url>
    <content><![CDATA[<h3 id="应用简介"><a href="#应用简介" class="headerlink" title="应用简介"></a>应用简介</h3><p><code>Shadowrocket</code>是在<code>iOS</code>平台上的客户端软件，支持<code>Shadowsocks</code>、<code>ShadowsocksR</code>以及 <code>VMess</code>协议。</p>
<p>目前 <code>Shadowrocket</code> 已经被 <code>Apple</code> 根据政府要求从中国大陆区的 <code>App Store</code>移除，之前在中国大陆商店购买此软件的用户将不能获得更新或重新下载。 <strong>请确保从苹果商店下载最新版小火箭，如果您不是最新版，请升级到最新版。</strong></p>
<p><a href="https://code.newban.cn/301.html">获取小火箭</a></p>
<p><a href="https://www.google.com/search?q=如何购买小火箭" target="_blank" rel="noopener">谷歌搜索：如何购买小火箭</a></p>
<h3 id="将V2ray节点导入小火箭"><a href="#将V2ray节点导入小火箭" class="headerlink" title="将V2ray节点导入小火箭"></a>将V2ray节点导入小火箭</h3><p><strong>首选方法：</strong> 从<a href="https://w1.v2dns.xyz/user" target="_blank" rel="noopener">V2free用户中心</a>，找到 ios/小火箭下方的 拷贝 V2Ray 订阅链接，将其导入小火箭。</p>
<p><strong>备选方法：</strong> 从<a href="https://w1.v2dns.xyz/user" target="_blank" rel="noopener">V2free用户中心</a>，拷贝全部节点URL后(不是订阅链接)，切换到Shadowrocket(小火箭)，小火箭会自动弹出提示：”将复制配置添加到您的列表(取消/添加)”,点”添加”按钮即可。</p>
<h3 id="Shadowrocket小火箭连不上的解决办法"><a href="#Shadowrocket小火箭连不上的解决办法" class="headerlink" title="Shadowrocket小火箭连不上的解决办法"></a>Shadowrocket小火箭连不上的解决办法</h3><p>我们发现可能是小火箭有bug，有时候会连不上，有2个办法：</p>
<ol>
<li><p>是到ios的vpn设置的地方，关闭vpn，再重新打开就连上了</p>
</li>
<li><p>另外，就是重启一下手机，然后打开小火箭，重新连接，就连上了</p>
</li>
</ol>
<p>这是一个付费软件，你需要购买才能使用。</p>
<h3 id="应用下载"><a href="#应用下载" class="headerlink" title="应用下载"></a>应用下载</h3><p><a href="https://apps.apple.com/us/app/shadowrocket/id932747118" target="_blank" rel="noopener">App Store:Shadowrocket</a></p>
<h3 id="订阅链接配置"><a href="#订阅链接配置" class="headerlink" title="订阅链接配置"></a>订阅链接配置</h3><p>以下面这个订阅链接为例, 给大家做个示范:<br><code>https://v1.ddnsgo.xyz/link/11111?clash=1</code></p>
<p>打开 <code>Shadowrocket</code>，点击底部导航栏的「设置」进入设置页面，随后往下划至最底部，进入「服务器订阅」子页面。</p>
<p>将「打开时更新」的开关 <strong>打开</strong>。</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/shadowrocket-1.jpg" alt></p>
<p><strong>回到首页</strong>，点击右上角的加号，再次点击第一行的「类型」，选择 <strong>Subscribe</strong>。</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/20211224163305.png" alt></p>
<p>在「备注」中输入本站名称，随后在「URL」中粘贴上方的订阅链接并保存。</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/20211224163318.png" alt></p>
<p>随后点击右上角保存，此时会自动更新获取服务器。</p>
<p><strong><em>小火箭手工更新订阅方法： 点“服务器节点”最上方的订阅链接右边的“i”图标，然后再点右上角的“完成”。\</em></strong></p>
<p>获取节点后，点击选中一个节点，然后点界面右上角的”未连接”开关，就可以开启vpn连接自由上网了。</p>
<h3 id="分流规则"><a href="#分流规则" class="headerlink" title="分流规则"></a>分流规则</h3><p>小火箭自带的一个简单的默认配置，有基本分流功能，自带规则比较精简，包含了常用网站，好处是体积小速度快，缺点是你上的网站如果不是常用或者是个cdn，它不一定会走代理。如果你不满意，可以继续下载配置一个高级分流规则。</p>
<p>在底部导航栏进入「配置」页面，点击右上角加号。</p>
<p>在弹出的输入框中输入 <a href="https://w1.v2dns.xyz/Shadowrocket.conf" target="_blank" rel="noopener">此链接网址</a> 【电脑：右键点链接-&gt;复制链接地址；手机长按链接，然后复制链接地址；或点击打开链接后从浏览器地址栏复制链接地址】。</p>
<p>随后点击 <strong>远程文件</strong> 中新增的配置文件地址，在弹出的菜单中选择第二个「使用配置」，此时 APP 会自动开始下载配置并应用配置。</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/20211224163330.png" alt></p>
<p><strong>回到首页</strong>，点击进入「全局路由」将其更改为 <strong>配置</strong>。</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/20211224163344.png" alt></p>
<h3 id="开始使用"><a href="#开始使用" class="headerlink" title="开始使用"></a>开始使用</h3><p>点右下角的：设置-&gt;延迟测试方法，改为</p>
<p><strong>CONNECT</strong></p>
<p>回到 <code>Shadowrocket</code>首页，点“连通性测试”测速，然后选择速度快延迟低的节点，随后打开第一行开关即可。</p>
<p>如提示添加 <code>VPN</code>配置，请点击<code>Allow</code> 并验证您的 密码、Touch ID、Face ID 。</p>
<p><strong>本文转载自</strong>:<a href="https://w1.v2dns.xyz/doc/#/iOS/Shadowrocket" target="_blank" rel="noopener">https://w1.v2dns.xyz/doc/#/iOS/Shadowrocket</a></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em><a href="https://code.newban.cn/">乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</a></em></p>
]]></content>
      <tags>
        <tag>墙里墙外</tag>
      </tags>
  </entry>
  <entry>
    <title>Quantumult X For IOS使用教程</title>
    <url>/308.html</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><code>Quantumult X</code>简称“圈X”，是一款功能强大的网络工具，本文主要介绍它的代理功能。</p>
<p><code>Quantumult X</code>目前支持的协议：<code>SS/SSR</code>、<code>V2Ray</code>、<code>Trojan</code>、<code>HTTP(S)</code></p>
<p><code>Quantumult X</code>是一款付费<strong>APP，7.99美元</strong>，需要用美区等AppleID账号登录 <code>Apple Store</code>下载。</p>
<h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><p><code>Quantumult X</code>在中国大陆区App Store已被下架。需要在商店里登录非中国大陆区的<code>AppleID</code>并付费下载该应用。</p>
<p><strong>自己注册美区号购买或者找代购美区应用。盗版和多账户下载已被开发者限制，无法使用正常功能。</strong></p>
<p><a href="https://apps.apple.com/us/app/quantumult-x/id1443988620" target="_blank" rel="noopener">https://apps.apple.com/us/app/quantumult-x/id1443988620</a></p>
<h2 id="订阅配置"><a href="#订阅配置" class="headerlink" title="订阅配置"></a>订阅配置</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https://v1.ddnsgo.xyz/link/gdfdsgdsg?list=Quantumult</span><br></pre></td></tr></table></figure>

<p>接下来以上面这个订阅链接为例个大家介绍</p>
<h2 id="导入节点"><a href="#导入节点" class="headerlink" title="导入节点"></a>导入节点</h2><p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/QuantumultX1.png" alt="1"></p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/QuantumultX2.png" alt="2"></p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/QuantumultX3.png" alt="3"></p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/QuantumultX4.png" alt="4"></p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/QuantumultX5.png" alt="5"></p>
<p><strong>本文转载自</strong>:<a href="https://w1.v2dns.xyz/doc/#/iOS/QuantumultX" target="_blank" rel="noopener">https://w1.v2dns.xyz/doc/#/iOS/QuantumultX</a></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em><a href="https://code.newban.cn/">乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</a></em></p>
]]></content>
      <tags>
        <tag>墙里墙外</tag>
      </tags>
  </entry>
  <entry>
    <title>如何在浏览器中手动设置cookies值实现前端分离调试</title>
    <url>/31.html</url>
    <content><![CDATA[<blockquote>
<p>在前端开发中经常会碰到需要cookies调试的情况, 下面介绍一下如何在浏览器中手动设置cookies值</p>
</blockquote>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/70-20200907095742754-20200907100541181.png" alt="img"></p>
<h3 id="1-查看cookies值"><a href="#1-查看cookies值" class="headerlink" title="1.查看cookies值"></a>1.查看cookies值</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">document.cookie</span><br></pre></td></tr></table></figure>

<h3 id="2-设置cookies值"><a href="#2-设置cookies值" class="headerlink" title="2.设置cookies值"></a>2.设置cookies值</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">document.cookie=&apos;name=Jack&apos;;</span><br></pre></td></tr></table></figure>

<h3 id="3-给cookies设置有效时间-默认浏览器关闭失效"><a href="#3-给cookies设置有效时间-默认浏览器关闭失效" class="headerlink" title="3.给cookies设置有效时间 默认浏览器关闭失效"></a>3.给cookies设置有效时间 默认浏览器关闭失效</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var oDate=new Date();</span><br><span class="line">oDate.setDate(oDate.getDate()+7);//设置为当前时间起算7天后过期</span><br><span class="line">document.cookie=&apos;name=Jack;expires=&apos;+oDate.toGMTString();</span><br></pre></td></tr></table></figure>

<h3 id="4-移除cookies"><a href="#4-移除cookies" class="headerlink" title="4.移除cookies"></a>4.移除cookies</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">setCookie(key,&quot;&quot;,-1);//把cookie设置为过期</span><br></pre></td></tr></table></figure>

<h3 id="函数封装"><a href="#函数封装" class="headerlink" title="函数封装"></a>函数封装</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setCookie</span>(<span class="params">key,value,t</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> oDate=<span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">  oDate.setDate(oDate.getDate()+t);</span><br><span class="line">  <span class="built_in">document</span>.cookie=key+<span class="string">"="</span>+value+<span class="string">"; 	 expires="</span>+oDate.toDateString();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getCookie</span>(<span class="params">key</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> arr1=<span class="built_in">document</span>.cookie.split(<span class="string">"; "</span>);<span class="comment">//由于cookie是通过一个分号+空格的形式串联起来的，所以这里需要先按分号空格截断,变成[name=Jack,pwd=123456,age=22]数组类型；</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;arr1.length;i++)&#123;</span><br><span class="line">      <span class="keyword">var</span> arr2=arr1[i].split(<span class="string">"="</span>);<span class="comment">//通过=截断，把name=Jack截断成[name,Jack]数组；</span></span><br><span class="line">      <span class="keyword">if</span>(arr2[<span class="number">0</span>]==key)&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">decodeURI</span>(arr2[<span class="number">1</span>]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//封装一个移除cookie的函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">removeCookie</span>(<span class="params">key</span>)</span>&#123;</span><br><span class="line">  setCookie(key,<span class="string">""</span>,<span class="number">-1</span>);<span class="comment">//把cookie设置为过期</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>本文为作者原创 转载时请注明出处 谢谢</strong></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em>乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</em></p>
]]></content>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>一款跨平台的Gif录制工具</title>
    <url>/313.html</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>写博客不时会有<code>gif</code>录制需求, 今天给大家推荐一款好用的<code>gif</code>录制工具, 名为<code>LICEcap</code></p>
<h3 id="软件优点"><a href="#软件优点" class="headerlink" title="软件优点"></a>软件优点</h3><ul>
<li><strong>免费开源</strong></li>
<li><strong>体积小 安装包不到1MB</strong></li>
<li><strong>跨平台 支持windows和Mac</strong></li>
</ul>
<h3 id="软件下载"><a href="#软件下载" class="headerlink" title="软件下载"></a>软件下载</h3><ul>
<li><strong>官网下载</strong>: <a href="https://www.cockos.com/licecap/" target="_blank" rel="noopener">LICEcap</a></li>
<li><strong>Github</strong>: <a href="https://github.com/justinfrankel/licecap" target="_blank" rel="noopener">LICEcap</a></li>
</ul>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20211228162505986.png" alt="image-20211228162505986"></p>
<h3 id="软件界面"><a href="#软件界面" class="headerlink" title="软件界面"></a>软件界面</h3><p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20211228162900705.png" alt="image-20211228162900705"></p>
<p>录制效果如下:</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/111.gif" alt="111"></p>
<h3 id="Gif压缩"><a href="#Gif压缩" class="headerlink" title="Gif压缩"></a>Gif压缩</h3><p>如果录制的<code>gif</code>文件过大不方便传输, 可以考虑进行压缩</p>
<ul>
<li>本地压缩工具: <a href="https://imageoptim.com/mac" target="_blank" rel="noopener">imageOptim</a> (目前只有Mac版)</li>
<li>在线压缩工具: <a href="https://www.soogif.com/compress" target="_blank" rel="noopener">soogif</a></li>
</ul>
<h3 id="其他录屏工具"><a href="#其他录屏工具" class="headerlink" title="其他录屏工具"></a>其他录屏工具</h3><ul>
<li><p><strong>QQ录屏</strong>: 录屏后可以导出为<code>gif, mp4,mov</code>三种格式, 非常方便 不过不能调整郑律, 导出的<code>gif</code>文件体积稍大</p>
</li>
<li><p><strong>操作系统自带录屏工具</strong>: <code>Mac</code>平台可以使用<code>Quicker Time</code>或者<a href="https://support.apple.com/zh-cn/HT208721" target="_blank" rel="noopener">截屏工具</a> <code>Windows10</code>平台可以使用<code>Xbox Game Bar</code> , 如果仅仅是操作步骤截图录制可以使用<a href="https://support.microsoft.com/zh-cn/topic/%E6%98%93%E5%AE%9D%E5%85%B8-win-7-%E9%9A%90%E8%97%8F%E5%B0%8F%E5%8A%9F%E8%83%BD-%E5%B1%8F%E5%B9%95%E5%BD%95%E5%88%B6-0d34aded-a76c-249c-5578-cecb9a86869f" target="_blank" rel="noopener">psr.exe</a></p>
<p><strong>需要注意的是:</strong></p>
<ul>
<li><p><code>Xbox Game Bar</code>不支持录制<code>Windows</code>桌面、文件资源管理器，每次只支持录制单独的应用窗口</p>
<p>可能会用到的几个快捷方式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Win+G 打开Xbox Game Bar</span><br><span class="line">Win+Alt+G 录制</span><br><span class="line">Win+Alt+R 开始/停止录制</span><br><span class="line">Win+Alt+M 麦克风打开/关闭</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>Mac</code>平台截屏录屏快捷键</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Shift+Command+5 调出截屏录屏工具栏</span><br><span class="line">Shift+Command+4 然后空格键  直接截取窗口全屏</span><br></pre></td></tr></table></figure>

<p><code>Quicker Time</code>不仅可以录屏还可单独录制音频和摄像头录制</p>
<p>无论使用截屏工具还是<code>Quiker Time</code>视频格式皆为<code>mov</code></p>
</li>
</ul>
</li>
</ul>
<h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><p>最近在<code>Mac</code>平台上使用<code>LICEcap</code>, 再经过imageOptim压缩后 发现出现画面掉帧的问题   这绝对是不能容忍的, 于是乎 我又找到两款性价比比较高的<code>gif</code>录制工具</p>
<ul>
<li><strong>GIF Brewery 3</strong></li>
<li><strong>Gifski</strong></li>
</ul>
<p>这两款工具 可以直接在<code>App Store</code>中下载免费使用</p>
<p><strong>本文为作者原创转载时请注明出处 谢谢</strong></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em><a href="https://code.newban.cn/">乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</a></em></p>
]]></content>
      <tags>
        <tag>实用工具</tag>
      </tags>
  </entry>
  <entry>
    <title>Android Studio 使用TinyPng插件一键压缩图片</title>
    <url>/312.html</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p><code>Apk</code>体积太大?  基本上是图片资源惹的祸,  此时我们需要对图片进行压缩, 而且是无损压缩</p>
<p>那么这里就得提到一个<code>Studio</code>插件, 那就是<code>TinyPNG Image Optimizer</code></p>
<h3 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤"></a>使用步骤</h3><ol>
<li><p>首先我们需要在<code>Studio</code>上安装<code>TinyPNG Image Optimizer</code>插件</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20211228153316868.png" alt="image-20211228153316868"></p>
</li>
<li><p>然后去<code>TinyPNG</code>官网申请一个<code>Api</code>, 以便我们能使用他们的压缩服务</p>
<p><a href="https://tinypng.com/developers" target="_blank" rel="noopener">点击进入TinyPNG开发者官网</a></p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20211228154806608.png" alt="image-20211228154806608"></p>
<p>这里需要填写一个邮箱, 如果你担心邮件骚扰, 可以去申请一个临时邮箱:</p>
<p><a href="https://temp-mail.org/zh/" target="_blank" rel="noopener">点击进入临时邮箱申请页面</a></p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20211228155000212.png" alt="image-20211228155000212"></p>
<p>用于临时验证什么的非常方便 强烈推荐大家使用</p>
</li>
<li><p>将获取到的<code>Api</code>填入<code>Studio</code>插件配置中</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20211228154334794.png" alt="image-20211228154334794"></p>
</li>
<li><p>选中需要压缩的图片右键选择<code>Optimize Image Size</code>, 当然你也可以选中<code>drawable</code>文件夹, 进行批量压缩</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20211228153858116.png" alt="image-20211228153858116"></p>
<p>​    </p>
<p>​    插件界面如下:</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20211228153715780.png" alt="image-20211228153715780"></p>
</li>
</ol>
<p>以上 就是<code>TinyPNG</code>插件的使用</p>
<p><strong>本文为作者原创转载时请注明出处 谢谢</strong></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em><a href="https://code.newban.cn/">乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</a></em></p>
]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>各大平台梯子软件汇总</title>
    <url>/310.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>话不多说, 直接往下看</p>
<h2 id="各大平台梯子汇总"><a href="#各大平台梯子汇总" class="headerlink" title="各大平台梯子汇总"></a>各大平台梯子汇总</h2><h3 id="Windows平台"><a href="#Windows平台" class="headerlink" title="Windows平台"></a>Windows平台</h3><ul>
<li><a href="https://github.com/Dreamacro/clash/releases" target="_blank" rel="noopener">Clash</a></li>
<li><a href="https://github.com/2dust/v2rayN/releases" target="_blank" rel="noopener">V2rayN</a></li>
<li><a href="https://github.com/v2rayA/v2rayA/releases" target="_blank" rel="noopener">V2rayA</a></li>
<li><a href="https://github.com/Qv2ray/Qv2ray/releases" target="_blank" rel="noopener">Qv2ray</a></li>
<li><a href="https://github.com/mellow-io/mellow/releases" target="_blank" rel="noopener">Mellow</a></li>
<li><a href="/releases">shadowsocks-windows</a></li>
</ul>
<h3 id="Mac平台"><a href="#Mac平台" class="headerlink" title="Mac平台"></a>Mac平台</h3><ul>
<li><a href="https://github.com/shadowsocks/ShadowsocksX-NG" target="_blank" rel="noopener">ShadowsocksX-NG</a></li>
<li><a href="https://github.com/Dreamacro/clash/releases" target="_blank" rel="noopener">Clash</a></li>
<li><a href="https://github.com/yanue/V2rayU/releases" target="_blank" rel="noopener">V2rayU</a></li>
<li><a href="https://github.com/v2rayA/v2rayA/releases" target="_blank" rel="noopener">V2rayA</a></li>
<li><a href="https://github.com/Qv2ray/Qv2ray/releases" target="_blank" rel="noopener">Qv2ray</a></li>
<li><a href="https://github.com/mellow-io/mellow/releases" target="_blank" rel="noopener">Mellow</a></li>
<li><a href="https://github.com/Cenmrev/V2RayX/releases" target="_blank" rel="noopener">V2RayX</a></li>
</ul>
<h3 id="Linux平台"><a href="#Linux平台" class="headerlink" title="Linux平台"></a>Linux平台</h3><ul>
<li><a href="https://github.com/Dreamacro/clash/releases" target="_blank" rel="noopener">Clash</a></li>
<li><a href="https://github.com/Qv2ray/Qv2ray/releases" target="_blank" rel="noopener">Qv2ray</a></li>
<li><a href="https://github.com/v2rayA/v2rayA/releases" target="_blank" rel="noopener">V2rayA</a></li>
<li><a href="https://github.com/mellow-io/mellow/releases" target="_blank" rel="noopener">Mellow</a></li>
</ul>
<h3 id="Freebsd平台"><a href="#Freebsd平台" class="headerlink" title="Freebsd平台"></a>Freebsd平台</h3><ul>
<li><a href="https://github.com/Dreamacro/clash/releases" target="_blank" rel="noopener">Clash</a></li>
<li><a href="https://github.com/v2rayA/v2rayA/releases" target="_blank" rel="noopener">V2rayA</a></li>
</ul>
<h3 id="Android-平台"><a href="#Android-平台" class="headerlink" title="Android 平台"></a>Android 平台</h3><ul>
<li><a href="https://github.com/2dust/v2rayNG/releases" target="_blank" rel="noopener">V2rayNG</a></li>
<li><a href="https://github.com/shadowsocks/shadowsocks-android/releases" target="_blank" rel="noopener">shadowsocks-android</a></li>
<li><a href="https://github.com/Kr328/ClashForAndroid/releases" target="_blank" rel="noopener">ClashForAndroid</a></li>
</ul>
<h3 id="路由器"><a href="#路由器" class="headerlink" title="路由器"></a>路由器</h3><ul>
<li><a href="https://github.com/hq450/fancyss" target="_blank" rel="noopener">Fancyss</a></li>
</ul>
<h2 id="下载指南"><a href="#下载指南" class="headerlink" title="下载指南"></a>下载指南</h2><p>在<code>Github</code>中如果你不知道该下载那个文件, 可以参考以下说明:</p>
<h4 id="Desktop-桌面端"><a href="#Desktop-桌面端" class="headerlink" title="Desktop(桌面端)"></a>Desktop(桌面端)</h4><ul>
<li><strong>Windows</strong><ul>
<li>如果你使用 Intel、AMD 的 x64 芯片的 Mac（较为<strong>普遍</strong>），则下载文件名中带有 <strong>win_x64</strong> 的文件</li>
<li>如果你使用 ARM64 芯片的 PC（极为<strong>稀有</strong>），例如 <strong>Surface Pro X</strong>，则下载文件名中带有 <strong>win_x64</strong> 的文件可通过 Win11 x86 模拟运行</li>
</ul>
</li>
<li><strong>macOS</strong><ul>
<li>如果你使用 Intel、AMD 的 x64 芯片的 Mac（较为<strong>普遍</strong>），则下载文件名中带有 <strong>macos_x64</strong> 的文件</li>
<li>如果你使用 ARM64 芯片的 Mac（较为<strong>稀有</strong>），例如 <strong>M1</strong>，则下载文件名中带有 <strong>macos_x64</strong> 的文件可通过 <a href="https://support.apple.com/zh-cn/HT211861" target="_blank" rel="noopener">Rosetta 2</a> 运行</li>
</ul>
</li>
<li><strong>Linux</strong><ul>
<li>如果你使用 Intel、AMD 的 x64 芯片的 PC（较为<strong>普遍</strong>）则下载文件名中带有 <strong>linux_x64</strong> 的文件</li>
<li>如果你使用 ARM64 芯片的 PC（较为<strong>稀有</strong>）例如 <strong>Raspberry Pi Model 3+</strong>，则下载文件名中带有 <strong>linux_arm64</strong> 的文件</li>
</ul>
</li>
<li><strong>Shared</strong><ul>
<li>如果你已安装了<code>ASP.NET Core Runtime 6.0.0</code>则下载文件名中带有<code>fde</code>的文件，可减少磁盘占用空间<ul>
<li><strong>在 Windows 上安装 .NET</strong><ul>
<li>在 Windows 上不需要 Hosting Bundle 和 IIS support</li>
<li><a href="https://dotnet.microsoft.com/download/dotnet/thank-you/runtime-aspnetcore-6.0.0-windows-x64-installer" target="_blank" rel="noopener">下载安装程序并手动安装(aspnetcore-runtime-6.0.0-win-x64.exe)</a></li>
<li><a href="https://docs.microsoft.com/en-us/dotnet/core/install/windows?tabs=net60#install-with-powershell-automation" target="_blank" rel="noopener">使用 PowerShell 自动化安装</a></li>
</ul>
</li>
<li><strong>在 Linux 上安装 .NET</strong><ul>
<li>推荐 <a href="https://docs.microsoft.com/zh-cn/dotnet/core/install/linux-snap" target="_blank" rel="noopener">通过 Snap 安装 .NET Runtime</a></li>
<li><code>sudo snap install dotnet-runtime-60 --classic</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="Mobile-移动端"><a href="#Mobile-移动端" class="headerlink" title="Mobile(移动端)"></a>Mobile(移动端)</h4><ul>
<li><strong>Android</strong><ul>
<li>如果你使用 ARM64 芯片的设备（较为<strong>普遍</strong>）则下载文件名中带有 <strong>android_arm64_v8a</strong> 的文件</li>
<li>如果你使用 ARM32 芯片的设备（较为<strong>稀有</strong>）通常为 <strong>14</strong> 年下半年之前生产的设备，则下载文件名中带有 <strong>android_armeabi_v7a</strong> 的文件</li>
<li>如果你使用 Intel、AMD 的 x86 芯片的设备（较为<strong>稀有</strong>）则下载文件名中带有 <strong>android_x86</strong> 的文件</li>
</ul>
</li>
</ul>
<h2 id="国内下载通道"><a href="#国内下载通道" class="headerlink" title="国内下载通道"></a>国内下载通道</h2><p>如果上面的软件无法下载或者访问缓慢, 可以进入国内下载通道</p>
<p> <a href="https://url97.ctfile.com/d/21042697-41429184-6115da" target="_blank" rel="noopener">点击进入</a>（访问密码：312306）</p>
<p><strong>本文为作者原创转载时请注明出处 谢谢</strong></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em><a href="https://code.newban.cn/">乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</a></em></p>
]]></content>
      <tags>
        <tag>墙里墙外</tag>
      </tags>
  </entry>
  <entry>
    <title>解决国内访问GitHub缓慢的解决方法汇总</title>
    <url>/314.html</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>在没有梯子的前提下, 国内访问GitHub可能会比较慢, 时长转圈圈, 如果想加快网页的访问, 有以下几种方法可以改善:</p>
<ul>
<li><strong>使用Steam++ 工具进行加速 (推荐)</strong></li>
<li><strong>使用UU加速器 (已失效)</strong></li>
<li><strong>使用dev-sidecar工具加速</strong></li>
<li><strong>修改Hosts文件</strong></li>
<li><strong>使用梯子</strong></li>
</ul>
<h3 id="使用Steam-工具进行加速"><a href="#使用Steam-工具进行加速" class="headerlink" title="使用Steam++ 工具进行加速"></a>使用Steam++ 工具进行加速</h3><p><code>Steam++</code>是一个包含 多种<code>Steam</code> 工具功能的工具箱, 主要有网站加速, 令牌管理, 库存管理, 内置插件等功能, 支持<code>Windows</code>, <code>Mac</code>,<code>UWP</code> ,<code>IOS</code>和<code>Android</code>四大平台, 工具免费开源, 推荐大家使用</p>
<p>官网介绍如下:</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20220104095648951.png" alt="image-20220104095648951"></p>
<p><a href="https://steampp.net/" target="_blank" rel="noopener">点击进入官网</a></p>
<h4 id="软件下载"><a href="#软件下载" class="headerlink" title="软件下载"></a>软件下载</h4><ul>
<li>官网下载: <a href="https://steampp.net/download" target="_blank" rel="noopener">Steam++</a></li>
<li>GitHub下载: <a href="https://github.com/BeyondDimension/SteamTools/releases" target="_blank" rel="noopener">Steam++</a></li>
</ul>
<p>应用主界面如下:</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20220104100033733.png" alt="image-20220104100033733"></p>
<p>选择<code>GitHub</code>进行一键加速即可开启快速访问</p>
<h3 id="使用dev-sidecar工具加速"><a href="#使用dev-sidecar工具加速" class="headerlink" title="使用dev-sidecar工具加速"></a>使用dev-sidecar工具加速</h3><p><strong>工具特性</strong></p>
<ul>
<li><strong>DNS优选</strong></li>
<li><strong>请求拦截</strong></li>
<li><strong>GitHub加速</strong></li>
<li><strong>Stack Overflow加速</strong></li>
<li><strong>npm加速</strong></li>
</ul>
<p>支持<code>windows</code>、<code>Mac</code>、<code>Linux(Ubuntu)</code>平台</p>
<p><strong>工具下载</strong></p>
<ul>
<li>Gitee通道下载: <a href="https://gitee.com/docmirror/dev-sidecar/releases" target="_blank" rel="noopener">Gitee Release</a></li>
<li>Github通道下载: <a href="https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2Fdocmirror%2Fdev-sidecar%2Freleases" target="_blank" rel="noopener">Github Release</a></li>
</ul>
<p><strong>应用界面</strong></p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/index.png" alt="img"></p>
<p><strong>官方使用文档</strong></p>
<p><a href="https://gitee.com/docmirror/dev-sidecar" target="_blank" rel="noopener">点击进入</a></p>
<h3 id="使用UU加速器"><a href="#使用UU加速器" class="headerlink" title="使用UU加速器"></a>使用UU加速器</h3><p>网易出品的一款游戏加速器, 国服游戏可以免费加速, 以前可以对Github进行加速, 现在好像不行了</p>
<h3 id="修改Hosts的方式"><a href="#修改Hosts的方式" class="headerlink" title="修改Hosts的方式"></a>修改Hosts的方式</h3><p>具体配置可参见之前的文章《<a href="https://code.newban.cn/42.html">解决国内访问github过慢的问题</a>》</p>
<h3 id="使用梯子"><a href="#使用梯子" class="headerlink" title="使用梯子"></a>使用梯子</h3><p>推荐使用<code>v2free</code>免费梯子, 详情可参见《<a href="https://code.newban.cn/295.html">关于机场订阅链接转换</a>》</p>
<p><strong>本文为作者原创转载时请注明出处 谢谢</strong></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em><a href="https://code.newban.cn/">乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</a></em></p>
]]></content>
      <tags>
        <tag>实用技巧</tag>
      </tags>
  </entry>
  <entry>
    <title>一款跨平台的SSH工具</title>
    <url>/315.html</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>有时候电脑不在身边, 想快速进入远程服务器解决问题, 此时我们可以借助手机进行<code>SSH</code>服务器连接</p>
<p>只需要下载一个<code>App</code>即可, 该应用名为<code>Termius</code></p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20220104115045524.png" alt="image-20220104115045524"></p>
<p><a href="https://www.termius.com/" target="_blank" rel="noopener">点击进入官网</a></p>
<h3 id="软件特色"><a href="#软件特色" class="headerlink" title="软件特色"></a>软件特色</h3><ul>
<li><strong>免费</strong></li>
<li><strong>跨平台</strong>: 支持<code>Mac</code> <code>Windows</code> <code>Linux</code>  <code>IOS</code>和<code>Android</code> 五大平台</li>
</ul>
<h3 id="软件下载"><a href="#软件下载" class="headerlink" title="软件下载"></a>软件下载</h3><p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20220104114433602.png" alt="image-20220104114433602"></p>
<ul>
<li><p><strong>Mac</strong>: </p>
</li>
<li><p><strong>Windows</strong>: <a href="https://termi.us/win" target="_blank" rel="noopener">Termius</a></p>
</li>
<li><p><strong>Linux</strong>: <a href="https://www.termius.com/download/linux/Termius.deb" target="_blank" rel="noopener">Termius</a></p>
</li>
<li><p><strong>IOS</strong>: <a href="https://termi.us/ios" target="_blank" rel="noopener">Termius</a></p>
</li>
<li><p><strong>Android</strong>: <a href="https://termi.us/googleplay" target="_blank" rel="noopener">Termius</a></p>
</li>
</ul>
<h3 id="国内下载通道"><a href="#国内下载通道" class="headerlink" title="国内下载通道"></a>国内下载通道</h3><p><code>Android</code>版官方下载渠道是谷歌商店的, 国内用户无法下载, 我这边已经将<code>APK上</code>传至国内网盘, 有需要的可以直接下载:</p>
<p><a href="https://url97.ctfile.com/d/21042697-46404497-5490a6" target="_blank" rel="noopener">点击下载</a>（访问密码：312306）</p>
<p><strong>本文为作者原创转载时请注明出处 谢谢</strong></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em><a href="https://code.newban.cn/">乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</a></em></p>
]]></content>
      <tags>
        <tag>实用工具</tag>
      </tags>
  </entry>
  <entry>
    <title>Mac平台下图片无损压缩工具</title>
    <url>/311.html</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>平常写博客经常会使用一些贴图, 有些录制的<code>gif</code>图片体积过大, 用户访问碰到网络不佳时难免体验不爽, 于是对于大图的压缩尤为关键</p>
<p>一方面提升图片的加载速度, 另一方面减少存储空间的占用</p>
<p>我们在对图片进行压缩时, 需要尽可能能地保证还原度, 也就是压缩痕迹不能太明显, 若能无损压缩最佳</p>
<p>这样的软件有不少, 比如:</p>
<ul>
<li><a href="https://tinypng.com/" target="_blank" rel="noopener">TinyPNG</a></li>
<li><a href="https://github.com/mozilla/mozjpeg" target="_blank" rel="noopener">MozJPEG</a></li>
<li><a href="https://github.com/google/guetzli" target="_blank" rel="noopener">Guetzli</a> </li>
</ul>
<p><code>TinyPNG</code>是一款在线图片压缩工具, 支持<code>webp</code>, <code>png</code>,<code>jpg</code>格式的压缩, 如果你是安卓开发者, 还可以直接使用 <code>TinyPNG</code>插件一键对Android工程内部图片批量压缩, 非常方便, 关于Android插件的使用可参考《<a href="https://code.newban.cn/312.html">Android Studio 使用TinyPng插件一键压缩图片》</a></p>
<p><code>MozJPEG</code>目前只支持Windows</p>
<p><code>Guetzli</code>是谷歌出品的一款开源图片压缩工具</p>
<p>本文给大家介绍<code>Mac</code>平台上的一款压缩工具, 名为<code>ImageOptim</code></p>
<h3 id="软件优点"><a href="#软件优点" class="headerlink" title="软件优点"></a>软件优点</h3><ul>
<li><strong>免费</strong></li>
<li><strong>开源</strong></li>
<li><strong>体积小</strong></li>
</ul>
<h3 id="软件下载"><a href="#软件下载" class="headerlink" title="软件下载"></a>软件下载</h3><ul>
<li><strong>官网下载</strong>: <a href="https://imageoptim.com/mac" target="_blank" rel="noopener">ImageOptim</a></li>
<li><strong>Github</strong>: <a href="https://github.com/ImageOptim/ImageOptim" target="_blank" rel="noopener">ImageOptim</a></li>
</ul>
<h3 id="软件界面"><a href="#软件界面" class="headerlink" title="软件界面"></a>软件界面</h3><p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20211228160643992.png" alt="image-20211228160643992"></p>
<p>在软件设置窗, 我们可以选择使用不同的压缩引擎, 还可以设置压缩质量等等:</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20211228161120200.png" alt="image-20211228161120200"></p>
<p>不过该软件暂时不支持透明图片的压缩, 如果你想压缩透明<code>png</code>图片, 可以使用另一款软件<code>pngmini</code></p>
<p><a href="https://pngmini.com/" target="_blank" rel="noopener">点击进入官网</a></p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20211228161444700.png" alt="image-20211228161444700"></p>
<p><strong>本文为作者原创转载时请注明出处 谢谢</strong></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em><a href="https://code.newban.cn/">乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</a></em></p>
]]></content>
      <tags>
        <tag>实用工具</tag>
      </tags>
  </entry>
  <entry>
    <title>用python写一个自动化喊麦 恭喜您发财</title>
    <url>/316.html</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>春节将近, 好运连连, 这里先祝大家在新的一年里, 身体健康, 万事如意, 财源滚滚~</p>
<p>春节这样一个喜庆的节日, 肯定是要嗨起来呀, 搞氛围最好的手段就是音乐, 不同的音乐, 不同的情绪</p>
<p>喊麦, 是一个非常接地气而且能快速调动人们情绪的一种音乐形式, 那么, AV Body 让我们开始躁起来吧, 哈哈哈</p>
<h3 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h3><ul>
<li>Python</li>
<li>喊麦诗词</li>
<li>喊麦BGM</li>
</ul>
<h5 id="喊麦词"><a href="#喊麦词" class="headerlink" title="喊麦词"></a>喊麦词</h5><h5 id="喊麦BGM"><a href="#喊麦BGM" class="headerlink" title="喊麦BGM"></a>喊麦BGM</h5><h3 id="喊麦步骤"><a href="#喊麦步骤" class="headerlink" title="喊麦步骤"></a>喊麦步骤</h3><h5 id="第一步-播放背景音乐"><a href="#第一步-播放背景音乐" class="headerlink" title="第一步 播放背景音乐"></a>第一步 播放背景音乐</h5><ol>
<li><p>首先确保<code>pip</code>为最新</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pip3 install --upgrade pip</span><br></pre></td></tr></table></figure>



</li>
</ol>
<h5 id="第二步-播放人声"><a href="#第二步-播放人声" class="headerlink" title="第二步 播放人声"></a>第二步 播放人声</h5><p>既然是自动化, 那么这里的人声用文字转语音代替, 这里我们需要使用到</p>
<ol>
<li><p>工具安装</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python3 -m pip install pyttsx3</span><br><span class="line"></span><br><span class="line">或者</span><br><span class="line"></span><br><span class="line">pip3 install pyttsx3</span><br></pre></td></tr></table></figure>
</li>
<li><p>朗读文本</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> </span><br></pre></td></tr></table></figure>





</li>
</ol>
<p><strong>本文为作者原创转载时请注明出处 谢谢</strong></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em><a href="https://code.newban.cn/">乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</a></em></p>
]]></content>
      <tags>
        <tag>人工智能</tag>
      </tags>
  </entry>
  <entry>
    <title>如何免费下载苹果商店收费软件</title>
    <url>/317.html</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>用惯了盗版软件, 突然要付费购买软件, 还真有些不太习惯, 最近看上了某款软件, 不过<code>App Store</code>售价惊人, 在网上找了一番, 没有找到相应的破解版本</p>
<p>于是我打开了拼夕夕和某宝, 直接搜关键字<code>苹果软件</code>, 找到一大堆</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20220107110945194.png" alt="image-20220107110945194"></p>
<p>原本售价几十几百的应用, 只需要几块钱</p>
<p>这样一来, 心里立马就舒服多了, 几百块钱不舍得花, 几块钱嘛, 还是愿意出的, 这跟免费没啥区别, 哈哈</p>
<p>以后但凡遇到付费的产品, 可以先去网上店铺看看有没有倒卖的, 嘿嘿</p>
<h3 id="后话"><a href="#后话" class="headerlink" title="后话"></a>后话</h3><p>当然有条件的话还是尽量购买正版, 享受正版服务, 至少软件更新啥的可以有保证, 同时也免去了各种繁琐的操作</p>
<p><strong>本文为作者原创转载时请注明出处 谢谢</strong></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em><a href="https://code.newban.cn/">乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</a></em></p>
]]></content>
      <tags>
        <tag>使用技巧</tag>
      </tags>
  </entry>
  <entry>
    <title>利用Android Studio快速给测试机截屏录屏</title>
    <url>/319.html</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>开发测试时, 可能会碰到需要给同事发送测试机上的应用截屏录屏, 如果你用的是自己的手机, 那么自然方便, 通过手机自带的截屏录屏功能配合微信QQ等完美搞定</p>
<p>但是, 如果测试机是公司的, 你只是临时一用, 同事要求你把测出的<code>bug</code>复现录个屏, 这时就有些麻烦了, 因为公司的测试机可能没有装微信等通讯软件, 即便装了也没有登录, 那图片视频就没法发送了, 想要解决有以下几种方法:</p>
<ul>
<li>给测试机装个微信然后登录或者安装局域网通讯应用</li>
<li>将<code>App</code>装到自己手机上</li>
<li>使用<code>Android Studio</code>的<code>Device File Explorer</code>, 将设备中的截图捞出来</li>
</ul>
<p>以上三种方式, 无论哪一种似乎都有些麻烦</p>
<p>此时的你开始暴躁, 最后索性改用模拟器 哈哈</p>
<p>事实上 如果你是<code>Andorid</code>开发, 那么我们的<code>Android Studio</code>可以完美解决以上的问题, <code>Studio</code>不仅可以给手机截屏, 还能录屏!!!</p>
<p>是的 你没听错, <code>Android Studio</code> 就是这么滴强大 嘿嘿 </p>
<h3 id="准备条件"><a href="#准备条件" class="headerlink" title="准备条件"></a>准备条件</h3><p>将手机调试模式连接至<code>Android Studio</code></p>
<h3 id="截屏"><a href="#截屏" class="headerlink" title="截屏"></a>截屏</h3><ol>
<li><p>第一种方式 使用<code>layout Inspector</code></p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20220112171043000.png" alt="image-20220112171043000"></p>
<p>这是<code>Studio</code>自带的应用布局查看器, 可以快速查看当前应用打开界面</p>
</li>
<li><p>第二种方式 使用<code>logcat</code>工具 (推荐)</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20220112171505186.png" alt="image-20220112171505186"></p>
<p><strong>点击截屏后:</strong></p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20220112171555143.png" alt="image-20220112171555143"></p>
<p>这个工具可以随意截取手机上任意一个页面, 不仅能对截取的图片进行旋转操作, 还可以添加手机边框, 去除阴影等等:</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20220112171922931.png" alt="image-20220112171922931"></p>
</li>
</ol>
<h3 id="录屏"><a href="#录屏" class="headerlink" title="录屏"></a>录屏</h3><p>同样是<code>logcat</code>选项卡中的一个小工具:</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20220112172036776.png" alt="image-20220112172036776"></p>
<p>​    点击后可以对录制的码率可宽高进行提前设置:</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20220112172132571.png" alt="image-20220112172132571"></p>
<p>最后导出的格式是<code>Mp4</code>, 配合<a href="https://convertio.co/zh/mp4-gif/" target="_blank" rel="noopener"><code>Mp4</code>在线转<code>gif</code>工具</a>, 我们可以很方便地给文章配测试动态图, 下面是录屏效果图:</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/device-2022-01-12-173145.gif" alt="device-2022-01-12-173145"></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>对于<code>Studio</code>这两个功能, 我个人是非常满意的, 测试机截屏录屏分分钟搞定, 不用担心图片不方便传输了</p>
<p><strong>本文为作者原创转载时请注明出处 谢谢</strong></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em><a href="https://code.newban.cn/">乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</a></em></p>
]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>python中播放音频的若干种方式</title>
    <url>/318.html</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>最近在做一个音乐自动化的工具, 涉及到背景音乐播放, 这里总结几种播放音频的方法, 如下</p>
<h3 id="第一种-使用pygame模块"><a href="#第一种-使用pygame模块" class="headerlink" title="第一种 使用pygame模块"></a>第一种 使用pygame模块</h3><ol>
<li><p><strong>模块安装</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pip install pygame</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>播放代码示例</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pygame</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">playMusic</span><span class="params">(fileName)</span>:</span>	</span><br><span class="line">    <span class="comment"># 初始化</span></span><br><span class="line">    pygame.mixer.init()</span><br><span class="line">    <span class="comment"># 加载音频文件</span></span><br><span class="line">    pygame.mixer.music.load(fileName) </span><br><span class="line">    <span class="comment"># 设置音量 范围为0.0到1.0</span></span><br><span class="line">    pygame.mixer.music.set_volume(<span class="number">0.5</span>) </span><br><span class="line">    <span class="comment"># 开始播放</span></span><br><span class="line">    pygame.mixer.music.play()</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p><strong>优点:</strong> 支持<code>wav</code>和<code>mp3</code>格式</p>
<p><strong>缺点:</strong> 声音是单声道的, 失真比较严重</p>
<h3 id="第二种-使用pyaudio模块"><a href="#第二种-使用pyaudio模块" class="headerlink" title="第二种 使用pyaudio模块"></a>第二种 使用pyaudio模块</h3><ol>
<li><p><strong>模块安装</strong></p>
<ol>
<li><p>由于<code>pyaudio</code>的运行需要依赖<code>portaudio</code>, 因此需要先安装</p>
<p><code>Mac</code>平台直接运行以下指令即可</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">brew install portaudio</span><br></pre></td></tr></table></figure>

<p>其他平台可参考<code>pyaudio</code>官方说明文档 <a href="http://people.csail.mit.edu/hubert/pyaudio/" target="_blank" rel="noopener">点击进入</a></p>
</li>
<li><p>安装<code>pyaudio</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip install pyaudio</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><p><strong>播放代码示例</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pyaudio</span><br><span class="line"><span class="keyword">import</span> wave</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">playMusic</span><span class="params">(fileName)</span>:</span></span><br><span class="line"></span><br><span class="line">    chunk = <span class="number">1024</span></span><br><span class="line">    wf = wave.open(fileName, <span class="string">'rb'</span>)</span><br><span class="line">    p = pyaudio.PyAudio()</span><br><span class="line">    stream = p.open(format=p.get_format_from_width(wf.getsampwidth()),</span><br><span class="line">            channels=wf.getnchannels(),</span><br><span class="line">            rate=wf.getframerate(),</span><br><span class="line">            output=<span class="literal">True</span>)</span><br><span class="line">    data = wf.readframes(chunk)</span><br><span class="line">    <span class="keyword">while</span> len(data) &gt; <span class="number">0</span>:</span><br><span class="line">        stream.write(data)</span><br><span class="line">        data = wf.readframes(chunk)</span><br><span class="line">    stream.stop_stream()</span><br><span class="line">    stream.close()</span><br><span class="line">    p.terminate()</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p><strong>优点:</strong> 支持音频录制, 回放为立体声, 支持<code>Windows</code>, <code>Mac</code>和<code>Linux</code>平台</p>
<p><strong>缺点:</strong> 不能播放mp3格式音频, 模块安装相对费劲</p>
<h3 id="第三种-使用simpleaudio"><a href="#第三种-使用simpleaudio" class="headerlink" title="第三种 使用simpleaudio"></a>第三种 使用simpleaudio</h3><ol>
<li><p><strong>模块安装</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pip install simpleaudio</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>播放代码</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> simpleaudio <span class="keyword">as</span> sa</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">playMusic3</span><span class="params">(fileName)</span>:</span></span><br><span class="line">    wave_obj = sa.WaveObject.from_wave_file(fileName)</span><br><span class="line">    play_obj = wave_obj.play()</span><br><span class="line">    play_obj.wait_done()</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p><strong>优点:</strong> 声音为立体声 安装简单</p>
<p><strong>缺点:</strong> 不能播放mp3格式音频</p>
<h3 id="第四种-综合版"><a href="#第四种-综合版" class="headerlink" title="第四种 综合版"></a>第四种 综合版</h3><p>上面几种方式总是不太完美, 有没有一种既支持mp3和wav格式, 又能立体声播放, 同时使用起来又方便的方式, 答案是 没有   哈哈</p>
<p>不过 我们可以借助一个音频格式转换工具然后配合<code>simpleaudio</code>, 就能实现我们的完美需求, 这个工具就是<code>pydub</code></p>
<p><code>pydub</code>不仅可以对音频进行格式转换, 还可以对音频进行切片(比如我播放音乐的前10秒 ), 淡入淡出, 以及获取音频总时长</p>
<p>更多用法可以参见<code>github</code> :</p>
<p><a href="https://github.com/jiaaro/pydub" target="_blank" rel="noopener">GitHub</a></p>
<h5 id="多格式音频播放实现"><a href="#多格式音频播放实现" class="headerlink" title="多格式音频播放实现"></a>多格式音频播放实现</h5><ol>
<li><p>模块安装</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip install pydub</span><br></pre></td></tr></table></figure>
</li>
<li><p>格式转换 比如<code>mp3</code>转<code>wav</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pydub <span class="keyword">import</span> AudioSegment</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">trans_mp3_to_wav</span><span class="params">(filepath)</span>:</span></span><br><span class="line">    song = AudioSegment.from_mp3(filepath)</span><br><span class="line">    song.export(<span class="string">"now.wav"</span>, format=<span class="string">"wav"</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>配合<code>simpleaudio</code>播放音频</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">from</span> pydub <span class="keyword">import</span> AudioSegment</span><br><span class="line"><span class="keyword">import</span> simpleaudio <span class="keyword">as</span> sa</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">trans_mp3_to_wav</span><span class="params">(filepath)</span>:</span></span><br><span class="line">    song = AudioSegment.from_mp3(filepath)</span><br><span class="line">    song.export(<span class="string">"./now.wav"</span>, format=<span class="string">"wav"</span>)</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">playMusic</span><span class="params">(fileName)</span>:</span></span><br><span class="line">    wave_obj = sa.WaveObject.from_wave_file(fileName)</span><br><span class="line">    play_obj = wave_obj.play()</span><br><span class="line">    play_obj.wait_done()</span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    trans_mp3_to_wav(<span class="string">"bgm2.mp3"</span>)</span><br><span class="line">    playMusic(<span class="string">"now.wav"</span>)</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p><strong>注意事项</strong>: 由于pydub这个模块, 过分依赖<code>ffmpeg</code>, 因此我们在使用时如果报错:</p>
<pre><code>FileNotFoundError: [Errno 2] No such file or directory: &apos;ffprobe&apos;</code></pre><p>那么需要先安装<code>ffmpeg</code></p>
<p><strong>各大平台安装<code>ffmpeg</code>方式:</strong></p>
<ol>
<li><p><strong>Mac平台</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">brew install ffmpeg</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>Windows平台</strong></p>
<ol>
<li>从<a href="http://builds.libav.org/windows/" target="_blank" rel="noopener">Windows binaries provided here</a>下载并提取<code>libav</code>；</li>
<li>添加libav <code>/bin</code> 文件夹到你的环境变量（PATH）</li>
</ol>
</li>
<li><p><strong>Linux平台</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apt-get install ffmpeg</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>除了以上几种之外还有一些其他的音频播放模块, 不过大多数都有各自的局限性, 结合自身需求进行选用即可</p>
<p><strong>本文为作者原创转载时请注明出处 谢谢</strong></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em><a href="https://code.newban.cn/">乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</a></em></p>
]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Git回退部分文件到历史版本</title>
    <url>/321.html</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>有时候我们需要将部分代码或者部分图标恢复到历史某个版本, 此时我们可以采取以下方式</p>
<h3 id="步骤如下"><a href="#步骤如下" class="headerlink" title="步骤如下"></a>步骤如下</h3><ol>
<li><p>查看某个文件的历史版本记录</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git log xxx.png</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20220211180311813.png" alt="image-20220211180311813"></p>
</li>
<li><p>对某个文件进行版本回退</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git reset 656fdsf65 xxx.png</span><br></pre></td></tr></table></figure>

<p>此时你会发现文件并未发生改变, 并提示<code>unStage</code>, 我们需要使用<code>checkout</code>将文件检出</p>
</li>
<li><p>检出文件内容</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">giit checkout xxx.png</span><br></pre></td></tr></table></figure>

<p>这时文件已经恢复</p>
</li>
<li><p>最后重新提交<code>push</code>即可</p>
</li>
</ol>
<p><strong>本文为作者原创转载时请注明出处 谢谢</strong></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em><a href="https://code.newban.cn/">乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</a></em></p>
]]></content>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>关于BottomSheetDialogFragment使用过程中常见的一些问题</title>
    <url>/320.html</url>
    <content><![CDATA[<h3 id="问题汇总"><a href="#问题汇总" class="headerlink" title="问题汇总"></a>问题汇总</h3><h4 id="1-默认白底去除"><a href="#1-默认白底去除" class="headerlink" title="1.默认白底去除"></a>1.默认白底去除</h4><p>​    <code>BottomSheetDialogFragment</code>布局默认有个白色背景, 当你给布局加圆角时就会发现这个问题, 如果我们要将这个背景改为透明, 可采用以下做法:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">override fun onViewCreated(view: View, savedInstanceState: Bundle?) &#123;</span><br><span class="line">      super.onViewCreated(view, savedInstanceState)</span><br><span class="line">      //去除默认的白底</span><br><span class="line">      (binding.root.parent as? View)?.setBackgroundColor(Color.TRANSPARENT)</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-下滑后弹窗未完全关闭-半透明蒙层还在"><a href="#2-下滑后弹窗未完全关闭-半透明蒙层还在" class="headerlink" title="2.下滑后弹窗未完全关闭 半透明蒙层还在"></a>2.下滑后弹窗未完全关闭 半透明蒙层还在</h4><p>我们一般会配合<code>setDimAmount()</code>函数来这只弹窗的背景透明度, 比如:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">override fun onStart() &#123;</span><br><span class="line">    super.onStart()</span><br><span class="line">        dialog?.window?.setDimAmount(0.6f)</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>如果<code>peekHeight</code>属性值没有设置到位的话, 比如设置为0, 就容易出现下滑关闭弹窗后半透明背景依旧存在, 需要再点一次才会消失, 实际上是因为弹窗未完全关闭导致的, 解决方法是将布局的实际高度赋值给<code>peekHeight</code>, 代码如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">override fun onViewCreated(view: View, savedInstanceState: Bundle?) &#123;</span><br><span class="line">    super.onViewCreated(view, savedInstanceState)</span><br><span class="line">    val onGlobalLayoutListener = ViewTreeObserver.OnGlobalLayoutListener &#123;</span><br><span class="line">        val dialog = dialog as BottomSheetDialog</span><br><span class="line">        val bottomSheet =</span><br><span class="line">            dialog.findViewById&lt;View&gt;(com.google.android.material.R.id.design_bottom_sheet) as FrameLayout?</span><br><span class="line">        val behavior = BottomSheetBehavior.from(bottomSheet!!)</span><br><span class="line">        behavior.state = BottomSheetBehavior.STATE_EXPANDED</span><br><span class="line">        behavior.peekHeight = view.height</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong>本文为作者原创转载时请注明出处 谢谢</strong></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em><a href="https://code.newban.cn/">乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</a></em></p>
]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>Hugo博客百度SEO优化 自动提交</title>
    <url>/32.html</url>
    <content><![CDATA[<p>在切换到Hugo平台之后,比较头疼的是之前hexo很多seo的插件不能使用了. 下面跟大家说一下我的seo优化方案.</p>
<h1 id="Meta标签优化"><a href="#Meta标签优化" class="headerlink" title="Meta标签优化"></a>Meta标签优化</h1><h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>meta description，被认为是最有用的meta标签，是网站的简介信息。 content控制在100个字符以内比较好。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">'description'</span> <span class="attr">itemprop</span>=<span class="string">"description"</span> <span class="attr">content</span>=<span class="string">"&#123;&#123; if .Description &#125;&#125;&#123;&#123; .Description &#125;&#125;&#123;&#123; else &#125;&#125;&#123;&#123;if .IsPage&#125;&#125;&#123;&#123;substr .Summary 0 100&#125;&#125;&#123;&#123; end &#125;&#125;&#123;&#123; end &#125;&#125;"</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="Keywords"><a href="#Keywords" class="headerlink" title="Keywords"></a>Keywords</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&#123;&#123; if .Keywords &#125;&#125; </span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"keywords"</span> <span class="attr">content</span>=<span class="string">"&#123;&#123; delimit .Keywords "</span>, " &#125;&#125;" &gt;</span></span><br><span class="line">&#123;&#123;else&#125;&#125;</span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"keywords"</span> <span class="attr">content</span>=<span class="string">"&#123;&#123; delimit .Site.Params.Keywords "</span>, " &#125;&#125;" &gt;</span></span><br><span class="line">&#123;&#123; end &#125;&#125;</span><br></pre></td></tr></table></figure>

<h1 id="百度熊掌号推送"><a href="#百度熊掌号推送" class="headerlink" title="百度熊掌号推送"></a>百度熊掌号推送</h1><p>说到seo熊掌号是必不可少的了,他可以做到24小时之内收录.所以这个必须不能放过.</p>
<h2 id="gulp"><a href="#gulp" class="headerlink" title="gulp"></a>gulp</h2><p>在这里我要使用gulp来做我的自动化任务管理工具</p>
<h3 id="安装gulp需要的模块"><a href="#安装gulp需要的模块" class="headerlink" title="安装gulp需要的模块"></a>安装gulp需要的模块</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm init</span><br><span class="line">npm install gulp --save</span><br><span class="line">npm install xml2js --save</span><br><span class="line">npm install xmlhttprequest --save</span><br></pre></td></tr></table></figure>

<h3 id="在项目根目录创建一个gulpfile-js文件"><a href="#在项目根目录创建一个gulpfile-js文件" class="headerlink" title="在项目根目录创建一个gulpfile.js文件"></a>在项目根目录创建一个<code>gulpfile.js</code>文件</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 导入相关依赖</span></span><br><span class="line"><span class="keyword">const</span> gulp = <span class="built_in">require</span>(<span class="string">"gulp"</span>);</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">const</span> xml2js = <span class="built_in">require</span>(<span class="string">'xml2js'</span>)</span><br><span class="line"><span class="keyword">const</span> parser = <span class="keyword">new</span> xml2js.Parser();</span><br><span class="line"><span class="keyword">const</span> XMLHttpRequest = <span class="built_in">require</span>(<span class="string">"xmlhttprequest"</span>).XMLHttpRequest;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册百度站长与熊掌号,百度会提供下面的数据给你</span></span><br><span class="line"><span class="keyword">var</span> xz_appid = <span class="string">'1623792852327580'</span>;</span><br><span class="line"><span class="keyword">var</span> xz_token = <span class="string">'bbd1f589b763b7fb40e52628c176ae27'</span>;</span><br><span class="line"><span class="keyword">var</span> baidu_token= <span class="string">'79IKQsDuvZSdXwd9'</span> </span><br><span class="line"></span><br><span class="line"><span class="comment">//熊掌号每天需要提交的url数量</span></span><br><span class="line"><span class="comment">// 注意这个数字必须要跟百度允许提交的url数量一致,如果多了会提交失败.</span></span><br><span class="line"><span class="keyword">const</span> xzCount = <span class="number">2000</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个任务</span></span><br><span class="line">gulp.task(<span class="string">'baiduSeo'</span>, () =&gt; &#123;</span><br><span class="line">    <span class="comment">// 读取sitemap.xml文件并且转换成json</span></span><br><span class="line">    fs.readFile(__dirname + <span class="string">'/public/sitemap.xml'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">        parser.parseString(data, <span class="function"><span class="keyword">function</span> (<span class="params">err, result</span>) </span>&#123;</span><br><span class="line">            <span class="comment">// 把读取的数据传入这个函数</span></span><br><span class="line">            urlSubmit(result.urlset.url)</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'Done'</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 提交url的方法</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">urlSubmit</span>(<span class="params">urls</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 最新内容提交</span></span><br><span class="line">    <span class="keyword">var</span> new_target = <span class="string">"http://data.zz.baidu.com/urls?appid="</span>+xz_appid+<span class="string">"&amp;token="</span>+xz_token+<span class="string">"&amp;type=realtime"</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 历史提交</span></span><br><span class="line">    <span class="keyword">var</span> history_target = <span class="string">"http://data.zz.baidu.com/urls?appid="</span>+xz_appid+<span class="string">"&amp;token="</span>+xz_token+<span class="string">"&amp;type=batch"</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 百度站长</span></span><br><span class="line">    <span class="keyword">var</span> baidu_target = <span class="string">"http://data.zz.baidu.com/urls?site=https://zaina.newban.cn&amp;token="</span>+baidu_token</span><br><span class="line"></span><br><span class="line">    <span class="comment">// MIP</span></span><br><span class="line">    <span class="keyword">var</span> MIP_target = <span class="string">"http://data.zz.baidu.com/urls?site=https://zaina.newban.cn&amp;token="</span>+baidu_token+<span class="string">"&amp;type=mip"</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// AMP</span></span><br><span class="line">    <span class="keyword">var</span> AMP_target = <span class="string">"http://data.zz.baidu.com/urls?site=https://zaina.newban.cn&amp;token="</span>+baidu_token+<span class="string">"&amp;type=amp"</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 最新url,看熊掌号情况而定</span></span><br><span class="line">    urls = urls.map(<span class="function"><span class="params">item</span>=&gt;</span>item.loc[<span class="number">0</span>])</span><br><span class="line">    allUrls = urls.join(<span class="string">'\n'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> new_urls_Arr = urls.slice(<span class="number">0</span>,xzCount)</span><br><span class="line">    new_urls= new_urls_Arr.join(<span class="string">'\n'</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.info(<span class="string">'百度站长开始提交'</span>,new_urls)</span><br><span class="line">    sendData(baidu_target,new_urls,<span class="string">'百度站长提交成功'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.info(<span class="string">'熊掌号开始提交'</span>)</span><br><span class="line">    <span class="comment">//sendData(new_target,new_urls,'熊掌号提交完成')</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 提交历史url 每天最多500w条</span></span><br><span class="line">    <span class="built_in">console</span>.info(<span class="string">"历史数据开始提交"</span>)</span><br><span class="line">    <span class="comment">//sendData(history_target,allUrls,"历史数据提交完成")</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.info(<span class="string">"MIP 开始提交"</span>)</span><br><span class="line">    <span class="comment">//sendData(MIP_target,allUrls,"MIP提交成功")</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.info(<span class="string">"AMP 开始提交"</span>)</span><br><span class="line">    <span class="comment">//sendData(AMP_target,allUrls,"AMP提交成功")</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 提交数据</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">sendData</span>(<span class="params">target,urls,message</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">        xhr.open(<span class="string">'POST'</span>, target, <span class="literal">false</span>);</span><br><span class="line">        xhr.setRequestHeader(<span class="string">'Content-type'</span>, <span class="string">'text/plain'</span>);</span><br><span class="line">        xhr.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="keyword">this</span>.responseText);</span><br><span class="line">            <span class="keyword">if</span>(message)&#123;<span class="built_in">console</span>.info(message)&#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        xhr.send(urls);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">gulp.task(<span class="string">"default"</span>,gulp.series( <span class="string">'baiduSeo'</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;))</span><br></pre></td></tr></table></figure>

<p>配置好以上都文件之后</p>
<h2 id="推送"><a href="#推送" class="headerlink" title="推送"></a>推送</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 博客生成</span></span><br><span class="line">hugo</span><br><span class="line"><span class="comment"># url推送</span></span><br><span class="line">gulp</span><br></pre></td></tr></table></figure>

<p><strong>本文为作者原创 转载时请注明出处 谢谢</strong></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em>乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</em></p>
]]></content>
      <tags>
        <tag>Hugo</tag>
      </tags>
  </entry>
  <entry>
    <title>Studio报错解决 Duplicate class kotlinx.android.parcel.IgnoredOnParcel found in modules</title>
    <url>/322.html</url>
    <content><![CDATA[<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>Android开发过程中给项目添加依赖包时<code>Studio</code>偶尔出现以下问题:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Duplicate class kotlinx.android.parcel.IgnoredOnParcel found in modules</span><br></pre></td></tr></table></figure>

<p>原因是依赖冲突</p>
<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>排除<code>org.jetbrains.kotlin</code>包, 如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">implementation (&apos;xxxx:1.0.0&apos;)&#123;</span><br><span class="line">      exclude group : &quot;org.jetbrains.kotlin&quot;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p><strong>本文为作者原创转载时请注明出处 谢谢</strong></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em><a href="https://code.newban.cn/">乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</a></em></p>
]]></content>
      <tags>
        <tag>问题集锦</tag>
      </tags>
  </entry>
  <entry>
    <title>PC端快速下载视频网站的视频</title>
    <url>/325.html</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>有时候在逛B站或者看QQ音乐MV的时候 有把视频下载到本地的需求</p>
<p>网上有很多针对特定网站视频的解析工具, 比如针对B站的有:</p>
<ul>
<li><p><a href="https://bilibili.iiilab.com/" target="_blank" rel="noopener">B站视频在线解析</a> </p>
</li>
<li><p><a href="https://github.com/FlySelfLog/downkyi/releases" target="_blank" rel="noopener">Downkyi下载姬</a></p>
</li>
<li><p><a href="http://client.jijidown.com/" target="_blank" rel="noopener">唧唧下载器</a></p>
</li>
</ul>
<p>对于我这种只是偶尔下载个视频的懒人而言, 为了下载一个视频单独安装一个软件, 实在是不太能接受  自然是优先选择在线解析的方案</p>
<p>但是 大部分在线解析网站都是针对某一个或者某几个主流的视频网站进行解析处理, 如果碰上冷门网站 那就有些尴尬了</p>
<p>今天给大家介绍一个非常简单实用, 并且对所有视频网站都通用的一个方法, 只需要一个浏览器就能快速获取视频源地址</p>
<h3 id="原料准备"><a href="#原料准备" class="headerlink" title="原料准备"></a>原料准备</h3><ul>
<li>浏览器 (本文以谷歌浏览器为例)</li>
<li>电脑 </li>
</ul>
<h3 id="开始抓取"><a href="#开始抓取" class="headerlink" title="开始抓取"></a>开始抓取</h3><ol>
<li><p>第一步打开浏览器 将视频地址填入地址栏</p>
</li>
<li><p>按F12进入开发者选项 选择移动设备浏览模式 对Media进行过滤 然后F5刷新页面</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20220424112429767.png" alt="image-20220424112429767"></p>
</li>
<li><p>拷贝视频文件路径 直接浏览器下载或者第三方软件下载</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20220424112609595.png" alt="image-20220424112609595"></p>
</li>
</ol>
<p>博主对B站和QQ音乐进行了测试, 均能获取到原视频地址, 如果没有出现地址, 建议多刷新几次试试, 一般都没有问题</p>
<p>很多在线视频解析的原理也就是这么一回事 </p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>上面这种方法 相信有很多人都知道, 但如果你不是做技术的, 可能就不太清楚了, 希望本文能帮到大家</p>
<p>另外 如果你有批量下载视频的需求, 该方法就有些费劲了, 这种情况建议大家使用软件进行解析下载</p>
<p><strong>本文为作者原创转载时请注明出处 谢谢</strong></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em><a href="https://code.newban.cn/">乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</a></em></p>
]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>Android集成支付宝支付以及沙箱环境测试注意事项</title>
    <url>/323.html</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>现在很多App都涉及到支付, 毕竟开发APP目的是为了盈利嘛, 通常我们会在App中同时集成支付宝和微信支付, 方便用户消费</p>
<h3 id="集成相关"><a href="#集成相关" class="headerlink" title="集成相关"></a>集成相关</h3><p>支付宝的集成相对简单, 前端无需添加<code>APPID</code>和密钥, 签名部分在在后端完成,只要确保应用签名和开发平台填入的保持一致就行,  不像微信不仅要配置<code>APPID</code>, 还要添加<code>WXEntryActivity</code> ,此外包名也必须匹配 少一个都不行</p>
<p>当然两者都需要在开发平台填入一个应用签名, 格式为<code>MD5</code></p>
<h3 id="沙箱环境"><a href="#沙箱环境" class="headerlink" title="沙箱环境"></a>沙箱环境</h3><p>当我们<code>SDK</code>集成完毕, 后台接口也调好后, 开始测试支付, 那么问题来了, 支付可是得花钱的呀, 为了解决这个问题, 支付宝官方给我们提供了一个沙箱环境的支付宝, 方便开发测试</p>
<p>简而言之就是提供了一个测试用的支付宝账号, 里面有很多钱, 可以随便花, 哈哈, 不过仅限于测试</p>
<p>这个测试账号不能直接登录我们平常用的支付宝App, 需要下载一个沙箱用的支付宝App</p>
<p> 这里提供了沙箱支付宝App下载地址</p>
<p><a href="https://sandbox.alipaydev.com/user/downloadApp.htm" target="_blank" rel="noopener">沙箱支付宝App下载</a></p>
<h3 id="沙箱测试"><a href="#沙箱测试" class="headerlink" title="沙箱测试"></a>沙箱测试</h3><p>安装完毕后登录沙箱账号, 看看你的应用能否调起支付</p>
<p>此时你会发现支付宝调不起来 ,如果返回错误码4000, 那么就是没有检测到沙箱支付宝App</p>
<p>此时 需要在支付<code>Activity</code>中开启沙箱环境, 代码如下:</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">    <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">    EnvUtils.setEnv(EnvUtils.EnvEnum.SANDBOX)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果依然无效, 那么大概率是后台签名出了问题, 后台网关需要改成沙箱环境地址</p>
<h3 id="支付宝H5支付"><a href="#支付宝H5支付" class="headerlink" title="支付宝H5支付"></a>支付宝H5支付</h3><p>当用户手机上未安装支付宝app时也需要支持支付功能的话, 可以采用H5页面支付方案, 此时需要在清单文件中声明相应<code>Activity</code>,如下:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--        支付宝客户端未安装时使用H5页面  --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">activity</span></span></span><br><span class="line"><span class="tag">          <span class="attr">android:name</span>=<span class="string">"com.alipay.sdk.app.H5PayActivity"</span></span></span><br><span class="line"><span class="tag">          <span class="attr">android:exported</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">          <span class="attr">android:theme</span>=<span class="string">"@android:style/Theme.Translucent.NoTitleBar"</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">activity</span></span></span><br><span class="line"><span class="tag">          <span class="attr">android:name</span>=<span class="string">"com.alipay.sdk.app.H5AuthActivity"</span></span></span><br><span class="line"><span class="tag">          <span class="attr">android:exported</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">          <span class="attr">android:theme</span>=<span class="string">"@android:style/Theme.Translucent.NoTitleBar"</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<p>该功能可选, 如果不需要可不添加</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>支付宝集成归纳如下:</p>
<ul>
<li>前端无需配置APPID, 只需确保<strong>应用签名</strong>正确 包名不一样也能正常调起</li>
<li>沙箱测试, 前端需要使用<code>EnvUtils</code>开启沙箱环境</li>
<li>沙箱支付宝登录使用开发后台提供的买家账号登录, 用于支付</li>
</ul>
<p>微信支付集成归纳如下:</p>
<ul>
<li><p>前端需要配置<strong>APPID和密钥</strong> 同时<strong>包名</strong>和<strong>应用签名</strong>需要正确</p>
</li>
<li><p>还需要再创建一个<code>WXEntryActivity</code>, 并在清单文件中注册</p>
<p>清单文件中可以考虑使用<code>activity-alias</code> 实现多合一注册, 示例如下</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">activity-alias</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:name</span>=<span class="string">"$&#123;applicationId&#125;.wxapi.WXPayEntryActivity"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:exported</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:targetActivity</span>=<span class="string">"WeiXinHandlerActivity"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:theme</span>=<span class="string">"@android:style/Theme.Translucent.NoTitleBar"</span> /&gt;</span>   </span><br><span class="line"><span class="tag">&lt;<span class="name">activity-alias</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:name</span>=<span class="string">"$&#123;applicationId&#125;.wxapi.WXEntryActivity"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:exported</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:targetActivity</span>=<span class="string">"WeiXinHandlerActivity"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:theme</span>=<span class="string">"@android:style/Theme.Translucent.NoTitleBar"</span> /&gt;</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p>从<code>Android11</code>开始, 涉及到一个软件可见性适配问题, 也就是说调起第三方应用时需要在清单文件中声明其对应的包名, 否则无法调起支付, 具体代码如下:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">queries</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">package</span> <span class="attr">android:name</span>=<span class="string">"com.eg.android.AlipayGphone"</span> /&gt;</span> <span class="comment">&lt;!-- 支付宝 --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">package</span> <span class="attr">android:name</span>=<span class="string">"hk.alipay.wallet"</span> /&gt;</span> <span class="comment">&lt;!-- AlipayHK --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">package</span> <span class="attr">android:name</span>=<span class="string">"com.tencent.mm"</span> /&gt;</span> <span class="comment">&lt;!-- 微信支付 --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">package</span> <span class="attr">android:name</span>=<span class="string">"com.sina.weibo"</span> /&gt;</span> <span class="comment">&lt;!-- 微博 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">queries</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">application</span></span></span><br><span class="line"><span class="tag">  <span class="attr">...</span></span></span><br></pre></td></tr></table></figure>

<p>《<a href="https://open.weixin.qq.com/cgi-bin/announce?action=getannouncement&key=11600155960jI9EY&version=&lang=&token=" target="_blank" rel="noopener">Android 11 系统策略更新</a>》</p>
<h3 id="附加"><a href="#附加" class="headerlink" title="附加"></a>附加</h3><p><a href="https://opendocs.alipay.com/open/54/104509" target="_blank" rel="noopener">支付宝支付客户端 DEMO&amp;SDK下载</a></p>
<p><a href="https://opendocs.alipay.com/open/204/105296" target="_blank" rel="noopener">支付宝支付集成文档</a></p>
<p><a href="https://developers.weixin.qq.com/doc/oplatform/Mobile_App/Access_Guide/Android.html" target="_blank" rel="noopener">微信支付安卓接入指南</a></p>
<p><strong>本文为作者原创转载时请注明出处 谢谢</strong></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em><a href="https://code.newban.cn/">乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</a></em></p>
]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>Window10如何设置只允许某个程序联网</title>
    <url>/328.html</url>
    <content><![CDATA[<h3 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h3><p>最近由于疫情原因不得不远程办公 宿舍有台笔记本 用于连接公司的电脑 由于平常在宿舍不怎么用电脑上网 所以没有装宽带 索性使用手机热点 </p>
<p>考虑到居家办公时长的不确定性 在使用热点上网之前 我打开了win10自带的流量计费功能 </p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20220505180406577.png" alt></p>
<p>这个功能可以限制系统后台程序偷跑流量 从而达到节省流量的目的 </p>
<p>毕竟 流量不便宜 </p>
<p>我已经做好了打持久战的准备</p>
<p>当我愉快的玩耍一会儿后 闲暇之余看了一下流量消耗 差点没让我喷血</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20220505180514353.png" alt></p>
<p>这虚幻居然给我偷跑流量 我明明没有启动这个应用啊 都不知道啥时候跑起来的 想想我远程软件也才用了几十兆流量而已  顿时气不打一处来</p>
<p>看来这个流量计费功能也不太好使呀 第三方应用它管不了 </p>
<p>于是我开始想 能不能只让我这个TeamView联网 而其他应用的禁止联网呢？  为了解决这个问题 我特地百度了一番 经过亲自尝试 最后得出了以下方案:</p>
<p><strong>使用防火墙功能 阻止所有应用程序联网 然后对需要联网的应用开白名单即可</strong></p>
<p>具体步骤如下:</p>
<h3 id="操作步骤"><a href="#操作步骤" class="headerlink" title="操作步骤"></a>操作步骤</h3><h4 id="第一步-开启防火墙功能"><a href="#第一步-开启防火墙功能" class="headerlink" title="第一步  开启防火墙功能"></a>第一步  开启防火墙功能</h4><p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20220505180829771.png" alt></p>
<p>这里 我将专用网络防火墙打开  并且将热点改成专用网络</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20220505181607206.png" alt></p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20220505181300659.png" alt></p>
<h4 id="第二步-阻止所有应用联网"><a href="#第二步-阻止所有应用联网" class="headerlink" title="第二步 阻止所有应用联网"></a>第二步 阻止所有应用联网</h4><p>我们进入防火墙高级设置页面:</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20220505181836588.png" alt></p>
<p>然后进入属性设置, 将专用配置文件选项下的出站连接改为阻止:</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20220505182029775.png" alt></p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20220505182122456.png" alt></p>
<p>这样就实现了阻止所有应用联网的目的 </p>
<h4 id="第三步-对需要联网的应用单独开启白名单"><a href="#第三步-对需要联网的应用单独开启白名单" class="headerlink" title="第三步 对需要联网的应用单独开启白名单"></a>第三步 对需要联网的应用单独开启白名单</h4><p>新建一个出站规则 选择相应的应用程序 并允许联网:</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20220505182502208.png" alt></p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20220505182533260.png" alt></p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20220505182614723.png" alt></p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20220505182709992.png" alt></p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20220505182818106.png" alt></p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20220505182915890.png" alt></p>
<p>点击完成 </p>
<p>此时TeamView可以联网了  而其他的应用则不能联网  </p>
<p>接下来 可以放心大胆的连上热点了  不用担心流量偷跑的问题</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>是教训 也是经验  </p>
<p>当我写完这篇文章时 我的气也基本消了  因为我又收获了一个小经验  没有什么比这个更让我满足的了</p>
<p>希望这个经验能帮助到你</p>
<p><strong>本文为作者原创转载时请注明出处 谢谢</strong></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em><a href="https://code.newban.cn/">乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</a></em></p>
]]></content>
      <tags>
        <tag>Windows</tag>
      </tags>
  </entry>
  <entry>
    <title>Android腾讯IM快速集成流程和注意事项</title>
    <url>/324.html</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>最近项目集成了及时通信业务, 采用的是腾讯IM</p>
<p>首先是SDK的快速集成, 步骤如下:</p>
<h3 id="第一步-安装依赖包"><a href="#第一步-安装依赖包" class="headerlink" title="第一步  安装依赖包"></a>第一步  安装依赖包</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">implementation <span class="string">'com.tencent.imsdk:imsdk-plus:5.6.1200'</span></span><br></pre></td></tr></table></figure>

<h3 id="第二步-初始化SDK-需要用到appid"><a href="#第二步-初始化SDK-需要用到appid" class="headerlink" title="第二步 初始化SDK (需要用到appid)"></a>第二步 初始化SDK (需要用到appid)</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">V2TIMManager.getInstance()</span><br><span class="line">            .initSDK(<span class="keyword">this</span>, <span class="string">"这里填写appid"</span>, V2TIMSDKConfig().apply &#123;</span><br><span class="line">                logLevel = V2TIMSDKConfig.V2TIM_LOG_INFO</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            &#125;, <span class="keyword">object</span> : V2TIMSDKListener() &#123;</span><br><span class="line">                <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onConnecting</span><span class="params">()</span></span> &#123;</span><br><span class="line">                    Log.i(<span class="string">"KIM"</span>, <span class="string">"正在连接到腾讯云服务器"</span>)</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onConnectSuccess</span><span class="params">()</span></span> &#123;</span><br><span class="line">                    Log.i(<span class="string">"KIM"</span>, <span class="string">"已经成功连接到腾讯云服务器"</span>)</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onConnectFailed</span><span class="params">(code: <span class="type">Int</span>, error: <span class="type">String</span>?)</span></span> &#123;</span><br><span class="line">                    Log.i(<span class="string">"KIM"</span>, <span class="string">"连接腾讯云服务器失败 <span class="variable">$code</span>  <span class="variable">$error</span>"</span>)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br></pre></td></tr></table></figure>

<h3 id="第三步-登录IM"><a href="#第三步-登录IM" class="headerlink" title="第三步 登录IM"></a>第三步 登录IM</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">V2TIMManager.getInstance().login(</span><br><span class="line">                <span class="string">"这里填当前用户id"</span>,</span><br><span class="line">                <span class="string">"这里填登录密钥 从后台获取"</span>,<span class="keyword">object</span> : V2TIMCallback &#123;</span><br><span class="line">                    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onSuccess</span><span class="params">()</span></span> &#123;</span><br><span class="line">                        Log.i(TAG, <span class="string">"登录成功"</span>)</span><br><span class="line">             </span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onError</span><span class="params">(code: <span class="type">Int</span>, desc: <span class="type">String</span>?)</span></span> &#123;</span><br><span class="line">                        Log.i(TAG, <span class="string">"登录失败 <span class="variable">$code</span> <span class="variable">$desc</span>"</span>)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br></pre></td></tr></table></figure>

<h3 id="第四步-加入群聊房间-如果是单聊可以跳过该步骤"><a href="#第四步-加入群聊房间-如果是单聊可以跳过该步骤" class="headerlink" title="第四步 加入群聊房间 (如果是单聊可以跳过该步骤)"></a>第四步 加入群聊房间 (如果是单聊可以跳过该步骤)</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">V2TIMManager.getInstance().joinGroup(<span class="string">"这里填房间号 从后台获取"</span>, <span class="string">""</span>, <span class="keyword">object</span> : V2TIMCallback &#123;</span><br><span class="line">            <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onSuccess</span><span class="params">()</span></span> &#123;</span><br><span class="line">                Log.i(TAG, <span class="string">"加入群组成功"</span>)</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onError</span><span class="params">(code: <span class="type">Int</span>, desc: <span class="type">String</span>?)</span></span> &#123;</span><br><span class="line">                Log.i(TAG, <span class="string">"加入群组失败 <span class="variable">$code</span> <span class="variable">$desc</span>"</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br></pre></td></tr></table></figure>

<h3 id="第五步-接收消息"><a href="#第五步-接收消息" class="headerlink" title="第五步 接收消息"></a>第五步 接收消息</h3><p><strong>如果业务不涉及音视频传输:</strong></p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">V2TIMManager.getInstance().addSimpleMsgListener(<span class="keyword">object</span> :</span><br><span class="line">        V2TIMSimpleMsgListener() &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 对应 sendGroupCustomMessage</span></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onRecvGroupCustomMessage</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            msgID: <span class="type">String</span>?,</span></span></span><br><span class="line"><span class="function"><span class="params">            groupID: <span class="type">String</span>?,</span></span></span><br><span class="line"><span class="function"><span class="params">            sender: <span class="type">V2TIMGroupMemberInfo</span>?,</span></span></span><br><span class="line"><span class="function"><span class="params">            customData: <span class="type">ByteArray</span>?</span></span></span><br><span class="line"><span class="function"><span class="params">        )</span></span> &#123;</span><br><span class="line">            <span class="keyword">super</span>.onRecvGroupCustomMessage(msgID, groupID, sender, customData)</span><br><span class="line">   		Log.i(TAG, <span class="string">"接收群聊自定义消息"</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 对应 sendGroupTextMessage</span></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onRecvGroupTextMessage</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            msgID: <span class="type">String</span>?,</span></span></span><br><span class="line"><span class="function"><span class="params">            groupID: <span class="type">String</span>?,</span></span></span><br><span class="line"><span class="function"><span class="params">            sender: <span class="type">V2TIMGroupMemberInfo</span>?,</span></span></span><br><span class="line"><span class="function"><span class="params">            body: <span class="type">String</span>?</span></span></span><br><span class="line"><span class="function"><span class="params">        )</span></span> &#123;</span><br><span class="line"></span><br><span class="line">            Log.i(TAG, <span class="string">"接收群聊文本消息 <span class="variable">$body</span>"</span>)</span><br><span class="line">       </span><br><span class="line">        &#125;</span><br><span class="line">          <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onRecvC2CTextMessage</span><span class="params">(msgID: <span class="type">String</span>?, sender: <span class="type">V2TIMUserInfo</span>?, text: <span class="type">String</span>?)</span></span> &#123;</span><br><span class="line">            <span class="keyword">super</span>.onRecvC2CTextMessage(msgID, sender, text)</span><br><span class="line">         Log.i(TAG, <span class="string">"接收单聊文本消息 <span class="variable">$text</span>"</span>)</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onRecvC2CCustomMessage</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            msgID: <span class="type">String</span>?,</span></span></span><br><span class="line"><span class="function"><span class="params">            sender: <span class="type">V2TIMUserInfo</span>?,</span></span></span><br><span class="line"><span class="function"><span class="params">            customData: <span class="type">ByteArray</span>?</span></span></span><br><span class="line"><span class="function"><span class="params">        )</span></span> &#123;</span><br><span class="line">            <span class="keyword">super</span>.onRecvC2CCustomMessage(msgID, sender, customData)</span><br><span class="line">           Log.i(TAG, <span class="string">"接收单聊自定义消息 "</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">          </span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure>

<p><strong>如果业务涉及音视频传输:</strong></p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">V2TIMManager.getMessageManager().addAdvancedMsgListener( <span class="keyword">object</span> : V2TIMAdvancedMsgListener() &#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onRecvNewMessage</span><span class="params">(msg: <span class="type">V2TIMMessage</span>?)</span></span> &#123;</span><br><span class="line">            Log.i(TAG, <span class="string">"收到消息类型<span class="subst">$&#123;msg?.elemType&#125;</span> "</span>)</span><br><span class="line"> </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure>

<h3 id="第六步-发送消息"><a href="#第六步-发送消息" class="headerlink" title="第六步 发送消息"></a>第六步 发送消息</h3><p><strong>如果业务不涉及音视频传输:</strong></p>
<ol>
<li><p>单聊 (分为文本消息和自定义消息)</p>
<ul>
<li><p>文本消息</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">V2TIMManager.getInstance().sendC2CTextMessage(<span class="string">"这里填需要发送的文本"</span>,</span><br><span class="line">            <span class="string">"这里填对方的登录id"</span>,</span><br><span class="line">            V2TIM_PRIORITY_HIGH,</span><br><span class="line">            <span class="keyword">object</span> : V2TIMValueCallback&lt;V2TIMMessage&gt; &#123;</span><br><span class="line">                <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onSuccess</span><span class="params">(t: <span class="type">V2TIMMessage</span>?)</span></span> &#123;</span><br><span class="line">                    Log.i(TAG, <span class="string">"发送单聊文本消息成功"</span>)</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onError</span><span class="params">(code: <span class="type">Int</span>, desc: <span class="type">String</span>?)</span></span> &#123;</span><br><span class="line">                    Log.i(TAG, <span class="string">"发送单聊文本消息失败 <span class="variable">$code</span> <span class="variable">$desc</span>"</span>)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>自定义消息</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">V2TIMManager.getInstance().sendC2CCustomMessage(<span class="string">"这里填需要发送的自定义消息 格式为字节数组"</span>,</span><br><span class="line">            <span class="string">"这里填对方的登录id"</span>,</span><br><span class="line">            V2TIM_PRIORITY_HIGH,</span><br><span class="line">            <span class="keyword">object</span> : V2TIMValueCallback&lt;V2TIMMessage&gt; &#123;</span><br><span class="line">                <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onSuccess</span><span class="params">(t: <span class="type">V2TIMMessage</span>?)</span></span> &#123;</span><br><span class="line">                    Log.i(TAG, <span class="string">"发送单聊自定义消息成功"</span>)</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onError</span><span class="params">(code: <span class="type">Int</span>, desc: <span class="type">String</span>?)</span></span> &#123;</span><br><span class="line">                    Log.i(TAG, <span class="string">"发送单聊自定义消息失败 <span class="variable">$code</span> <span class="variable">$desc</span>"</span>)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br></pre></td></tr></table></figure>





</li>
</ul>
</li>
</ol>
<ol start="2">
<li><p>群聊 (分为文本消息和自定义消息)</p>
<ul>
<li><p>文本消息</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">V2TIMManager.getInstance().sendGroupTextMessage(<span class="string">"这里填需要发送的文本"</span>,</span><br><span class="line">            <span class="string">"这里填群聊房间id"</span>,</span><br><span class="line">            V2TIM_PRIORITY_HIGH,</span><br><span class="line">            <span class="keyword">object</span> : V2TIMValueCallback&lt;V2TIMMessage&gt; &#123;</span><br><span class="line">                <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onSuccess</span><span class="params">(t: <span class="type">V2TIMMessage</span>?)</span></span> &#123;</span><br><span class="line">                    Log.i(TAG, <span class="string">"发送群文本消息成功"</span>)</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onError</span><span class="params">(code: <span class="type">Int</span>, desc: <span class="type">String</span>?)</span></span> &#123;</span><br><span class="line">                    Log.i(TAG, <span class="string">"发送群文本消息失败 <span class="variable">$code</span> <span class="variable">$desc</span>"</span>)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br></pre></td></tr></table></figure>


</li>
</ul>
</li>
</ol>
<ul>
<li><p>自定义消息</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">V2TIMManager.getInstance().sendGroupCustomMessage(<span class="string">"这里填需要发送的自定义消息 格式为字节数组"</span>,</span><br><span class="line">            <span class="string">"这里填群聊房间id"</span>,</span><br><span class="line">            V2TIM_PRIORITY_HIGH,</span><br><span class="line">            <span class="keyword">object</span> : V2TIMValueCallback&lt;V2TIMMessage&gt; &#123;</span><br><span class="line">                <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onSuccess</span><span class="params">(t: <span class="type">V2TIMMessage</span>?)</span></span> &#123;</span><br><span class="line">                    Log.i(TAG, <span class="string">"发送群自定义消息成功"</span>)</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onError</span><span class="params">(code: <span class="type">Int</span>, desc: <span class="type">String</span>?)</span></span> &#123;</span><br><span class="line">                    Log.i(TAG, <span class="string">"发送群自定义消息失败 <span class="variable">$code</span> <span class="variable">$desc</span>"</span>)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br></pre></td></tr></table></figure>




</li>
</ul>
<p><strong>如果业务涉及音视频传输:</strong></p>
<p>该方法支持音视频图片 文本和自定义消息</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">V2TIMManager.getMessageManager().sendMessage()</span><br></pre></td></tr></table></figure>

<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p>这里的坑主要在于消息的收发, 官方给的API比较多, 单聊和群聊串在一块, 看文档有时容易懵, 这里对收发消息的使用做了一个总结, 如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">* IM群聊和单聊的消息收发走的是同一套  总共分为两种需求:</span><br><span class="line">* 第一种: 不涉及音视频 只涉及字符串传输 那么监听消息使用addSimpleMsgListener 发消息使用sendC2C(Group)TextMessage和sendC2C(Group)CustomMessage</span><br><span class="line">* 第二种: 涉及音视频等复杂消息传递 那么监听消息使用addAdvancedMsgListener 发消息使用V2TIMManager.getMessageManager().sendMessage()</span><br><span class="line">*</span><br><span class="line">* 注意: setGroupListener不是监听的群聊消息 而是对群组相关的事件监听 比如群创建通知 公告等等</span><br></pre></td></tr></table></figure>

<h3 id="附加"><a href="#附加" class="headerlink" title="附加"></a>附加</h3><p><a href="https://cloud.tencent.com/document/product/269/44498" target="_blank" rel="noopener">腾讯IM集成文档</a></p>
<p><strong>本文为作者原创转载时请注明出处 谢谢</strong></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em><a href="https://code.newban.cn/">乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</a></em></p>
]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>Windows平台下cmd常用命令</title>
    <url>/329.html</url>
    <content><![CDATA[<h3 id="常用命令如下"><a href="#常用命令如下" class="headerlink" title="常用命令如下"></a>常用命令如下</h3><ol>
<li><p>进入某个盘符</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">盘符名:</span><br></pre></td></tr></table></figure>
</li>
<li><p>打开文件夹</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd 文件夹名</span><br></pre></td></tr></table></figure>
</li>
<li><p>回退到上一层目录</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd ..</span><br></pre></td></tr></table></figure>
</li>
<li><p>进入根目录</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd\</span><br></pre></td></tr></table></figure>
</li>
<li><p>列出当前目录下所有文件夹(不含隐藏文件夹)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dir</span><br></pre></td></tr></table></figure>
</li>
<li><p>列出当前目录下所有文件夹(包含隐藏文件夹)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dir  /A:H</span><br></pre></td></tr></table></figure>
</li>
<li><p>列出当前目录下所有文件夹和文件(包含隐藏文件夹)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dir /A *</span><br></pre></td></tr></table></figure>
</li>
<li><p>移动文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">move 需要移动的文件或文件夹名 目标文件夹名</span><br></pre></td></tr></table></figure>
</li>
<li><p>拷贝当前目录下所有文件到D盘</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">copy * &quot;d:\&quot;</span><br></pre></td></tr></table></figure>
</li>
<li><p>更改文件属性 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">attrib 文件名 -H </span><br><span class="line">attrib 文件名 +H </span><br><span class="line">attrib 文件名 -A </span><br><span class="line">attrib 文件名 +A </span><br><span class="line">attrib 文件名 -R </span><br><span class="line">attrib 文件名 +R </span><br><span class="line">attrib 文件名 -S </span><br><span class="line">attrib 文件名 +S</span><br></pre></td></tr></table></figure>

<p><strong>注释:</strong></p>
<ul>
<li>H: 表示隐藏属性</li>
<li>A: 表示存档属性</li>
<li>R: 表示只读属性</li>
<li>S: 表示系统属性</li>
</ul>
<p>加号表示添加 减号表示移除</p>
</li>
</ol>
<p><strong>本文为作者原创转载时请注明出处 谢谢</strong></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em><a href="https://code.newban.cn/">乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</a></em></p>
]]></content>
      <tags>
        <tag>Windows</tag>
      </tags>
  </entry>
  <entry>
    <title>说说移动设备的各种标识码（DeviceID, IMEI, UUID, UDID, OAID, IDFA, GAID</title>
    <url>/326.html</url>
    <content><![CDATA[<h3 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h3><ul>
<li><p><strong>Device ID</strong>：设备ID。</p>
</li>
<li><p><strong>IMEI</strong>：（International Mobile Equipment Identity）国际移动设备标识的缩写。是由15位数字组成的“电子串号”，它与每台手机一一对应，每个IMEI在世界上都是唯一的。</p>
</li>
<li><p><strong>MEID</strong>：(Mobile Equipment Identifier) 移动设备识别码是CDMA手机的身份识别码，也是每台CDMA手机或通讯平板唯一的识别码。</p>
</li>
<li><p><strong>IDFA</strong>：（Identifier For Advertising）iOS独有的广告标识符。</p>
</li>
<li><p><strong>UDID</strong>：（Unique Device Identifier）唯一设备标识码。</p>
</li>
<li><p><strong>UUID</strong>：（Universally Unique Identifier）通用唯一识别码。目前最广泛应用的UUID，是微软公司的全局唯一标识符GUID。其目的是让分布式系统中的所有元素，都能有唯一的辨识信息，而不需要通过中央控制端来做辨识信息的指定。</p>
</li>
<li><p><strong>OAID</strong>：(Open Anonymous Device Identifier) 开放匿名设备标识符。</p>
</li>
<li><p><strong>GAID</strong>：Google Advertising ID。</p>
</li>
</ul>
<h3 id="详细介绍"><a href="#详细介绍" class="headerlink" title="详细介绍"></a>详细介绍</h3><p><strong>（1）Device ID</strong></p>
<p>设备ID，具有唯一性。其中又包括IMEI 和 MEID/ESN。一般情况我们获取手机的DeviceId也就是手机的IMEI码。</p>
<p><strong>（2）IMEI</strong></p>
<p>GSM设备返回的，并且是写在主板上的，重装APP不会改变IMEI。</p>
<p>Android：Android 6.0以上系统需要用户授予read_phone_state权限（弹窗授权），如果用户拒绝就无法获得。但是Andorid Q（10.0）版本，将无法获取IMEI，出于用户隐私等一系列安全问题的考虑。将用其他匿名标识符代替，比如OAID。</p>
<p>IOS：iOS 5 之后被禁止。</p>
<p>IMEI是联通、移动手机的标识，MEID是电信手机的标识。</p>
<p>IMEI可以在在移动设备上查询到，一般来说一个双卡手机不止一个IMEI值，全网通双卡手机有两个IMEI和一个MEID。</p>
<p><strong>（3）MEID</strong></p>
<p>在手机键盘直接键入*#06#可获得。</p>
<p>MEID/ESN：CDMA设备返回的，一般不使用。</p>
<p><strong>（4）mac地址</strong></p>
<p>硬件标识符，包括WiFi mac地址和蓝牙mac地址。</p>
<p>Android：Android 6.0之后被禁止，若获取则会被判定为有害应用。</p>
<p>IOS：iOS 7 之后被禁止（同时禁止的还有OpenUDID）。</p>
<p><strong>（5）UDID</strong></p>
<p>用来标示设备的唯一性，由40个字符的字母和数字组成 。</p>
<p>Android：获取UUID后，写入.so文件生成UDID。即使APP重装，值也不变，除非root手机（普通用户做不到）。</p>
<p>IOS：iOS 6 之后被禁止获取系统原生的UDID，但可以通过uuid，写入到钥匙串中，从而获得自定义的UDID（非系统原生），即使用户重装APP，只要每次都取这个钥匙串返回，就是不变的。</p>
<p>OpenUDID：是一个替代 UDID 的第三发解决方案。缺点是如果你完全删除全部带有 OpenUDID SDK 包的 App（比如恢复系统等），那么 OpenUDID 会重新生成，而且和之前的值会不同，相当于新设备。</p>
<p><strong>（6）UUID</strong></p>
<p>APP重装后会改变。</p>
<p><strong>（7）IDFA</strong></p>
<p>IDFA 是苹果 iOS 6 开始新增的广告标识符，用于给开发者跟踪广告效果用的，可以简单理解为 iPhone 的设备临时身份证，说是临时身份证是因为它允许用户更换，IDFA 存储在用户 iOS 系统上，同一设备上的应用获取到的 IDFA 是相同的。iOS 用户可以通过（设置程序 -&gt; 通用 -&gt; 还原 -&gt; 还原位置与隐私）更换 IDFA，iOS 10 系统开始提供禁止广告跟踪功能，用户勾选这个功能后，应用程序将无法读取到设备的 IDFA。（在统计唯一用户的时候，IDFA 的可变性会造成部分用户的重复统计。）</p>
<p>适用于对外：例如广告推广，换量等跨应用的用户追踪等。</p>
<p>总结：iOS 6 时面世，可以监控广告效果，同时保证用户设备不被APP追踪的折中方案。可能发生变化，如系统重置、在设置里还原广告标识符。用户可以在设置里打开“限制广告跟踪”。</p>
<p><strong>（8）OAID</strong></p>
<p>APP类广告效果追踪需要使用到用户的设备标识进行广告点击和转化效果的匹配，而安卓系统当前强依赖于IMEI的获取，上面提到Andorid Q（10.0）版本后，将无法获取IMEI。基于此背景，进行广告投放的效果追踪，需要能够替代及补充IMEI的设备标识。</p>
<p>目前OAID作为目前市场主流的归因补充标识，OAID是由中国信息通讯研究院号召，移动安全联盟推行的安卓设备标识，在无法获取设备号情况下可以使用该标识进行数据匹配，目前主流厂商均已在新版本系统中支持该标识的获取，具有权威性。OAID可以理解为是国内联合推出的广告标识。</p>
<p>与IDFA类似，对于OAID 用户也可以手动在设置中通过重置广告标识符更换OAID或者“限制广告跟踪”。</p>
<p>与OAID相关的设备标识体系中拥有四种设备标识：</p>
<p><strong>（9）GAID</strong></p>
<p>Google推出的广告标识，与IDFA类似。在装了google play service的安卓手机上，才可以获取到GAID。</p>
<p>广告id是用户特殊的，独特的，可重置的广告id，由Google Play Service 提供，它为用户更好的控制，为开发人员提供简单、标准的系统继续使用你的应用程序，它用于广告目的的匿名标示符和或者重置其标示符或者退出以利益为基础的Google Play的应用程序。</p>
<p>主要用于广告定向，并且和IDFA一样 对于GAID 用户也可以自己设置禁止广告跟踪。</p>
<p>整理，借鉴了多个地方的资料，有不准确的欢迎指出！</p>
<h2 id="用户唯一标识"><a href="#用户唯一标识" class="headerlink" title="用户唯一标识"></a>用户唯一标识</h2><h3 id="为什么要建设用户唯一标识"><a href="#为什么要建设用户唯一标识" class="headerlink" title="为什么要建设用户唯一标识"></a>为什么要建设用户唯一标识</h3><p>如何区分某个用户就是他这个用户，而不是另一个用户，在数据埋点中，是一个非常重要的事情。因为如果做不到用户的唯一识别，那凡是涉及到用户的数据都将是错的（比如用户量、新增用户数、活跃用户数等等）。所以建设用户唯一标识，尤为重要。</p>
<h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>设计埋点字段的时候，有两个字段是一定要包括的，即<strong>设备ID和用户ID</strong>。这两个字段应该纳入通用字段，每个埋点的事件都必须要集成收集。</p>
<p><strong>（1）设备ID</strong></p>
<p>使用相应的算法，生成一个设备ID，以唯一识别用户的终端设备。不同终端的设备ID，其生成算法规则不一样，以下列举不同终端的设备ID的生成规则：</p>
<p><strong>AndroidApp</strong></p>
<p>安卓系统历经多次升级，对权限控制越来越严格，唯一识别手机的方法也在发生变化。下面整理一下安卓系统适合做设备唯一标识符的几个标识符，以及其特性：</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/v2-bdfd76a24b27bacfa59a775788289cb8_1440w.jpg" alt="img"></p>
<p>从表格中看出，IMEI是最适合做设备唯一标识的，奈何获取IMEI需要授予权限且Android 10以后不再开放IMEI的权限。综合起来，安卓系统中，应该按照<strong>IMEI -&gt;OAID -&gt; ANDROID_ID</strong>的顺序生成设备ID。即先获取IMEI号，获取不到IMEI时获取OAID，获取不到OAID时，再获取ANDROID_ID，然后使用相关算法生成设备ID。</p>
<p><strong>IOS App</strong></p>
<p>苹果系统，可用于识别唯一设备的标识不多，如下图。综合起来，苹果系统生成设备ID的标识符顺序应该是<strong>IDFA -&gt; IDFV -&gt;UDID</strong>，即先获取IDFA，获取不到在获取IDFV，获取不到IDFV时，再获取UDID，然后使用相关算法生成一个设备ID。</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/v2-c40480adcc3be9c92803c2be424f3216_1440w.jpg" alt="img"></p>
<p><strong>Web网站</strong></p>
<p>Web网站，使用cookie_id作为设备ID，并存储在浏览器的cookie中。</p>
<p><strong>微信小程序</strong></p>
<p>通常做法使用openid作为设备ID，当然也可以自己生产一个ID，作为设备ID。如果用过openid作为设备ID，需要注意微信小程序的冷启动问题（<strong>获取 openid 是一个异步的操作，所以会导致数据上报的时候，可能还没获取到openid，这就是导致设备ID为空</strong>）。</p>
<p><strong>2）用户ID</strong></p>
<p>用户ID，即用户在业务产品注册的用户账号。</p>
<p>收集到设备ID和用户ID后，就要想办法将设备ID和用户ID关联起来，也即用户唯一标识建模，详见下文。</p>
<h2 id="用户唯一标识建设"><a href="#用户唯一标识建设" class="headerlink" title="用户唯一标识建设"></a>用户唯一标识建设</h2><p>设计一个字段，比如就叫<strong>distinct_id</strong>（设备ID命名为device_id，用户ID命名为user_id）这个字段用于识别唯一用户。凡是统计用户相关的数据时，都以<strong>distinct_id</strong>作为用户的唯一区别标识。下面，以具体案例进行阐述。</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/v2-d563301707deda4e26447ead14f2ffe8_1440w.jpg" alt="img"></p>
<p><strong>步骤说明：</strong></p>
<ol>
<li>小明在一部手机上启动了app。该手机的device_id为x1，此时生成一个dsitinct_id为d1；</li>
<li>小明在这个手机上用账号u1进行登录。此时device_id为x1，user_id为u1，dsitinct_id为d1；</li>
<li>小明继续在这手机上使用app。此时device_id为x1，user_id为u1，dsitinct_id为d1；</li>
<li>小明退出自己的账号，继续使用app。此时仍然device_id为x1，user_id为u1，dsitinct_id为d1；</li>
<li>小明把手机给了小花，小花用自己的账号u2登录app。此时u2去关联x1，因为x1已经与u1关联，故关联失败。所以重新生成一个distinct_id为d2来标识此用户（u2）；</li>
<li>小花继续使用app。此时device_id为x1，user_id为u2，dsitinct_id为d2；</li>
<li>小明换了部新手机，使用app。此时device_id为一个新的x2，后台生成一个新的dsitinct_id为d3；</li>
<li>小明在新手机上，使用账号u1登录了app。此时u1去关联x2，因为x2之前没有与账号关联过，所以关联成功，但是u1已经有一个dsitinct_id为d1，所以此时的dsitinct_id仍然为d1；</li>
<li>小明继续在新手机上使用app。此时device_id为x2，user_id为u1，dsitinct_id为d1。</li>
</ol>
<p><strong>此时三个字段的映射关系为：</strong></p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/v2-3be07ad5528d0c9da5b5660ae163bc64_1440w.jpg" alt="img"></p>
<p><strong>（1）后续修复</strong></p>
<p><strong>事件字段修复</strong></p>
<p>小明换新手机后，在登录前，系统给分配的dsitinct_id为d3，不符合实际情况，故要将在新手机上登录前的dsitinct_id修复为d1。如下：</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/v2-144aa57bb74452d0e5f619bb9722c364_1440w.jpg" alt="img"></p>
<p><strong>映射表修复</strong></p>
<p>1）删除d3与x2的映射关系</p>
<p>2）将x2添加到d1的device_id_list字段</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/v2-17b54bc2d25400c36551bea6b695d04c_1440w.jpg" alt="img"></p>
<p><strong>本文转载自:</strong> <a href="https://zhuanlan.zhihu.com/p/395387972" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/395387972</a> </p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em><a href="https://code.newban.cn/">乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</a></em></p>
]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>关于Git查看提交修改的文件列表</title>
    <url>/327.html</url>
    <content><![CDATA[<h4 id="1-查看最后一次提交记录的修改文件信息"><a href="#1-查看最后一次提交记录的修改文件信息" class="headerlink" title="1.查看最后一次提交记录的修改文件信息"></a>1.查看最后一次提交记录的修改文件信息</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git show --raw</span><br></pre></td></tr></table></figure>

<h4 id="2-查看指定commit-id对应修改文件列表"><a href="#2-查看指定commit-id对应修改文件列表" class="headerlink" title="2.查看指定commit id对应修改文件列表"></a>2.查看指定commit id对应修改文件列表</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git show --raw commit_id</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git show --raw 2f80f1c8bb2cb8e91d22ad38480b681c194f6518</span><br></pre></td></tr></table></figure>

<h4 id="3-查看所有提交记录的修改文件信息"><a href="#3-查看所有提交记录的修改文件信息" class="headerlink" title="3.查看所有提交记录的修改文件信息"></a>3.查看所有提交记录的修改文件信息</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git log --stat</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git log --name-only</span><br></pre></td></tr></table></figure>

<h4 id="4-查看所有修改相关的commit-ID和comment信息"><a href="#4-查看所有修改相关的commit-ID和comment信息" class="headerlink" title="4.查看所有修改相关的commit ID和comment信息"></a>4.查看所有修改相关的commit ID和comment信息</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git log --pretty=oneline</span><br></pre></td></tr></table></figure>

<h4 id="5-查询指定author的修改信息"><a href="#5-查询指定author的修改信息" class="headerlink" title="5.查询指定author的修改信息"></a>5.查询指定author的修改信息</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git log --author=jack.li</span><br></pre></td></tr></table></figure>

<h4 id="6-查看指定author在指定时间修改信息"><a href="#6-查看指定author在指定时间修改信息" class="headerlink" title="6.查看指定author在指定时间修改信息"></a>6.查看指定author在指定时间修改信息</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git log --pretty=&quot;%h - %s&quot; --author=&apos;Junio C Hamano&apos; --since=&quot;2008-10-01&quot; \</span><br><span class="line">   --before=&quot;2008-11-01&quot; --no-merges -- t/</span><br><span class="line">5610e3b - Fix testcase failure when extended attributes are in use</span><br><span class="line">acd3b9e - Enhance hold_lock_file_for_&#123;update,append&#125;() API</span><br><span class="line">f563754 - demonstrate breakage of detached checkout with symbolic link HEAD</span><br><span class="line">d1a43f2 - reset --hard/read-tree --reset -u: remove unmerged new paths</span><br><span class="line">51a94af - Fix &quot;checkout --track -b newbranch&quot; on detached HEAD</span><br><span class="line">b0ad11e - pull: allow &quot;git pull origin $something:$current_branch&quot; into an unborn branch</span><br></pre></td></tr></table></figure>

<p><strong>本文为作者原创转载时请注明出处 谢谢</strong></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em><a href="https://code.newban.cn/">乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</a></em></p>
]]></content>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>从found.000中恢复数据 某个文件夹突然不见了</title>
    <url>/331.html</url>
    <content><![CDATA[<h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><ul>
<li>本文是问题解决后编写的，解决顺序已经尽力按照我记得的编写。希望能给遇到此问题的朋友一份参考。</li>
<li>因涉及数据此等重要性的东西，建议还是看完全文再操作。在理解了我的解决思路之后，并且觉得我的方案有用方可尝试。切勿在你解决无望的时候，看到本文以为是发现新大陆，然后盲目操作导致数据丢失得不偿失！（因为我搜索过关于<code>found.000</code>的相关，有些人说用数据恢复软件，有些人说这个文件恢复不了，还有人提问该文件夹能不能删除诸如此类）</li>
<li>但是你还是想尝试，可以尝试复制一份<code>found.000</code>出来，在别的盘上或者电脑上对该文件夹进行操作。（切勿在源路径操作，方便你实在不行的情况下拿去维修）或者你对自己非常有信心，就在源路径下操作吧（因为我也不知道复制出来能不能恢复😂）。</li>
<li>本文更多的是提供思路，实际操作需要的一些诸如命令行操作，文件夹提权等需要大家自行百度。<h3 id="问题说明（此时我的电脑上是没有found-000这个文件的）"><a href="#问题说明（此时我的电脑上是没有found-000这个文件的）" class="headerlink" title="问题说明（此时我的电脑上是没有found.000这个文件的）"></a>问题说明（此时我的电脑上是没有found.000这个文件的）</h3>某天我的D盘下的“资料”文件夹突然不见了。<br>当时我的思路是：</li>
</ul>
<ol>
<li><p>该文件夹被病毒隐藏了？</p>
</li>
<li><p>我之前误删了？</p>
</li>
</ol>
<h4 id="初步解决方案"><a href="#初步解决方案" class="headerlink" title="初步解决方案"></a>初步解决方案</h4><p>通过问题排查（查看隐藏文件+受保护的文件），发现思路1是错误的。</p>
<p>那接下来就是怎么验证误删？因为该文件夹比较大，删除的情况下会提示放入不了回收站，要直接删除吗？所以回收站没有我的删除记录。然后思路2的解决方法是进PE使用数据恢复软件（如：Recuva，金山数据恢复）查看有没有相关痕迹，结果发现没有“资料“文件夹被删除的相关痕迹（着急解决问题，没想到截图）。（进不进PE没多大关系，但可能是因为我进PE恢复数据导致重启电脑的时候进行磁盘检查，然后我的电脑上才有<code>found.000</code>）</p>
<p>经过以上的方案，还是不行之后。我剩下的思路只有装杀软看看。但是，我没有装，因为接下来的操作我也是第一次遇到。</p>
<p>无意中，我使用 <code>everything</code> 软件进行搜索”资料”的时候，通过搜索结果看到我的文件还是存在的。忘记截图了，但我记得结果是xxx资料 <code>D:\资料\xxx</code>。当时我看到我的文件夹存在的时候很开心，马上右键打开所在路径，结果提示：请检查你的路径，没有该路径之类的话。（当时我一脸懵圈。<code>everything</code>可以搜索到，难道是<code>everything</code>之前的索引还存在？这个结果只是一个假象？）</p>
<ul>
<li><code>everything</code>的结果说明了什么？（我此时相信我的文件夹还是存在的）说明了我的文件夹还是存在的。没有被数据恢复软件没有检索到是因为我的文件夹根本没有被删除啊。但是不知道为什么就是看不到它了（注意，此时并不是隐藏，因为常规的查看隐藏文件方式已经不起作用了，我的理解是，因为某个原因，系统对”资料“这个文件夹的索引没有了）<h4 id="可行的解决方案"><a href="#可行的解决方案" class="headerlink" title="可行的解决方案"></a>可行的解决方案</h4></li>
<li><em>step1: 确保你的硬盘里有found.000*</em><br>因为我成功解决问题的基础是有这个文件。所以只需要在重启的时候进行磁盘检查，让系统重新找回对这个文件夹的索引。（如果你的电脑此时有这个文件跳过这一步）</li>
</ul>
<p><strong>step2: 存在 found.000后</strong><br>使用<code>everything</code> 搜索一下丢失文件夹的关键字。如下：可以看到我的资料都在这个文件夹下。</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE4OTc0MTE=,size_16,color_FFFFFF,t_70.png" alt="在这里插入图片描述"></p>
<p><strong>step3: 进入文件夹</strong></p>
<p>于是我马上右键打开所在路径，我的天！进来了。我试了一下打开 <code>pdf</code> ，是可以打开的。我马上复制一份到别的盘打开，是可以打开的！于是我慢慢一步一步点上一级路径跳转，是可以访问的。可是当我点击<code>dir0001.chk</code>之后提示错误了。（具体提示的错误我忘记了）</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE4OTc0MTE=,size_16,color_FFFFFF,t_70-20220701114831592.png" alt="在这里插入图片描述"></p>
<p><strong>step4: 从文件浏览器进入found.000</strong></p>
<p>因为<code>step3</code>: 倒着进不了上一级路径。此时我想能不能正着进入该路径，于是我从文件夹点进去，提示权限不足，此时对文件夹提权就好了。</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE4OTc0MTE=,size_16,color_FFFFFF,t_70-20220701114845374.png" alt="在这里插入图片描述"></p>
<p>进入后，发现如下：（写下此文的时候我已经忘记相关弹窗提示，但是我记得我第一次提权进入该文件夹的时候没有这么多东西的，我是进行了<code>step5</code>才看到下图如此完整的文件夹）</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE4OTc0MTE=,size_16,color_FFFFFF,t_70-20220701114857321.png" alt="在这里插入图片描述"></p>
<p><strong>step5: 从bash进入dir0001.chk</strong></p>
<p>在<code>step4</code>我说明了我第一次进入<code>found.000</code>文件夹是没有什么东西的。于是我的思路是：无论如何都要进入<code>单片机</code>的上一级目录（我原本保存的路径就是<code>D:\资料\单片机</code>），所以虽然不能进入<code>found.000</code>，但是只要我进入”单片机“上一级目录就可以对我之前的数据全部复制保存。</p>
<ul>
<li><p>怎么操作？很简单，当时我想到的是从命令行看能不能进入，于是有下图：</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE4OTc0MTE=,size_16,color_FFFFFF,t_70-20220701114917729.png" alt="在这里插入图片描述"></p>
</li>
</ul>
<p>奇怪的是，我从命令行进入<code>单片机</code>的上一级目录之后，我就可以正着进<code>found.000</code>文件夹，并且还能看到比较多的文件夹了。才有了<code>step4</code>的第二张截图。然后也有了下面的截图。</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE4OTc0MTE=,size_16,color_FFFFFF,t_70-20220701114927261.png" alt="在这里插入图片描述"></p>
<p>经过我的发现，之前的数据并不是全都在<code>dir0001.chk</code>中，在<code>found000</code>文件下的其他<code>dirxxxx.chk</code>都保存了我之前的资料。大家不放心每个文件夹都点开看看吧！</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol>
<li>想办法让电脑中存在 <code>found.000</code>（通过重启后进行磁盘检查）</li>
<li>想办法进入<code>found.000</code>（通过命令行，必要时结合 <code>everything</code>）</li>
<li>事后我想，是不是一开始就可以通过 命令行 进入该文件夹了？即使不能正着进去，我也可以通过 everything 打开所在路径之后再通过命令行进入，然后通过<code>cp</code>命令直接复制到别的盘保存。</li>
<li>同时，我成功恢复数据感觉也是很多的机缘巧合，比如，如果我不进PE恢复数据，是不是就没有磁盘检查了，也就没有生成<code>found.000</code>，我可能就还不能解决此问题了！</li>
</ol>
<p><strong>本文转载自</strong>: <a href="https://blog.csdn.net/u011897411/article/details/106879852" target="_blank" rel="noopener">https://blog.csdn.net/u011897411/article/details/106879852</a></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt> </p>
<p><em><a href="https://code.newban.cn/">乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</a></em></p>
]]></content>
      <tags>
        <tag>移动硬盘</tag>
      </tags>
  </entry>
  <entry>
    <title>记录关于移动硬盘文件丢失的找回过程</title>
    <url>/330.html</url>
    <content><![CDATA[<h3 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h3><p>由于居家办公需要, 经常使用移动硬盘来回在公司和宿舍之间进行大文件拷贝, 某一天突然发现硬盘中的文件夹消失不见, 而空间占用依然存在</p>
<p>难道是文件被隐藏了?  检查一番之后发现不是</p>
<p>当时我就慌了 因为消失的都是重要文件, 于是赶紧百度</p>
<p><strong>搜索一阵之后, 我推测可能是不同系统兼容性错误导致的磁盘坏道</strong></p>
<p>因为公司的电脑是Mac系统 宿舍的电脑是Windows系统, 而我的硬盘格式是NTFS, Mac本身是不兼容该格式的, 加上我使用了<code>Omi NTFS</code>这个工具进行桥接中转 硬盘出现点问题 似乎是情理之中</p>
<p>既然发现了问题所在, 那就需要解决 尽可能地将文件恢复回来</p>
<p><strong>而我第一时间想到的便是进行磁盘修复, 当我在Windows平台中对硬盘进行修复之后, 丢失的文件夹确实出现了 但是却变成了一个未知文件 无法打开</strong></p>
<p>这就有点坑了</p>
<p>无奈之下我停止了对该硬盘进行文件写入操作, 免得操作频繁导致后期无法恢复</p>
<p>于是将该硬盘放置了一段时间, 直到有一天我需要从硬盘中未被破坏的文件夹里面找寻一些资料, 顺带使用了<code>everything</code>软件检索, 突然获得了意外惊喜, <code>everything</code>检索到了丢失文件夹中的资料</p>
<p>这意味着文件依然存在于移动硬盘中, 可能是被迁移到了某个隐藏文件中</p>
<p><strong>我利用<code>everything</code>找到了丢失文件所在目录, 名为<code>found.000</code></strong></p>
<p>这个<code>found.000</code>目录是隐藏目录, 即便开启显示隐藏文件夹功能也是看不到的, 而且这个目录需要管理员权限才能对里面的文件进行拷贝移动操作</p>
<p>既然目录找到了 那么恢复文件就不难了</p>
<h4 id="操作步骤"><a href="#操作步骤" class="headerlink" title="操作步骤"></a>操作步骤</h4><ol>
<li><p>打开管理员<code>cmd</code>窗口, 进入到<code>found.000</code>目录</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">F:    //进入移动硬盘盘符</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd found.000   //打开隐藏文件</span><br></pre></td></tr></table></figure>
</li>
<li><p>列出当前目录下所有文件夹和文件(包含隐藏文件夹)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dir /A *</span><br></pre></td></tr></table></figure>
</li>
<li><p>移动文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">move 需要移动的文件或文件夹名 目标文件夹名</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>被恢复的目录中可能会存在一些隐藏目录, 为了确保所有文件都恢复, 需要仔细检查</p>
<p>网上有位小伙伴也碰到了和我类似的问题, 大家有兴趣的可以参考一番:</p>
<p>《<a href="https://code.newban.cn/331.html">【问题记录】从found.000中恢复数据（某个文件夹突然不见了）</a>》</p>
<p><strong>本文为作者原创转载时请注明出处 谢谢</strong></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em><a href="https://code.newban.cn/">乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</a></em></p>
]]></content>
      <tags>
        <tag>移动硬盘</tag>
      </tags>
  </entry>
  <entry>
    <title>idea最新激活码</title>
    <url>/33.html</url>
    <content><![CDATA[<h4 id="第一个激活码"><a href="#第一个激活码" class="headerlink" title="第一个激活码"></a>第一个激活码</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">7PNLXJPODN-eyJsaWNlbnNlSWQiOiI3UE5MWEpQT0ROIiwibGljZW5zZWVOYW1lIjoi6aOe6LGhIOeggeWGnCIsImFzc2lnbmVlTmFtZSI6IiIsImFzc2lnbmVlRW1haWwiOiIiLCJsaWNlbnNlUmVzdHJpY3Rpb24iOiIiLCJjaGVja0NvbmN1cnJlbnRVc2UiOmZhbHNlLCJwcm9kdWN0cyI6W3siY29kZSI6IklJIiwiZmFsbGJhY2tEYXRlIjoiMjAyMC0wMS0xNSIsInBhaWRVcFRvIjoiMjAyMS0wMS0xNCJ9LHsiY29kZSI6IkFDIiwiZmFsbGJhY2tEYXRlIjoiMjAyMC0wMS0xNSIsInBhaWRVcFRvIjoiMjAyMS0wMS0xNCJ9LHsiY29kZSI6IkRQTiIsImZhbGxiYWNrRGF0ZSI6IjIwMjAtMDEtMTUiLCJwYWlkVXBUbyI6IjIwMjEtMDEtMTQifSx7ImNvZGUiOiJQUyIsImZhbGxiYWNrRGF0ZSI6IjIwMjAtMDEtMTUiLCJwYWlkVXBUbyI6IjIwMjEtMDEtMTQifSx7ImNvZGUiOiJHTyIsImZhbGxiYWNrRGF0ZSI6IjIwMjAtMDEtMTUiLCJwYWlkVXBUbyI6IjIwMjEtMDEtMTQifSx7ImNvZGUiOiJETSIsImZhbGxiYWNrRGF0ZSI6IjIwMjAtMDEtMTUiLCJwYWlkVXBUbyI6IjIwMjEtMDEtMTQifSx7ImNvZGUiOiJDTCIsImZhbGxiYWNrRGF0ZSI6IjIwMjAtMDEtMTUiLCJwYWlkVXBUbyI6IjIwMjEtMDEtMTQifSx7ImNvZGUiOiJSUzAiLCJmYWxsYmFja0RhdGUiOiIyMDIwLTAxLTE1IiwicGFpZFVwVG8iOiIyMDIxLTAxLTE0In0seyJjb2RlIjoiUkMiLCJmYWxsYmFja0RhdGUiOiIyMDIwLTAxLTE1IiwicGFpZFVwVG8iOiIyMDIxLTAxLTE0In0seyJjb2RlIjoiUkQiLCJmYWxsYmFja0RhdGUiOiIyMDIwLTAxLTE1IiwicGFpZFVwVG8iOiIyMDIxLTAxLTE0In0seyJjb2RlIjoiUEMiLCJmYWxsYmFja0RhdGUiOiIyMDIwLTAxLTE1IiwicGFpZFVwVG8iOiIyMDIxLTAxLTE0In0seyJjb2RlIjoiUk0iLCJmYWxsYmFja0RhdGUiOiIyMDIwLTAxLTE1IiwicGFpZFVwVG8iOiIyMDIxLTAxLTE0In0seyJjb2RlIjoiV1MiLCJmYWxsYmFja0RhdGUiOiIyMDIwLTAxLTE1IiwicGFpZFVwVG8iOiIyMDIxLTAxLTE0In0seyJjb2RlIjoiREIiLCJmYWxsYmFja0RhdGUiOiIyMDIwLTAxLTE1IiwicGFpZFVwVG8iOiIyMDIxLTAxLTE0In0seyJjb2RlIjoiREMiLCJmYWxsYmFja0RhdGUiOiIyMDIwLTAxLTE1IiwicGFpZFVwVG8iOiIyMDIxLTAxLTE0In0seyJjb2RlIjoiUlNVIiwiZmFsbGJhY2tEYXRlIjoiMjAyMC0wMS0xNSIsInBhaWRVcFRvIjoiMjAyMS0wMS0xNCJ9XSwiaGFzaCI6IjE2MjYyNDE0LzAiLCJncmFjZVBlcmlvZERheXMiOjcsImF1dG9Qcm9sb25nYXRlZCI6ZmFsc2UsImlzQXV0b1Byb2xvbmdhdGVkIjpmYWxzZX0=-PPKBrTimCndddUn6boFzGrhkBW8JU7D4lQuuOxKq4rdA4U3IQix9gM+8UYYUaJCQMg8zPmE42QPSkSWneE5VAShaAwhfdu5/D2KbG9jv2uoy8deXu4YWYRHRmn6TdU1/fBhOsbI4EbqYoRDjQ6R+ibYQBanurdcdySH8wDx2kiEBOEbbHJ9ekkGG4YZysbxWVdnFDX3+s+3IanmZKqK/Lih/+XGK5rwp1QGr3+fFX6yAuI5gK78BOajkkEAq6RR9lzvaMDGt7t5wpYxSnEzN9UgkIhdf1zpg/OG1CB4hRsrQU9IG39r2W2IxqHXdipGkPDag+4MTEkwMuofgXFF9NQ==-MIIElTCCAn2gAwIBAgIBCTANBgkqhkiG9w0BAQsFADAYMRYwFAYDVQQDDA1KZXRQcm9maWxlIENBMB4XDTE4MTEwMTEyMjk0NloXDTIwMTEwMjEyMjk0NlowaDELMAkGA1UEBhMCQ1oxDjAMBgNVBAgMBU51c2xlMQ8wDQYDVQQHDAZQcmFndWUxGTAXBgNVBAoMEEpldEJyYWlucyBzLnIuby4xHTAbBgNVBAMMFHByb2QzeS1mcm9tLTIwMTgxMTAxMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAxcQkq+zdxlR2mmRYBPzGbUNdMN6OaXiXzxIWtMEkrJMO/5oUfQJbLLuMSMK0QHFmaI37WShyxZcfRCidwXjot4zmNBKnlyHodDij/78TmVqFl8nOeD5+07B8VEaIu7c3E1N+e1doC6wht4I4+IEmtsPAdoaj5WCQVQbrI8KeT8M9VcBIWX7fD0fhexfg3ZRt0xqwMcXGNp3DdJHiO0rCdU+Itv7EmtnSVq9jBG1usMSFvMowR25mju2JcPFp1+I4ZI+FqgR8gyG8oiNDyNEoAbsR3lOpI7grUYSvkB/xVy/VoklPCK2h0f0GJxFjnye8NT1PAywoyl7RmiAVRE/EKwIDAQABo4GZMIGWMAkGA1UdEwQCMAAwHQYDVR0OBBYEFGEpG9oZGcfLMGNBkY7SgHiMGgTcMEgGA1UdIwRBMD+AFKOetkhnQhI2Qb1t4Lm0oFKLl/GzoRykGjAYMRYwFAYDVQQDDA1KZXRQcm9maWxlIENBggkA0myxg7KDeeEwEwYDVR0lBAwwCgYIKwYBBQUHAwEwCwYDVR0PBAQDAgWgMA0GCSqGSIb3DQEBCwUAA4ICAQAF8uc+YJOHHwOFcPzmbjcxNDuGoOUIP+2h1R75Lecswb7ru2LWWSUMtXVKQzChLNPn/72W0k+oI056tgiwuG7M49LXp4zQVlQnFmWU1wwGvVhq5R63Rpjx1zjGUhcXgayu7+9zMUW596Lbomsg8qVve6euqsrFicYkIIuUu4zYPndJwfe0YkS5nY72SHnNdbPhEnN8wcB2Kz+OIG0lih3yz5EqFhld03bGp222ZQCIghCTVL6QBNadGsiN/lWLl4JdR3lJkZzlpFdiHijoVRdWeSWqM4y0t23c92HXKrgppoSV18XMxrWVdoSM3nuMHwxGhFyde05OdDtLpCv+jlWf5REAHHA201pAU6bJSZINyHDUTB+Beo28rRXSwSh3OUIvYwKNVeoBY+KwOJ7WnuTCUq1meE6GkKc4D/cXmgpOyW/1SmBz3XjVIi/zprZ0zf3qH5mkphtg6ksjKgKjmx1cXfZAAX6wcDBNaCL+Ortep1Dh8xDUbqbBVNBL4jbiL3i3xsfNiyJgaZ5sX7i8tmStEpLbPwvHcByuf59qJhV/bZOl8KqJBETCDJcY6O2aqhTUy+9x93ThKs1GKrRPePrWPluud7ttlgtRveit/pcBrnQcXOl1rHq7ByB8CFAxNotRUYL9IF5n3wJOgkPojMy6jetQA5Ogc8Sm7RG6vg1yow==</span><br></pre></td></tr></table></figure>

<h4 id="第二个激活码"><a href="#第二个激活码" class="headerlink" title="第二个激活码"></a>第二个激活码</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">QYYBAC9D3J-eyJsaWNlbnNlSWQiOiJRWVlCQUM5RDNKIiwibGljZW5zZWVOYW1lIjoi6LaF57qnIOeoi+W6j+WRmCIsImFzc2lnbmVlTmFtZSI6IiIsImFzc2lnbmVlRW1haWwiOiIiLCJsaWNlbnNlUmVzdHJpY3Rpb24iOiIiLCJjaGVja0NvbmN1cnJlbnRVc2UiOmZhbHNlLCJwcm9kdWN0cyI6W3siY29kZSI6IklJIiwiZmFsbGJhY2tEYXRlIjoiMjAyMC0wMS0wNCIsInBhaWRVcFRvIjoiMjAyMS0wMS0wMyJ9LHsiY29kZSI6IkFDIiwiZmFsbGJhY2tEYXRlIjoiMjAyMC0wMS0wNCIsInBhaWRVcFRvIjoiMjAyMS0wMS0wMyJ9LHsiY29kZSI6IkRQTiIsImZhbGxiYWNrRGF0ZSI6IjIwMjAtMDEtMDQiLCJwYWlkVXBUbyI6IjIwMjEtMDEtMDMifSx7ImNvZGUiOiJQUyIsImZhbGxiYWNrRGF0ZSI6IjIwMjAtMDEtMDQiLCJwYWlkVXBUbyI6IjIwMjEtMDEtMDMifSx7ImNvZGUiOiJHTyIsImZhbGxiYWNrRGF0ZSI6IjIwMjAtMDEtMDQiLCJwYWlkVXBUbyI6IjIwMjEtMDEtMDMifSx7ImNvZGUiOiJETSIsImZhbGxiYWNrRGF0ZSI6IjIwMjAtMDEtMDQiLCJwYWlkVXBUbyI6IjIwMjEtMDEtMDMifSx7ImNvZGUiOiJDTCIsImZhbGxiYWNrRGF0ZSI6IjIwMjAtMDEtMDQiLCJwYWlkVXBUbyI6IjIwMjEtMDEtMDMifSx7ImNvZGUiOiJSUzAiLCJmYWxsYmFja0RhdGUiOiIyMDIwLTAxLTA0IiwicGFpZFVwVG8iOiIyMDIxLTAxLTAzIn0seyJjb2RlIjoiUkMiLCJmYWxsYmFja0RhdGUiOiIyMDIwLTAxLTA0IiwicGFpZFVwVG8iOiIyMDIxLTAxLTAzIn0seyJjb2RlIjoiUkQiLCJmYWxsYmFja0RhdGUiOiIyMDIwLTAxLTA0IiwicGFpZFVwVG8iOiIyMDIxLTAxLTAzIn0seyJjb2RlIjoiUEMiLCJmYWxsYmFja0RhdGUiOiIyMDIwLTAxLTA0IiwicGFpZFVwVG8iOiIyMDIxLTAxLTAzIn0seyJjb2RlIjoiUk0iLCJmYWxsYmFja0RhdGUiOiIyMDIwLTAxLTA0IiwicGFpZFVwVG8iOiIyMDIxLTAxLTAzIn0seyJjb2RlIjoiV1MiLCJmYWxsYmFja0RhdGUiOiIyMDIwLTAxLTA0IiwicGFpZFVwVG8iOiIyMDIxLTAxLTAzIn0seyJjb2RlIjoiREIiLCJmYWxsYmFja0RhdGUiOiIyMDIwLTAxLTA0IiwicGFpZFVwVG8iOiIyMDIxLTAxLTAzIn0seyJjb2RlIjoiREMiLCJmYWxsYmFja0RhdGUiOiIyMDIwLTAxLTA0IiwicGFpZFVwVG8iOiIyMDIxLTAxLTAzIn0seyJjb2RlIjoiUlNVIiwiZmFsbGJhY2tEYXRlIjoiMjAyMC0wMS0wNCIsInBhaWRVcFRvIjoiMjAyMS0wMS0wMyJ9XSwiaGFzaCI6IjE2MDgwOTA5LzAiLCJncmFjZVBlcmlvZERheXMiOjcsImF1dG9Qcm9sb25nYXRlZCI6ZmFsc2UsImlzQXV0b1Byb2xvbmdhdGVkIjpmYWxzZX0=-I7c5mu4hUCMxcldrwZEJMaT+qkrzrF1bjJi0i5QHcrRxk2LO0jqzUe2fBOUR4L+x+7n6kCwAoBBODm9wXst8dWLXdq179EtjU3rfJENr1wXGgtef//FNow+Id5iRufJ4W+p+3s5959GSFibl35YtbELELuCUH2IbCRly0PUBjitgA0r2y+9jV5YD/dmrd/p4C87MccC74NxtQfRdeUEGx87vnhsqTFH/sP4C2VljSo/F/Ft9JqsSlGfwSKjzU8BreYt1QleosdMnMK7a+fkfxh7n5zg4DskdVlNbfe6jvYgMVE16DMXd6F1Zhwq+lrmewJA2jPToc+H5304rcJfa9w==-MIIElTCCAn2gAwIBAgIBCTANBgkqhkiG9w0BAQsFADAYMRYwFAYDVQQDDA1KZXRQcm9maWxlIENBMB4XDTE4MTEwMTEyMjk0NloXDTIwMTEwMjEyMjk0NlowaDELMAkGA1UEBhMCQ1oxDjAMBgNVBAgMBU51c2xlMQ8wDQYDVQQHDAZQcmFndWUxGTAXBgNVBAoMEEpldEJyYWlucyBzLnIuby4xHTAbBgNVBAMMFHByb2QzeS1mcm9tLTIwMTgxMTAxMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAxcQkq+zdxlR2mmRYBPzGbUNdMN6OaXiXzxIWtMEkrJMO/5oUfQJbLLuMSMK0QHFmaI37WShyxZcfRCidwXjot4zmNBKnlyHodDij/78TmVqFl8nOeD5+07B8VEaIu7c3E1N+e1doC6wht4I4+IEmtsPAdoaj5WCQVQbrI8KeT8M9VcBIWX7fD0fhexfg3ZRt0xqwMcXGNp3DdJHiO0rCdU+Itv7EmtnSVq9jBG1usMSFvMowR25mju2JcPFp1+I4ZI+FqgR8gyG8oiNDyNEoAbsR3lOpI7grUYSvkB/xVy/VoklPCK2h0f0GJxFjnye8NT1PAywoyl7RmiAVRE/EKwIDAQABo4GZMIGWMAkGA1UdEwQCMAAwHQYDVR0OBBYEFGEpG9oZGcfLMGNBkY7SgHiMGgTcMEgGA1UdIwRBMD+AFKOetkhnQhI2Qb1t4Lm0oFKLl/GzoRykGjAYMRYwFAYDVQQDDA1KZXRQcm9maWxlIENBggkA0myxg7KDeeEwEwYDVR0lBAwwCgYIKwYBBQUHAwEwCwYDVR0PBAQDAgWgMA0GCSqGSIb3DQEBCwUAA4ICAQAF8uc+YJOHHwOFcPzmbjcxNDuGoOUIP+2h1R75Lecswb7ru2LWWSUMtXVKQzChLNPn/72W0k+oI056tgiwuG7M49LXp4zQVlQnFmWU1wwGvVhq5R63Rpjx1zjGUhcXgayu7+9zMUW596Lbomsg8qVve6euqsrFicYkIIuUu4zYPndJwfe0YkS5nY72SHnNdbPhEnN8wcB2Kz+OIG0lih3yz5EqFhld03bGp222ZQCIghCTVL6QBNadGsiN/lWLl4JdR3lJkZzlpFdiHijoVRdWeSWqM4y0t23c92HXKrgppoSV18XMxrWVdoSM3nuMHwxGhFyde05OdDtLpCv+jlWf5REAHHA201pAU6bJSZINyHDUTB+Beo28rRXSwSh3OUIvYwKNVeoBY+KwOJ7WnuTCUq1meE6GkKc4D/cXmgpOyW/1SmBz3XjVIi/zprZ0zf3qH5mkphtg6ksjKgKjmx1cXfZAAX6wcDBNaCL+Ortep1Dh8xDUbqbBVNBL4jbiL3i3xsfNiyJgaZ5sX7i8tmStEpLbPwvHcByuf59qJhV/bZOl8KqJBETCDJcY6O2aqhTUy+9x93ThKs1GKrRPePrWPluud7ttlgtRveit/pcBrnQcXOl1rHq7ByB8CFAxNotRUYL9IF5n3wJOgkPojMy6jetQA5Ogc8Sm7RG6vg1yow==</span><br></pre></td></tr></table></figure>

<h4 id="第三个激活码"><a href="#第三个激活码" class="headerlink" title="第三个激活码"></a>第三个激活码</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">E70JHCOV2H-eyJsaWNlbnNlSWQiOiJFNzBKSENPVjJIIiwibGljZW5zZWVOYW1lIjoi5bGx5Lic55CG5bel5aSn5a2mIiwiYXNzaWduZWVOYW1lIjoiIiwiYXNzaWduZWVFbWFpbCI6IiIsImxpY2Vuc2VSZXN0cmljdGlvbiI6IkZvciBlZHVjYXRpb25hbCB1c2Ugb25seSIsImNoZWNrQ29uY3VycmVudFVzZSI6ZmFsc2UsInByb2R1Y3RzIjpbeyJjb2RlIjoiSUkiLCJwYWlkVXBUbyI6IjIwMjEtMDItMTgifSx7ImNvZGUiOiJBQyIsInBhaWRVcFRvIjoiMjAyMS0wMi0xOCJ9LHsiY29kZSI6IkRQTiIsInBhaWRVcFRvIjoiMjAyMS0wMi0xOCJ9LHsiY29kZSI6IlBTIiwicGFpZFVwVG8iOiIyMDIxLTAyLTE4In0seyJjb2RlIjoiR08iLCJwYWlkVXBUbyI6IjIwMjEtMDItMTgifSx7ImNvZGUiOiJETSIsInBhaWRVcFRvIjoiMjAyMS0wMi0xOCJ9LHsiY29kZSI6IkNMIiwicGFpZFVwVG8iOiIyMDIxLTAyLTE4In0seyJjb2RlIjoiUlMwIiwicGFpZFVwVG8iOiIyMDIxLTAyLTE4In0seyJjb2RlIjoiUkMiLCJwYWlkVXBUbyI6IjIwMjEtMDItMTgifSx7ImNvZGUiOiJSRCIsInBhaWRVcFRvIjoiMjAyMS0wMi0xOCJ9LHsiY29kZSI6IlBDIiwicGFpZFVwVG8iOiIyMDIxLTAyLTE4In0seyJjb2RlIjoiUk0iLCJwYWlkVXBUbyI6IjIwMjEtMDItMTgifSx7ImNvZGUiOiJXUyIsInBhaWRVcFRvIjoiMjAyMS0wMi0xOCJ9LHsiY29kZSI6IkRCIiwicGFpZFVwVG8iOiIyMDIxLTAyLTE4In0seyJjb2RlIjoiREMiLCJwYWlkVXBUbyI6IjIwMjEtMDItMTgifSx7ImNvZGUiOiJSU1UiLCJwYWlkVXBUbyI6IjIwMjEtMDItMTgifV0sImhhc2giOiIxNjc5MTgwMy8wIiwiZ3JhY2VQZXJpb2REYXlzIjo3LCJhdXRvUHJvbG9uZ2F0ZWQiOmZhbHNlLCJpc0F1dG9Qcm9sb25nYXRlZCI6ZmFsc2V9-qlgtO4xVGHX/r45fIKMaR6B9pWQtucrCYVsz0o00crcAiYN1k/kSMygggYl187B0u0jeXQCe4BmQIItKL79x6NwoPn43inreVhZ88f4+Cbl+V/KGeAYeybon+7YoTs8FY4+31ANW/LwBPxkPnlErxYdQ6oc/k6mnxIOm5Nf8WjKRfYYIl5Bhmdt1gHMGgFsocCcTLLiqDUGEcPj5tUIJXwwYaeKAR3YGXm/P73QpnYR/BcGaodBN3jprQRxsS5Ia5y06rrDAJcPSZuttAFpAit/4o/gq2XzhrjaBCtOMxNzk3XEAT82glTlWQOQx6KnRq6D7WUXzd81g44aP+Dca5Q==-MIIElTCCAn2gAwIBAgIBCTANBgkqhkiG9w0BAQsFADAYMRYwFAYDVQQDDA1KZXRQcm9maWxlIENBMB4XDTE4MTEwMTEyMjk0NloXDTIwMTEwMjEyMjk0NlowaDELMAkGA1UEBhMCQ1oxDjAMBgNVBAgMBU51c2xlMQ8wDQYDVQQHDAZQcmFndWUxGTAXBgNVBAoMEEpldEJyYWlucyBzLnIuby4xHTAbBgNVBAMMFHByb2QzeS1mcm9tLTIwMTgxMTAxMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAxcQkq+zdxlR2mmRYBPzGbUNdMN6OaXiXzxIWtMEkrJMO/5oUfQJbLLuMSMK0QHFmaI37WShyxZcfRCidwXjot4zmNBKnlyHodDij/78TmVqFl8nOeD5+07B8VEaIu7c3E1N+e1doC6wht4I4+IEmtsPAdoaj5WCQVQbrI8KeT8M9VcBIWX7fD0fhexfg3ZRt0xqwMcXGNp3DdJHiO0rCdU+Itv7EmtnSVq9jBG1usMSFvMowR25mju2JcPFp1+I4ZI+FqgR8gyG8oiNDyNEoAbsR3lOpI7grUYSvkB/xVy/VoklPCK2h0f0GJxFjnye8NT1PAywoyl7RmiAVRE/EKwIDAQABo4GZMIGWMAkGA1UdEwQCMAAwHQYDVR0OBBYEFGEpG9oZGcfLMGNBkY7SgHiMGgTcMEgGA1UdIwRBMD+AFKOetkhnQhI2Qb1t4Lm0oFKLl/GzoRykGjAYMRYwFAYDVQQDDA1KZXRQcm9maWxlIENBggkA0myxg7KDeeEwEwYDVR0lBAwwCgYIKwYBBQUHAwEwCwYDVR0PBAQDAgWgMA0GCSqGSIb3DQEBCwUAA4ICAQAF8uc+YJOHHwOFcPzmbjcxNDuGoOUIP+2h1R75Lecswb7ru2LWWSUMtXVKQzChLNPn/72W0k+oI056tgiwuG7M49LXp4zQVlQnFmWU1wwGvVhq5R63Rpjx1zjGUhcXgayu7+9zMUW596Lbomsg8qVve6euqsrFicYkIIuUu4zYPndJwfe0YkS5nY72SHnNdbPhEnN8wcB2Kz+OIG0lih3yz5EqFhld03bGp222ZQCIghCTVL6QBNadGsiN/lWLl4JdR3lJkZzlpFdiHijoVRdWeSWqM4y0t23c92HXKrgppoSV18XMxrWVdoSM3nuMHwxGhFyde05OdDtLpCv+jlWf5REAHHA201pAU6bJSZINyHDUTB+Beo28rRXSwSh3OUIvYwKNVeoBY+KwOJ7WnuTCUq1meE6GkKc4D/cXmgpOyW/1SmBz3XjVIi/zprZ0zf3qH5mkphtg6ksjKgKjmx1cXfZAAX6wcDBNaCL+Ortep1Dh8xDUbqbBVNBL4jbiL3i3xsfNiyJgaZ5sX7i8tmStEpLbPwvHcByuf59qJhV/bZOl8KqJBETCDJcY6O2aqhTUy+9x93ThKs1GKrRPePrWPluud7ttlgtRveit/pcBrnQcXOl1rHq7ByB8CFAxNotRUYL9IF5n3wJOgkPojMy6jetQA5Ogc8Sm7RG6vg1yow==</span><br></pre></td></tr></table></figure>

<p><strong>本帖附件</strong></p>
<p><a href="https://545c.com/file/21042697-459766209" target="_blank" rel="noopener">点击下载</a></p>
<p><strong>本文为作者原创 转载时请注明出处 谢谢</strong></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em>乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</em></p>
]]></content>
      <tags>
        <tag>开发工具</tag>
      </tags>
  </entry>
  <entry>
    <title>关于Markdown图表绘制</title>
    <url>/332.html</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>写作时难免会有图表绘制需求 比如下面几种</p>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><h5 id="第一种样式时序图"><a href="#第一种样式时序图" class="headerlink" title="第一种样式时序图"></a>第一种样式时序图</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">Alice -&gt; Bob:Hello Bob, How are you?</span><br><span class="line">Note right of Bob: Bob thinks</span><br><span class="line">Bob -&gt; Alice: I am good thanks!</span><br></pre></td></tr></table></figure>

<h5 id="第二种样式时序图"><a href="#第二种样式时序图" class="headerlink" title="第二种样式时序图"></a>第二种样式时序图</h5><pre class="mermaid"> sequenceDiagram
    participant Alice
    participant Bob
    Alice->John: Hello John, how are you?
    loop Healthcheck
            John->John: Fight against hypochondria
    end
    Note right of John: Rational thoughts <br>prevail...
    John-->Alice: Great!
    John->Bob: How about you?
    Bob-->John: Jolly good!</pre>

<h5 id="甘特图"><a href="#甘特图" class="headerlink" title="甘特图"></a>甘特图</h5><pre class="mermaid">  gantt
    dateFormat  YYYY-MM-DD
    title Adding GANTT diagram functionality to mermaid
    section A section
    Completed task            :done,    des1, 2014-01-06,2014-01-08
    Active task               :active,  des2, 2014-01-09, 3d
    Future task               :         des3, after des2, 5d
    Future task2               :         des4, after des3,6d</pre>
<h5 id="上下流程图"><a href="#上下流程图" class="headerlink" title="上下流程图"></a>上下流程图</h5><pre class="mermaid">graph TD;
            A-->B;
            A-->C;
            B-->D;
            C-->D;</pre>

<h5 id="左右流程图"><a href="#左右流程图" class="headerlink" title="左右流程图"></a>左右流程图</h5><pre class="mermaid">graph LR;

律动乐器-->律动+氛围乐器-->律动+鼓组贝斯-->律动+鼓组贝斯+氛围乐器;
铺底+氛围-->铺底+氛围+律动-->铺底+氛围+律动+鼓组贝斯-->追加间奏乐器;</pre>

<h5 id="自定义style的流程图"><a href="#自定义style的流程图" class="headerlink" title="自定义style的流程图"></a>自定义style的流程图</h5><pre class="mermaid">graph LR;
    id1(Start)-->id2(Stop)
    style id1 fill:#f9f,stroke:#333,stroke-width:4px
    style id2 fill:#bbf,stroke:#f66,stroke-width:2px,color:#fff,stroke-dasharray: 5 5</pre>

<h5 id="各种形状的流程图"><a href="#各种形状的流程图" class="headerlink" title="各种形状的流程图"></a>各种形状的流程图</h5>
<pre class="mermaid">graph  TD;
    A[/Christmas\]--> B[\This is the text in the box\]-->
     C[\Go shopping/]-->D[/This is the text in the box/]-->E{{This is the text in the box}}-->F{This is the text in the box}-->G>This is the text in the box]-->H((This is the text in the circle))-->J(This is the text in the box)</pre>

<h3 id="语法实现"><a href="#语法实现" class="headerlink" title="语法实现"></a>语法实现</h3><p><strong>时序图demo代码：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    &lt;pre class=&quot;mermaid&quot;&gt;    sequenceDiagram</span><br><span class="line">    participant Alice</span><br><span class="line">    participant Bob</span><br><span class="line">    Alice-&gt;John: Hello John, how are you?</span><br><span class="line">    loop Healthcheck</span><br><span class="line">            John-&gt;John: Fight against hypochondria</span><br><span class="line">    end</span><br><span class="line">    Note right of John: Rational thoughts &lt;br/&gt;prevail...</span><br><span class="line">    John--&gt;Alice: Great!</span><br><span class="line">    John-&gt;Bob: How about you?</span><br><span class="line">    Bob--&gt;John: Jolly good!&lt;/pre&gt;</span><br><span class="line">**甘特图demo代码：**</span><br></pre></td></tr></table></figure>

<pre><code>&lt;pre class=&quot;mermaid&quot;&gt;    gantt
dateFormat  YYYY-MM-DD
title Adding GANTT diagram functionality to mermaid
section A section
Completed task            :done,    des1, 2014-01-06,2014-01-08
Active task               :active,  des2, 2014-01-09, 3d
Future task               :         des3, after des2, 5d
Future task2               :         des4, after des3, 5d
section Critical tasks
Completed task in the critical line :crit, done, 2014-01-06,24h
Implement parser and jison          :crit, done, after des1, 2d
Create tests for parser             :crit, active, 3d
Future task in critical line        :crit, 5d
Create tests for renderer           :2d
Add to mermaid                      :1d&lt;/pre&gt;</code></pre><p><strong>流程图demo代码：</strong></p>
<pre><code>    &lt;pre class=&quot;mermaid&quot;&gt;    graph TD;
            A--&gt;B;
            A--&gt;C;
            B--&gt;D;
            C--&gt;D;&lt;/pre&gt;

### 总结

以上只是列举其中几种 , 除此之外还可以绘制饼状图 状态图 类图 需求图等等

更多技巧可以参考`mermaid`文档: 《[mermaid官方文档](https://mermaid-js.github.io/mermaid/#/flowchart)》





**本文为作者原创转载时请注明出处 谢谢**

![](https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png)

*[乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站](https://code.newban.cn/)*

</code></pre>]]></content>
      <tags>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>关于Github加速方法总结</title>
    <url>/334.html</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>最近网站大部分图片访问变慢, 原因出在<code>jsdelivr</code>加速失效, 为此我更换了CDN域名, 顺带总结一下<code>github</code>加速小技巧</p>
<h3 id="GitHub访问加速"><a href="#GitHub访问加速" class="headerlink" title="GitHub访问加速"></a>GitHub访问加速</h3><h5 id="1-使用镜像访问"><a href="#1-使用镜像访问" class="headerlink" title="1. 使用镜像访问"></a>1. 使用镜像访问</h5><p>这相当于是克隆版的 GitHub , 网站的内容和 GitHub 是完整同步, 可以在这个网站里面进行下载克隆等操作, 镜像地址如下:</p>
<ul>
<li><a href="https://hub.fastgit.org/" target="_blank" rel="noopener">https://hub.fastgit.org</a></li>
</ul>
<p><strong>使用示范:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https://github.com/typecho/typecho</span><br><span class="line"></span><br><span class="line">可以改成</span><br><span class="line"></span><br><span class="line">https://hub.fastgit.xyz/typecho/typecho</span><br></pre></td></tr></table></figure>

<h5 id="2-修改Host文件加速"><a href="#2-修改Host文件加速" class="headerlink" title="2.修改Host文件加速"></a>2.修改Host文件加速</h5><p>首先需要获取对应域名实际ip地址, 可以通过以下网站查询:</p>
<ul>
<li><p><a href="https://www.itdog.cn/" target="_blank" rel="noopener">https://www.itdog.cn/</a></p>
</li>
<li><p><a href="https://www.ipaddress.com/" target="_blank" rel="noopener">https://www.ipaddress.com/</a></p>
</li>
</ul>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20220707154831063.png" alt="image-20220707154831063"></p>
<p>需要查询的地址有:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 基本地址</span><br><span class="line">&apos;github.com&apos;,</span><br><span class="line">&apos;gist.github.com&apos;,</span><br><span class="line">&apos;assets-cdn.github.com&apos;,</span><br><span class="line">&apos;raw.githubusercontent.com&apos;,</span><br><span class="line">&apos;gist.githubusercontent.com&apos;,</span><br><span class="line">&apos;cloud.githubusercontent.com&apos;,</span><br><span class="line">&apos;camo.githubusercontent.com&apos;,</span><br><span class="line">&apos;avatars0.githubusercontent.com&apos;,</span><br><span class="line">&apos;avatars1.githubusercontent.com&apos;,</span><br><span class="line">&apos;avatars2.githubusercontent.com&apos;,</span><br><span class="line">&apos;avatars3.githubusercontent.com&apos;,</span><br><span class="line">&apos;avatars4.githubusercontent.com&apos;,</span><br><span class="line">&apos;avatars5.githubusercontent.com&apos;,</span><br><span class="line">&apos;avatars6.githubusercontent.com&apos;,</span><br><span class="line">&apos;avatars7.githubusercontent.com&apos;,</span><br><span class="line">&apos;avatars8.githubusercontent.com&apos;,</span><br><span class="line">&apos;avatars.githubusercontent.com&apos;,</span><br><span class="line">&apos;github.githubassets.com&apos;,</span><br><span class="line">&apos;user-images.githubusercontent.com&apos;,</span><br><span class="line">&apos;codeload.github.com&apos;,</span><br><span class="line">&apos;favicons.githubusercontent.com&apos;,</span><br><span class="line">&apos;api.github.com&apos;</span><br></pre></td></tr></table></figure>

<p>一个一个查询太过麻烦, 可以使用python脚本快速批量获取, 代码如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!/usr/bin/env python</span><br><span class="line"># coding:utf-8</span><br><span class="line"> </span><br><span class="line">import socket</span><br><span class="line"></span><br><span class="line">def output_hosts():</span><br><span class="line">    domains = [&apos;github.com&apos;,</span><br><span class="line">                &apos;gist.github.com&apos;,</span><br><span class="line">                &apos;assets-cdn.github.com&apos;,</span><br><span class="line">                &apos;raw.githubusercontent.com&apos;,</span><br><span class="line">                &apos;gist.githubusercontent.com&apos;,</span><br><span class="line">                &apos;cloud.githubusercontent.com&apos;,</span><br><span class="line">                &apos;camo.githubusercontent.com&apos;,</span><br><span class="line">                &apos;avatars0.githubusercontent.com&apos;,</span><br><span class="line">                &apos;avatars1.githubusercontent.com&apos;,</span><br><span class="line">                &apos;avatars2.githubusercontent.com&apos;,</span><br><span class="line">                &apos;avatars3.githubusercontent.com&apos;,</span><br><span class="line">                &apos;avatars4.githubusercontent.com&apos;,</span><br><span class="line">                &apos;avatars5.githubusercontent.com&apos;,</span><br><span class="line">                &apos;avatars6.githubusercontent.com&apos;,</span><br><span class="line">                &apos;avatars7.githubusercontent.com&apos;,</span><br><span class="line">                &apos;avatars8.githubusercontent.com&apos;,</span><br><span class="line">                &apos;avatars.githubusercontent.com&apos;,</span><br><span class="line">                &apos;github.githubassets.com&apos;,</span><br><span class="line">                &apos;user-images.githubusercontent.com&apos;,</span><br><span class="line">                &apos;codeload.github.com&apos;,</span><br><span class="line">                &apos;favicons.githubusercontent.com&apos;,</span><br><span class="line">                &apos;api.github.com&apos;</span><br><span class="line">                ]</span><br><span class="line">    </span><br><span class="line">    with open(&apos;hosts.txt&apos;, &apos;w&apos;) as f:</span><br><span class="line">        f.write(&apos;```\n&apos;)</span><br><span class="line">        f.write(&apos;# GitHub Start \n&apos;)</span><br><span class="line">        for domain in domains:</span><br><span class="line">            print(&apos;Querying ip for domain %s&apos;%domain)</span><br><span class="line">            ip = socket.gethostbyname(domain)</span><br><span class="line">            print(ip)</span><br><span class="line">            f.write(&apos;%s %s\n&apos;%(ip, domain))</span><br><span class="line">        f.write(&apos;# GitHub End \n&apos;) </span><br><span class="line">        f.write(&apos;```\n&apos;)</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    </span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    output_hosts()</span><br></pre></td></tr></table></figure>

<p>执行脚本后, 得到如下结果:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># GitHub Start </span><br><span class="line">140.82.121.3  github.com</span><br><span class="line">140.82.121.3  gist.github.com</span><br><span class="line">185.199.110.153 assets-cdn.github.com</span><br><span class="line">185.199.108.133 raw.githubusercontent.com</span><br><span class="line">185.199.111.133 gist.githubusercontent.com</span><br><span class="line">185.199.110.133 cloud.githubusercontent.com</span><br><span class="line">185.199.111.133 camo.githubusercontent.com</span><br><span class="line">185.199.111.133 avatars0.githubusercontent.com</span><br><span class="line">185.199.110.133 avatars1.githubusercontent.com</span><br><span class="line">185.199.111.133 avatars2.githubusercontent.com</span><br><span class="line">185.199.109.133 avatars3.githubusercontent.com</span><br><span class="line">185.199.108.133 avatars4.githubusercontent.com</span><br><span class="line">185.199.111.133 avatars5.githubusercontent.com</span><br><span class="line">185.199.109.133 avatars6.githubusercontent.com</span><br><span class="line">185.199.109.133 avatars7.githubusercontent.com</span><br><span class="line">185.199.110.133 avatars8.githubusercontent.com</span><br><span class="line">185.199.108.133 avatars.githubusercontent.com</span><br><span class="line">185.199.111.154 github.githubassets.com</span><br><span class="line">185.199.109.133 user-images.githubusercontent.com</span><br><span class="line">140.82.112.9 codeload.github.com</span><br><span class="line">185.199.110.133 favicons.githubusercontent.com</span><br><span class="line">192.30.255.116 api.github.com</span><br><span class="line"># GitHub End</span><br></pre></td></tr></table></figure>

<p>将以上内容拷贝到系统Host文件中即可, 不同操作系统host文件所在路径不一样:</p>
<ol>
<li><strong>Windows系统</strong>：修改<code>C:\Windows\System32\drivers\etc\hosts</code>文件</li>
</ol>
   <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 网络刷新</span><br><span class="line">ipconfig /flushdns</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p><strong>Linux系统</strong>：修改<code>C:\Windows\System32\drivers\etc\hosts</code>文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 网络刷新</span><br><span class="line">systemctl restart network</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="仓库Clone下载加速"><a href="#仓库Clone下载加速" class="headerlink" title="仓库Clone下载加速"></a>仓库Clone下载加速</h3><h5 id="1-将仓库克隆到Gitee"><a href="#1-将仓库克隆到Gitee" class="headerlink" title="1. 将仓库克隆到Gitee"></a>1. 将仓库克隆到Gitee</h5><p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20220707151023271.png" alt="image-20220707151023271"></p>
<h5 id="2-使用Fast-GitHub浏览器插件"><a href="#2-使用Fast-GitHub浏览器插件" class="headerlink" title="2.使用Fast-GitHub浏览器插件"></a>2.使用Fast-GitHub浏览器插件</h5><p><a href="https://github.com/fhefh2015/Fast-GitHub" target="_blank" rel="noopener">Fast-GitHub</a></p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20220707151433012.png" alt="image-20220707151433012"></p>
<h5 id="3-第三方网站解析加速"><a href="#3-第三方网站解析加速" class="headerlink" title="3.第三方网站解析加速"></a>3.第三方网站解析加速</h5><p><a href="http://toolwa.com/github/" target="_blank" rel="noopener">Toolwa</a></p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20220707151746721.png" alt="image-20220707151746721"></p>
<p><a href="https://github.com/hunshcn/gh-proxy" target="_blank" rel="noopener">gh-proxy</a></p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20220707152513916.png" alt="image-20220707152513916"></p>
<p><a href="https://ghproxy.com/" target="_blank" rel="noopener">Ghproxy</a></p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20220707155957192.png" alt="image-20220707155957192"></p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20220707160024075.png" alt="image-20220707160024075"></p>
<h3 id="Raw资源加速"><a href="#Raw资源加速" class="headerlink" title="Raw资源加速"></a>Raw资源加速</h3><h5 id="1-使用fastgit"><a href="#1-使用fastgit" class="headerlink" title="1. 使用fastgit"></a>1. 使用fastgit</h5><p>将<code>raw.githubusercontent.com</code>替换成<code>raw.staticdn.net</code>或者<code>raw.gitmirror.com</code></p>
<p>使用示例</p>
<p>实际上<code>fastgit</code>功能很丰富, 几乎囊括了<code>github</code>所有. 具体如下表:</p>
<p><strong>反代列表</strong></p>
<table>
<thead>
<tr>
<th>站源</th>
<th>地址</th>
<th>缓存</th>
</tr>
</thead>
<tbody><tr>
<td>github.com</td>
<td>hub.fastgit.xyz</td>
<td>无</td>
</tr>
<tr>
<td>raw.githubusercontent.com</td>
<td>raw.staticdn.net</td>
<td>无</td>
</tr>
<tr>
<td>github.githubassets.com</td>
<td>assets.fastgit.org</td>
<td>无</td>
</tr>
<tr>
<td>customer-stories-feed.github.com</td>
<td>customer-stories-feed.fastgit.org</td>
<td>480 分钟</td>
</tr>
<tr>
<td>Github Download</td>
<td>download.fastgit.org</td>
<td>480 分钟</td>
</tr>
<tr>
<td>GitHub Archive</td>
<td>archive.fastgit.org</td>
<td>无</td>
</tr>
</tbody></table>
<p><a href="https://fastgit.org/" target="_blank" rel="noopener">fastgit官网</a></p>
<h5 id="2-使用ghproxy"><a href="#2-使用ghproxy" class="headerlink" title="2.使用ghproxy"></a>2.使用ghproxy</h5><p>在<code>https://raw.githubusercontent.com</code>地址前面添加<code>https://ghproxy.com/</code></p>
<p>比如:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https://ghproxy.com/https://raw.githubusercontent.com/stilleshan/ServerStatus/master/Dockerfile</span><br></pre></td></tr></table></figure>

<p><strong>本文为作者原创转载时请注明出处 谢谢</strong></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em><a href="https://code.newban.cn/">乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</a></em></p>
]]></content>
      <tags>
        <tag>常用技巧</tag>
      </tags>
  </entry>
  <entry>
    <title>给Hexo添加Github贡献日历图</title>
    <url>/336.html</url>
    <content><![CDATA[<h3 id="图示"><a href="#图示" class="headerlink" title="图示"></a>图示</h3><h5 id="样式一"><a href="#样式一" class="headerlink" title="样式一"></a>样式一</h5><p><img src="https://github-readme-stats.vercel.app/api?username=songjianzaina" alt="Zfour&#39;s github stats"></p>
<h5 id="样式二"><a href="#样式二" class="headerlink" title="样式二"></a>样式二</h5><p><img src="https://ghchart.rshah.org/newbanh" alt></p>
<h5 id="样式三"><a href="#样式三" class="headerlink" title="样式三"></a>样式三</h5><p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU4MDA3Ng==,size_16,color_FFFFFF,t_70.png" alt="小冰的插件效果"></p>
<p>接下来给大家介绍它们的实现方法</p>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><h5 id="第一种"><a href="#第一种" class="headerlink" title="第一种"></a>第一种</h5><p>只需将<code>username</code>的值设置为你的<code>github</code>用户名即可:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https://github-readme-stats.vercel.app/api?username=github用户名</span><br></pre></td></tr></table></figure>

<p>然后以图片的形式进行加载:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">![](https://github-readme-stats.vercel.app/api?username=github用户名)</span><br></pre></td></tr></table></figure>

<p>如果是放置在<code>html</code>中, 替换用户名后 拷贝以下代码:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;img src=&quot;https://github-readme-stats.vercel.app/api?username=github用户名&quot; referrerpolicy=&quot;no-referrer&quot; &quot;&gt;</span><br></pre></td></tr></table></figure>

<p>项目GitHub: <a href="https://github.com/anuraghazra/github-readme-stats" target="_blank" rel="noopener">github-readme-stats</a></p>
<h5 id="第二种"><a href="#第二种" class="headerlink" title="第二种"></a>第二种</h5><p>和第一种类似, 尾部改成<code>github</code>用户名即可</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https://ghchart.rshah.org/github用户名</span><br></pre></td></tr></table></figure>

<p>然后以图片的形式进行加载:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">![](https://ghchart.rshah.org/github用户名)</span><br></pre></td></tr></table></figure>

<p>如果是放置在<code>html</code>中, 替换用户名后 拷贝以下代码:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;img src=&quot;https://ghchart.rshah.org/github用户名&quot;  referrerpolicy=&quot;no-referrer&quot; &quot;&gt;</span><br></pre></td></tr></table></figure>

<p>项目GitHub: <a href="https://github.com/2016rshah/githubchart-api" target="_blank" rel="noopener">githubchart-api</a></p>
<h5 id="第三种"><a href="#第三种" class="headerlink" title="第三种"></a>第三种</h5><p>这种是以<code>hexo</code>插件的形式实现, 具体步骤如下:</p>
<ol>
<li><p>安装插件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm i hexo-githubcalendar --save</span><br></pre></td></tr></table></figure>
</li>
<li><p>hexo根目录下的config文件添加如下配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Ice Kano Plus_in</span><br><span class="line"># Hexo Github Canlendar</span><br><span class="line"># Author: Ice Kano</span><br><span class="line"># Modify: Lete乐特</span><br><span class="line">githubcalendar:</span><br><span class="line">  enable: true</span><br><span class="line">  enable_page: /</span><br><span class="line">  user: 你的github用户名</span><br><span class="line">  layout:</span><br><span class="line">    type: id</span><br><span class="line">    name: recent-posts</span><br><span class="line">    index: 0</span><br><span class="line">  githubcalendar_html: &apos;&lt;div class=&quot;recent-post-item&quot; style=&quot;width:100%;height:auto;padding:10px;&quot;&gt;&lt;div id=&quot;github_loading&quot; style=&quot;width:10%;height:100%;margin:0 auto;display: block&quot;&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; xmlns:xlink=&quot;http://www.w3.org/1999/xlink&quot;  viewBox=&quot;0 0 50 50&quot; style=&quot;enable-background:new 0 0 50 50&quot; xml:space=&quot;preserve&quot;&gt;&lt;path fill=&quot;#d0d0d0&quot; d=&quot;M25.251,6.461c-10.318,0-18.683,8.365-18.683,18.683h4.068c0-8.071,6.543-14.615,14.615-14.615V6.461z&quot; transform=&quot;rotate(275.098 25 25)&quot;&gt;&lt;animateTransform attributeType=&quot;xml&quot; attributeName=&quot;transform&quot; type=&quot;rotate&quot; from=&quot;0 25 25&quot; to=&quot;360 25 25&quot; dur=&quot;0.6s&quot; repeatCount=&quot;indefinite&quot;&gt;&lt;/animateTransform&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/div&gt;&lt;div id=&quot;github_container&quot;&gt;&lt;/div&gt;&lt;/div&gt;&apos;</span><br><span class="line">  pc_minheight: 280px</span><br><span class="line">  mobile_minheight: 0px</span><br><span class="line">  color: &quot;[&apos;#ebedf0&apos;, &apos;#fdcdec&apos;, &apos;#fc9bd9&apos;, &apos;#fa6ac5&apos;, &apos;#f838b2&apos;, &apos;#f5089f&apos;, &apos;#c4067e&apos;, &apos;#92055e&apos;, &apos;#540336&apos;, &apos;#48022f&apos;, &apos;#30021f&apos;]&quot;</span><br><span class="line">  api: https://python-github-calendar-api.vercel.app/api</span><br><span class="line">  # api: https://python-gitee-calendar-api.vercel.app/api</span><br><span class="line">  calendar_js: https://cdn.jsdelivr.net/gh/Zfour/hexo-github-calendar@1.21/hexo_githubcalendar.js</span><br><span class="line">  plus_style: &quot;&quot;</span><br></pre></td></tr></table></figure>

<p>将<code>user</code>属性修改为你的<code>github</code>用户名即可,</p>
<ul>
<li><p>其他属性用法可参见《<a href="https://zfe.space/post/hexo-githubcalendar.html" target="_blank" rel="noopener">教程：hexo-githubcalendar 插件 1.0</a>》</p>
</li>
<li><p>涉及主题: <a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="noopener">hexo-theme-butterfly</a></p>
</li>
<li><p>插件GitHub: <a href="https://github.com/Zfour/hexo-github-calendar" target="_blank" rel="noopener">hexo-github-calendar</a></p>
</li>
</ul>
</li>
</ol>
<p><strong>本文为作者原创转载时请注明出处 谢谢</strong></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em><a href="https://code.newban.cn/">乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</a></em></p>
]]></content>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo NexT 主题渲染 Mermaid 绘图</title>
    <url>/333.html</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>由于我的Hexo博客中的Next主题是旧版, 并不支持<code>mermaid</code>, 因此需要手动配置, 步骤如下</p>
<h3 id="配置步骤"><a href="#配置步骤" class="headerlink" title="配置步骤"></a>配置步骤</h3><h5 id="第一步-安装-mermaid-插件"><a href="#第一步-安装-mermaid-插件" class="headerlink" title="第一步 安装 mermaid 插件"></a>第一步 安装 mermaid 插件</h5><p>在博客的根目录下，执行以下命令安装 <code>hexo-filter-mermaid-diagrams</code> 插件</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$ npm install hexo-filter-mermaid-diagrams --save</span><br></pre></td></tr></table></figure>

<h5 id="第二步-NexT-启用-Mermaid"><a href="#第二步-NexT-启用-Mermaid" class="headerlink" title="第二步 NexT 启用 Mermaid"></a>第二步 NexT 启用 Mermaid</h5><p>打开 NexT 主题的 <code>_config.yml</code> 配置文件，添加以下代码：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Mermaid tag</span></span><br><span class="line"><span class="attr">mermaid:</span></span><br><span class="line"><span class="attr">  enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># Available themes: default | dark | forest | neutral</span></span><br><span class="line"><span class="attr">  theme:</span> <span class="string">default</span></span><br></pre></td></tr></table></figure>

<h5 id="第三步-添加script脚本"><a href="#第三步-添加script脚本" class="headerlink" title="第三步 添加script脚本"></a>第三步 添加<code>script</code>脚本</h5><p>打开<code>next/layout/_partials/footer.swig</code>文件, 添加以下代码:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;% <span class="keyword">if</span> theme.mermaid.enable %&#125;</span><br><span class="line">  &lt;script type=<span class="string">"text/javascript"</span> src=<span class="string">'https://unpkg.com/mermaid@9.0.0/dist/mermaid.min.js'</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line">  &lt;script&gt;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">window</span>.mermaid) &#123;</span><br><span class="line">        <span class="keyword">var</span> mermaid_config = &#123;</span><br><span class="line">            startOnLoad: <span class="literal">true</span>,</span><br><span class="line">            theme: <span class="string">'&#123;&#123;theme.mermaid.theme&#125;&#125;'</span>,</span><br><span class="line">            flowchart:&#123;</span><br><span class="line">                useMaxWidth: <span class="literal">false</span>,</span><br><span class="line">                htmlLabels: <span class="literal">true</span></span><br><span class="line">            &#125;                </span><br><span class="line">        &#125;</span><br><span class="line">        mermaid.initialize(mermaid_config);</span><br><span class="line">  &#125;</span><br><span class="line">  &lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">  &#123;% endif %&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="至此-配置完毕"><a href="#至此-配置完毕" class="headerlink" title="至此 配置完毕"></a>至此 配置完毕</h3><hr>
<h3 id="js本地引用"><a href="#js本地引用" class="headerlink" title="js本地引用"></a>js本地引用</h3><p>如果你打算将<code>js</code>文件存放在本地, 可以将<code>js</code>文件放置到<code>next/source/js/src</code>目录下, 那么<code>script</code>脚本改成如下即可:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;% <span class="keyword">if</span> theme.mermaid.enable %&#125;</span><br><span class="line">  &lt;script type=<span class="string">"text/javascript"</span> <span class="keyword">async</span>  src=<span class="string">'js/src/mermaid.min.js'</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line">  &lt;script&gt;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">window</span>.mermaid) &#123;</span><br><span class="line">        <span class="keyword">var</span> mermaid_config = &#123;</span><br><span class="line">            startOnLoad: <span class="literal">true</span>,</span><br><span class="line">            theme: <span class="string">'&#123;&#123;theme.mermaid.theme&#125;&#125;'</span>,</span><br><span class="line">            flowchart:&#123;</span><br><span class="line">                useMaxWidth: <span class="literal">false</span>,</span><br><span class="line">                htmlLabels: <span class="literal">true</span></span><br><span class="line">            &#125;                </span><br><span class="line">        &#125;</span><br><span class="line">        mermaid.initialize(mermaid_config);</span><br><span class="line">  &#125;</span><br><span class="line">  &lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">  &#123;% endif %&#125;</span></span><br></pre></td></tr></table></figure>

<p><strong>本文为作者原创转载时请注明出处 谢谢</strong></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em><a href="https://code.newban.cn/">乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</a></em></p>
]]></content>
      <tags>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>img标签随机获取高质量图片</title>
    <url>/338.html</url>
    <content><![CDATA[<h3 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h3><p>博主打算为自己在vps上挂载的服务, 建立一个导航页, 于是写一个静态页面, 贴了几个超链接</p>
<p>后来, 感觉不美观, 就放了几张图片</p>
<p>服务器存储的图片看了几遍就看腻了, 于是找了一个高质量图片的api, 每次打开导航页都能看到随机的封面</p>
<h3 id="开源图片api的使用"><a href="#开源图片api的使用" class="headerlink" title="开源图片api的使用"></a>开源图片api的使用</h3><ul>
<li><p>我想获得<code>300*300</code>, 关于<code>book</code>和<code>library</code>的图片” </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https://source.unsplash.com/300x300/?book,library</span><br></pre></td></tr></table></figure>
</li>
<li><p>将随机图片嵌入到html中 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;img src=&quot;https://source.unsplash.com/300x300/?book,library&quot;&gt;</span><br></pre></td></tr></table></figure>




</li>
</ul>
<h3 id="随机封面效果展示"><a href="#随机封面效果展示" class="headerlink" title="随机封面效果展示"></a>随机封面效果展示</h3><ul>
<li>第一次打开:</li>
</ul>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/1620.png" alt="img"></p>
<ul>
<li>第二次打开</li>
</ul>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/1620-20220708113914217.png" alt="img"></p>
<ul>
<li>第三次打开</li>
</ul>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/1620-20220708114509494.png" alt="img"></p>
<ul>
<li>第N次打开…</li>
</ul>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/1620-20220708113921160.png" alt="img"></p>
<h3 id="随机封面测试地址-页面每次刷新，都能看到不同的封面"><a href="#随机封面测试地址-页面每次刷新，都能看到不同的封面" class="headerlink" title="随机封面测试地址(页面每次刷新，都能看到不同的封面)"></a>随机封面测试地址(页面每次刷新，都能看到不同的封面)</h3><p>页面部分源码:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;section <span class="class"><span class="keyword">class</span></span>=<span class="string">"clearfix"</span>&gt;</span><br><span class="line">        &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"item"</span>&gt;</span><br><span class="line">            &lt;a href=<span class="string">"http://git.zhaoolee.com"</span>&gt;</span><br><span class="line">                &lt;img src=<span class="string">"https://source.unsplash.com/300x300/?program"</span> alt=<span class="string">""</span>&gt;</span><br><span class="line">                &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"item-title"</span>&gt;私有Git仓库&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">            &lt;/</span>a&gt;</span><br><span class="line">        &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">        &lt;div class="item"&gt;</span></span><br><span class="line"><span class="regexp">            &lt;a href="http:/</span><span class="regexp">/cloud.zhaoolee.com"&gt;</span></span><br><span class="line"><span class="regexp">                &lt;img src="https:/</span><span class="regexp">/source.unsplash.com/</span><span class="number">300</span>x300/?<span class="built_in">document</span><span class="string">" alt="</span><span class="string">"&gt;</span></span><br><span class="line"><span class="string">                &lt;div class="</span>item-title<span class="string">"&gt;私有云网盘&lt;/div&gt;</span></span><br><span class="line"><span class="string">            &lt;/a&gt;</span></span><br><span class="line"><span class="string">        &lt;/div&gt;</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">        &lt;div class="</span>item<span class="string">"&gt;</span></span><br><span class="line"><span class="string">            &lt;a href="</span>https:<span class="comment">//www.jianshu.com/u/c5d047065c42"&gt;</span></span><br><span class="line">                &lt;img src=<span class="string">"https://source.unsplash.com/300x300/?book,library"</span> alt=<span class="string">""</span>&gt;</span><br><span class="line">                &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"item-title"</span>&gt;简书主页&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">            &lt;/</span>a&gt;</span><br><span class="line">        &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    </span></span><br><span class="line"><span class="regexp">        &lt;div class="item"&gt;</span></span><br><span class="line"><span class="regexp">            &lt;a href="https:/</span><span class="regexp">/github.com/</span>zhaoolee<span class="string">"&gt;</span></span><br><span class="line"><span class="string">                &lt;img src="</span>https:<span class="comment">//source.unsplash.com/300x300/?github" alt=""&gt;</span></span><br><span class="line">                &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"item-title"</span>&gt;Github主页&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">            &lt;/</span>a&gt;</span><br><span class="line">        &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    </span></span><br><span class="line"><span class="regexp">        &lt;div class="item"&gt;</span></span><br><span class="line"><span class="regexp">            &lt;a href=""&gt;</span></span><br><span class="line"><span class="regexp">                &lt;img src="https:/</span><span class="regexp">/source.unsplash.com/</span><span class="number">300</span>x300/?cartoon<span class="string">" alt="</span><span class="string">"&gt;</span></span><br><span class="line"><span class="string">                &lt;div class="</span>item-title<span class="string">"&gt;在线爬虫(建设中)&lt;/div&gt;</span></span><br><span class="line"><span class="string">            &lt;/a&gt;</span></span><br><span class="line"><span class="string">        &lt;/div&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        &lt;div class="</span>item<span class="string">"&gt;</span></span><br><span class="line"><span class="string">            &lt;a href="</span><span class="string">"&gt;</span></span><br><span class="line"><span class="string">                &lt;img src="</span>https:<span class="comment">//source.unsplash.com/300x300/?beauty" alt=""&gt;</span></span><br><span class="line">                &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"item-title"</span>&gt;资源分享(建设中)&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">            &lt;/</span>a&gt;</span><br><span class="line">        &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>section&gt;</span><br><span class="line">&lt;<span class="regexp">/body&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="小结"><a href="#小结" class="headerlink" title="小结:"></a>小结:</h3><ul>
<li>使用随机化开源图片封面, 能让我们每次打开页面都有惊喜.</li>
<li>对于刚刚接触前端的小伙伴, 使用开源的图片库, 能让你的页面更加丰富多彩, 提升学习的兴趣.</li>
<li>对于前端老司机,可以获取定制化的开源图片, 提升页面展示效果.</li>
<li>如果你对图片的质量有极致的追求,<a href="https://source.unsplash.com/" target="_blank" rel="noopener">https://source.unsplash.com</a> 提供了丰富的接口参数设置,可以定制化随机图片的范围, 当然也可以在<a href="http://unsplash.com/" target="_blank" rel="noopener">unsplash.com</a> 注册一个账号, 订阅特别主题的图片</li>
</ul>
<p><strong>本文转载自</strong>: <a href="https://cloud.tencent.com/developer/article/1344365?from=15425" target="_blank" rel="noopener">https://cloud.tencent.com/developer/article/1344365?from=15425</a></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em><a href="https://code.newban.cn/">乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</a></em></p>
]]></content>
      <tags>
        <tag>html</tag>
      </tags>
  </entry>
  <entry>
    <title>Android锁屏息屏状态下弹出界面</title>
    <url>/335.html</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>最近公司客户端项目需要支持锁屏息屏状态下弹出应用界面, 类似于微信来电显示, 实现方法很简单, 如下:</p>
<h3 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤"></a>实现步骤</h3><h5 id="第一步-在清单文件中添加休眠唤醒和解锁权限"><a href="#第一步-在清单文件中添加休眠唤醒和解锁权限" class="headerlink" title="第一步 在清单文件中添加休眠唤醒和解锁权限"></a>第一步 在清单文件中添加休眠唤醒和解锁权限</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;uses-permission android:name=&quot;android.permission.DISABLE_KEYGUARD&quot; /&gt;</span><br><span class="line">&lt;uses-permission android:name=&quot;android.permission.WAKE_LOCK&quot; /&gt;</span><br></pre></td></tr></table></figure>

<h5 id="第二步-在需要弹出显示的Activity的onCreate方法中添加相应flag代码"><a href="#第二步-在需要弹出显示的Activity的onCreate方法中添加相应flag代码" class="headerlink" title="第二步 在需要弹出显示的Activity的onCreate方法中添加相应flag代码"></a>第二步 在需要弹出显示的<code>Activity</code>的<code>onCreate</code>方法中添加相应<code>flag</code>代码</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">       getWindow().addFlags(WindowManager.LayoutParams.FLAG_SHOW_WHEN_LOCKED <span class="comment">//锁屏显示</span></span><br><span class="line">               | WindowManager.LayoutParams.FLAG_DISMISS_KEYGUARD <span class="comment">//解锁</span></span><br><span class="line">               | WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON <span class="comment">//保持屏幕不息屏</span></span><br><span class="line">               | WindowManager.LayoutParams.FLAG_TURN_SCREEN_ON);<span class="comment">//点亮屏幕</span></span><br><span class="line">     </span><br><span class="line">     setContentView(R.layout.activity_main);</span><br><span class="line">     </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h5 id="第三步-触发Activity启动"><a href="#第三步-触发Activity启动" class="headerlink" title="第三步 触发Activity启动"></a>第三步 触发Activity启动</h5><p>比如推送触发  后台<code>Service</code>触发  或者<code>IM</code>长连接信令触发等等</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">openActivity</span><span class="params">(Context context, String msg)</span> </span>&#123;</span><br><span class="line">Intent intent = <span class="keyword">new</span> Intent(context, MainActivity.class)ialarmIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS);</span><br><span class="line">       context.startActivity(intent);</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>

<h5 id="完毕"><a href="#完毕" class="headerlink" title="完毕"></a>完毕</h5><p><strong>本文为作者原创转载时请注明出处 谢谢</strong></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em><a href="https://code.newban.cn/">乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</a></em></p>
]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>解决图片的防盗链导致图片显示不出来</title>
    <url>/337.html</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>你平常有可能将图片存放到<code>github</code>、<code>gitee</code> 或者博客园  简书等等地方, 供静态博客使用, 除了<code>github</code>之外 大部分国内的网站都设置了图片防盗链</p>
<p>如果直接使用会导致图片无法显示</p>
<p>解决防盗链的问题其实也非常简单</p>
<h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><p>在<code>html</code>的<code>head</code>标签中添加如下代码即可:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;meta name=&quot;referrer&quot; content=&quot;never&quot;&gt;</span><br></pre></td></tr></table></figure>

<p>如果你只想处理某部分图片, 可以针对性设置, 比如:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;img src=&quot;xxxx.jpg&quot; referrerPolicy=&quot;no-referrer&quot; /&gt;</span><br></pre></td></tr></table></figure>

<h3 id="批量替换图片域名"><a href="#批量替换图片域名" class="headerlink" title="批量替换图片域名"></a>批量替换图片域名</h3><p>偶尔图床CDN挂了需要更换域名, 一些文章存放在数据库,比如<code>wordpress</code>网站  为了方便 可以采用<code>js</code>动态替换的方式, 将以下代码拷贝到<code>html</code>页脚标签中即可 </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">let</span> context = <span class="built_in">Array</span>.prototype.map.call(<span class="built_in">document</span>.images, (event) =&gt; &#123;</span><br><span class="line">          event.src = event.src.replace(<span class="string">"cdn.jsdelivr.net/gh/xxx/xxx"</span>, <span class="string">"raw.staticdn.net/xxx/xxx/master"</span>)</span><br><span class="line">        </span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line">  &lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>

<p>另外还可以动态添加<code>meta</code>标签</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> addMeta = <span class="function">(<span class="params">name, content</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> meta = <span class="built_in">document</span>.createElement(<span class="string">'meta'</span>);</span><br><span class="line">  meta.content = content;</span><br><span class="line">  meta.name = name;</span><br><span class="line">  <span class="built_in">document</span>.getElementsByTagName(<span class="string">'head'</span>)[<span class="number">0</span>].appendChild(meta);</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">addMeta(</span><br><span class="line">    <span class="string">'referrer'</span>,</span><br><span class="line">    <span class="string">'never'</span>,</span><br><span class="line">  );</span><br></pre></td></tr></table></figure>

<p><strong>本文为作者原创转载时请注明出处 谢谢</strong></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em><a href="https://code.newban.cn/">乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</a></em></p>
]]></content>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Android TV 电视盒子开发之远程网络调试</title>
    <url>/341.html</url>
    <content><![CDATA[<h3 id="硬件环境准备"><a href="#硬件环境准备" class="headerlink" title="硬件环境准备"></a>硬件环境准备</h3><p>一般电视盒子是不具备 <code>USB</code> 线调试功能 , 多数只能使用<code>adb</code>远程调试 , 国内的电视盒子提供一个 <code>USB</code> 的接口可以插 U 盘 ;</p>
<p><code>USB</code>线调试 : 有些厂商提供了通过该接口进行 adb 调试的功能 , 如 小米 , 但是必须使用一根公对公的 <code>USB</code> 线 ;<br>( 国内的电视盒子一般要使用 <code>USB</code> 公对公接口 , 两头都是 <code>USB</code> 接口 , 有些电视没有该功能 )</p>
<p>远程调试 : 开发者电脑 与 <code>Android TV</code> , 必须在同一个局域网中 , 才能进行远程调试 ; ( 远程调试的速度一般要低于 )</p>
<h3 id="开启开发者模式"><a href="#开启开发者模式" class="headerlink" title="开启开发者模式"></a>开启开发者模式</h3><p>先到 <code>关于本机</code> 界面 , 启用开发者模式 , 选择 <code>关于本机 / 产品信息 / 软件版本</code> 点击多次 , 即可启用开发者模式 ;</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hhbjEyMDIwMTI=,size_16,color_FFFFFF,t_70.png" alt="在这里插入图片描述"></p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hhbjEyMDIwMTI=,size_16,color_FFFFFF,t_70-20220712113006908.png" alt="在这里插入图片描述"></p>
<p>在 <code>账户安全</code> 界面的 <code>ADB模式</code> 选择 <code>开启</code> 即可进行远程调试 ;</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hhbjEyMDIwMTI=,size_16,color_FFFFFF,t_70-20220712113036212.png" alt="在这里插入图片描述"></p>
<h3 id="查询-Android-电视局域网-IP-地址"><a href="#查询-Android-电视局域网-IP-地址" class="headerlink" title="查询 Android 电视局域网 IP 地址"></a>查询 Android 电视局域网 IP 地址</h3><p>进入设置界面 , 选择网络连接界面进入 ;</p>
<p><img src="https://img-blog.csdnimg.cn/20210626094725370.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hhbjEyMDIwMTI=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>进入 <code>网络设置</code> 后 , 选择当前连接的 <code>WIFI</code>选项 , 进入 ;</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hhbjEyMDIwMTI=,size_16,color_FFFFFF,t_70-20220712113110810.png" alt="在这里插入图片描述"></p>
<p>此时就可以看到<code>Android TV</code> 的局域网 IP 地址 ;</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hhbjEyMDIwMTI=,size_16,color_FFFFFF,t_70-20220712113121376.png" alt="在这里插入图片描述"></p>
<h3 id="开启远程连接"><a href="#开启远程连接" class="headerlink" title="开启远程连接"></a>开启远程连接</h3><p>在上面得到安卓电视的 <code>IP</code> 地址是 <code>192.168.1.104</code> , 先<code>ping</code> 一下 , 查看是否能<code>ping</code> 通 ;</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hhbjEyMDIwMTI=,size_16,color_FFFFFF,t_70-20220712113153166.png" alt="在这里插入图片描述"></p>
<p>如果 <code>ping</code> 不通 , 说明 电脑 与 电视 , 网络连接不通 , 无法进行 <code>adb</code> 调试 , 此时需要排查问题 , 电脑是否网络通常 , 电视网络是否通常 , 电脑和电视是否在同一个局域网中 ;</p>
<p>如果能<code>ping</code> 通 , 则使用 <code>adb connect</code> 命令 , 连接该远程设备 ;</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">adb connect 192.168.1.104:5555   #5555可以省略</span><br></pre></td></tr></table></figure>

<p>执行上述命令 , 即可通过网络连接 <code>adb</code> 调试 ;</p>
<p>使用<code>adb devices</code>命令 , 可以查看当前使用 adb 调试的设备 ;</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/20210626100614623.png" alt="在这里插入图片描述"></p>
<p>在<code>Android Studio</code> 中也可以看到该电视盒子 , 并且打印电视盒子的相关日志 , 向电视盒子中部署程序 , 跟使用 USB 调试手机一样 ;</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hhbjEyMDIwMTI=,size_16,color_FFFFFF,t_70-20220712113228773.png" alt="在这里插入图片描述"></p>
<p>以上远程调试方法不仅针对<code>AndroidTV</code>, 对于<code>Android</code>手机也是一样的流程</p>
<h3 id="附加"><a href="#附加" class="headerlink" title="附加"></a>附加</h3><ol>
<li><p>如果出现连接不上的情况  可能是设备<code>tcpip</code>模式未开启, 可以执行以下指令开启:</p>
   <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">adb -s 设备名 tcpip 5555</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果依然无法连接, 那么有可能是安卓设备没有开启<code>adb</code>远程调试或者端口未开放</p>
<p>我们可以通过<code>shel</code>l查看安卓设备<code>5555</code>端口是否开启, 指令如下:</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">adb -s 设备名 shell netstat -ntlp | grep 55</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/5a2a2c8cccbb41b383246163afd97df7.png" alt="img"></p>
</li>
<li><p>如果端口没有开启, 则运行以下指令开启:</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">adb -s 设备名 shell setprop service.adb.tcp.port 5555</span><br></pre></td></tr></table></figure>
</li>
<li><p>另外  如果要通过<code>shell</code>查看设备<code>ip</code>, 可以运行以下指令:</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">adb -s 设备名 shell ifconfig</span><br></pre></td></tr></table></figure>


</li>
</ol>
<pre><code>或者

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">adb -s 设备名 shell netcfg</span><br></pre></td></tr></table></figure></code></pre><ol start="5">
<li><p>最后 断开设备连接</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">adb disconnect 192.168.1.104:5555</span><br></pre></td></tr></table></figure>







</li>
</ol>
<p><strong>本文转载自</strong>:  <a href="https://blog.csdn.net/shulianghan/article/details/118241238" target="_blank" rel="noopener">https://blog.csdn.net/shulianghan/article/details/118241238</a></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em><a href="https://code.newban.cn/">乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</a></em></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>AndroidTV</tag>
      </tags>
  </entry>
  <entry>
    <title>Mac识别二维码 无需安装第三放应用</title>
    <url>/339.html</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>我们在浏览网页的时候经常会碰到二维码扫描需求, 一般情况下 我们会考虑将二维码图片发送到手机上 然后用手机识别    或者干脆装个第三方扫码软件</p>
<p>为了方便 (主要是懒)  接下来给大家介绍一种使用<code>Safari</code>浏览器二维码识别的方法</p>
<h3 id="具体操作"><a href="#具体操作" class="headerlink" title="具体操作"></a>具体操作</h3><h5 id="第一步"><a href="#第一步" class="headerlink" title="第一步"></a>第一步</h5><p>选中要识别的二维码图片，把它拖到<code>Safar浏览器</code>打开。</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/20220708154220.png" alt></p>
<h5 id="第二步"><a href="#第二步" class="headerlink" title="第二步"></a>第二步</h5><p>随后右键点击二维码，选择<code>在新标签页中打开...</code></p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/20220708154248.png" alt></p>
<p>新标签页中打开的就是二维码中的内容</p>
<p>是不是很简单 赶紧试试吧~</p>
<p><strong>本文为作者原创转载时请注明出处 谢谢</strong></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em><a href="https://code.newban.cn/">乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</a></em></p>
]]></content>
      <tags>
        <tag>Mac</tag>
      </tags>
  </entry>
  <entry>
    <title>Mac平台下使用Charles进行抓包</title>
    <url>/34.html</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p> 某天，突然产生了对手机访问进行抓包的想法，<code>google</code>了一下，发现在<code>mac</code>下使用<code>charles</code>进行手机访问的抓包比较容易，就进行了一次手机抓包的尝试（安卓手机）。</p>
<p><strong>这里强调一下 安卓应用抓包建议使用<code>Android7.0</code>以下的模拟器进行操作, 否则HTTPS协议的请求可能存在<code>443</code>无法抓取情况</strong></p>
<h3 id="mac安装charles"><a href="#mac安装charles" class="headerlink" title="mac安装charles"></a>mac安装charles</h3><p> 对于<code>mac</code>下安装<code>charles</code>，网上教程很多，这里不再进行说明，如果有条件的话，最好进行购买。</p>
<h3 id="charles捕获http请求"><a href="#charles捕获http请求" class="headerlink" title="charles捕获http请求"></a>charles捕获http请求</h3><p> 1、<strong>Proxy – macOS</strong> Proxy 先打开代理，使得mac上所有请求都通过charles进行代理。 <img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/20200908145123.png" alt></p>
<p> 2、<strong>Proxy – Proxy Settings</strong> 设置监听端口号为8888。</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/hWPSUBakNF97n12.png" alt></p>
<p> 3、此时，用电脑访问百度，就已经可以获取访问的包了，如果我们需要监听手机的访问，就还得在手机上进行设置。 <img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/wQbUoSWAdhlP52J.png" alt></p>
<p> 4、先获取电脑的ip地址，<strong>Help – Local Ip Address</strong> <img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/BOIz4r5VSdRFAgW.png" alt></p>
<p> 5、然后在手机连接wifi，此时手机和电脑连接的必须是同一个wifi，然后在手机设置代理。 <img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/bdZgW19vieRu3LM.png" alt></p>
<p>6、设置完成后，在手机打开一个网址，此时chartles就可以获取到手机访问的包了。</p>
<h3 id="charles捕获https请求"><a href="#charles捕获https请求" class="headerlink" title="charles捕获https请求"></a>charles捕获https请求</h3><p> http的请求我们已经可以获取，但是有些网站是https的，如果我们需要解析https的包，就需要安装证书了。</p>
<p> 1、<strong>Help – SSL Proxying – install Charles Root Certificate</strong>,首先在mac安装CA证书。 <img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/FrVcvGhgWL7CB5T.png" alt></p>
<p> 2、然后要始终信任该证书。 <img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/ibw5QkjI4g8DLEA.png" alt></p>
<p> 3、<strong>Help – SSL Proxying – Install Charles Root Certificate On …</strong>,然后生成手机上的证书。</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/5RkQIY1svdKUDbN.png" alt></p>
<p> 4、<strong>Help – SSL Proxying – Save …</strong>,然后保存该证书，它会生成一个类似<strong>charles-ssl-proxying.pem</strong>的文件，把该文件的后缀改为<strong>.crt</strong>,然后发送到你的安卓手机，进行安装即可。 <img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/lRA2w4Go5YjLqb8.png" alt></p>
<p> 5、<strong>Proxy – SSL Proxying setting</strong>,设置你要监听的https请求的网址 <img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/GY2pOr1ktqWla9i.png" alt></p>
<p> 6、手机再访问该网址，即可以抓到https的包了。</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/elVRwzuWX4Jsc32.png" alt></p>
<h3 id="APP安装报错解决"><a href="#APP安装报错解决" class="headerlink" title="APP安装报错解决"></a>APP安装报错解决</h3><h4 id="1-如果出现打开时提示：xxx-app已损坏，无法打开-那么输入以下指令解决"><a href="#1-如果出现打开时提示：xxx-app已损坏，无法打开-那么输入以下指令解决" class="headerlink" title="1. 如果出现打开时提示：xxx.app已损坏，无法打开,那么输入以下指令解决:"></a>1. 如果出现打开时提示：xxx.app已损坏，无法打开,那么输入以下指令解决:</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo xattr -d com.apple.quarantine /Applications/xxx.app</span><br></pre></td></tr></table></figure>

<p>其中<code>xxx.app</code>是出问题的APP名称，如名称中有空格，可用“\”加空格代替</p>
<h4 id="2-如果报错"><a href="#2-如果报错" class="headerlink" title="2.如果报错"></a>2.如果报错</h4><blockquote>
<p>Charles cannot configure your proxy settings while it is on a read-only volume. Perhaps you are running Charles from the disk image? If so, please copy Charles to the Applications folder and run it again. Otherwise please ensure that Charles is running on a volume that is read-write and try again.</p>
</blockquote>
<h4 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo chown -R root &quot;/Applications/Charles.app/Contents/Resources&quot;</span><br><span class="line"> sudo chmod -R u+s &quot;/Applications/Charles.app/Contents/Resources&quot;</span><br></pre></td></tr></table></figure>

<p><strong>本文为作者原创 转载时请注明出处 谢谢</strong></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em>乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</em></p>
]]></content>
      <tags>
        <tag>抓包</tag>
      </tags>
  </entry>
  <entry>
    <title>Mac快速开启http本地服务共享文件</title>
    <url>/340.html</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>有时候我们可能需要用手机访问电脑上的文件, 或者用手机测试电脑上编写的程序</p>
<p>此时 在同一个<code>wifi</code>网络的前提下我们可以这么做:</p>
<h3 id="第一种-使用python"><a href="#第一种-使用python" class="headerlink" title="第一种 使用python"></a>第一种 使用python</h3><p>直接使用自带<code>python</code>工具开启<code>http</code>服务, 首先打开终端, 进入需要共享的目录,然后运行以下代码即可:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">python -m SimpleHTTPServer  <span class="number">8000</span></span><br></pre></td></tr></table></figure>

<p>如果是<code>python3</code>, 则将<code>SimpleHTTPServer</code>改成<code>http.server</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">python -m http.server <span class="number">8000</span></span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20220711144617056.png" alt="image-20220711144617056"></p>
<p>紧接着就可以在浏览器上访问了: 在地址栏输入<code>http://127.0.0.1:8000/</code>或者<code>http://localhost:8000/</code></p>
<h5 id="局域网设备访问"><a href="#局域网设备访问" class="headerlink" title="局域网设备访问"></a>局域网设备访问</h5><p>如果局域网内其他设备访问, 则需要先获取到<code>Mac</code>的局域网<code>Ip</code>, 我们可以从系统偏好设置中的网络选项中查看到<code>IP</code>地址:</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20220711145144222.png" alt="image-20220711145144222"></p>
<p>然后使用<code>http://局域网ip:8000</code>这个地址就可以供其他设备访问啦</p>
<h3 id="第二种-使用Apache"><a href="#第二种-使用Apache" class="headerlink" title="第二种 使用Apache"></a>第二种 使用Apache</h3><h5 id="服务开启"><a href="#服务开启" class="headerlink" title="服务开启"></a>服务开启</h5><p><code>Mac</code>本身自带了<code>Apache</code>服务, 我们无需另外安装, 直接开启即可, 打开终端输入以下指令开启:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apachectl start</span><br></pre></td></tr></table></figure>

<p>打开服务后, 浏览器输入以下地址即可访问:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http://127.0.0.1</span><br><span class="line"></span><br><span class="line">或者</span><br><span class="line"></span><br><span class="line">http://localhost/</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/c55e4df1cd8b78d32f275946ca4077c4.png" alt="img"></p>
<p>出现以上页面表示服务启动成功</p>
<p>此时 <code>Apache</code>默认的服务器根目录在：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/Library/WebServer/Documents</span><br></pre></td></tr></table></figure>

<p>我们可以将需要共享的文件存放到该目录下, 比如我存放了一张名为<code>111.gif</code>的图片, 那么访问<code>http://127.0.0.1/111.gif</code>即可查看该图</p>
<h5 id="Apache配置目录浏览"><a href="#Apache配置目录浏览" class="headerlink" title="Apache配置目录浏览"></a>Apache配置目录浏览</h5><p>可是上面这种操作并不符合我们的预期, 我们想要输入地址后直接列出该目录下的所有文件</p>
<p>这需要对<code>Apache</code>配置文件中进行修改, 其配置文件路径为:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/etc/apache2/</span><br></pre></td></tr></table></figure>

<p>文件名为<code>httpd.conf</code>, 修改之前建议大家进行一次备份</p>
<p>打开该文件,  在<code>Options</code> 后面追加一句<code>Indexes</code></p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20220711151550133.png" alt="image-20220711151550133"></p>
<p>重启<code>apache</code>服务后, 浏览器输入地址就能查看目录了</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20220711151755973.png" alt="image-20220711151755973"></p>
<p>每次更改了配置, 需要重启服务才能生效, 重启指令如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//重启apache:    </span><br><span class="line">sudo apachectl restart</span><br></pre></td></tr></table></figure>

<h5 id="Apache其他配置"><a href="#Apache其他配置" class="headerlink" title="Apache其他配置"></a>Apache其他配置</h5><ol>
<li><p><strong>更改服务根目录</strong></p>
<p>搜索<code>DocumentRoot</code>关键字</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20220711152308158.png" alt="image-20220711152308158"></p>
</li>
<li><p><strong>更改访问端口</strong></p>
<p>搜索<code>ServerName</code>关键字, 去掉改行注释, 然后改为<code>ServerName localhost:端口号</code>或者<code>ServerName 127.0.0.1:端口号</code></p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20220711152426884.png" alt="image-20220711152426884"></p>
</li>
<li><p><strong>开启对<code>PHP</code>的支持</strong></p>
<p>搜索<code>LoadModule</code>, 去掉<code>php7</code>注释</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20220711152834896.png" alt="image-20220711152834896"></p>
</li>
</ol>
<h5 id="局域网设备访问-1"><a href="#局域网设备访问-1" class="headerlink" title="局域网设备访问"></a>局域网设备访问</h5><p><code>Apache</code>默认开启的是<code>80</code>端口,  因此直接<code>http://局域网ip</code>访问即可</p>
<h5 id="服务关闭"><a href="#服务关闭" class="headerlink" title="服务关闭"></a>服务关闭</h5><p>服务一旦开启 每次电脑启动后<code>Apache</code>都会自动跟着开启</p>
<p>平常不用的时候我们可以关闭服务, 减少资源消耗, 关闭指令如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//关闭apache:    </span><br><span class="line">sudo apachectl stop</span><br></pre></td></tr></table></figure>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>两种方式, 各有各的好处, <code>apache</code>的强大是毋庸置疑的, 如果只是任意文件夹共享, 直接使用<code>python</code>的方法会更加方便一些</p>
<p><strong>本文为作者原创转载时请注明出处 谢谢</strong></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em><a href="https://code.newban.cn/">乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</a></em></p>
]]></content>
      <tags>
        <tag>Mac</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo博客自定义404页面</title>
    <url>/344.html</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>一个成熟的网站当然要有他独特的<code>404</code>页面，使用<code>GitHub Pages</code>部署的博客虽然有<code>GitHub</code>的默认<code>404</code>页面，但显然不够美观，也与我们的网站整体风格不搭。</p>
<p>要实现自定义<code>404</code>其实很简单，<strong>只要在网站的根目录放一个<code>404.html</code>文件即可</strong>。而对于我们使用的<code>Hexo</code>，则有更合适的处理方法。</p>
<h3 id="操作步骤"><a href="#操作步骤" class="headerlink" title="操作步骤"></a>操作步骤</h3><h5 id="第一步-创建404页面"><a href="#第一步-创建404页面" class="headerlink" title="第一步 创建404页面"></a>第一步 创建404页面</h5><p>进入<code>hexo</code>站点的根目录，打开终端，输入：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo n page &quot;404&quot;</span><br></pre></td></tr></table></figure>

<p>将会在<code>source</code>目录下生成一个<code>404</code>文件夹，其中有一个<code>index.md</code>文件，这个文件其实就相当于是<code>404.html</code>了。</p>
<h5 id="第二步-打开index-md，修改头部信息："><a href="#第二步-打开index-md，修改头部信息：" class="headerlink" title="第二步 打开index.md，修改头部信息："></a>第二步 打开<code>index.md</code>，修改头部信息：</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">layout: false</span><br><span class="line">comments: false</span><br><span class="line">title: 404</span><br><span class="line">permalink: /404</span><br></pre></td></tr></table></figure>

<p>注意不要忘了修改<code>permalink</code>，不然不会在根目录下生成<code>404.html</code>。</p>
<h5 id="第三步-编写404页面内容"><a href="#第三步-编写404页面内容" class="headerlink" title="第三步 编写404页面内容"></a>第三步 编写404页面内容</h5><p>由于markdown是支持插入html内容的，因此只需要在这个<code>md</code>文件里写入<code>html</code>代码即可。<strong>要注意的是<code>html</code>代码之间千万不能有空行，不然会标签识别错误！</strong></p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/format,png.png" alt="类似这样"></p>
<p>那么接下来的就是考验你前端编码的能力和审美了。可惜本人不才，让我凭空写一个美观的网页几乎不可能，那只能靠拿来了！</p>
<p>这里推荐一个<a href="https://404.life/" target="_blank" rel="noopener">404模板网站</a>，有非常多美观的<code>404</code>页面，总能找到属于你的菜。</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/format,png-20220721121746440.png" alt="选模板"></p>
<p>找一个你喜欢的模板，点击下载源码，里面一般包含了<code>html+js+css</code>。<code>html</code>刚才说了直接贴<code>markdown</code>文档里即可，<strong>而<code>js</code>和<code>css</code>可以放到刚才生成的<code>404</code>目录下。</strong></p>
<p>同时别忘了修改<code>html</code>中的<code>css</code>和<code>js</code>引用地址：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- 网站icon --&gt;</span><br><span class="line">&lt;link rel=&quot;icon&quot; href=&quot;/img/favicon.svg&quot;&gt;</span><br><span class="line">&lt;!-- css文件 --&gt;</span><br><span class="line">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;/404/404.css&quot;&gt;</span><br><span class="line">&lt;!-- js文件 --&gt;</span><br><span class="line"></span><br><span class="line">&lt;script type=&quot;text/javascript&quot; src=&quot;/404/404.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>这样就基本完成了，<code>hexo s</code>看看效果：</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/format,png-20220721121919897.png" alt="404页面"></p>
<p>有兴趣的话可以再微调下页面内容即可。</p>
<h3 id="附加思考"><a href="#附加思考" class="headerlink" title="附加思考"></a>附加思考</h3><ol>
<li><p><strong>可以直接在<code>_post</code>目录中添加<code>404.md</code>吗?</strong></p>
<p>答: 可以 不过<code>_post</code>目录下的文本会当做文章收入进主页中, 如果不想在主页和归档列表中看到404页面, 建议还是使用<code>hexo n page</code>指令, 将其单独放置在一个目录中</p>
</li>
<li><p><strong>404页面和网站整体融合性</strong></p>
<p>我们发现 上述的方法生成的<code>404</code>页面和网站融合度很高, 可以保留或者移除主题布局, 如果你想单独制作一个和原网站风格不相关的404页面,那么直接自定义一个<code>404.html</code>文件放置到网站根目录即可</p>
</li>
</ol>
<p><strong>本文转载自</strong>:<a href="https://blog.luzy.top/posts/456645515/" target="_blank" rel="noopener">https://blog.luzy.top/posts/456645515/</a></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em><a href="https://code.newban.cn/">乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</a></em></p>
]]></content>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Android代码跳转至电池优化电池信息界面</title>
    <url>/345.html</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>最近有一款产品有后台保活需求, 无奈甲方太穷, 厂商白名单什么的是别想了, 只能采用原始粗暴的方法, 就是让用户手动开启各种权限, 至于用户体验  这个不存在的  顶多跳转到相关设置页面</p>
<p>其中有一项就是涉及到电池优化的, 禁止电池优化可以延长后台保活时间</p>
<p>以小米手机为例, 给大家列举几个电池相关页面的跳转代码</p>
<h3 id="电池优化页面"><a href="#电池优化页面" class="headerlink" title="电池优化页面"></a>电池优化页面</h3><p>页面图示:</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/1701658389765_.pic.jpg" alt="1701658389765_.pic"></p>
<p>代码如下:</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">startActivity(Intent().apply &#123;</span><br><span class="line">          action = Settings.ACTION_IGNORE_BATTERY_OPTIMIZATION_SETTINGS</span><br><span class="line">      &#125;)</span><br></pre></td></tr></table></figure>

<h3 id="电池信息页面"><a href="#电池信息页面" class="headerlink" title="电池信息页面"></a>电池信息页面</h3><p>页面图示:</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/1681658389761_.pic.jpg" alt="1681658389761_.pic"></p>
<p>代码如下:</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">startActivity(Intent(<span class="string">"/"</span>).apply &#123;</span><br><span class="line">          component = ComponentName(<span class="string">"com.android.settings"</span>, <span class="string">"com.android.settings.BatteryInfo"</span>)</span><br><span class="line">          action = <span class="string">"android.intent.action.VIEW"</span></span><br><span class="line">      &#125;)</span><br></pre></td></tr></table></figure>

<h3 id="耗电统计页面"><a href="#耗电统计页面" class="headerlink" title="耗电统计页面"></a>耗电统计页面</h3><p>页面图示:</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/1691658389763_.pic.jpg" alt="1691658389763_.pic"></p>
<p>代码如下:</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> powerUsageIntent = Intent(Intent.ACTION_POWER_USAGE_SUMMARY)</span><br><span class="line">    <span class="keyword">val</span> resolveInfo: ResolveInfo? = requireActivity().packageManager.resolveActivity(powerUsageIntent, <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">if</span> (resolveInfo != <span class="literal">null</span>) &#123;</span><br><span class="line">        startActivity(powerUsageIntent)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="休眠时始终保持网络连接"><a href="#休眠时始终保持网络连接" class="headerlink" title="休眠时始终保持网络连接"></a>休眠时始终保持网络连接</h3><p>华为手机有这个页面</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/Screenshot_20220721_171601_com.huawei.systemmanager.jpg" alt="Screenshot_20220721_171601_com.huawei.systemmanager"></p>
<p>想要跳转到这个页面, 首先需要获取到该页面的包名和<code>Activity</code>全路径, 可以使用<code>adb</code>获取, 指令如下;</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">adb -s 设备名  shell dumpsys activity activities</span><br></pre></td></tr></table></figure>

<p>运行结果如图:</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20220721170255859.png" alt="image-20220721170255859"></p>
<p>其中<code>com.huawei.systemmanager</code>表示包名 也就是<code>applicationId</code>, 而<code>.power.ui.PowerSettingActivity</code>表示<code>Activity</code>路径, 但最前面有个点 因此需要把包名加进去, 最后得到全路径是:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">com.huawei.systemmanager.power.ui.PowerSettingActivity</span><br></pre></td></tr></table></figure>

<p>有了包名和<code>Activity</code>路径, 那么直接上启动代码:</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">startActivity(Intent().apply &#123;</span><br><span class="line">          flags = Intent.FLAG_ACTIVITY_NEW_TASK</span><br><span class="line">          putExtra(<span class="string">"packageName"</span>, requireActivity().packageName)</span><br><span class="line">          component = ComponentName(</span><br><span class="line">              <span class="string">"com.huawei.systemmanager"</span>,</span><br><span class="line">              <span class="string">"com.huawei.systemmanager.power.ui.PowerSettingActivity"</span></span><br><span class="line">          )</span><br><span class="line">      &#125;)</span><br></pre></td></tr></table></figure>

<p>最后运行报错. 提示没有权限:</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">java.lang.SecurityException: Permission Denial: starting Intent &#123; flg=<span class="number">0x10000000</span> cmp=com.huawei.systemmanager/.power.ui.PowerSettingActivity (has extras) &#125; from ProcessRecord&#123;<span class="number">439</span>cab1 <span class="number">15282</span>:com.xxx.xxx/u0a211&#125; (pid=<span class="number">15282</span>, uid=<span class="number">10211</span>) not exported from uid <span class="number">1000</span></span><br></pre></td></tr></table></figure>

<p>暂时没有找到解决方法, 以上只是一种思路, 仅供参考</p>
<p><strong>本文为作者原创转载时请注明出处 谢谢</strong></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em><a href="https://code.newban.cn/">乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</a></em></p>
]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>QQ空间相册批量下载原图方法</title>
    <url>/343.html</url>
    <content><![CDATA[<h2 id="▍1-QQ空间导出助手（浏览器扩展）"><a href="#▍1-QQ空间导出助手（浏览器扩展）" class="headerlink" title="▍1 QQ空间导出助手（浏览器扩展）"></a>▍1 QQ空间导出助手（浏览器扩展）</h2><p>这一回的话就要首推这款浏览器扩展了：<a href="https://link.zhihu.com/?target=https%3A//github.com/ShunCai/QZoneExport" target="_blank" rel="noopener">https://github.com/ShunCai/QZoneExport</a></p>
<p>如果你访问Github困难，也可以访问项目的Gitee镜像地址：<a href="https://link.zhihu.com/?target=https%3A//gitee.com/mirrors_ShunCai/QZoneExport" target="_blank" rel="noopener">https://gitee.com/mirrors_ShunCai/QZoneExport</a></p>
<blockquote>
<p>建议了解<a href="https://link.zhihu.com/?target=https%3A//mp.weixin.qq.com/s/C5XUgzL3_KGIga2X-LHJuw" target="_blank" rel="noopener">《2022 Github加速访问教程》</a></p>
</blockquote>
<p>作者在2021年11月28日对扩展进行了更新，1.1.4版修复了之前介绍时提到的诸多问题</p>
<p>打开项目地址后，你有以下多种方式可以进行安装这款浏览器扩展</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/v2-faa2b435533c2a7c54afc2edf41f5b89_720w.jpg" alt="img"></p>
<p>如果你不会富强上网，建议就是自己去下载一个Edge或者360浏览器，这样直接就能从扩展商店在线进行安装</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/v2-d8766b052638fb13a6ebd4f7bc8640a0_720w.jpg" alt="img"></p>
<p>扩展安装好之后，右键扩展图标，点击扩展选项</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/v2-261e97c0809c2314295be73cb709f265_720w.jpg" alt="img"></p>
<p>在「公共」选项卡下设置下载方式为「浏览器」，或者你也可以根据说明设置为 Aria2、迅雷，设置好之后<strong><em>记得点击保存\</em></strong></p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/v2-d2bc8eb914e958953d6558534084b203_720w.jpg" alt="img"></p>
<p>然后打开浏览器设置，关闭下载设置中的「每次下载都询问我该做些什么」这个选项（不关的话之后下载会一直有弹窗）</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/v2-834512c48bcbd909ae20b587573f6b9d_720w.jpg" alt="img"></p>
<p>然后就没什么好说的了，扩展<strong><em>默认下载原图（带EXIF信息）\</em></strong>，这款扩展不仅支持备份相册，同事还支持导出说说、日志、私密日记、视频、留言板、好友、收藏夹、分享、访客内容，可谓非常全能！</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/v2-3a495a0cf6095e0b20e97d43d5f9b08a_720w.jpg" alt="img"></p>
<p>如果你勾选了下载说说、日志等东西，最后还可以点击一个打包下载，扩展会生成一个网页文件供你方便查看</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/v2-3e34ba7fcc1a17782f91e1a65ae22482_720w.jpg" alt="img"></p>
<h2 id="▍2-QQ空间相册下载神器（油猴脚本）"><a href="#▍2-QQ空间相册下载神器（油猴脚本）" class="headerlink" title="▍2 QQ空间相册下载神器（油猴脚本）"></a>▍2 QQ空间相册下载神器（油猴脚本）</h2><p>第二款相对方便的工具就是这个油猴脚本了：<a href="https://link.zhihu.com/?target=https%3A//greasyfork.org/zh-CN/scripts/399958" target="_blank" rel="noopener">https://greasyfork.org/zh-CN/scripts/399958</a></p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/v2-10896b600d38adc0e14c4e8ebcb35102_720w.jpg" alt="img"></p>
<blockquote>
<p>油猴脚本的安装方法请复习：<a href="https://link.zhihu.com/?target=https%3A//mp.weixin.qq.com/s/m_LhkDyLEBySzJV1LU4c9Q" target="_blank" rel="noopener">这篇文章的第2节</a></p>
</blockquote>
<p>脚本装好之后，在使用之前，务必有俩个地方需要设置</p>
<p>打开浏览器设置，关闭下载设置中的「每次下载都询问我该做些什么」这个选项（不关的话之后下载会一直有弹窗）</p>
<p>并且千万记得创建一个文件夹，并将下载位置改一下（否则可能会下载到遍桌面都是）</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/v2-7ec40f012ebc6462909b32ec0ed76587_720w.jpg" alt="img"></p>
<p>这时再打开你的QQ空间，你会发现在相册里面多出了一个「下载当页」的按钮</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/v2-76eaab24c136216eace236a741a97963_720w.jpg" alt="img"></p>
<p>点击一下你就会发现其将会在浏览器新窗口疯狂开图片，并调用浏览器进行下载</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/v2-77e4f2e46d70f73623d54a7ce6413e22_720w.jpg" alt="img"></p>
<p>当然，放心，图片下载完之后其会自动关闭新窗口，不必你挨着挨着去关闭</p>
<p>阿虚实测下载到的也都是<strong><em>带EXIF信息的原图\</em></strong></p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/v2-f3225b1ad35b6aacb445eb5c530139cd_720w.jpg" alt="img"></p>
<h2 id="▍3-qq-zone（WIN）"><a href="#▍3-qq-zone（WIN）" class="headerlink" title="▍3 qq-zone（WIN）"></a>▍3 qq-zone（WIN）</h2><p>Github地址：<a href="https://link.zhihu.com/?target=https%3A//github.com/qinjintian/qq-zone" target="_blank" rel="noopener">https://github.com/qinjintian/qq-zone</a></p>
<blockquote>
<p>如果你访问Github困难，建议了解<a href="https://link.zhihu.com/?target=https%3A//mp.weixin.qq.com/s/C5XUgzL3_KGIga2X-LHJuw" target="_blank" rel="noopener">《2022 Github加速访问教程》</a></p>
</blockquote>
<p>打开网页之后，点击Code，下载整个项目<code>（如果你有学习阿虚上方的Github加速教程，才会有像下图一样的加速下载方式）</code></p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/v2-8aeaec1a2d38bdcb3f5559a92b94e02b_720w.jpg" alt="img"></p>
<p>总之下载成功之后，运行作者已经帮我们编译好的<strong>qq-zone.exe</strong>，就会弹出下面这样一个窗口</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/v2-1bf181dcdcc21507e5cf78ef27abdd8d_720w.jpg" alt="img"></p>
<p>根据提示依次通过键盘输入，关于下载并行数，100M的宽带作者建议设置为8－15／200M的宽带建议设置为16－30，这个根据自身的网络来进行设置</p>
<p>然后就是输入你需要下载的相册名了（一定要完全和空间里的对应上）</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/v2-ffb1b5afd6d01e0d8cafd1c4c1c95485_720w.jpg" alt="img"></p>
<p>如果是下载自己空间里的相册，会在软件的目录里面生成一个<strong>qrcode.png</strong>二维码，点开它，用手机QQ扫码进行登录</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/v2-e8c953dff582c842ab364a80fc18982c_720w.jpg" alt="img"></p>
<p>然后很快就能下载完了</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/v2-cdfc64a7f225fecf2a3e30e36d77b05a_720w.jpg" alt="img"></p>
<p>这款软件下载的.jpg格式的图片，下载后会被保存为<strong>.jfif格式</strong>，但图片的<strong><em>EXIF信息也是还在的\</em></strong></p>
<h2 id="▍4-QZAlbumTool-（WIN）"><a href="#▍4-QZAlbumTool-（WIN）" class="headerlink" title="▍4 QZAlbumTool （WIN）"></a>▍4 QZAlbumTool （WIN）</h2><p>Github地址：<a href="https://link.zhihu.com/?target=https%3A//github.com/kahotv/QZAlbumTool" target="_blank" rel="noopener">https://github.com/kahotv/QZAlbumTool</a></p>
<blockquote>
<p>如果你访问Github困难，建议了解<a href="https://link.zhihu.com/?target=https%3A//mp.weixin.qq.com/s/C5XUgzL3_KGIga2X-LHJuw" target="_blank" rel="noopener">《2022 Github加速访问教程》</a></p>
</blockquote>
<p>这款软件最后的更新时间在2019.11.03，但阿虚实测2022年依旧能用的，而且使用也属于是最简单的了</p>
<p>下载软件解压之后，双击目录中的<strong>QZAlbumTool.exe</strong>运行软件，然后扫码进行的登录</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/v2-86b573e9059bbfa85d2e076048eacdb7_720w.jpg" alt="img"></p>
<p>耐心等待其读取完相册之后，切换到相册选项卡，像下图一样选中你需要下载的相册，再点击导出选中即可</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/v2-89a29e46da52520ab450e79bd3cff547_720w.jpg" alt="img"></p>
<p>不过这款软件的下载效率有点低了（可能是代码没优化很好），总之就是<strong>下载的有点慢！</strong></p>
<p>虽然需要耐心等待，不过下载到图片的都是<strong><em>带EXIF信息的原图\</em></strong>，这个是可以放心的</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/v2-279cadb213bac05a886642247222a3b0_720w.jpg" alt="img"></p>
<h2 id="▍5-QQ空间（安卓／iOS）"><a href="#▍5-QQ空间（安卓／iOS）" class="headerlink" title="▍5 QQ空间（安卓／iOS）"></a>▍5 QQ空间（安卓／iOS）</h2><p>官方的QQ空间APP其实也能批量下载<strong><em>带EXIF信息的照片原图\</em></strong>，不过被限制了<strong>一次性只能下载50张</strong></p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/v2-7daeae04540226eb1968be7637ca3e2f_720w.jpg" alt="img"></p>
<p>APP可在各大应用商店或者官网直接下载：</p>
<p><a href="https://link.zhihu.com/?target=http%3A//z.qzone.com/download.html" target="_blank" rel="noopener">http://z.qzone.com/download.htmlz.qzone.com/download.html</a></p>
<h2 id="▍6-如果你会Python"><a href="#▍6-如果你会Python" class="headerlink" title="▍6 如果你会Python"></a>▍6 如果你会Python</h2><p>如果你会用Python，也可以自己搭建相关运行环境，自己跑代码来使用以下项目：</p>
<ol>
<li>qzone-photo-downloader（需要搭配Chrome浏览器）：<a href="https://link.zhihu.com/?target=https%3A//github.com/dslwind/qzone-photo-downloader" target="_blank" rel="noopener">https://github.com/dslwind/qzone-photo-downloader</a></li>
<li>QQZone_AutoDownload_Album（需要搭配Firefox浏览器）：<a href="https://link.zhihu.com/?target=https%3A//gitee.com/songxf1024/QQZone_AutoDownload_Album" target="_blank" rel="noopener">https://gitee.com/songxf1024/QQZone_AutoDownload_Album</a></li>
<li>QzoneExporter（需从浏览器获取cookies、tk值）：<a href="https://link.zhihu.com/?target=https%3A//github.com/wwwpf/QzoneExporter" target="_blank" rel="noopener">https://github.com/wwwpf/QzoneExporter</a></li>
</ol>
<p>但对于多数人，前文介绍的4款工具既方便又好用，这些Python项目就留给各位程序员去折腾吧</p>
<p>避免有些粉丝的确下载不来Github上的软件，本文提到的软件类工具阿虚都已经帮大家打包好了</p>
<blockquote>
<p><a href="https://link.zhihu.com/?target=https%3A//www.yuque.com/docs/share/2d592174-c15c-49f2-91b4-16e9a3ec2193" target="_blank" rel="noopener">点击这里即可下载</a></p>
</blockquote>
<p>照片到是可以通过以上方法下载回来了，不过如果你还没有想好今后怎么备份相册的话，阿虚前不久才写了一篇7000字的长文，建议各位是可以去看一看的</p>
<p><a href="https://link.zhihu.com/?target=https%3A//mp.weixin.qq.com/s/qiRu-tC_5kysQISgrv5xYw" target="_blank" rel="noopener">为了寻找当下最好的照片备份方式，我写了7000字的长文…mp.weixin.qq.com/s/qiRu-tC_5kysQISgrv5xYw<img src="https://pic1.zhimg.com/v2-e27fa493cc914c89c32a577ac4868294_180x120.jpg" alt="img"></a></p>
<p><strong>本文转载自</strong>:<a href="https://zhuanlan.zhihu.com/p/340238253" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/340238253</a></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em><a href="https://code.newban.cn/">乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</a></em></p>
]]></content>
      <tags>
        <tag>黑科技</tag>
      </tags>
  </entry>
  <entry>
    <title>关于移动设备唯一标识的获取</title>
    <url>/342.html</url>
    <content><![CDATA[<h3 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h3><p>我们在做移动端开发时, 不可避免地会遇到需要获取设备唯一标识的问题</p>
<p>如果仅仅只需要给设备去重, 通常情况下我们可以考虑直接使用推送<code>SDK</code>生成的设备<code>Token</code>, 比如极光推送, 或者腾讯<code>TPNS</code>,  <code>App</code>重装后这个<code>token</code>可能会变,  但重复的概率极低  只是并不具备唯一性</p>
<p>想要唯一性 以安卓设备为例, 其实有很多设备码可用, 比如<code>IMEI</code>, <code>MAC地址</code>等等, 但是为什么我们在实际应用中无法将它们用作唯一标识呢</p>
<p>我们挨个来分析一下</p>
<h3 id="IMEI"><a href="#IMEI" class="headerlink" title="IMEI"></a>IMEI</h3><p><code>Android中</code>也叫<code>DEVICE_ID</code>, 是移动电话的唯一设备码, 相当于手机的身份证, 具备唯一性</p>
<p>但是:</p>
<ul>
<li>有通话功能的设备才有该码, 不是所有移动设备都具备拨号功能</li>
<li>双卡双待会有两个<code>IMEI</code>值</li>
<li>模拟器可以修改<code>IMEI</code></li>
<li><code>Android10</code>以上无法获取<code>IMEI</code></li>
</ul>
<h3 id="网卡-Mac地址"><a href="#网卡-Mac地址" class="headerlink" title="网卡 Mac地址"></a>网卡 Mac地址</h3><p>其中包含硬件<code>MAC</code>地址和<code>WLAN MAC</code>地址(<code>BSSID</code>),  硬件<code>MAC</code>地址和硬件绑定, 具备唯一性 , 但是<code>WLAN MAC</code>地址通常是随机的 主要是为了避免隐私泄露, 每个热点在连接时会使用随机的地址</p>
<p>可即便是硬件<code>Mac</code>也存在不足之处:</p>
<ul>
<li>有网卡的设备才有<code>Mac</code>地址, 不是所有设备都具备联网功能</li>
<li><code>Mac</code>地址可以通过软件欺骗性修改 </li>
</ul>
<h3 id="蓝牙Mac地址"><a href="#蓝牙Mac地址" class="headerlink" title="蓝牙Mac地址"></a>蓝牙Mac地址</h3><p>和<code>WLAN Mac</code>一样具备唯一性</p>
<p>但是:</p>
<ul>
<li>没有蓝牙的设备获取不到该值</li>
<li>蓝牙需要保持开启状态才有值</li>
</ul>
<h3 id="ANDROID-ID"><a href="#ANDROID-ID" class="headerlink" title="ANDROID_ID"></a>ANDROID_ID</h3><p>官方推荐使用的设备码, 具备唯一性</p>
<p>但是:</p>
<ul>
<li>设备恢复出厂设置 或者<code>ROOT</code>后 该值会改变</li>
<li>国内定制系统的设备可能返回<code>null</code></li>
<li><code>Android8</code>以下无法获取<code>Android_ID</code></li>
</ul>
<h3 id="PsuedoID"><a href="#PsuedoID" class="headerlink" title="PsuedoID"></a>PsuedoID</h3><p>该方式是通过拼接硬件信息获取到的，代码如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//获得独一无二的Psuedo ID</span><br><span class="line">public static String getUniquePsuedoID() &#123;</span><br><span class="line">       String serial = null;</span><br><span class="line"></span><br><span class="line">       String m_szDevIDShort = &quot;35&quot; + </span><br><span class="line">            Build.BOARD.length()%10+ Build.BRAND.length()%10 + </span><br><span class="line"></span><br><span class="line">            Build.CPU_ABI.length()%10 + Build.DEVICE.length()%10 + </span><br><span class="line"></span><br><span class="line">            Build.DISPLAY.length()%10 + Build.HOST.length()%10 + </span><br><span class="line"></span><br><span class="line">            Build.ID.length()%10 + Build.MANUFACTURER.length()%10 + </span><br><span class="line"></span><br><span class="line">            Build.MODEL.length()%10 + Build.PRODUCT.length()%10 + </span><br><span class="line"></span><br><span class="line">            Build.TAGS.length()%10 + Build.TYPE.length()%10 + </span><br><span class="line"></span><br><span class="line">            Build.USER.length()%10 ; //13 位</span><br><span class="line"></span><br><span class="line">    try &#123;</span><br><span class="line">        serial = android.os.Build.class.getField(&quot;SERIAL&quot;).get(null).toString();</span><br><span class="line">       //API&gt;=9 使用serial号</span><br><span class="line">        return new UUID(m_szDevIDShort.hashCode(), serial.hashCode()).toString();</span><br><span class="line">    &#125; catch (Exception exception) &#123;</span><br><span class="line">        //serial需要一个初始化</span><br><span class="line">        serial = &quot;serial&quot;; // 随便一个初始化</span><br><span class="line">    &#125;</span><br><span class="line">    //使用硬件信息拼凑出来的15位号码</span><br><span class="line">    return new UUID(m_szDevIDShort.hashCode(), serial.hashCode()).toString();</span><br></pre></td></tr></table></figure>

<p>最终会得到类似于这样的一串ID：<code>00000000-088ee-388eb-ffff-ffffe93ee2</code></p>
<p>这种方案只能做到小范围内唯一</p>
<p>因为:</p>
<ul>
<li>系统升级后 该值可能会变化</li>
<li>同一批次出厂的设备可能出现值重复 </li>
</ul>
<p>总体来说 该方案可行性相对较高一些 重复的概率极低, 而且不需要获取用户权限</p>
<p>但是依然不够唯一</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>以上所有的方案似乎都只是理论唯一, 真要用到实际产品中还是差了点, 如果非要准确一些可以考虑以下方案:</p>
<h5 id="第一种"><a href="#第一种" class="headerlink" title="第一种"></a>第一种</h5><ul>
<li><code>Android 8.0</code>以下 使用 <code>PsuedoID + DeviceId</code> 来判断设备唯一性</li>
<li>Android 8.0及以上  使用<code>PsuedoID + ANDROID_ID</code>来判断设备唯一性</li>
</ul>
<h5 id="第二种"><a href="#第二种" class="headerlink" title="第二种"></a>第二种</h5><p>如果忽略大部分不能联网的设备, 可以使用<code>Mac</code>地址作为唯一标识, 由于<code>Android6.0</code>以上的版本无法获取<code>Mac</code>地址, 我们可以考虑从底层文件获取, <code>Mac</code>地址文件路径为:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/sys/class/net/wlan0/address</span><br></pre></td></tr></table></figure>

<p>具体代码如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fun getMacAddr(): String &#123;</span><br><span class="line">    return try &#123;</span><br><span class="line">        loadFileAsString(&quot;/sys/class/net/wlan0/address&quot;)</span><br><span class="line">            .toUpperCase().substring(0, 17)</span><br><span class="line">    &#125; catch (e: IOException) &#123;</span><br><span class="line">        e.printStackTrace()</span><br><span class="line">        &quot;&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Throws(IOException::class)</span><br><span class="line">private fun loadFileAsString(filePath: String): String &#123;</span><br><span class="line">    val fileData = StringBuffer(1000)</span><br><span class="line">    val reader = BufferedReader(FileReader(filePath))</span><br><span class="line">    val buf = CharArray(1024)</span><br><span class="line">    var numRead = 0</span><br><span class="line">    while (reader.read(buf).also &#123; numRead = it &#125; != -1) &#123;</span><br><span class="line">        val readData = String(buf, 0, numRead)</span><br><span class="line">        fileData.append(readData)</span><br><span class="line">    &#125;</span><br><span class="line">    reader.close()</span><br><span class="line">    return fileData.toString()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="第三种"><a href="#第三种" class="headerlink" title="第三种"></a>第三种</h5><p>使用第三方设备唯一标识提供商, 比如<strong>数字联盟</strong>, 对于<code>Android</code>和<code>IOS</code>设备均适用</p>
<p><strong>本文为作者原创转载时请注明出处 谢谢</strong></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em><a href="https://code.newban.cn/">乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</a></em></p>
]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>ANDROID跳转到手机自启动管理页面</title>
    <url>/346.html</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>有时候，为了确保APP的后台正常运行，需要让用户去设置打开APP的自启动权限（或者改为手动管理/huawei）。为了更好的用户体验，在APP中可以直接跳转到手机的自启动管理页面或者权限管理页面。</p>
<hr>
<h4 id="应用启动管理页面"><a href="#应用启动管理页面" class="headerlink" title="应用启动管理页面"></a>应用启动管理页面</h4><p><code>oppo/vivo</code>是没有这个页面的<br><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/85488098af0ed6049af38f6c344e5d7d.png" alt="华为"></p>
<ul>
<li><strong>华为</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ComponentName componentName = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">int</span> sdkVersion = Build.VERSION.SDK_INT;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    Intent intent = <span class="keyword">new</span> Intent();</span><br><span class="line">    intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);</span><br><span class="line">    <span class="comment">//跳自启动管理</span></span><br><span class="line">    <span class="keyword">if</span> (sdkVersion &gt;= <span class="number">28</span>)&#123;<span class="comment">//9:已测试</span></span><br><span class="line">        componentName = ComponentName.unflattenFromString(<span class="string">"com.huawei.systemmanager/.startupmgr.ui.StartupNormalAppListActivity"</span>);<span class="comment">//跳自启动管理</span></span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (sdkVersion &gt;= <span class="number">26</span>)&#123;<span class="comment">//8：已测试</span></span><br><span class="line">        componentName = ComponentName.unflattenFromString(<span class="string">"com.huawei.systemmanager/.appcontrol.activity.StartupAppControlActivity"</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (sdkVersion &gt;= <span class="number">23</span>)&#123;<span class="comment">//7.6：已测试</span></span><br><span class="line">        componentName = ComponentName.unflattenFromString(<span class="string">"com.huawei.systemmanager/.startupmgr.ui.StartupNormalAppListActivity"</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (sdkVersion &gt;= <span class="number">21</span>)&#123;<span class="comment">//5</span></span><br><span class="line">        componentName = ComponentName.unflattenFromString(<span class="string">"com.huawei.systemmanager/com.huawei.permissionmanager.ui.MainActivity"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//componentName = new ComponentName("com.huawei.systemmanager", "com.huawei.systemmanager.optimize.process.ProtectActivity");//锁屏清理</span></span><br><span class="line">    intent.setComponent(componentName);</span><br><span class="line">    startActivity(intent);</span><br><span class="line">&#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">	<span class="comment">//跳转失败</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123456789101112131415161718192021</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>小米</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Intent intent = <span class="keyword">new</span> Intent();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);</span><br><span class="line">    ComponentName componentName = <span class="keyword">null</span>;</span><br><span class="line">    componentName = <span class="keyword">new</span> ComponentName(<span class="string">"com.miui.securitycenter"</span>, <span class="string">"com.miui.permcenter.autostart.AutoStartManagementActivity"</span>);</span><br><span class="line">    intent.setComponent(componentName);</span><br><span class="line">    context.startActivity(intent);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;<span class="comment">//抛出异常就直接打开设置页面</span></span><br><span class="line">    jumpAPPInfo(context);</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">12345678910</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>三星</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Intent intent = <span class="keyword">new</span> Intent();</span><br><span class="line">ComponentName componentName = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);</span><br><span class="line">    <span class="comment">//跳自启动管理</span></span><br><span class="line">    componentName = ComponentName.unflattenFromString(<span class="string">"com.samsung.android.sm/.app.dashboard.SmartManagerDashBoardActivity"</span>);</span><br><span class="line">    intent.setComponent(componentName);</span><br><span class="line">    startActivity(intent);</span><br><span class="line">&#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        componentName = <span class="keyword">new</span> ComponentName(<span class="string">"com.samsung.android.sm_cn"</span>, <span class="string">"com.samsung.android.sm.ui.ram.AutoRunActivity"</span>);</span><br><span class="line">        intent.setComponent(componentName);</span><br><span class="line">        startActivity(intent);</span><br><span class="line">    &#125;<span class="keyword">catch</span> (Exception e1)&#123;</span><br><span class="line">        <span class="comment">//跳转失败</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1234567891011121314151617</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>魅族</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Intent intent = <span class="keyword">new</span> Intent();</span><br><span class="line">ComponentName componentName = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);</span><br><span class="line">    <span class="comment">//跳自启动管理</span></span><br><span class="line">    componentName = ComponentName.unflattenFromString(<span class="string">"com.meizu.safe/.permission.SmartBGActivity"</span>);<span class="comment">//跳转到后台管理页面</span></span><br><span class="line">    intent.setComponent(componentName);</span><br><span class="line">    startActivity(intent);</span><br><span class="line">&#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        componentName = ComponentName.unflattenFromString(<span class="string">"com.meizu.safe/.permission.PermissionMainActivity"</span>);<span class="comment">//跳转到手机管家</span></span><br><span class="line">        intent.setComponent(componentName);</span><br><span class="line">        startActivity(intent);</span><br><span class="line">    &#125;<span class="keyword">catch</span> (Exception e1)&#123;</span><br><span class="line">        <span class="comment">//跳转失败</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1234567891011121314151617</span></span><br></pre></td></tr></table></figure>

<hr>
<h4 id="权限管理页面"><a href="#权限管理页面" class="headerlink" title="权限管理页面"></a>权限管理页面</h4><p>这个页面重要的权限自启动、锁屏显示、后台弹出界面</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/03b40afbb51494b361fbb9e41ff0b172.png" alt="vivo"></p>
<ul>
<li><strong>vivo</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Intent localIntent;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (((Build.MODEL.contains(<span class="string">"Y85"</span>)) &amp;&amp; (!Build.MODEL.contains(<span class="string">"Y85A"</span>))) || (Build.MODEL.contains(<span class="string">"vivo Y53L"</span>))) &#123;</span><br><span class="line">        localIntent = <span class="keyword">new</span> Intent();</span><br><span class="line">        localIntent.setClassName(<span class="string">"com.vivo.permissionmanager"</span>, <span class="string">"com.vivo.permissionmanager.activity.PurviewTabActivity"</span>);</span><br><span class="line">        localIntent.putExtra(<span class="string">"packagename"</span>, context.getPackageName());</span><br><span class="line">        localIntent.putExtra(<span class="string">"tabId"</span>, <span class="string">"1"</span>);</span><br><span class="line">        context.startActivity(localIntent);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        localIntent = <span class="keyword">new</span> Intent();</span><br><span class="line">        localIntent.setClassName(<span class="string">"com.vivo.permissionmanager"</span>, <span class="string">"com.vivo.permissionmanager.activity.SoftPermissionDetailActivity"</span>);</span><br><span class="line">        localIntent.setAction(<span class="string">"secure.intent.action.softPermissionDetail"</span>);</span><br><span class="line">        localIntent.putExtra(<span class="string">"packagename"</span>, context.getPackageName());</span><br><span class="line">        context.startActivity(localIntent);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">    <span class="comment">// 否则跳转到应用详情</span></span><br><span class="line">    localIntent = <span class="keyword">new</span> Intent(Settings.ACTION_APPLICATION_DETAILS_SETTINGS);</span><br><span class="line">    Uri uri = Uri.fromParts(<span class="string">"package"</span>, context.getPackageName(), <span class="keyword">null</span>);</span><br><span class="line">    localIntent.setData(uri);</span><br><span class="line">    context.startActivity(localIntent);</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">12345678910111213141516171819202122</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>OPPO</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Intent intent = <span class="keyword">new</span> Intent();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);</span><br><span class="line">    intent.putExtra(<span class="string">"packageName"</span>, BuildConfig.APPLICATION_ID);</span><br><span class="line">    ComponentName comp = <span class="keyword">new</span> ComponentName(<span class="string">"com.color.safecenter"</span>, <span class="string">"com.color.safecenter.permission.PermissionManagerActivity"</span>);</span><br><span class="line">    intent.setComponent(comp);</span><br><span class="line">    startActivity(intent);</span><br><span class="line">&#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);</span><br><span class="line">        intent.putExtra(<span class="string">"pkg_name"</span>, context.getPackageName());</span><br><span class="line">        intent.putExtra(<span class="string">"app_name"</span>, context.getString(R.string.app_name));</span><br><span class="line">        intent.putExtra(<span class="string">"class_name"</span>, <span class="string">"com.welab.notificationdemo.MainActivity"</span>);</span><br><span class="line">        ComponentName comp = <span class="keyword">new</span> ComponentName(<span class="string">"com.coloros.notificationmanager"</span>, <span class="string">"com.coloros"</span> +</span><br><span class="line">                <span class="string">".notificationmanager.AppDetailPreferenceActivity"</span>);</span><br><span class="line">        intent.setComponent(comp);</span><br><span class="line">        startActivity(intent);</span><br><span class="line">    &#125;<span class="keyword">catch</span> (Exception e1)&#123;</span><br><span class="line">        <span class="comment">// 否则跳转到应用详情</span></span><br><span class="line">        intent = <span class="keyword">new</span> Intent(Settings.ACTION_APPLICATION_DETAILS_SETTINGS);</span><br><span class="line">        Uri uri = Uri.fromParts(<span class="string">"package"</span>, context.getPackageName(), <span class="keyword">null</span>);</span><br><span class="line">        intent.setData(uri);</span><br><span class="line">        context.startActivity(intent);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">12345678910111213141516171819202122232425</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>小米</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// MIUI 8</span></span><br><span class="line">    Intent localIntent = <span class="keyword">new</span> Intent(<span class="string">"miui.intent.action.APP_PERM_EDITOR"</span>);</span><br><span class="line">    localIntent.setClassName(<span class="string">"com.miui.securitycenter"</span>, <span class="string">"com.miui.permcenter.permissions.PermissionsEditorActivity"</span>);</span><br><span class="line">    localIntent.putExtra(<span class="string">"extra_pkgname"</span>, context.getPackageName());</span><br><span class="line">    context.startActivity(localIntent);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// MIUI 5/6/7</span></span><br><span class="line">        Intent localIntent = <span class="keyword">new</span> Intent(<span class="string">"miui.intent.action.APP_PERM_EDITOR"</span>);</span><br><span class="line">        localIntent.setClassName(<span class="string">"com.miui.securitycenter"</span>, <span class="string">"com.miui.permcenter.permissions.AppPermissionsEditorActivity"</span>);</span><br><span class="line">        localIntent.putExtra(<span class="string">"extra_pkgname"</span>, context.getPackageName());</span><br><span class="line">        context.startActivity(localIntent);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e1) &#123;</span><br><span class="line">        <span class="comment">// 否则跳转到应用详情</span></span><br><span class="line">        Intent intent = <span class="keyword">new</span> Intent(Settings.ACTION_APPLICATION_DETAILS_SETTINGS);</span><br><span class="line">        Uri uri = Uri.fromParts(<span class="string">"package"</span>, context.getPackageName(), <span class="keyword">null</span>);</span><br><span class="line">        intent.setData(uri);</span><br><span class="line">        context.startActivity(intent);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123456789101112131415161718192021</span></span><br></pre></td></tr></table></figure>

<h4 id="应用详情页面"><a href="#应用详情页面" class="headerlink" title="应用详情页面"></a>应用详情页面</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Intent intent = <span class="keyword">new</span> Intent(Settings.ACTION_APPLICATION_DETAILS_SETTINGS);</span><br><span class="line">Uri uri = Uri.fromParts(<span class="string">"package"</span>, context.getPackageName(), <span class="keyword">null</span>);</span><br><span class="line">intent.setData(uri);</span><br><span class="line">startActivity(intent);</span><br><span class="line"><span class="number">1234</span></span><br></pre></td></tr></table></figure>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>在其他应用上层显示、后台弹出界面、锁屏显示这三个权限会直接影响APP从后台启动活动，详情可以了解另一篇文章–&gt;<a href="https://blog.csdn.net/weixin_44021615/article/details/104609157" target="_blank" rel="noopener">Android 在后台无法启动Activity</a>。</p>
<h3 id="附加"><a href="#附加" class="headerlink" title="附加"></a>附加</h3><p><code>vivo/oppo/小米</code>手机有一个“后台弹出界面”权限, 华为是没有的, 可以使用以下代码来检测该权限是否开启:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isAllowed</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     AppOpsManager ops = (AppOpsManager) getSystemService(Context.APP_OPS_SERVICE);</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="keyword">int</span> op = <span class="number">10021</span>;</span><br><span class="line">         Method method = ops.getClass().getMethod(<span class="string">"checkOpNoThrow"</span>, <span class="keyword">new</span> Class[]&#123;<span class="keyword">int</span>.class, <span class="keyword">int</span>.class, String.class&#125;);</span><br><span class="line">         Integer result = (Integer) method.invoke(ops, op, Process.myUid(), getPackageName());</span><br><span class="line">         <span class="keyword">return</span> result == AppOpsManager.MODE_ALLOWED;</span><br><span class="line"> </span><br><span class="line">     &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">         Log.e(TAG, <span class="string">"not support"</span>);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p><strong>本文转载自</strong>:<a href="https://www.freesion.com/article/7753459867/" target="_blank" rel="noopener">https://www.freesion.com/article/7753459867/</a></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em><a href="https://code.newban.cn/">乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</a></em></p>
]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>下载视频m3u8格式视频的若干种方法</title>
    <url>/347.html</url>
    <content><![CDATA[<h2 id="第一种方法-使用ffmpeg工具"><a href="#第一种方法-使用ffmpeg工具" class="headerlink" title="第一种方法 使用ffmpeg工具"></a>第一种方法 使用ffmpeg工具</h2><p>先安装ffmpeg：</p>
<blockquote>
<p><strong>brew install ffmpeg</strong></p>
</blockquote>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/v2-a17cb10fcb6fa92e300f1da3642ab0a0_720w.jpg" alt="img"></p>
<p>ffmpeg安装完成</p>
<p><strong>ffmpeg使用：通过检查元素，元素定位，可以看到某视频地址的资源地址如下blob:URL的这种形式</strong></p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/v2-9718a385f10135d4907eebce7e158e8e_720w.jpg" alt="img"></p>
<p>然后通过查看Network，找到blob:URL地址背后的m3u8地址</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/v2-cf3ecc6496f532fcd956de52df1bda7e_720w.jpg" alt="img"></p>
<p><strong>用ffmpeg下载视频，并将m3u8格式转为mp4格式</strong>，指令如下</p>
<blockquote>
<p><strong>ffmpeg -i</strong> <a href="https://link.zhihu.com/?target=https%3A//youku.com-youku.net/20180620/13336_33db73a9/index.m3u8" target="_blank" rel="noopener">https://youku.com-youku.net/20180620/13336_33db73a9/index.m3u8</a> <strong>fileName.mp4</strong></p>
</blockquote>
<p>或</p>
<blockquote>
<p><strong>ffmpeg -i</strong> <a href="https://link.zhihu.com/?target=https%3A//youku.com-youku.net/20180620/13336_33db73a9/index.m3u8" target="_blank" rel="noopener">https://youku.com-youku.net/20180620/13336_33db73a9/index.m3u8</a> <strong>-c copy fileName.mp4</strong></p>
</blockquote>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/v2-6bbe97f1f8b56fef4740145be4c1f401_720w.jpg" alt="img"></p>
<p>如上下载中</p>
<p>由于视频很大，下载需要很长长长时间(1个G的视频可能需下载几小时…)。</p>
<p>可以通过如下指令进行<strong>下载提速</strong>（下载速度大约能提升到<strong>几到十几分钟</strong>，很棒了哦，起码比百度云快）：</p>
<blockquote>
<p><strong>ffmpeg -i</strong> <a href="https://link.zhihu.com/?target=https%3A//youku.com-youku.net/20180620/13336_33db73a9/index.m3u8" target="_blank" rel="noopener">https://youku.com-youku.net/20180620/13336_33db73a9/index.m3u8</a> <strong>-c copy -bsf:a aac_adtstoasc fileName.mp4</strong></p>
</blockquote>
<p>如果你想用终端工具拉起视频播放，直接通过如下指令就能 <strong>播放某链接的视频</strong></p>
<blockquote>
<p><strong>ffplay -i</strong> <a href="https://link.zhihu.com/?target=https%3A//youku.com-youku.net/20180620/13336_33db73a9/index.m3u8" target="_blank" rel="noopener">https://youku.com-youku.net/20180620/13336_33db73a9/index.m3u8</a></p>
</blockquote>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/v2-a927d74233b2b271f515901f8087576d_720w.jpg" alt="img"></p>
<p>下载完成，播放中</p>
<h2 id="第二种方法-使用Chrome插件Tampermonkey（油猴"><a href="#第二种方法-使用Chrome插件Tampermonkey（油猴" class="headerlink" title="第二种方法 使用Chrome插件Tampermonkey（油猴)"></a>第二种方法 使用Chrome插件Tampermonkey（油猴)</h2><p>关于Tampermonkey油猴的安装和基本使用，见我之前的一篇文章：</p>
<p><a href="https://zhuanlan.zhihu.com/p/341412928" target="_blank" rel="noopener">晒一下我常用的几款chrome 插件，你值得拥有</a></p>
<h3 id="这里介绍油猴中1个好用的脚本：media-source-extract"><a href="#这里介绍油猴中1个好用的脚本：media-source-extract" class="headerlink" title="这里介绍油猴中1个好用的脚本：media-source-extract"></a>这里介绍油猴中1个好用的脚本：media-source-extract</h3><p>在油猴脚本列表中暂时无法提供下载，目前需要手动创建安装，具体的视频下载和工具使用，见链接：</p>
<p><a href="https://github.com/Momo707577045/media-source-extract" target="_blank" rel="noopener">点击进入下载</a></p>
<p><code>media-source-extract</code>是一款提取视频画面和音频的工具，最终下载得到的是音频文件和视频画面文件。</p>
<p>因此可以通过合并音视频来完成最终的视频。</p>
<p>具体音视频合成方法网上有很多，我这边提供一套ffmpeg的合并方法，具体分2步走：</p>
<p>1、先把音频「audio_mp4」（或多个「audio_mp4」） 进行<strong>合并转码</strong>，转为.aac格式：命令行执行如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ffmpeg -i &quot;***-audio_mp4;codecs=***.mp4&quot; -acodec copy &quot;audio.aac&quot;</span><br></pre></td></tr></table></figure>

<p>（记得命令行先切换到音频所在的文件路径下）</p>
<p>2、再将原始视频「video_mp4」（或多个「video_mp4」），和上一步得到的 aac 「audio.aac」组装到一起，命令行执行如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ffmpeg -i &quot;***-video_mp4;codecs=***.mp4&quot; -i &quot;audio.aac&quot; -c copy -shortest &quot;result.mp4&quot;</span><br></pre></td></tr></table></figure>

<p>（记得命令行先切换到音频所在的文件路径下）</p>
<h3 id="最终result-mp4就是你要的合并了音频和画面的视频了！"><a href="#最终result-mp4就是你要的合并了音频和画面的视频了！" class="headerlink" title="最终result.mp4就是你要的合并了音频和画面的视频了！"></a>最终result.mp4就是你要的合并了音频和画面的视频了！</h3><p>media-source-extract这种提取音视频合并的方法，太麻烦了，有点像录屏的感觉。</p>
<p>下载操作的复杂度，以及过程可能会丢失的视频片段，我表示很淦。</p>
<p>但是作为一个下载方式，有价值，可作为备胎。</p>
<h3 id="再介绍1个比较好油猴插件：m3u8-downloader"><a href="#再介绍1个比较好油猴插件：m3u8-downloader" class="headerlink" title="再介绍1个比较好油猴插件：m3u8-downloader"></a>再介绍1个比较好油猴插件：m3u8-downloader</h3><p>在油猴脚本地址栏 <a href="https://link.zhihu.com/?target=https%3A//greasyfork.org/zh-CN/scripts%3Fq%3Dm3u8-downloader" target="_blank" rel="noopener">用户脚本</a> 中去搜索下载安装，如下图：</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/v2-ee45d0c93a265a3c1c8dca02285aae01_720w.jpg" alt="img"></p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/v2-7ab4ce4601118b72cb03f4da7977121c_720w.jpg" alt="img"></p>
<p>使用：譬如下载一部烂片 <a href="https://link.zhihu.com/?target=https%3A//www.gxwkxf.com/xingchenp/89599-1-1.html" target="_blank" rel="noopener">动作片《蛇蝎情人2003正片》免费在线播放-星空影院</a>，用google浏览器输入该视频网址，m3u8-downloader 脚本会自动识别blob:URL地址并拿到m3u8文件，如下：</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/v2-94c77990118e9bdff5fb0da627840483_720w.jpg" alt="img"></p>
<p>点击“跳转下载”，会跳转到下载页面</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/v2-94c77990118e9bdff5fb0da627840483_720w-20220805173702403.jpg" alt="img"></p>
<p>选择“原格式下载”或“转码为MP4下载”</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/v2-a1df751f4effd8fc3eef5b7463f2761b_720w.jpg" alt="img"></p>
<p>开始下载，同时可以看到下载进度，如下：</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/v2-db90f4d256a3f9a55f5e5ad61b1d66d2_720w.jpg" alt="img"></p>
<p>下载完成，本地播放，如图：</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/v2-84215873dcff9d34d9b4067adb97ca0d_720w.jpg" alt="img"></p>
<h2 id="第三种方法-使用NeatDownloadManager-Extension"><a href="#第三种方法-使用NeatDownloadManager-Extension" class="headerlink" title="第三种方法 使用NeatDownloadManager Extension"></a>第三种方法 使用NeatDownloadManager Extension</h2><p>这是一款我常用的插件，很好用。</p>
<p>可以去下载1个PC端软件 和 google插件</p>
<p>PC端NeatDownloadManager下载地址：<a href="https://link.zhihu.com/?target=http%3A//www.neatdownloadmanager.com/index.php/en/" target="_blank" rel="noopener">Neat Download Manager for Mac and Windows (Free Internet Download Manager Mac &amp; Windows )</a></p>
<p>安装后，界面如下</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/v2-6a432bee3ca67e72e73e52b043bdaeda_720w.jpg" alt="img"></p>
<p>在红色标记1的Setting中，可以设置对应代理，譬如常见的某d下载提速，可以像这样设置：</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/v2-7da9ed71415974b365e9af5bc307cac1_720w.jpg" alt="img"></p>
<p>红色标记2的Browsers中，点击“Add Chrome Extension”就可以给google浏览器添加该插件啦：</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/v2-328ff8e3e524ca967a3b66aacafe6e62_720w.jpg" alt="img"></p>
<p>当然也可以直接在google插件搜索 NeatDownloadManager Extension（需要f墙），进行安装：</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/v2-642344f4a2461b29227b50350e3f9505_720w.jpg" alt="img"></p>
<p>安装已经完成啦：</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/v2-80fd87838a3c1aaecba8776c99214d4b_720w.jpg" alt="img"></p>
<p>NeatDownloadManager Extension插件的使用：</p>
<p>我想下载温老的视频：<a href="https://link.zhihu.com/?target=https%3A//www.bilibili.com/video/BV1y44y1H7NN%3Ffrom%3Dsearch%26seid%3D17794320619746015840%26spm_id_from%3D333.337.0.0" target="_blank" rel="noopener">温铁军：四大文明古国为何只有中国没有灭亡？罗马的民主只对其10%的人口？【温铁军践闻录5-35】_哔哩哔哩_bilibili</a></p>
<p>在google浏览器里，打开该地址，就可以看到该插件拿到的视频资源：</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/v2-158f53d50a36edc65a7dfe0fa98c51b7_720w.jpg" alt="img"></p>
<p>点击那个size最大的视频资源，就会自动下载了：</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/v2-33d7425486b4c0d4e16aa5677eab813f_720w.jpg" alt="img"></p>
<p>下载完成</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/v2-36fcdbed33f3f18f9652c4797f485e3e_720w.jpg" alt="img"></p>
<p>搞定！</p>
<h2 id="第四种方法-使用视频下载器-CoCoCut"><a href="#第四种方法-使用视频下载器-CoCoCut" class="headerlink" title="第四种方法 使用视频下载器 - CoCoCut"></a>第四种方法 使用视频下载器 - CoCoCut</h2><p>在<code>google</code>网上应用商店（需要f墙），搜索“视频下载器 - CoCoCut”</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/v2-3919d3f6769e87439c1135e996e94621_720w.jpg" alt="img"></p>
<p>安装该插件：</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/v2-be27ebd818a82ae20b3d15fa3c086fb1_720w.jpg" alt="img"></p>
<p>视频下载器 - CoCoCut使用：</p>
<p>譬如我想下载一个电影，我在goolge 浏览器上随便找了一个电影网站：<a href="https://link.zhihu.com/?target=https%3A//v.iztyy.com/play/aHR0cHM6Ly93d3cuMzYwa2FuLmNvbS9tL2hLUGlaUkg0UUhQN1R4Lmh0bWw%3D.html" target="_blank" rel="noopener">《战狼2》高清完整版_最新电影_免费在线观看平台_猪蹄影院</a> ，然后该插件就会自动检测到该视频信息，点开该插件，就可以看到并执行下载了</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/v2-f895aa8f25e525ab5972bcabb70869e6_720w.jpg" alt="img"></p>
<p>下载中</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/v2-46cfba4c8aa4247e4a13dad31889a28b_720w.jpg" alt="img"></p>
<p>下载完成。</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/v2-b59aea33c51aefdd3202b24632f32fb2_720w.jpg" alt="img"></p>
<hr>
<p>最后，推荐几款我常用的解析.m3u8的在线网站：</p>
<p><a href="https://www.flvcd.com/index.htm" target="_blank" rel="noopener">FLVCD - 硕鼠官网|FLV下载|视频下载</a></p>
<p><a href="https://www.gihosoft.com/free-youtube-downloader.html" target="_blank" rel="noopener">Gihosoft TubeGet</a></p>
<p>真心希望，更多的技术为更多人使用。</p>
<p><strong>本文转载自</strong>:<a href="https://zhuanlan.zhihu.com/p/341412928" target="_blank" rel="noopener">知乎</a></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em><a href="https://code.newban.cn/">乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</a></em></p>
]]></content>
      <tags>
        <tag>下载工具</tag>
      </tags>
  </entry>
  <entry>
    <title>一款好用的搜索引擎推荐</title>
    <url>/349.html</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>周围不少小伙伴反应，最近搜索引擎的准确率越来越低了，有时候搜索官网都搜不到。</p>
<p>之前介绍过号称 “<a href="http://mp.weixin.qq.com/s?__biz=MzAwOTk3Mjg4Mg==&mid=2247488414&idx=1&sn=fd614803d9aab89b1ac85e84814e1d4e&chksm=9b562e63ac21a7751b5a85c5120e69d904436ffe855965685858d94cc0a3131dc16208f54d44&scene=21#wechat_redirect" target="_blank" rel="noopener">国内版 Google</a>” 的F搜，前不久还由于各种原因无法访问了。</p>
<p>今天一看发现，又回归了，域名也由 <code>fsou.cc</code>换成了 <code>fsoufsou.com</code>。界面也和<code>Google</code> 搜索越来越像了。</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/20220811122444.png" alt></p>
<p><strong>不过今天的重点不在这里，最近发现个超级牛的搜索引擎。</strong></p>
<p>网站走的简洁风格，但功能可不简单。汇聚了来自 <code>Google</code>，<code>Bing</code> 等70多个不同搜索引擎的结果。</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/20220811122505.png" alt></p>
<p>除了常规的网页和图片搜索，<strong>还支持视频，新闻，音乐，学术，文件，社交媒体等。</strong></p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/20220811122517.png" alt></p>
<p>还可以在首选项里设置里对不同标签开启不同的搜索引擎。比如常规类中只开启了<code>Google</code>，还可以开启<code>Bing</code>，<code>duckduckgo</code> 等搜索结果。</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/20220811122528.png" alt></p>
<p><strong>开启后你会发现搜索结果准确率又进一步提高。</strong>这个搜索引擎目前是开源的，人人都可以搭建。</p>
<p>不过，已经有很多大神已经搭建好了，镜像站点非常多，就没必要自己动手了。</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/20220811122540.png" alt></p>
<p><strong>只需要在 <a href="https://searx.space" target="_blank" rel="noopener">https://searx.space</a> 选择一个最快的站点就能访问了。</strong></p>
<p>通过这个搜索工具 可以搜到平常搜不到的东西 大家懂得</p>
<p><strong>本文转载自</strong>:<a href="https://mp.weixin.qq.com/s/NSODu5jFta_QS98qJw0oIA" target="_blank" rel="noopener">微信公众号</a></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em><a href="https://code.newban.cn/">乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</a></em></p>
]]></content>
      <tags>
        <tag>搜索工具</tag>
      </tags>
  </entry>
  <entry>
    <title>一款跨平台的m3u8视频下载工具</title>
    <url>/348.html</url>
    <content><![CDATA[<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>M3U8-Downloader是基于Electron框架开发的一款可以下载、播放HLS视频流的APP。</p>
<table>
<thead>
<tr>
<th align="left">功能</th>
<th align="left">支持</th>
</tr>
</thead>
<tbody><tr>
<td align="left">HLS标准源</td>
<td align="left">✓</td>
</tr>
<tr>
<td align="left">标准 AES-128-CBC加密</td>
<td align="left">✓</td>
</tr>
<tr>
<td align="left">标准 AES-196-CBC加密</td>
<td align="left">✓</td>
</tr>
<tr>
<td align="left">标准 AES-256-CBC加密</td>
<td align="left">✓</td>
</tr>
<tr>
<td align="left">非标准 AES-*-CBC加密</td>
<td align="left">ㄨ</td>
</tr>
</tbody></table>
<h3 id="开放源码-M3U8-Downloader"><a href="#开放源码-M3U8-Downloader" class="headerlink" title="开放源码 M3U8-Downloader"></a>开放源码 <a href="https://github.com/HeiSir2014/M3U8-Downloader" target="_blank" rel="noopener">M3U8-Downloader</a></h3><h5 id><a href="#" class="headerlink" title></a><a href="https://github.com/HeiSir2014/M3U8-Downloader/" target="_blank" rel="noopener"><img src="https://img.shields.io/github/stars/HeiSir2014/M3U8-Downloader?style=for-the-badge" alt="GitHub stars"></a></h5><h3 id="下载最新版-2-0-7-2022-01-26"><a href="#下载最新版-2-0-7-2022-01-26" class="headerlink" title="下载最新版 2.0.7 (2022-01-26)"></a>下载最新版 2.0.7 (2022-01-26)</h3><h5 id="百度网盘下载"><a href="#百度网盘下载" class="headerlink" title="百度网盘下载"></a>百度网盘下载</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">链接：https://pan.baidu.com/s/14zaMkxgfTC0HSge-Ze6EpQ 提取码：m3u8</span><br></pre></td></tr></table></figure>

<h5 id="阿里云盘下载"><a href="#阿里云盘下载" class="headerlink" title="阿里云盘下载"></a>阿里云盘下载</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">链接：https://www.aliyundrive.com/s/1QjQvn29W6J</span><br></pre></td></tr></table></figure>

<h3 id="使用展示"><a href="#使用展示" class="headerlink" title="使用展示"></a>使用展示</h3><p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/HLSDownloadShow-3-1.gif" alt="M3U8-Downloader 下载展示"><br><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/HLSDownloadShow-3-2.gif" alt="M3U8-Downloader 合并展示"><br><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/HLSDownloadShow-4.gif" alt="M3U8-Downloader 修复合并展示"></p>
<h3 id="HLS源怎么抓取呢？"><a href="#HLS源怎么抓取呢？" class="headerlink" title="HLS源怎么抓取呢？"></a>HLS源怎么抓取呢？</h3><p>在chrome浏览器打开视频网页，按下F12,页签点击到Network页面，在Filter框里输入”m3u8”,然后按F5刷新页面，如果网页里的视频使用的是HLS源，就可以在这里捕获到视频流地址，然后选中右键 Copy -&gt; Copy Link Address.</p>
<p>M3U8-Downloader 可以使用您提供m3u8源地址下载并无损转码Mp4文件。</p>
<iframe src="https://player.bilibili.com/player.html?aid=498666070&amp;bvid=BV1QK411n7VJ&amp;cid=206827525&amp;page=1&autoplay=false" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"></iframe>

<h3 id="关于-M3U8-Downloader"><a href="#关于-M3U8-Downloader" class="headerlink" title="关于 M3U8-Downloader"></a>关于 M3U8-Downloader</h3><p><a href="https://tools.heisir.cn/HLSDownload/" target="_blank" rel="noopener">点击进入官网</a></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em><a href="https://code.newban.cn/">乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</a></em></p>
]]></content>
      <tags>
        <tag>下载工具</tag>
      </tags>
  </entry>
  <entry>
    <title>Python的.sort()方法和sorted（）比较总结</title>
    <url>/35.html</url>
    <content><![CDATA[<h4 id="1，-sort（）方法"><a href="#1，-sort（）方法" class="headerlink" title="1，.sort（）方法"></a>1，.sort（）方法</h4><p>　　使用方式是：列表.sort(),作用是将原来的列表正序排序，所以它是对原来的列表进行的操作，不会产生一个新列表，例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import  random</span><br><span class="line">numList=[]</span><br><span class="line">print(numList)</span><br><span class="line">for i in range(10):</span><br><span class="line">    numList.append(random.randrange(1,10))# 不包括10</span><br><span class="line">print(&quot;未排序的列表：&quot;,numList)</span><br><span class="line"># numList.sort()执行过程是将列表拍完序后又赋值给了原列表</span><br><span class="line">numList.sort()</span><br><span class="line">print(&quot;排序后列表：&quot;,numList)</span><br><span class="line"># 无法将numList.sort()赋值给一个新列表，以为它并不返回一个新列表</span><br><span class="line">numList=numList.sort()</span><br><span class="line">print(&quot;无法赋值给新列表的的结果：&quot;,numList)</span><br></pre></td></tr></table></figure>

<p>执行结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">未排序的列表： [7, 2, 2, 4, 5, 6, 7, 9, 4, 8]</span><br><span class="line">排序后列表： [2, 2, 4, 4, 5, 6, 7, 7, 8, 9]</span><br><span class="line">无法赋值给新列表的的结果： None</span><br></pre></td></tr></table></figure>

<h4 id="2，sorted-列表-是Python内置函数，该函数对原列表不会产生影响，只是在原来列表的基础上，产生一个有序的新列表，可以复制一个列表名"><a href="#2，sorted-列表-是Python内置函数，该函数对原列表不会产生影响，只是在原来列表的基础上，产生一个有序的新列表，可以复制一个列表名" class="headerlink" title="2，sorted(列表),是Python内置函数，该函数对原列表不会产生影响，只是在原来列表的基础上，产生一个有序的新列表，可以复制一个列表名"></a>2，sorted(列表),是Python内置函数，该函数对原列表不会产生影响，只是在原来列表的基础上，产生一个有序的新列表，可以复制一个列表名</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import  random</span><br><span class="line">numList=[]</span><br><span class="line">print(numList)</span><br><span class="line">for i in range(10):</span><br><span class="line">    numList.append(random.randrange(1,10))# 不包括10</span><br><span class="line">print(&quot;未排序的列表：&quot;,numList)</span><br><span class="line"></span><br><span class="line">sorted(numList)</span><br><span class="line">print(&quot;sorted排序后的数组，不会对原列表有任何影响：&quot;,numList)</span><br><span class="line">getList=sorted(numList)</span><br><span class="line">print(&quot;sorted获得的新的列表：&quot;,getList)</span><br></pre></td></tr></table></figure>

<p>执行结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">未排序的列表： [1, 4, 3, 4, 3, 9, 5, 4, 4, 9]</span><br><span class="line">sorted排序后的数组，不会对原列表有任何影响： [1, 4, 3, 4, 3, 9, 5, 4, 4, 9]</span><br><span class="line">sorted获得的新的列表： [1, 3, 3, 4, 4, 4, 4, 5, 9, 9]</span><br></pre></td></tr></table></figure>










<p><strong>本文为作者原创 转载时请注明出处 谢谢</strong></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em>乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</em></p>
]]></content>
      <tags>
        <tag>python基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Youtube的山寨版LibreTube国内直连</title>
    <url>/350.html</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p><strong>发现一款软件 - LibreTube，看这名字就知道八成是 Youtube 的山寨版</strong>。</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/20220811122931.png" alt>请忽略google的渣翻译</p>
<p>打开 APP 后长这样，直接访问无压力：</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/20220811122945.png" alt></p>
<p>界面设计的看起来还是不错的，<strong>视频刚打开需要多缓冲几秒。</strong></p>
<p>左上角的设置里还可以设置不同国家和视频源，默认分辨率等。<strong>速度慢可以在【选择实例】里切换其他的\</strong>实例*<em>。*</em></p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/20220811123003.png" alt></p>
<p><strong>搜索功能也同样好用</strong>，经过小编测试，动漫新番，包括最近比较火的电视剧都能搜到，关键还都是正版。</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/20220811123046.png" alt></p>
<p>视频播放器还自带字幕，变速功能。这么多年过去了，神仙姐姐依旧那么好看<img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/20220811123148.png" alt></p>
<p><strong>另外还可以把喜欢的视频下载下来，订阅喜欢的频道，非常方便。</strong></p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/20220811123227.png" alt></p>
<p><strong>APP 是免费开源的</strong>，安装包只有 13.7MB，不得不说，开源牛逼，开源万岁。</p>
<p>由于直接从 <a href="https://github.com/libre-tube/LibreTube" target="_blank" rel="noopener">Github</a> 下载太慢，小编已经将 apk 安装包上传到了网盘。</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/20220811123251.png" alt></p>
<p>最后附上下载地址：</p>
<ul>
<li><p>GitHub: <a href="https://github.com/libre-tube/LibreTube/releases" target="_blank" rel="noopener">点击下载</a></p>
</li>
<li><p>蓝奏网盘: <a href="https://wws.lanzoub.com/b00vrggxe" target="_blank" rel="noopener">点击下载</a></p>
</li>
</ul>
<p><strong>本文转载自</strong>:<a href="https://mp.weixin.qq.com/s/-U6iWNORpz-cGKOLvAKSiQ" target="_blank" rel="noopener">微信公众号</a></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em><a href="https://code.newban.cn/">乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</a></em></p>
]]></content>
      <tags>
        <tag>Youtube</tag>
      </tags>
  </entry>
  <entry>
    <title>关于虚幻引擎位置迁移之路径修改</title>
    <url>/351.html</url>
    <content><![CDATA[<h3 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h3><p>最近换了硬盘 打算将原来的虚幻引擎迁移到另一块硬盘 但是当我将引擎文件拷贝过去后 虚幻启动程序并未识别  然而设置面板中又没有关于这一块路径的修改</p>
<p>难道我得重新下载一遍? 这我肯定是不能接受的呀</p>
<p>于是乎我百度了一番经过尝试之后发现一个方法可行</p>
<h3 id="解决方案一"><a href="#解决方案一" class="headerlink" title="解决方案一"></a>解决方案一</h3><p>重新下载引擎 然后选择新的引擎下载路径 该路径是你新硬盘位置  </p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20220822145537993.png" alt="image-20220822145537993"></p>
<p>下载开始后硬盘中会自动生成相应的引擎目录 此时暂停下载  紧接着将旧引擎迁移至该目录下 最后重启<code>Epic Games Launcher</code>即可</p>
<h3 id="解决方案二"><a href="#解决方案二" class="headerlink" title="解决方案二"></a>解决方案二</h3><p>进入虚幻<code>support</code>目录 修改<code>install.in</code>文件, <code>Mac</code>系统路径如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/Users/你的用户名/Library/Application Support/Epic/UnrealEngine/install.in</span><br></pre></td></tr></table></figure>

<p>用文本文件打开 然后修改对应的路径即可</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20220822150921510.png" alt="image-20220822150921510"></p>
<p>同样的 最后重启<code>Epic Games Launcher</code>即可</p>
<p><strong>本文为作者原创转载时请注明出处 谢谢</strong></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em><a href="https://code.newban.cn/">乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</a></em></p>
]]></content>
      <tags>
        <tag>虚幻</tag>
      </tags>
  </entry>
  <entry>
    <title>使用ACME搭配freessl网站实现免费https证书的生成和更新</title>
    <url>/355.html</url>
    <content><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>最近在使用<code>netlify</code>的静态网站托管服务, 如果需要自定义域名的话 需要提供<code>https</code>证书, 如下图:</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20220902113147959.png" alt="image-20220902113147959"></p>
<h3 id="SSL证书介绍"><a href="#SSL证书介绍" class="headerlink" title="SSL证书介绍"></a>SSL证书介绍</h3><p>是一种配置在服务器上的数字证书, 由可信的数字证书颁发机构（CA）颁发, 类似于我们的驾驶证, 它具有服务器身份验证和数据传输加密功能。</p>
<p>证书实际上就是几串字符密钥 以文本的形式存放在诸如<code>.key</code>  <code>.cer</code>   <code>.csr</code> 结尾的文件中:</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20220902121037323.png" alt="image-20220902121037323"></p>
<p>文件介绍:</p>
<ul>
<li><code>.key</code>文件: 证书私钥</li>
<li><code>.cer</code>文件: <code>certificate</code>的缩写,这就是数字证书</li>
<li><code>.csr</code>文件:<code>certificate signing request</code>的缩写 证书签名请求文件，含有公钥信息</li>
</ul>
<p>这些文件需要存放在服务器中, 当浏览器通过域名对服务器进行访问时, 可获取服务器中的证书, 证书中含有公钥</p>
<p>那么浏览器和服务器  一个持有私钥一个持有公钥  进行加密会话 保证数据安全</p>
<h3 id="自制SSL证书"><a href="#自制SSL证书" class="headerlink" title="自制SSL证书"></a>自制SSL证书</h3><p>既然所谓的证书就是<code>RSA</code>密钥, 那我们自然可以自己生成, 比如:</p>
<p><a href="https://myssl.com/csr_create.html" target="_blank" rel="noopener">在线生成SSL证书</a></p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20220902142026451.png" alt="image-20220902142026451"></p>
<p>但是这种自己颁发的证书是不被浏览器认可的, 就好比自己给自己手写一张驾驶证, 完全没有任何法律效力</p>
<p>因此我们只能向<code>CA</code>机构申请证书, 国际知名的<code>CA</code>机构有<code>GeoTrust</code>、<code>Comodo</code>、<code>DigiCert</code>、<code>Sectigo</code>、<code>Thawte</code>、<code>GlobalSign</code>、<code>Symantec</code>、<code>AlphaSSL</code>等 </p>
<p>大部分都是收费的, 那么我们要用免费的话, 可以退而求其次,<code>freessl</code>这个平台是个不错的选择</p>
<h3 id="freessl-cn"><a href="#freessl-cn" class="headerlink" title="freessl.cn"></a>freessl.cn</h3><p>该网站免费提供由<code>Let&#39;s Encrypt</code> 与 <code>TrustAsia</code>两家<code>CA</code>机构颁发的<code>SSL</code>证书, 我们注册后即可免费申请, 但是证书有效期只有三个月, 到期后需要重新申请</p>
<p>为了解决自动续期的问题 我们需要用到一个工具, 那就是<code>acme.sh</code></p>
<h3 id="ACME-SH"><a href="#ACME-SH" class="headerlink" title="ACME.SH"></a>ACME.SH</h3><p><code>acme.sh</code>是一个数字证书管理工具, 利用它我们可以:</p>
<ul>
<li>辅助申请<code>SSL</code>证书文件到本地</li>
<li>内置定时程序 到期自动申请证书</li>
<li>安装证书到指定目录</li>
</ul>
<p><a href="https://github.com/acmesh-official/acme.sh" target="_blank" rel="noopener">GitHub地址</a></p>
<h5 id="工具使用"><a href="#工具使用" class="headerlink" title="工具使用"></a>工具使用</h5><ol>
<li><p><strong>工具安装</strong></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> https://github.com/acmesh-official/acme.sh.git</span><br><span class="line">$ <span class="built_in">cd</span> ./acme.sh</span><br><span class="line">$ ./acme.sh --install -m my@example.com</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>证书申请</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">acme.sh --issue -d 域名 -w 证书存放目录</span><br></pre></td></tr></table></figure>

<p><code>acme.sh</code> 默认会从<a href="https://zerossl.com/" target="_blank" rel="noopener">zerossl</a>获取证书, <code>zerossl</code>和<code>freessl.cn</code>一样, 也是一个证书中介网站 ,<code>zerossl</code>提供由<code>Let&#39;s Encrypt</code> 颁发的数字证书, 每个注册账户可以申请三个免费证书</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20220902150909721.png" alt="image-20220902150909721"></p>
<p>但是 由于免费的数量有限 所以我们不选择从<code>zerossl</code>获取</p>
<p>如果只是临时测试用的话 可以用一用 直接在官网申请并下载证书<code>zip</code>包即可:</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20220902151803041.png" alt="image-20220902151803041"></p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20220902152401511.png" alt="image-20220902152401511"></p>
<p>考虑到长期使用, 因此我们选择<code>freessl.cn</code></p>
</li>
<li><p><strong>从<code>freessl.cn</code>获取证书</strong></p>
<p><code>freessl</code>支持<code>acme</code>自动化</p>
<p>在网站输入域名并且进行校验后会生成一个<code>acme</code>地址, 这个地址相当于账号凭证, 利用这个它我们可以借助<code>acme.sh</code>快速获取证书:</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20220902152759063.png" alt="image-20220902152759063"></p>
<p>具体指令如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">acme.sh --issue -d 域名  --dns dns_dp --server 你的acme地址</span><br></pre></td></tr></table></figure>

<p>执行后自动将证书下载到本地:</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20220902113332949.png" alt="image-20220902113332949"></p>
<p>最后我们将证书密钥拷贝至托管服务器中, 这里以<code>netlify</code>为例:</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20220902154250607.png" alt="image-20220902154250607"></p>
<p>填写完后点击安装, 证书成功识别</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20220902113754771.png" alt="image-20220902113754771"></p>
<p>此时 我们即可通过自定义域名访问<code>netlify</code>中的静态网站了, 在浏览器中可以查看当前获取到的证书信息:</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20220902141040045.png" alt="image-20220902141040045"></p>
</li>
</ol>
<h3 id="关于自动更新"><a href="#关于自动更新" class="headerlink" title="关于自动更新"></a>关于自动更新</h3><p>通常我们会将<code>acme.sh</code>安装至服务器中, 然后实现证书的自动更新, 由于我这边使用的是<code>netlify</code>, 所以三个月到期后需要手动执行一下代码</p>
<p>更多关于<code>acme.sh</code>自动化的用法, 可以参见《<a href="https://code.newban.cn/356.html">acme.sh证书自动部署教程</a>》</p>
<h3 id="其他可以获取免费SSL证书的网站"><a href="#其他可以获取免费SSL证书的网站" class="headerlink" title="其他可以获取免费SSL证书的网站"></a>其他可以获取免费SSL证书的网站</h3><ul>
<li><strong>OHTTPS</strong>: <a href="https://ohttps.com/" target="_blank" rel="noopener">https://ohttps.com/</a></li>
</ul>
<p><strong>本文为作者原创转载时请注明出处 谢谢</strong></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em><a href="https://code.newban.cn/">乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</a></em></p>
]]></content>
      <tags>
        <tag>ssl</tag>
      </tags>
  </entry>
  <entry>
    <title>虚幻蓝图快速上手</title>
    <url>/353.html</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>蓝图 实际上也是一门编程语言 一种图形化的语言  </p>
<p>使用蓝图 可以使开发者们省去代码的编写  即便你不会代码 也能进行游戏开发 </p>
<p>这一点 很大程度地吸引了许许多多的游戏爱好者的加入</p>
<p>……</p>
<p>如果你有编程基础的话 那么蓝图上手会非常的快, 接下来 我们来快速入门</p>
<h4 id="语言类比"><a href="#语言类比" class="headerlink" title="语言类比"></a>语言类比</h4><p>我们知道 正常的编程的语言 基本上都有变量 函数的概念, 蓝图既然是一门语言, 那么它自然也有  只不过表现形式不太一样罢了</p>
<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><ol>
<li><p><strong>蓝图中函数的表现形式</strong></p>
<p>在蓝图中 每一个蓝图节点我们可以视作一个函数</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20220829152437687.png" alt="image-20220829152437687"></p>
</li>
<li><p><strong>函数的定义</strong></p>
<p>虚幻引擎给我们封装好了许多函数 比如打印字符串的函数 给物体添加材质的函数等等</p>
<p>如果我们想要自定义一个函数呢, 那么直接在左侧面板中添加一个新函数, 比如 我定义一个名为<code>Test</code>的函数  内部逻辑是比较传入的值是否等于3</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20220829180025489.png" alt="image-20220829180025489"></p>
<p>函数创建好后可以在蓝图事件表中通过鼠标右键进行名称搜索使用:</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20220829180313058.png" alt="image-20220829180313058"></p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20220829180354133.png" alt="image-20220829180354133"></p>
</li>
<li><p><strong>函数的调用</strong></p>
<p>节点连线可以表示函数调用和传参, 这种箭头形状的输入口 表示的就是函数调用, 左边调用右边</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20220829152624719.png" alt="image-20220829152624719"></p>
</li>
<li><p><strong>函数传参</strong></p>
<p>蓝图节点左侧下方的一系列入口 可以理解为函数参数的传递入口:</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20220829170225676.png" alt="image-20220829170225676"></p>
</li>
</ol>
<h3 id="事件监听"><a href="#事件监听" class="headerlink" title="事件监听"></a>事件监听</h3><p>现代程序的编写几乎离不开监听回调, 在设计模式的领域中也叫做观察者者模式, 我们可以在蓝图编辑面板中左侧查看当前创建事件:</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20220919152646963.png" alt="image-20220919152646963"></p>
<p>事件主要用于蓝图类之间的信息交互, 当关卡中的某一个子物体需要和所处关卡进行通信时, 我们可以在关卡蓝图中自定义一个事件, 然后子物体蓝图中调用触发:</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20220919153104557.png" alt="image-20220919153104557"></p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20220919153620945.png" alt="image-20220919153620945"></p>
<p>事件触发命令格式为: <code>ce 事件名</code></p>
<blockquote>
<p>关卡蓝图是当前关卡内所有物体的父级 它可以获取到物体的实例 很容易和子物体进行数据通信, 但是物体并不持有关卡的实例, 所以信息交互需要依靠事件</p>
</blockquote>
<h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><ol>
<li><p><strong>定义全局变量</strong></p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20220829152044387.png" alt></p>
<p>添加变量后 我们可以在属性细节面板中 设置变量的数据类型</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20220829153316870.png" alt="image-20220829153316870">    </p>
</li>
<li><p><strong>定义局部变量</strong></p>
<p>在左侧面板中 点击鼠标右键调出菜单 可以增加局部变量的设置入口, 其操作和使用与全局变量一样 这里不再赘述</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20220829155333576.png" alt="image-20220829155333576"></p>
</li>
<li><p><strong>初始化变量的值</strong></p>
<p>通常情况下 我们在定义变量的同时 会对该变量进行值的初始化</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20220829153622095.png" alt="image-20220829153622095"></p>
</li>
<li><p><strong>获取变量值</strong></p>
<p>程序运行时  我们需要动态读取变量的值, 此时我们按住Ctrl键  然后鼠标左键将变量拖拽至事件图标中 </p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/getvar.gif" alt="getvar"></p>
<p>此时会生成一个获取变量值的函数(蓝图节点)</p>
</li>
<li><p><strong>设置变量的值</strong></p>
<p>同样的 我们要生成一个设置变量值的函数时, 按住Alt键 然后鼠标左键将变量拖拽至事件图标中即可</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/setvar.gif" alt="setvar"></p>
</li>
</ol>
<h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><p>任何一门编程语言都有注释  方便我们对于程序的维护  蓝图自然也有</p>
<p>选中你需要进行注释的蓝图节点 然后按键盘C  则会出现一个方块将选中的节点包裹  此时可以输入注释内容</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20220829153005361.png" alt="image-20220829153005361"></p>
<h3 id="逻辑执行"><a href="#逻辑执行" class="headerlink" title="逻辑执行"></a>逻辑执行</h3><p>比如我们要执行一个在屏幕上打印字符串的逻辑, 那么我们可以在游戏启动的时候 调用打印字符串的函数(节点)</p>
<p>事件开始运行 这个函数 表示的就是游戏启动的 相当于<code>Java</code>中的<code>main</code>函数, 只执行一次</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20220829160253326.png" alt="image-20220829160253326"></p>
<p>编写好逻辑后 运行游戏 就能看到屏幕上打印的内容了</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/printString.gif" alt="printString"></p>
<h3 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h3><p>蓝图是一门面向对象的编程语言  在游戏中每一个物体都是一个对象 </p>
<ol>
<li><p><strong>创建对象</strong></p>
<p>在世界大纲中显示的所有物体都是对象 </p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20220829161621529.png" alt="image-20220829161621529"></p>
<p> 而创建对象方法很简单就是直接将素材拖拽至场景中</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/2022-08-29%2016-32-03.2022-08-29%2016_34_17.gif" alt="2022-08-29 16-32-03.2022-08-29 16_34_17"></p>
<p>有些素材拖入场景后世界大纲中找不到 比如材质 说明该素材在蓝图事件表中不能直接通过右键的方式来创建对象引用</p>
<p>材质比较特殊 对硬件资源消耗比较大  我们通常会在材质基础上创建材质实例 其好处是一方面减少资源消耗 另一方面可以暴露参数在游戏过程中动态修改属性</p>
<p>对于材质对象的创建 我们可以选中对应材质 然后鼠标右键创建材质实例:</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20220829170844561.png" alt="image-20220829170844561"></p>
<p>点击创建后 素材面板会多出一个材质实例, 这个实例是材质的子类:</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20220829171302287.png" alt="image-20220829171302287"></p>
<p>我们可以在蓝图中创建数组变量来存放该实例:</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20220829173504954.png" alt="image-20220829173504954"></p>
</li>
<li><p><strong>获取对象实例</strong></p>
<p>我们只需在场景或者世界大纲中选中需要引用的物体对象, 然后在蓝图事件表中 右键创建对象引用节点即可</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20220829164655130.png" alt="image-20220829164655130"></p>
<p>动图操作如下:</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/2022-08-29%2016-48-00.2022-08-29%2016_49_34.gif" alt="2022-08-29 16-48-00.2022-08-29 16_49_34"></p>
</li>
<li><p>修改对象属性</p>
<p>比如修改某个物体的位置属性, 我们可以在游戏启动时调用位置修改函数</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20220829165958763.png" alt="image-20220829165958763"></p>
</li>
</ol>
<h3 id="关卡蓝图和蓝图类"><a href="#关卡蓝图和蓝图类" class="headerlink" title="关卡蓝图和蓝图类"></a>关卡蓝图和蓝图类</h3><ul>
<li><strong>关卡蓝图</strong>: 重点在关卡 而不是蓝图  是指以蓝图语言编辑的关卡 </li>
<li><strong>蓝图类</strong>: 重点在类 是指以蓝图语言定义和编辑的类</li>
</ul>
<p>在游戏引擎中  关卡本质就是一个集合了众多<code>Actor</code>的类</p>
<h3 id="虚幻引擎类继承关系"><a href="#虚幻引擎类继承关系" class="headerlink" title="虚幻引擎类继承关系"></a>虚幻引擎类继承关系</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">        |--Actor--Pawn--Character</span><br><span class="line">        |</span><br><span class="line">Object--|--PlayerController</span><br><span class="line">				|</span><br><span class="line">				|--Info--GameModeBase</span><br><span class="line">				|</span><br><span class="line">				|--ActorComponent--SceneComponent</span><br></pre></td></tr></table></figure>

<h3 id="开发文档参考"><a href="#开发文档参考" class="headerlink" title="开发文档参考"></a>开发文档参考</h3><p><a href="https://docs.unrealengine.com/4.27/zh-CN/Basics/GettingStarted/" target="_blank" rel="noopener">官方文档</a></p>
<p><strong>本文为作者原创转载时请注明出处 谢谢</strong></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em><a href="https://code.newban.cn/">乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</a></em></p>
]]></content>
      <tags>
        <tag>虚幻</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Hugo搭建个人博客</title>
    <url>/354.html</url>
    <content><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p><code>Hugo</code>和<code>Hexo</code>类似, 也是一个搭建静态博客的工具, <code>Hugo</code>由<code>Go</code>语言编写,相比之下 <code>Hugo</code>编译速度要比<code>Hexo</code>快很多</p>
<p>不过各有各的优点, 目前我两个工具都在用, 主要还是以<code>Hexo</code>为主</p>
<p>接下来介绍<code>Hugo</code>的使用</p>
<h3 id="工具安装"><a href="#工具安装" class="headerlink" title="工具安装"></a>工具安装</h3><ol>
<li><p><strong>Mac用户</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">brew install hugo</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>Windows用户</strong></p>
<p><a href="https://github.com/gohugoio/hugo/releases" target="_blank" rel="noopener">GitHub下载安装包</a></p>
<p>下载完后 给<code>hugo.exe</code>配置环境变量, 方便任意目录使用该程序</p>
</li>
</ol>
<p>安装完后 可以在命令窗口输入<code>hugo version</code> 来检测是否安装成功</p>
<h3 id="工具基础使用"><a href="#工具基础使用" class="headerlink" title="工具基础使用"></a>工具基础使用</h3><ol>
<li><p><strong>创建博客空工程</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hugo new site 项目名称</span><br></pre></td></tr></table></figure>

<p>执行完后会在当前目录下生成工程文件夹:</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20220901170044828.png" alt="image-20220901170044828"></p>
<p>目录介绍:</p>
<ul>
<li><strong>content目录</strong>: 用于存放博客文章</li>
<li><strong>themes目录</strong>: 用于存放博客主题</li>
<li><strong>static目录</strong>: 该目录下文件不会被渲染 可用于存放静态资源 比如图片<code>js</code> <code>css</code>以及<code>CNAME</code>等等</li>
<li><strong>archetypes目录</strong>:里面存放文章模版文件</li>
<li><strong>data目录</strong>:用于存放数据</li>
<li><strong>layouts目录</strong>:用于存放布局文件</li>
<li><strong>config.toml文件</strong>: 配置文件</li>
</ul>
</li>
<li><p><strong>新建文章</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hugo new post/first.md</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>下载博客主题</strong></p>
<p>博客必须要有一个主题 不然渲染出来的页面是空白, 我们以<code>hyde</code>主题为例:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 创建 themes 目录</span><br><span class="line">$ cd themes</span><br><span class="line">$ git clone https://github.com/spf13/hyde.git</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>生成静态文件</strong></p>
<p>需要指定以那个主题进行静态页面渲染</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hugo --theme=hyde</span><br></pre></td></tr></table></figure>

<p>此时目录下会自动生成一个<code>public</code>目录, 里面的文件即为生成的静态文件, 可以直接部署到网站</p>
</li>
<li><p><strong>部署到<code>GitHub</code></strong></p>
<p>添加静态仓库关联:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ cd public</span><br><span class="line">$ git init</span><br><span class="line">$ git remote add origin https://github.com/xxx/xxx.github.io.git</span><br></pre></td></tr></table></figure>

<p>或者使用submodule的方式:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git submodule add -f -b master https://github.com/xxx/xxx.github.io.git public</span><br></pre></td></tr></table></figure>

<p>最后将静态文件推送到仓库:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">$ git add -A</span><br><span class="line">$ git commit -m &quot;first commit&quot;</span><br><span class="line">$ git push -u origin master</span><br></pre></td></tr></table></figure>

<p>部署这一块 相比<code>hexo</code>要繁琐一些, 我们可以使用脚本或者用<code>GitHub actions</code>自动部署</p>
</li>
</ol>
<h3 id="其他命令"><a href="#其他命令" class="headerlink" title="其他命令"></a>其他命令</h3><ol>
<li><p><strong>生成独立页面</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hugo new about.md</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>博客本地调试</strong></p>
<p>调试时同样需要指定一个主题</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hugo server --theme=hyde</span><br></pre></td></tr></table></figure>

<p>服务启动后 浏览器里打开： <code>http://localhost:1313</code>, 即可看到当前博客页面, 修改文章动态更新</p>
<p>如果需要让草稿一并加入调试 那么可以加入<code>-D</code>:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hugo server --theme=hyde -D</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>生成静态文件时草稿也进行渲染</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hugo  --theme=hyde -D</span><br></pre></td></tr></table></figure>

<p>必须是大写的<code>D</code></p>
</li>
</ol>
<h3 id="进阶使用"><a href="#进阶使用" class="headerlink" title="进阶使用"></a>进阶使用</h3><ol>
<li><p>每次执行指令都要指定主题太过繁琐?  没事 我们在配置文件中添加以下代码 配置默认主题即可解决烦恼</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 主题名称</span><br><span class="line">theme = &quot;hyde&quot;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20220901174231361.png" alt="image-20220901174231361"></p>
</li>
<li><p>自定义域名无法访问?</p>
<ol>
<li>需要在配置文件中将<code>baseURL</code>参数替换成你的域名</li>
<li>同时在<code>static</code>目录下新建<code>CNAME</code>文件, 然后输入你的域名</li>
</ol>
</li>
</ol>
<p><strong>本文为作者原创转载时请注明出处 谢谢</strong></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em><a href="https://code.newban.cn/">乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</a></em></p>
]]></content>
      <tags>
        <tag>Hugo</tag>
      </tags>
  </entry>
  <entry>
    <title>JS读取本地json文件的方法汇总</title>
    <url>/357.html</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>对于单纯的静态网站而言, 我们有时候可能会直接将<code>json</code>数据放在本地, 此时涉及到<code>json</code>文件内容读取的问题</p>
<p>假设<code>html</code>同级目录下有一个名为<code>data.json</code>的文件, 读取的方式有:</p>
<h3 id="第一种-使用ajax"><a href="#第一种-使用ajax" class="headerlink" title="第一种 使用ajax"></a>第一种 使用ajax</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$.ajax(&#123;</span><br><span class="line">                url: <span class="string">"data.json"</span>,<span class="comment">//同文件夹下的json文件路径</span></span><br><span class="line">                type: <span class="string">"GET"</span>,<span class="comment">//请求方式为get</span></span><br><span class="line">                dataType: <span class="string">"json"</span>, <span class="comment">//返回数据格式为json</span></span><br><span class="line">                success: <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;<span class="comment">//请求成功完成后要执行的方法 </span></span><br><span class="line">                    <span class="built_in">console</span>.log(data);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;)</span><br></pre></td></tr></table></figure>

<h3 id="第二种-getJson"><a href="#第二种-getJson" class="headerlink" title="第二种 getJson"></a>第二种 getJson</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$.getJSON(<span class="string">"data.json"</span>, <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">              <span class="built_in">console</span>.log(data)</span><br><span class="line">          &#125;);</span><br></pre></td></tr></table></figure>

<h3 id="第三种-使用原生XMLHttpRequest"><a href="#第三种-使用原生XMLHttpRequest" class="headerlink" title="第三种 使用原生XMLHttpRequest"></a>第三种 使用原生XMLHttpRequest</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> url = <span class="string">"data.json"</span></span><br><span class="line"><span class="comment">// 申明一个XMLHttpRequest</span></span><br><span class="line"><span class="keyword">var</span> request = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line"><span class="comment">// 设置请求方法与路径</span></span><br><span class="line">request.open(<span class="string">"get"</span>, url);</span><br><span class="line"><span class="comment">// 不发送数据到服务器</span></span><br><span class="line">request.send(<span class="literal">null</span>);</span><br><span class="line"><span class="comment">//XHR对象获取到返回信息后执行</span></span><br><span class="line">request.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 解析获取到的数据</span></span><br><span class="line">    <span class="keyword">var</span> data = <span class="built_in">JSON</span>.parse(request.responseText);</span><br><span class="line">    <span class="built_in">console</span>.log(data)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="跨域问题"><a href="#跨域问题" class="headerlink" title="跨域问题"></a>跨域问题</h3><p>我们在进行本地代码测试的时候, 如果以双击的形式打开<code>html</code>, 会出现跨域问题, 浏览器控台报错如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Access to XMLHttpRequest at &apos;file:///Users/songjian/Desktop/data.json&apos; from origin &apos;null&apos; has been blocked by CORS policy: Cross origin requests are only supported for protocol schemes: http, data, chrome, chrome-extension, chrome-untrusted, https, isolated-app</span><br></pre></td></tr></table></figure>

<p><strong>解决方法有两种:</strong></p>
<ol>
<li><p>第一种是给网页添加一个域名, 比如<code>localhost</code>, 我们可以使用<code>python</code>或者<code>nodejs</code>在本地启动一个服务, 这里以<code>python3</code>为例:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python -m http.server 8000</span><br></pre></td></tr></table></figure>

<p>启动服务后, 浏览器输入<code>localhost:8000</code>, 即可正常获取到本地<code>json</code>数据</p>
</li>
<li><p>第二种是修改本地浏览器设置, 以<code>Windows</code>平台谷歌浏览器为例, 启动时添加参数<code>--allow-file-access-from-files</code></p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/c8235f9d82ac126c8659f46c06bebb80.png" alt="20201223114910"></p>
</li>
</ol>
<p><strong>本文为作者原创转载时请注明出处 谢谢</strong></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em><a href="https://code.newban.cn/">乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</a></em></p>
]]></content>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>虚幻引擎实用快捷键汇总</title>
    <url>/352.html</url>
    <content><![CDATA[<h3 id="场景相关"><a href="#场景相关" class="headerlink" title="场景相关"></a>场景相关</h3><ol>
<li><p>快速定位聚焦到某个物体</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">键盘F</span><br></pre></td></tr></table></figure>
</li>
<li><p>使物体下落吸附至地面</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">键盘end</span><br></pre></td></tr></table></figure>
</li>
<li><p>快速旋转地图</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Alt+鼠标左键</span><br></pre></td></tr></table></figure>
</li>
<li><p>快速缩放地图</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Alt+鼠标右键</span><br></pre></td></tr></table></figure>


</li>
</ol>
<ol start="5">
<li><p>临时放大地图</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">C+鼠标任意键长按</span><br></pre></td></tr></table></figure>
</li>
<li><p>临时缩小地图</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Z+鼠标任意键长按</span><br></pre></td></tr></table></figure>
</li>
<li><p>进入预览模式</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Alt+P</span><br></pre></td></tr></table></figure>



</li>
</ol>
<h3 id="蓝图相关"><a href="#蓝图相关" class="headerlink" title="蓝图相关"></a>蓝图相关</h3><ol>
<li><p>在蓝图面板获取变量值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Ctrl+鼠标左键拖动</span><br></pre></td></tr></table></figure>
</li>
<li><p>在蓝图面板设置变量值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Alt+鼠标左键拖动</span><br></pre></td></tr></table></figure>
</li>
<li><p>切断蓝图节点之间的连线</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">光标移至线上 然后 Alt+鼠标左键</span><br></pre></td></tr></table></figure>
</li>
<li><p>给选中的蓝图节点添加注释</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">键盘C</span><br></pre></td></tr></table></figure>
</li>
<li><p>克隆选中的蓝图节点</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> </span><br></pre></td></tr></table></figure>









</li>
</ol>
<p><strong>本文为作者原创转载时请注明出处 谢谢</strong></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em><a href="https://code.newban.cn/">乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</a></em></p>
]]></content>
      <tags>
        <tag>虚幻</tag>
      </tags>
  </entry>
  <entry>
    <title>acme.sh证书自动部署教程</title>
    <url>/356.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本页面介绍了 ACME.sh 结合 CertCloud 的部署流程。</p>
<blockquote>
<p>在开始之前需要完成 <a href="https://docs.certcloud.cn/docs/installation/auto/acme" target="_blank" rel="noopener">证书ACME自动部署</a> 页面的前两个步骤。</p>
</blockquote>
<h2 id="创建-ACME-目录-URL"><a href="#创建-ACME-目录-URL" class="headerlink" title="创建 ACME 目录 URL"></a>创建 ACME 目录 URL</h2><ol>
<li>登录 CertCloud 账户，点击【自动化】-&gt;【ACME】-&gt;【添加 ACME 目录 URL】 <img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/acmepage.png" alt="ACME URL 生成操作步骤"></li>
<li>在弹出框中输入具有标识性的<code>名称</code>，选择证书来源[订单,产品]，选择相应的<code>订单</code>或<code>产品</code> <code>组织</code> ，点击【添加】按钮。ACME 界面会新增一条记录。</li>
<li>ACME 界面会新增一条记录 ，点击对应记录的 【部署】 按钮，在跳转的页面选择 <code>acme.sh</code>，点击<code>复制图标</code>复制 <strong>acme.sh 部署命令</strong> 。</li>
</ol>
<blockquote>
<p>当前，CertCloud ACME 仅支持 OV 和 EV TLS / SSL 证书。<br>如果需要查看详细的 ACME URL ，则只需要点击对应数据的“ 部署 ”按钮，就可以看到详细的 ACME URL 信息。</p>
</blockquote>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>官网：<a href="https://github.com/acmesh-official/acme.sh" target="_blank" rel="noopener">ACME.sh GitHub项目地址</a></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl  https://get.acme.sh | sh</span><br></pre></td></tr></table></figure>

<p>普通用户和 root 用户都可以安装使用。</p>
<p>安装过程:</p>
<ol>
<li>默认安装 acme.sh 到你的 <strong>home</strong> 目录下:</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#cd ~/.acme.sh/</span><br></pre></td></tr></table></figure>

<p>为了方便使用 acme.sh，可以创建 一个 bash 的 alias:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">alias acme.sh=~/.acme.sh/acme.sh</span><br></pre></td></tr></table></figure>

<h2 id="颁发并安装证书"><a href="#颁发并安装证书" class="headerlink" title="颁发并安装证书"></a>颁发并安装证书</h2><ol>
<li>通过 SSH 连接到安装有 ACME 客户端的 Web 服务器。</li>
<li>在终端提示符下，使用 ACME.sh 客户端命令执行上述复制的颁发命令请求证书。<strong>ACME.sh 客户端颁发、安装以及重颁发示例：</strong></li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 获取</span></span><br><span class="line">sudo acme.sh --issue -d DOMAIN --dns DNS_TYPE --server YOUR-ACME-URL --days DAYS </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 安装</span></span><br><span class="line">sudo acme.sh --installcert -d DOMAIN --key-file  YOUR-KEY.pem  --fullchain-file  YOUR-CERT.pem --reloadcmd   "YOUR-SERVER-RELOAD"</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 获取并安装（以上两条命令合在一起）</span></span><br><span class="line">sudo acme.sh --issue -d DOMAIN --dns DNS_TYPE --server YOUR-ACME-URL --days DAYS &amp;&amp; sudo acme.sh --installcert -d DOMAIN --key-file  YOUR-KEY.pem  --fullchain-file  YOUR-CERT.pem --reloadcmd   "YOUR-SERVER-RELOAD"</span><br></pre></td></tr></table></figure>

<ul>
<li><code>DOMAIN</code> 需要替换为申请时提交的域名信息，可以为多个。</li>
<li><code>DNS_TYPE</code> 为需要验证的域名的 DNS 的类型，不同的类型需要配置不同的环境变量。(预审核通过的可以直接配置为 dns_dp ,不需要配置密钥信息)</li>
<li><code>DAYS</code> 为申请的证书的请求周期，应比当前订单的<strong>密钥轮换周期</strong>时间小。</li>
<li><code>YOUR-ACME-URL</code> 为先前创建的 ACME 目录 URL （请参阅 <strong>创建 ACME 目录 URL</strong>）。</li>
<li><code>YOUR-KEY.pem</code> 表示服务配置的证书私钥的路径地址信息。</li>
<li><code>YOUR-CERT.pem</code> 表示服务配置的证书文件的路径地址信息。</li>
<li><code>YOUR-SERVER-RELOAD</code> 表示服务重载服务的命令。（具体的实例，可以看下方的 <strong>ACME.sh 部分常用命令</strong>）</li>
</ul>
<p>注：可以根据自己的需要和服务器环境自定义 ACME 客户端执行命令。</p>
<p>ACME返回的错误和错误消息与 CertCloud API 中返回的错误和错误消息相同。有关错误代码及其含义的列表，请参见 <a href="https://docs.certcloud.cn/docs/installation/auto/openapi/errcode" target="_blank" rel="noopener">Open API 错误</a>。</p>
<blockquote>
<p>完成后，终端将显示一条成功消息<br>恭喜你！ACME 证书请求已完成，并且新发行的证书已安装(保存)在 Web 服务器上。可以访问网站以确认安装成功。</p>
</blockquote>
<h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><p>为了更方便使用，提供了部分 ACME.sh 的常用命令。</p>
<table>
<thead>
<tr>
<th>字段信息</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>- -issue</td>
<td>签发请求</td>
</tr>
<tr>
<td>- -days [days]</td>
<td>请求签发证书的周期，配合 –issue 使用</td>
</tr>
<tr>
<td>- -server [ACME 目录 URL]</td>
<td>证书服务商的 ACME 目录 URL，配合 –issue 使用</td>
</tr>
<tr>
<td>- -installcert</td>
<td>安装证书</td>
</tr>
<tr>
<td>-d [网站域名]</td>
<td>配置证书的域名信息</td>
</tr>
<tr>
<td>- -webroot [网站跟文件路径]</td>
<td>文件验证需要的网站跟文件路径</td>
</tr>
<tr>
<td>- -dns [DNS类型]</td>
<td>配置验证域名的DNS信息</td>
</tr>
<tr>
<td>- -cert-file [证书保存的路径]</td>
<td>安装证书保存的路径</td>
</tr>
<tr>
<td>- -key-file [私钥保存的路径]</td>
<td>安装私钥保存的路径</td>
</tr>
<tr>
<td>- -fullchain-file [证书链保存的路径]</td>
<td>安装证书链保存的路径</td>
</tr>
<tr>
<td>- -reloadcmd [Web 重载命令]</td>
<td>安装证书完成之后Web服务的重载命令</td>
</tr>
</tbody></table>
<ol>
<li><p>文件验证</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">acme.sh  --issue  -d mydomain.com -d www.mydomain.com  --webroot  /home/wwwroot/mydomain.com/ --server https://acme.certcloud.cn/acme/directory/XXX</span><br></pre></td></tr></table></figure>
</li>
<li><p>DNS 验证( 以 DNSPod ，阿里 DNS 为例)</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">export DP_Id="XXX"</span><br><span class="line">export DP_Key="XXX"</span><br><span class="line">acme.sh  --issue  --dns dns_dp   -d aa.com  -d www.aa.com --server https://acme.certcloud.cn/acme/directory/XXX </span><br><span class="line">   </span><br><span class="line">export Ali_Key="XXX"</span><br><span class="line">export Ali_Secret="XXX"</span><br><span class="line">acme.sh  --issue --dns dns_ali -d example.com -d www.example.com --server https://acme.certcloud.cn/acme/directory/XXX</span><br></pre></td></tr></table></figure>

<p>更多支持的DNS类型详见 [<a href="https://github.com/acmesh-official/acme.sh/wiki/dnsapi" target="_blank" rel="noopener">ACME.sh 支持的 DNS 类型大全</a>]</p>
</li>
<li><p>证书部署：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Nginx example:</span><br><span class="line">   </span><br><span class="line">acme.sh --installcert -d example.com --server https://acme.certcloud.cn/acme/directory/XXX \</span><br><span class="line">--key-file       /path/to/keyfile/in/nginx/key.pem  \</span><br><span class="line">--fullchain-file /path/to/fullchain/nginx/cert.pem \</span><br><span class="line">--reloadcmd     "service nginx force-reload"</span><br><span class="line">   </span><br><span class="line">Apache example:</span><br><span class="line">   </span><br><span class="line">acme.sh --installcert -d example.com --server https://acme.certcloud.cn/acme/directory/XXX  \</span><br><span class="line">--cert-file      /path/to/certfile/in/apache/cert.pem  \</span><br><span class="line">--key-file       /path/to/keyfile/in/apache/key.pem  \</span><br><span class="line">--fullchain-file /path/to/fullchain/certfile/apache/fullchain.pem \</span><br><span class="line">--reloadcmd     "service apache2 force-reload"</span><br></pre></td></tr></table></figure>
</li>
<li><p>获取并部署</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">acme.sh --issue -d example.com -d www.example.com --dns dns_dp --server https://acme.certcloud.cn/acme/directory/XXX --days 30 </span><br><span class="line">&amp;&amp; acme.sh --installcert -d example.com -d www.example.com \</span><br><span class="line">--key-file    /etc/nginx/conf.d/example.com.key  \</span><br><span class="line">--fullchain-file /etc/nginx/conf.d/example.com.cer \</span><br><span class="line">--reloadcmd  "service nginx force-reload"</span><br></pre></td></tr></table></figure>

<p>days 的周期为 30 天，acme.sh 会每 30 天去请求 server 去获取新的证书，并进行安装。</p>
</li>
</ol>
<p><strong>本文转载自</strong>: <a href="https://docs.certcloud.cn/docs/installation/auto/acme/acmesh/" target="_blank" rel="noopener">https://docs.certcloud.cn/docs/installation/auto/acme/acmesh/</a></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em><a href="https://code.newban.cn/">乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</a></em></p>
]]></content>
      <tags>
        <tag>ssl</tag>
      </tags>
  </entry>
  <entry>
    <title>快速上手免费开源游戏引擎Godot</title>
    <url>/358.html</url>
    <content><![CDATA[<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p><code>Godot</code>是一款免费开源的游戏引擎, 其优点如下:</p>
<ul>
<li>免费开源</li>
<li>体积小 非常轻量 而且功能齐全</li>
<li>跨平台开发 支持<code>Windows</code>  <code>Mac</code>  <code>Linux</code>  <code>Android</code>甚至<code>Web在线开发</code></li>
<li>脚本语言简单 语法和<code>python</code>类似</li>
<li>游戏跨平台运行</li>
<li>内置脚本编辑器 无需额外安装第三方编辑器 </li>
</ul>
<p>当然 它也有一定的劣势:</p>
<ul>
<li>对H5的支持不太好 不适合做页游</li>
<li>不支持小程序</li>
<li><code>2D</code>比较成熟 但<code>3D</code>相对<code>Unity</code>和<code>UE</code>而言弱一些</li>
</ul>
<p>总之 中小型的游戏开发  完全可以胜任</p>
<p><a href="https://godotengine.org/" target="_blank" rel="noopener">官网地址</a></p>
<p><a href="https://github.com/godotengine/godot" target="_blank" rel="noopener">GitHub地址</a></p>
<p><a href="https://docs.godotengine.org/zh_CN/latest/" target="_blank" rel="noopener">官方中文文档</a></p>
<h3 id="快速上手"><a href="#快速上手" class="headerlink" title="快速上手"></a>快速上手</h3><p>以下介绍针对有编程语言基础的同学食用</p>
<p>我们知道所谓引擎 其实就是一团封装好的代码而已, 将一些常用且重复的逻辑进行抽取简化  方便开发者调用 从而提升游戏开发的效率</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20220913144306654.png" alt="image-20220913144306654"></p>
<p>在<code>Godot</code>中 每一个节点就是一个对象, 场景是一个节点 精灵也是一个节点 都是对象<strong>(如果你是<code>android</code>开发 我们可以将其看成是布局文件中的控件)</strong></p>
<p>如果我们想在某个类中创建一个对象, 那么直接在该类中创建一个节点, 比如我们想在<code>Main</code>这个类中创建<code>Control</code>对象:</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20220913144722992.png" alt="image-20220913144722992"></p>
<p>既然是对象, 那么肯定有继承关系 属性和方法, 我们可以从右侧检查器面板中看到继承关系以及本类和父类们的属性 :</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20220913144543831.png" alt="image-20220913144543831"></p>
<p>而右侧节点面板中的信号列表, 其实就相当于我们平常所说的监听回调:</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20220913145102898.png" alt="image-20220913145102898"></p>
<p>如果需要查看该对象的方法以及方法说明, 我们可以直接在检查器面板中打开随时查看:</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20220913145406023.png" alt="image-20220913145406023"></p>
<h3 id="Godot进阶"><a href="#Godot进阶" class="headerlink" title="Godot进阶"></a>Godot进阶</h3><ol>
<li><p>使用场景自动加载的形式创建单例</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20220914113325298.png" alt="image-20220914113325298"></p>
</li>
</ol>
<h3 id="常用快捷键"><a href="#常用快捷键" class="headerlink" title="常用快捷键"></a>常用快捷键</h3><ol>
<li><p>添加节点</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ctrl+A</span><br></pre></td></tr></table></figure>
</li>
<li><p>全局搜索</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ctrl+shift+F</span><br></pre></td></tr></table></figure>
</li>
<li><p>复制物体</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ctrl+D</span><br></pre></td></tr></table></figure>
</li>
<li><p>播放动画</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">shift+D</span><br></pre></td></tr></table></figure>
</li>
<li><p>停止动画</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">S</span><br></pre></td></tr></table></figure>



</li>
</ol>
<h3 id="游戏导出"><a href="#游戏导出" class="headerlink" title="游戏导出"></a>游戏导出</h3><p>以导出Android包为例, 首先需要在编辑器设置中指定好<code>SDK</code>和签名路径:</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20220914114349233.png" alt="image-20220914114349233"></p>
<p>签名可以用以下指令生成:</p>
<figure class="highlight d"><table><tr><td class="code"><pre><span class="line">keytool -keyalg RSA -genkeypair -<span class="keyword">alias</span> 用户名 -keypass 密码 -keystore <span class="keyword">debug</span>.keystore -storepass 密码 -dname <span class="string">"CN=Android Debug,O=Android,C=US"</span> -validity <span class="number">9999</span> -deststoretype pkcs12</span><br></pre></td></tr></table></figure>

<p>紧接着进入导出界面, 选择Android, 然后提示模板缺失, 此时我们点击管理模板:</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20220914114704962.png" alt="image-20220914114704962"></p>
<p>然后点击下载模板:</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20220914114745522.png" alt="image-20220914114745522"></p>
<p>这个模板文件 包含了所有支持平台的基础框架包:</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20220914115341762.png" alt="image-20220914115341762"></p>
<p>此时 我们再次进入导出面板, 配置签名后点击导出项目就可以了:</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20220914115952330.png" alt="image-20220914115952330"></p>
<p>其他平台导出方法可参考官方文档, 当然还有贴吧小伙伴的经验贴可参考:</p>
<p><a href="https://tieba.baidu.com/p/6015825850" target="_blank" rel="noopener">跨平台导出参考</a></p>
<p><strong>本文为作者原创转载时请注明出处 谢谢</strong></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em><a href="https://code.newban.cn/">乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</a></em></p>
]]></content>
      <tags>
        <tag>游戏开发</tag>
      </tags>
  </entry>
  <entry>
    <title>使用netlify部署静态博客网站</title>
    <url>/359.html</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>最近我部署在<code>github</code>上的一个静态网站突然不能访问了, 排查一看原来是<code>github</code>账户被封禁了, 我想有可能是受到了最近俄罗斯制裁的影响, 因为这个账号我当初是用梯子注册的, 对方可能以为我是俄罗斯人</p>
<p>问题找到之后 我决定暂时先不注册新<code>Github</code>账号了, 直接换成<code>netlify</code></p>
<p><code>netlify</code>有很多优势:</p>
<ul>
<li>单账号不限制网站数量</li>
<li>可直接从<code>github</code>或者<code>gitlab</code>仓库中拉取代码自动部署</li>
<li>支持<code>HTTPS</code>访问</li>
<li>国内访问速度不比<code>gitpages</code>差</li>
</ul>
<p>于是我直接将网站静态文件上传到了<code>netlify</code>, 关于部署的具体流程 详见如下:</p>
<h3 id="开始使用"><a href="#开始使用" class="headerlink" title="开始使用"></a>开始使用</h3><p>首先登陆<code>netlify</code>网站并登录, 如果你的博客源码放在了<code>Github</code>上, 那么可以直接使用<code>Github</code>账号关联登录</p>
<p><a href="https://app.netlify.com/" target="_blank" rel="noopener">点击进入netlify官网</a></p>
<p>登录之后会出现以下面板, 我们点击<code>Add new site</code>按钮添加一个新站点:</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20220915123216935.png" alt="image-20220915123216935"></p>
<p>点击后出现多个选项:</p>
<ul>
<li><code>import an existing project</code>:表示从Github中的仓库中直接拉取代码</li>
<li><code>start from a template</code>: 表示基于某个模板创建一个新的仓库</li>
<li><code>Deploy manually</code>: 表示手动上传网站静态文件</li>
</ul>
<p>接下来 我以<code>hexo</code>博客为例, 介绍第一种和第三种的用法</p>
<h3 id="第一种-import-an-existing-project"><a href="#第一种-import-an-existing-project" class="headerlink" title="第一种 import an existing project"></a>第一种 <code>import an existing project</code></h3><p>点击后进入仓库选择页面, 我们可以选择从指定的托管厂商拉取网站源码:</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20220915121740890.png" alt="image-20220915121740890"></p>
<p>由于我网站源码托管在了<code>Github</code>, 于是我点击<code>Github</code>选项, 进入到仓库选择页面:</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20220915121922914.png" alt="image-20220915121922914"></p>
<p>选择好后进入网站部署配置页面, 填入我们需要让<code>netlify</code>在拉取我们的仓库后进行的指令操作,<code>hexo g</code>生成静态文件 然后将生成的静态文件上传到<code>netlify</code>:</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20220915122130743.png" alt="image-20220915122130743"></p>
<p>填好后点击<code>Deploy site</code>, 然后<code>netlify</code>会自动拉取代码并部署网站</p>
<p>紧接着 我们来到网站设置选项卡中配置自定义域名:</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20220915122650516.png" alt="image-20220915122650516"></p>
<p>需要将自定义域名以<code>CNAME</code>的方式解析到<code>xxxxx.netlify.app</code>, 如果你的域名是阿里云注册的, 直接去阿里云控台配置即可</p>
<p>解析配置完毕后, <code>netlify</code>会自动给网站配置<code>SSL</code>证书实现域名<code>https</code>访问:</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20220915122938054.png" alt="image-20220915122938054"></p>
<p>此时 我们就可以使用域名正常访问我们的网站啦:</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20220915123105502.png" alt="image-20220915123105502"></p>
<h3 id="第三种-Deploy-manually"><a href="#第三种-Deploy-manually" class="headerlink" title="第三种 Deploy manually"></a>第三种 <code>Deploy manually</code></h3><p>这个就比较简单了, 点击后会进入到如下页面:</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20220915123323777.png" alt="image-20220915123323777"></p>
<p>我们只需将<code>public</code>文件夹拖拽到页面 即可自动上传部署</p>
<p>上传完后回到<code>netlify</code>主页就能看到网站了, 然后进行自定义的域名配置即可正常访问 </p>
<p>当然了 如果不用自定义域名 直接使用<code>netlify</code>提供的二级域名也能访问, 这个大家都明白 就不多赘述了</p>
<h3 id="网站测速"><a href="#网站测速" class="headerlink" title="网站测速"></a>网站测速</h3><p>以下是国内访问测速图, 总体还不错 :</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20220915123913425.png" alt="image-20220915123913425"></p>
<h3 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h3><p>经过此次账号封禁, 我开始担忧自己存放在<code>Github</code>上的数据安全性问题了, 万一国内开发者收到制裁  <code>Github</code>来个大扫除, 岂不是完蛋, 不过 这对于国内的代码托管厂商而言也许是个难得的机会</p>
<p>所以我接下打算 将重要数据做个多地备份处理</p>
<p><strong>本文为作者原创转载时请注明出处 谢谢</strong></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em><a href="https://code.newban.cn/">乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</a></em></p>
]]></content>
      <tags>
        <tag>netlify</tag>
      </tags>
  </entry>
  <entry>
    <title>独立游戏开发者必备工具汇总</title>
    <url>/360.html</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>对于独立开发者而言, 使用一些免费且好用的工具相对来说会更加有利, 接下来我们围绕以下几点进行工具的汇总:</p>
<ul>
<li><strong>开源免费</strong>: 不用考虑版权问题 解决后顾之忧</li>
<li><strong>跨平台</strong>: 可随时切换平台开发 这个不必多说</li>
<li><strong>工具得好用</strong></li>
</ul>
<h3 id="工具汇总"><a href="#工具汇总" class="headerlink" title="工具汇总"></a>工具汇总</h3><ol>
<li><p><strong>Krita</strong></p>
<p>开源免费的绘画工具, <code>procreate</code>的替代品, 可绘画和制作逐帧动画</p>
<p><a href="https://github.com/KDE/krita" target="_blank" rel="noopener">GitHub</a></p>
<p><a href="https://krita.org/zh/" target="_blank" rel="noopener">官网</a></p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20220915162224967.png" alt="image-20220915162224967"></p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20220915161819097.png" alt="image-20220915161819097"></p>
</li>
<li><p><strong>Blender</strong></p>
<p>这个大家都熟悉, 免费开源的三维图形图像软件，提供从建模、动画、材质、渲染、到音频处理、视频剪辑等一系列动画短片制作解决方案</p>
<p><a href="https://github.com/blender/blender" target="_blank" rel="noopener">Github</a></p>
<p><a href="https://www.blender.org/download/" target="_blank" rel="noopener">官网下载</a></p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20211228145312330.png" alt="image-20211228145312330"></p>
</li>
<li><p><strong>Pixelorama</strong></p>
<p>也是一款强大的像素画绘制工具, 基于<code>Godot</code>引擎的<code>GDScript</code>语言编写, 功能强大 软件跨平台, 可以说是<code>Godot</code>的完美搭档, 我猜想未来可能会将该工具直接集成进<code>Godot</code>内部</p>
<p><a href="https://github.com/Orama-Interactive/Pixelorama" target="_blank" rel="noopener">Github</a></p>
<p><a href="https://orama-interactive.itch.io/pixelorama" target="_blank" rel="noopener">官网</a></p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20220915155142976.png" alt="image-20220915155142976"></p>
<p>有<code>Web</code>在线版 也可以下载到本地使用:</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20220915155311899.png" alt="image-20220915155311899"></p>
</li>
<li><p><strong>Godot</strong></p>
<p>免费开源的轻量级游戏开发引擎, 麻雀虽小五脏俱全, 支持2D和3D游戏的开发, 内置<code>Tilemap</code>和2D骨骼, 中小型游戏完全胜任</p>
<p><a href="https://godotengine.org/" target="_blank" rel="noopener">官网地址</a></p>
<p><a href="https://github.com/godotengine/godot" target="_blank" rel="noopener">GitHub地址</a></p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20220915162249596.png" alt="image-20220915162249596"></p>
</li>
<li><p><strong>虚幻引擎</strong></p>
<p>如果要做大型3D游戏, 那么虚幻必然是首选, 它也是开源软件, 但是并不免费, 收入超过100万美金的部分按照5%来计算交费, 这样一来 对于个人而言 和免费无异</p>
<p><a href="https://github.com/EpicGames/UnrealEngine" target="_blank" rel="noopener">Github</a>: 这个需要<a href="https://www.unrealengine.com/zh-CN/ue-on-github" target="_blank" rel="noopener">授权</a>才能访问</p>
<p><a href="https://www.unrealengine.com/zh-CN" target="_blank" rel="noopener">点击进入官网</a></p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20220915163612724.png" alt="image-20220915163612724"></p>
</li>
</ol>
<p><strong>本文为作者原创转载时请注明出处 谢谢</strong></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em><a href="https://code.newban.cn/">乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</a></em></p>
]]></content>
      <tags>
        <tag>游戏开发</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Android Studio进行C/C++的开发</title>
    <url>/363.html</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>作为一名专业<code>Android</code>开发者, 当我们遇到需要<code>C/C++</code>的开发时, 完全可以直接使用<code>Android Studio</code>, 而不用另外下载诸如<code>CLion</code>  <code>AppCode</code>等收费<code>IDE</code></p>
<p>使用<code>Android Studio</code>的好处有:</p>
<ul>
<li><strong>免费</strong>: <code>JetBrains</code>的软件大部分都是收费的 唯独<code>Android Studio</code> 完全免费使用</li>
<li><strong><code>Gradle</code>天然支持C语言的编译</strong>: <code>Gradle</code>不仅可以编译<code>Groovy</code>  <code>Java</code>和<code>Kotlin</code>, 还可以编译<code>C/C++</code> 、<code>Scala</code>和<code>Swift</code>, 未来还会支持更多语言, 潜力无限</li>
<li><strong>节省电脑资源</strong>: 无需装多个<code>IDE</code>, 一个<code>Android Studio</code>就可以搞定<code>Android</code>  <code>Web</code>和<code>C</code>的开发 你说爽不爽</li>
</ul>
<p>说了这么多好处, 接来了咱们来聊聊如何实现<code>Android Studio</code>的<code>C/C++</code>开发</p>
<h3 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤"></a>实现步骤</h3><ol>
<li><p>创建一个空工程, 默认选择<code>Android</code>空<code>Activity</code>工程即可, 然后将一些用不上的文件都清除, 最后目录结构如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">|-- build.gradle</span><br><span class="line">`-- src</span><br><span class="line">    `-- main</span><br><span class="line">        `-- c</span><br><span class="line">            `-- hello.c</span><br></pre></td></tr></table></figure>

<p>如果是<code>C++</code>开发, 那么目录名改成<code>cpp</code>, 其结构如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">|-- build.gradle</span><br><span class="line">`-- src</span><br><span class="line">    `-- main</span><br><span class="line">        `-- cpp</span><br><span class="line">            `-- hello.cpp</span><br></pre></td></tr></table></figure>
</li>
<li><p>在<code>App</code>目录下的<code>build.gradle</code>中的内容全部清除 然后填入以下内容:</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">apply <span class="string">plugin:</span> <span class="string">'c'</span></span><br><span class="line"></span><br><span class="line">model &#123;</span><br><span class="line">    components &#123;</span><br><span class="line">        main(NativeExecutableSpec) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同样的 如果是C++, 则将plugin改成cpp, 如下:</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">apply <span class="string">plugin:</span> <span class="string">'cpp'</span></span><br><span class="line"></span><br><span class="line">model &#123;</span><br><span class="line">    components &#123;</span><br><span class="line">        main(NativeExecutableSpec) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>gradle</code>同步之后, 右侧<code>gradle task</code>面板中会生成三个<code>task</code>:</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20220916122044974.png" alt="image-20220916122044974"></p>
</li>
<li><p>此时我们尝试编写C代码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Hello World!\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>编写完后 运行<code>gradle task</code>中的<code>build</code>, 就会自动对源码进行编译并生成可执行文件, 该文件我们可以在<code>build</code>目录中找到</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20220916122359799.png" alt="image-20220916122359799"></p>
</li>
<li><p>打开文件 双击运行, 此时控台输出<code>Hello World</code></p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20220916122515283.png" alt="image-20220916122515283"></p>
</li>
</ol>
<h3 id="构建执行流程优化"><a href="#构建执行流程优化" class="headerlink" title="构建执行流程优化"></a>构建执行流程优化</h3><ol>
<li><p>编译结束后自动执行程序</p>
<p>修改<code>build.gradle</code>文件内容如下即可:</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">apply <span class="string">plugin:</span> <span class="string">'c'</span></span><br><span class="line"></span><br><span class="line">model &#123;</span><br><span class="line">    components &#123;</span><br><span class="line">        main(NativeExecutableSpec) &#123;</span><br><span class="line">            println(<span class="string">"开始编译..."</span>)</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">task execProgram()&#123;</span><br><span class="line">    doLast &#123;</span><br><span class="line">        println(<span class="string">"开始执行..."</span>)</span><br><span class="line">        exec &#123;</span><br><span class="line">            commandLine(<span class="string">"./build/exe/main/main"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">build.finalizedBy(execProgram)</span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样, 点击<code>build</code>任务之后就会自动执行程序了, 如果只想重复执行程序 不进行重新编译, 那么单独执行<code>execProgram</code>任务即可:</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20220916181048724.png" alt="image-20220916181048724"></p>
</li>
</ol>
<h3 id="增加代码错误提示功能"><a href="#增加代码错误提示功能" class="headerlink" title="增加代码错误提示功能"></a>增加代码错误提示功能</h3><p>虽然<code>c/c++</code>程序可以正常编译执行了, 但是代码在编写过程中并没有语法错误提示, 在这种环境下写代码的体验会比较差</p>
<p>接下来 我们把该功能实现, 这里需要配合<code>android</code>插件以及<code>cmake</code>构建工具:</p>
<ol>
<li><p><strong>下载<code>NDK</code>和<code>cmake</code>工具</strong></p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20220928141059262.png" alt="image-20220928141059262"></p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20220928141148055.png" alt="image-20220928141148055"></p>
</li>
<li><p><strong>配置<code>build.gradle</code></strong></p>
<p>增加如下内容:</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">apply <span class="string">plugin:</span> <span class="string">'com.android.application'</span></span><br><span class="line">android&#123;</span><br><span class="line">    compileSdkVersion <span class="number">30</span></span><br><span class="line">    externalNativeBuild &#123;</span><br><span class="line">        cmake &#123;</span><br><span class="line">            path <span class="string">"CMakeLists.txt"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    defaultConfig &#123;</span><br><span class="line">        <span class="comment">//需要限制最小库版本不能太低 不然有些c库可能缺失</span></span><br><span class="line">        minSdkVersion    <span class="number">21</span></span><br><span class="line">        targetSdkVersion <span class="number">30</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>在<code>build.gradle</code>同级目录下创建<code>CMakeLists.txt</code>文件</strong></p>
<p>并添加以下内容:</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 限定cmake最小版本号 当前使用的版本必须在这个之上</span></span><br><span class="line">cmake_minimum_required(VERSION 3.10.2)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 描述工程名称</span></span><br><span class="line">project(<span class="string">"cproject"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 自定义变量  使用$&#123;变量名&#125;进行引用</span></span><br><span class="line">set(BINARY_NAME <span class="string">"android-lib"</span>)</span><br><span class="line">set(EXEC_NAME <span class="string">"androidexc"</span>)</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line"><span class="comment">#获取指定目录下源文件列表，保存到 `DIR_SRCS` 变量中</span></span><br><span class="line">aux_source_directory($&#123;PROJECT_SOURCE_DIR&#125;/src/main/c DIR_SRCS)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成可执行文件</span></span><br><span class="line">add_executable($&#123;EXEC_NAME&#125; $&#123;DIR_SRCS&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成动态链接库</span></span><br><span class="line">add_library( <span class="comment"># 动态库名称</span></span><br><span class="line">        $&#123;BINARY_NAME&#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 生成动态库</span></span><br><span class="line">        SHARED</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 被编译进入库中的源码文件</span></span><br><span class="line">        $&#123;DIR_SRCS&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>在<code>main</code>目录下创建<code>AndroidManifest.xml</code>文件</strong></p>
<p>并添加以下内容, 包名自定义:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class="line">    package=&quot;自定义包名&quot;&gt;</span><br><span class="line">    &lt;/manifest&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>同步工程</strong></p>
<p>同步刷新<code>gradle</code>工程后, 此时我们发现<code>c</code>目录下的源码可以语法错误提示了, 并且代码自动补全功能也有了</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20220928170120305.png" alt="image-20220928170120305"></p>
</li>
</ol>
<h3 id="实现交叉编译"><a href="#实现交叉编译" class="headerlink" title="实现交叉编译"></a>实现交叉编译</h3><p>经过上面如此一番配置之后, 相当于结合了<code>gradle</code>和<code>cmake</code>两大构建工具,可以说是强大无比</p>
<p>我们既可以使用<code>gradle</code>执行<code>execProgram</code>任务生成本地平台的可执行文件, 同时还可以使用<code>cmake</code>交叉编译生成<code>android</code>平台的执行文件和动态库文件</p>
<p>我们只需编译工程或者执行<code>build</code>任务, 即可自动生成执行文件和动态库, 同时动态库会被<code>gradle</code>工具自动打包进<code>apk</code>文件中</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20220928171158748.png" alt="image-20220928171158748"></p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20220928171103061.png" alt="image-20220928171103061"></p>
<p><strong>本文为作者原创转载时请注明出处 谢谢</strong></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em><a href="https://code.newban.cn/">乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</a></em></p>
]]></content>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>一个快速实现创意的游戏开发工具，不止适合新手</title>
    <url>/362.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p> 我最近和朋友聊天，越发觉得但凡尝试过自行开发游戏的人，对开发工具应该都有相似的感受：UE4这类引擎上限非常高，但对于编程基础薄弱的人，可能不是第一选择；RPGmaker这一类工具我也用了一段时间，非常好上手，可惜2D画面有些简单。 </p>
<p> 今天我也想分享一个不错的游戏开发工具，它比较能满足以下人群的需求，文章比较长，大家可以自行判断阅读：</p>
<ul>
<li><p>刚刚入门游戏开发的初学者</p>
</li>
<li><p>手头上有个游戏创意，想快速实现的人</p>
</li>
<li><p>希望快速验证游戏玩法和品质的人</p>
<p>前两天我看到微博上介绍了一个叫罗布乐思（Roblox）的游戏引擎，据说它在全球范围内已经有1亿月活，超过400万的游戏开发者，和超过3000万的作品。</p>
<p>虽然我猜测那是鹅厂做的一个推广，但还是有点好奇什么工具可以有这么高的月活量，所以试着用了三天，发现它有几个亮点。</p>
</li>
</ul>
<h2 id="引擎非常简单易上手"><a href="#引擎非常简单易上手" class="headerlink" title="引擎非常简单易上手"></a><strong>引擎非常简单易上手</strong></h2><p>  这个引擎有多容易上手呢？简单到我在没看教程的前提下，就做出了一个游玩时长不到一分钟的横版跳跃小玩法，因为这个游戏<strong>大量的预设内容以及简单的脚本语言</strong>。</p>
<p>  罗布乐思是一个有很多预设模块的3D引擎，比如我在这里展示的城市场景模板。</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/1280.jpeg" alt="6c505eea559516304660c4cee93d760d.jpg"></p>
<p>   除了场景模板，编辑器里还有大量预设好的模型和效果。预设内容大大降低了制作游戏的时间和精力成本，假设你想做一个城市障碍跑酷小游戏，那么只需要打开城市模板，加入各种汽车、楼房甚至形状部件，就可以直接跑起来了。</p>
<p>  当然，这些预设内容也是可以修改的，以这辆车为例，右上角的资源管理器显示，你可以控制的部分具体到某个车门、车窗以及乘客座位。再复杂点，你还可以实现对这辆车的加速速度、车轮扭矩、发动机动力等各种效果的控制。</p>
<p>   如果你想做更多更复杂的玩法如捏脸、回合制、战棋等等，通过脚本就可以实现，官网的教程里也有对RPG类等级系统、任务线、武器刷新、NPC等各种内容的设置教程，连重生点也只需要单击就可以添加。</p>
<p>  罗布乐思这个工具，可以说是把能简化的内容都帮你简化了一遍，非常友好。只要跟着教程走，很快你的游戏想法就能让人们玩儿上了。</p>
<p>  并且，这个引擎用的脚本语言是lua。虽然相比起主流如C#，lua比较小众，但事实上它作为一个轻量小巧又五脏俱全的语言，概念简单，学起来是比较容易的。</p>
<p>  对这一部分的实现有兴趣，可以到罗布乐思的创作者主页感受一下，在这里泡上一段时间，简单的游戏制作应该难不倒你。（指路<a href="https://developer.roblox.com/zh-cn/learn-roblox/all-tutorials）" target="_blank" rel="noopener">https://developer.roblox.com/zh-cn/learn-roblox/all-tutorials）</a></p>
<h2 id="大量的免费美术资源"><a href="#大量的免费美术资源" class="headerlink" title="大量的免费美术资源"></a><strong>大量的免费美术资源</strong></h2><p>   在工具箱的“商店”里，有官方提供的大量免费美术资源，涵盖各种内容和类别。如果你在搜索框里输入“hair”，那么搜出来的不止是可以覆盖在部件表面上的超多种毛发材质，还有许多直接可以使用的发型贴图——一个换装小游戏的发型选择界面十分钟内就可以完成了。</p>
<p>  老实说，我身边有不止一个朋友表示过，想参加游戏比赛或是做游戏，却因为缺乏美术资源或队友而难以实现。当然这个商店里的美术资源主要满足的是基本需求，胜在可以帮你快速地给自己的游戏套好一个皮，不至于光秃秃的。</p>
<p>  对于在画面风格上有所追求的人，我在罗布乐思的中文论坛也看到有人做出过很不错的画面效果。</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/1280-20220915180720169.jpeg" alt="0ebf37e707b7b2ebb2ae1986777165e5.jpg">  这是开发者Joseph155用四个星期时间制作的《23号公寓》，这种画风和光影让我想到了《我的世界》和《模拟人生》。</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/1280-20220915180725532.jpeg" alt="e2018002457e89692e0244f6649e4c44.jpg"></p>
<p>  这是我在罗布乐思网站发现的游戏《ROSES》，它的光影在网站里应该算非常优秀的了。按我的理解，这种效果能够通过插件实现，同时选项卡里可以直接管理插件，如此一来美术效果上自然可以有更多的实现空间。</p>
<h2 id="没有服务器成本，还能一键发布多个平台"><a href="#没有服务器成本，还能一键发布多个平台" class="headerlink" title="没有服务器成本，还能一键发布多个平台"></a><strong>没有服务器成本，还能一键发布多个平台</strong></h2><p>  <strong>但我认为这个工具最重要的两个优势，是没有服务器成本——也就是能够零成本做联机游戏，以及一键多平台发布。</strong></p>
<p>  由于这款工具的客户端和服务端是集成一体的，这使它不仅能够免费提供服务器，还能够免费负责容灾、运维等一系列网络端工作。</p>
<p>  B站上有一位做独立游戏的Up主做了个试玩罗布乐思的视频，他只用一小时就做了个简单跑酷，发布之后，他还直接用PC和iPad登陆不同账号并联机游玩自己的游戏。</p>
<p>（视频指路：<a href="https://www.bilibili.com/video/av76363666）" target="_blank" rel="noopener">https://www.bilibili.com/video/av76363666）</a></p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/1280-20220915180732276.jpeg" alt="f57037c0d13350ce437145677d844bee.jpg">  也就是说，这个一小时做出来的小跑酷已经实现了联机功能，而且Up主并不需要操心服务器问题。这是非常节省人力精力的，以前我还泡在MC某著名私服的时候，运营团队有位负责网络的大神，因为熊孩子太多都被逼得退群两次，更别提搭服务器的成本了。</p>
<p>  此外，根据我的理解和官网的说法，罗布乐思上的游戏可以只通过一个按键直接发布在PC、安卓、iOS，甚至是Xbox和VR平台的罗布乐思客户端，然后那些不同系统和设备上的玩家就可以直接玩到你的游戏。当然这应该只是海外的情况，国内如何我不是很确定。</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/1280-20220915180739021.jpeg" alt="34a991aac186784f75ed3d49b2b43739.jpg">  这也体现在测试选框里的一个功能上：点击模拟器就可以看到在不同主流设备上的模拟画面，这应该就是为了便于在各种设备上发布作品而设计的。做完之后直接点击发布，你会得到一个网址，任何人在浏览器上打开这个网址，或是在任何系统与设备的罗布乐思客户端上搜索游戏名，都能玩到这个游戏。</p>
<p>  很明显，这完全省去了中间漫长痛苦的各平台打包过程，想想只是把游戏传个Steam就需要多久，还得分成不同的操作系统，移动设备上也没办法玩到——在这里只要点击一下发布。</p>
<p>  有了这些已经设计好的功能，剩下的就只是好好把游戏创意实现出来，钻研一个真正好玩的玩法。依赖这款游戏的超高月活，游戏创意与玩法的质量会很容易得到验证。      </p>
<p>  不过这工具虽然很实用，但在国内很少人知道，网上关于这个游戏的信息也很少。</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/1280-20220915180745323.jpeg" alt="bd9a253e5c04b243e1afe84cd4842bdc.jpg"> 所以我自行搜索过不少资料，发现YouTube上的个别Roblox视频能达到7000多万的播放量，社区（指路<a href="https://robloxforum.com/" target="_blank" rel="noopener">https://robloxforum.com</a>；<a href="https://devforum.roblox.com/" target="_blank" rel="noopener">https://devforum.roblox.com</a>）活跃程度也很高。</p>
<p> 还有18岁高中生通过罗布乐思年收入上百万美元的新闻，这是17年的事儿了。</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/1280-20220915180751272.jpeg" alt="2b39017fd4866344361ddf595504bb9a.jpg"></p>
<p>  但是我估计过不了多久，罗布乐思就会在国内变得更有知名度，因为那个所有游戏都躲不过的鹅厂已经找上门来了。很明显，罗布乐思很快就要进入中国市场了。</p>
<p>  就看最近的新闻，它们推出了一个北极星计划，准备花3000万扶持创作者，另外还有技术和流量扶持，以及优先出海的名额；最近还有一个征集作品的创意比赛。只是这部分内容比较多，我也不太记得，有兴趣可以去搜一下。</p>
<p>  我个人认为，如果大家都认可罗布乐思在开发游戏方面的实用性，接下来鹅厂又能好好做国内落地运营，未来这可能是一个很不错的社区。毕竟鹅厂要用心还是能做点东西出来的。当然，大家有别的想法欢迎留言讨论。</p>
<p><strong>本文转载自:</strong> <a href="https://cowlevel.net/article/2084510" target="_blank" rel="noopener">奶牛关</a></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em><a href="https://code.newban.cn/">乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</a></em></p>
]]></content>
      <tags>
        <tag>游戏开发</tag>
      </tags>
  </entry>
  <entry>
    <title>MAC下使用Tree指令打印目录结构树</title>
    <url>/364.html</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── app</span><br><span class="line">│   ├── build</span><br><span class="line">│   │   ├── exe</span><br><span class="line">│   │   │   └── main</span><br><span class="line">│   │   │       └── main</span><br><span class="line">│   │   ├── objs</span><br><span class="line">│   │   │   └── main</span><br><span class="line">│   │   │       └── mainCpp</span><br><span class="line">│   │   │           └── c8slc3rovxgcr2csa5t8w6tth</span><br><span class="line">│   │   │               └── HH.o</span><br><span class="line">│   │   └── tmp</span><br><span class="line">│   │       ├── compileMainExecutableMainCpp</span><br><span class="line">│   │       │   ├── options.txt</span><br><span class="line">│   │       │   └── output.txt</span><br><span class="line">│   │       └── linkMainExecutable</span><br><span class="line">│   │           ├── options.txt</span><br><span class="line">│   │           └── output.txt</span><br><span class="line">│   ├── build.gradle</span><br><span class="line">│   ├── libs</span><br><span class="line">│   ├── proguard-rules.pro</span><br><span class="line">│   └── src</span><br><span class="line">│       ├── androidTest</span><br><span class="line">│       │   └── java</span><br><span class="line">│       │       └── com</span><br><span class="line">│       │           └── example</span><br><span class="line">│       │               └── myapplication</span><br><span class="line">│       │                   └── ExampleInstrumentedTest.kt</span><br><span class="line">│       ├── main</span><br><span class="line">│       │   ├── c</span><br><span class="line">│       │   │   ├── Hello.c</span><br><span class="line">│       │   │   └── Hello.h</span><br><span class="line">│       │   └── cpp</span><br><span class="line">│       │       └── HH.cpp</span><br><span class="line">│       └── test</span><br><span class="line">│           └── java</span><br><span class="line">│               └── com</span><br><span class="line">│                   └── example</span><br><span class="line">│                       └── myapplication</span><br><span class="line">│                           └── ExampleUnitTest.kt</span><br><span class="line">├── build.gradle</span><br><span class="line">├── gradle</span><br><span class="line">│   └── wrapper</span><br><span class="line">│       ├── gradle-wrapper.jar</span><br><span class="line">│       └── gradle-wrapper.properties</span><br><span class="line">├── gradle.properties</span><br><span class="line">├── gradlew</span><br><span class="line">├── gradlew.bat</span><br><span class="line">├── local.properties</span><br><span class="line">└── settings.gradle</span><br></pre></td></tr></table></figure>

<p>如果你也想要打印类似于上面的目录结构树, 那么我们可以安装一个<code>tree</code>程序, </p>
<p>如果是<code>Mac</code>平台 那么直接使用<code>brew</code>工具进行安装:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">brew install tree</span><br></pre></td></tr></table></figure>

<p>安装完毕后 在你只需要打印结构树的目录下输入<code>tree</code>即可</p>
<h3 id="Tree的常用技巧"><a href="#Tree的常用技巧" class="headerlink" title="Tree的常用技巧"></a>Tree的常用技巧</h3><ol>
<li><p>如果想将目录树输出到文本, 我们可以:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tree &gt;README.md</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果我们指定打印层级数, 那么可以:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tree -L 层级数量</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果我们只想打印文件夹</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tree -d</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果我们想滤除掉某个文件夹</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tree -I 文件夹名称</span><br></pre></td></tr></table></figure>



</li>
</ol>
<p><strong>本文为作者原创转载时请注明出处 谢谢</strong></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em><a href="https://code.newban.cn/">乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</a></em></p>
]]></content>
      <tags>
        <tag>tree</tag>
      </tags>
  </entry>
  <entry>
    <title>Python跨平台之将Python 程序打包成Windows和Linux可执行文件</title>
    <url>/36.html</url>
    <content><![CDATA[<p>通常执行 python 程序要有相应的 Python 环境，但某些特定场景下，我们可能并不愿意这么麻烦的去配置这些环境（比如将写好的脚本发给客户进行操作），如果可以提前将程序打包成 Windows平台的 <code>.exe</code> 文件或者是Linux下的 <code>.sh</code> 脚本，那么使用起来就会方便很多，py2exe 和 PyInstaller 这两款工具都是干这么个事的，下面以 hello.py 脚本（代码内容如下）为例进行介绍。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">age = input(<span class="string">"How old are you?\n"</span>)</span><br><span class="line">print(<span class="string">"A: "</span> + age)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>提示：PyInstaller 可以在 Windows 和 Linux 下使用，更推荐使用，而 py2exe 暂不支持 Linux 平台 而且只支持python低版本环境</p>
</blockquote>
<h3 id="PyInstaller"><a href="#PyInstaller" class="headerlink" title="PyInstaller"></a>PyInstaller</h3><ol>
<li>安装</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip install pyinstaller</span><br></pre></td></tr></table></figure>

<ol>
<li>使用</li>
</ol>
<p>常见的用法有：</p>
<ul>
<li>生成单个可执行文件：<code>pyinstaller -F hello.py</code></li>
<li>生成指定icon的可执行文件：<code>pyinstaller -i xxx.ico hello.py</code></li>
</ul>
<blockquote>
<p>在当前目录下的 dist 文件夹内可以找到生成后的可执行文件（脚本），更多用法请参考说明</p>
</blockquote>
<h3 id="py2exe"><a href="#py2exe" class="headerlink" title="py2exe"></a><a href="https://links.jianshu.com/go?to=https%3A%2F%2Fpypi.org%2Fproject%2Fpy2exe%2F" target="_blank" rel="noopener">py2exe</a></h3><ol>
<li>安装</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip install py2exe</span><br></pre></td></tr></table></figure>

<ol>
<li>使用</li>
</ol>
<p>如上图，打包失败了，留意到<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fstackoverflow.com%2Fquestions%2F41578808%2Fpython-indexerror-tuple-index-out-of-range-when-using-py2exe" target="_blank" rel="noopener">这里</a>说不支持 python3.6，果断放弃，有兴趣的可以自行降低到 python3.4 或 python3.5 进行尝试。</p>
<p><strong>本文为作者原创 转载时请注明出处 谢谢</strong></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em>乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</em></p>
]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Git同时将代码推送到多个仓库</title>
    <url>/361.html</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>随着<code>GitHub</code>的制裁, 我开始考虑将一些代码同步推送到国内的一些代码托管厂商, 比如<code>gitee</code>或者<code>codingnet</code></p>
<p><code>gitee</code>可以直接对<code>github</code>上的仓库进行克隆和更新, 这一点还是比较方便的, 不过手动同步代码总是麻烦一些, 而且容易遗忘, 所以我们可以考虑在<code>push</code>的时候将代码同时推送到多个仓库</p>
<p>具体实现如下:</p>
<h3 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h3><ol>
<li><p>首先定义一个仓库地址合集, 名字自定义, 我们将其命名为<code>all</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git remote add all git@github.com:xxx/xxx.git</span><br></pre></td></tr></table></figure>
</li>
<li><p>然后将需要同时推送的仓库地址追加进入该合集中</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git remote set-url --add all git@gitee.com:xxx/xxx.git</span><br></pre></td></tr></table></figure>
</li>
<li><p>此时我们输入<code>git remote -v</code>可以查看当前仓库所有地址信息, 如下:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">all	git@github.com:xxx/xxx.git (fetch)</span></span><br><span class="line"><span class="meta">$</span><span class="bash">all	git@github.com:xxx/xxx.git (push)</span></span><br><span class="line"><span class="meta">$</span><span class="bash">all	git@gitee.com:xxx/xxx.git (push)</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>最后推送仓库到远程</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git push all master</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果你想移除某个仓库合集</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git remote rm all</span><br></pre></td></tr></table></figure>



</li>
</ol>
<h3 id="附加"><a href="#附加" class="headerlink" title="附加"></a>附加</h3><p>关于仓库地址的配置我们可以直接在 <code>.git/config</code> 查看,<code>git</code>默认合集名为<code>origin</code> </p>
<p>如果你习惯了输入<code>git push origin master</code>来推送仓库, 那么我们可以直接打开<code>config</code>文件然后在<code>origin</code>合集下追加其他仓库的地址, 如下:</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20220915173750105.png" alt="image-20220915173750105"></p>
<p>保存后, 我们就可以使用啦 </p>
<p>如果你担心文本输入出错, 也可以采用命令行的形式进行地址追加:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git remote set-url --add origin git@gitee.com:xxx/xxx.git</span><br></pre></td></tr></table></figure>

<p><strong>本文为作者原创转载时请注明出处 谢谢</strong></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em><a href="https://code.newban.cn/">乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</a></em></p>
]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>Android Studio关于插件市场Marketplace无法搜索的问题解决</title>
    <url>/367.html</url>
    <content><![CDATA[<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>有的小伙伴在进行插件搜索时可能会出现搜索空白的情况, 界面显示<code>Not Found</code></p>
<p>此时 只需要设置一下国内代理即可:</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20220916162230660.png" alt="image-20220916162230660"></p>
<p>进入代理设置, 勾选自动代理 并输入以下地址:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http://mirrors.neusoft.edu.cn:80</span><br></pre></td></tr></table></figure>

<p>重新搜索 OK</p>
<p><strong>本文为作者原创转载时请注明出处 谢谢</strong></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em><a href="https://code.newban.cn/">乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</a></em></p>
]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Docker搭建基于gitea的私有git仓库</title>
    <url>/368.html</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>最近打算将一些私有仓库转移到自己服务器上, 以备不时之需, 目前免费开源的<code>Git</code>仓库框架有<code>Gitlab</code>和<code>Gitea</code>, 考虑到资源消耗问题, 果断选择了<code>Gitea</code></p>
<p><a href="https://github.com/go-gitea/gitea" target="_blank" rel="noopener">Gitea的Github地址</a></p>
<p>接下来分享我个人使用<code>Docker</code>快速搭建<code>Gitea</code>的过程</p>
<h3 id="步骤如下"><a href="#步骤如下" class="headerlink" title="步骤如下"></a>步骤如下</h3><h4 id="安装gitea"><a href="#安装gitea" class="headerlink" title="安装gitea"></a>安装gitea</h4><ol>
<li><p>搜索<code>gitea</code>镜像</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker search gitea</span><br></pre></td></tr></table></figure>
</li>
<li><p>拉取<code>gitea</code>镜像</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker pull gitea/gitea</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建并运行容器</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run -id \</span><br><span class="line">--privileged=true \</span><br><span class="line">--restart=always \</span><br><span class="line">--name=c_gitea \</span><br><span class="line">-p 10022:22 \</span><br><span class="line">-p 13000:3000 \</span><br><span class="line">-v /root/app/gitea:/data \</span><br><span class="line">-h c_gitea \</span><br><span class="line"> gitea/gitea:latest</span><br></pre></td></tr></table></figure>

<p><strong>参数详解:</strong></p>
<ul>
<li><strong>privileged</strong>: 是否授予容器<code>root</code>权限</li>
<li><strong>restart</strong> : docker启动是是否自动启动容器</li>
<li><strong>name</strong>: 表示容器别名</li>
<li><code>-p 10022:22</code>: 容器暴露了<code>22</code>和<code>3000</code>端口 </li>
<li><code>-v /root/app/gitea:/data</code>: 容器的<code>data</code>目录挂载到<code>/root/app/gitea</code></li>
</ul>
</li>
<li><p>浏览器访问<code>gitea</code>配置页面</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http://服务器ip:13000</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20220919172350179.png" alt="image-20220919172350179"></p>
<p>这里主要需要配置数据库以及域名 其他的保持默认即可</p>
<p>首先数据库的话 这里有多种数据库可选, 考虑到资源消耗和移植方便 我选择<code>sqlite3</code></p>
<p>那么在进行配置之前 我们需要先安装<code>sqlite3</code>来创建数据库文件</p>
<p>依然使用<code>docker</code>快速安装:</p>
</li>
</ol>
<h4 id="安装sqlite3"><a href="#安装sqlite3" class="headerlink" title="安装sqlite3"></a>安装<code>sqlite3</code></h4><ol>
<li><p>拉取镜像</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker pull nouchka/sqlite3</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建并运行容器</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run -id \</span><br><span class="line">--restart=always \</span><br><span class="line">--name=c_sqlite \</span><br><span class="line">-p 1433:1433 \</span><br><span class="line">-v /root/app/gitea/sqlite:/root/db \</span><br><span class="line">-h c_sqlite \</span><br><span class="line">nouchka/sqlite3:latest</span><br></pre></td></tr></table></figure>
</li>
<li><p>进入容器</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker exec -it c_sqlite bash</span><br></pre></td></tr></table></figure>


</li>
</ol>
<ol start="4">
<li><p>进入容器后运行指令创建数据库</p>
   <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sqlite3 数据库名.db</span><br></pre></td></tr></table></figure>

<p>   运行创建数据库指令时 <code>sqlite3</code>默认会在当前目录生成<code>db</code>文件, 所以执行前要确保当前目录为挂载目录,也就是<code>/root/db</code></p>
<p>   <img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20220919182016029.png" alt="image-20220919182016029"></p>
<pre><code>执行`sqlite3`进入`SQL`状态, 此时我们输入`.database`可以查看并刷新已经创建的数据库文件 这一步关键 否则宿主挂载目录文件不更新</code></pre></li>
<li><p>退出数据库</p>
   <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.quit</span><br></pre></td></tr></table></figure>

<p>   <img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20220919182305343.png" alt="image-20220919182305343"></p>
<pre><code>此时我们在宿主的`/root/app/gitea/sqlite`可以查看到刚刚生成的数据库</code></pre></li>
</ol>
<h4 id="数据库关联"><a href="#数据库关联" class="headerlink" title="数据库关联"></a>数据库关联</h4><p>我们需要明白的是, 在<code>docker</code>中<code>gitea</code>容器是个独立的系统, 在配置页面中填写的路径皆为<code>gitea</code>容器内部路径, 而非宿主路径</p>
<p>由于<code>gitea</code>容器的<code>/data</code>目录映射到了宿主的<code>/root/app/gitea</code>目录, 因此 我们需要将生成的<code>sqlite</code>数据库文件放置在宿主的<code>/root/app/gitea</code>目录下, 这样<code>gitea</code>容器才能访问到数据库文件</p>
<p>这一点 我在<code>sqlite</code>容器创建时已经考虑到了, 所以将<code>sqlite</code>挂载目录设为了<code>/root/app/gitea/sqlite</code>, 从而免去了数据库文件的迁移</p>
<p>此时 我只需在配置页面数据库路径一项填入<code>/data/sqlite/gitea.db</code>即可:</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20220920101539648.png" alt="image-20220920101539648"></p>
<blockquote>
<p>如果后期需要修改配置可以进入<code>/root/app/gitea/gitea/conf/app.ini</code> 进行修改, 每次修改后记得需要重启<code>gitea</code>容器才能生效</p>
</blockquote>
<p>配置完毕后 点击安装 </p>
<p>紧接着自动跳转到登录页面, 此时我们注册一个新账号然后登录:</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20220920102423120.png" alt="image-20220920102423120"></p>
<p>至此 我们的私有仓库就搭建完毕了, 如果需要节省资源, 可以将<code>sqlite</code>容器停止, 它的存在只是为了创建数据库 以及必要的时候进行数据自定义处理, 暂时不需要它保持运行状态</p>
<h4 id="外部仓库同步"><a href="#外部仓库同步" class="headerlink" title="外部仓库同步"></a>外部仓库同步</h4><p><code>gitea</code>支持从外部仓库导入 支持以下常见厂商:</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20220920103201263.png" alt="image-20220920103201263"></p>
<p>如果从<code>github</code> 导入 首先需要去<code>github</code>中申请一个<code>access token</code>      </p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20220920104007824.png" alt="image-20220920104007824"></p>
<p>当然我们也可以直接使用<code>clone</code>的形式进行迁移 无需<code>token</code>:</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20220920115211964.png" alt="image-20220920115211964"></p>
<p>后面的就不多介绍了  </p>
<h4 id="自定义域名"><a href="#自定义域名" class="headerlink" title="自定义域名"></a>自定义域名</h4><p>正常情况下我们可以通过地址<code>http://服务器公网IP:13000</code>来访问服务器, 如果需要配置自定义域名, 那么需要修改一些配置:</p>
<p>首先域名端, 也就是域名解析需要指向服务器IP, 这点不做过多介绍 大家都明白</p>
<p>另外就是服务端 </p>
<p>由于我使用了<code>Nginx</code>进行反向代理, 并且给<code>docker</code>配置了桥接网络, 所以在<code>nginx.conf</code>文件中配置如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http&#123;</span><br><span class="line">upstream gitea&#123;</span><br><span class="line">server c_gitea:3000;</span><br><span class="line">&#125;</span><br><span class="line">server&#123;</span><br><span class="line">        listen       80;</span><br><span class="line">    server_name git.newban.cn;</span><br><span class="line">    location / &#123;</span><br><span class="line">            proxy_redirect off;</span><br><span class="line">            proxy_set_header Host $host;</span><br><span class="line">            proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line">            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">            proxy_pass http://gitea;</span><br><span class="line">            break;</span><br><span class="line">                 &#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过桥接网络 我们可以直接使用容器别名实现容器间的相互通信, 减少端口暴露的风险</p>
<h3 id="gitea目录结构"><a href="#gitea目录结构" class="headerlink" title="gitea目录结构"></a>gitea目录结构</h3><p>数据库主要用于存放用户和仓库相关的配置数据</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20220920112051764.png" alt="image-20220920112051764"></p>
<p>而我们的代码主要是放在了本地磁盘的<code>/root/app/gitea/git</code>目录下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── git</span><br><span class="line">│   ├── lfs</span><br><span class="line">│   └── repositories</span><br><span class="line">├── gitea</span><br><span class="line">│   ├── attachments</span><br><span class="line">│   ├── avatars</span><br><span class="line">│   ├── conf</span><br><span class="line">│   ├── home</span><br><span class="line">│   ├── indexers</span><br><span class="line">│   ├── jwt</span><br><span class="line">│   ├── log</span><br><span class="line">│   ├── packages</span><br><span class="line">│   ├── queues</span><br><span class="line">│   ├── repo-archive</span><br><span class="line">│   ├── repo-avatars</span><br><span class="line">│   ├── sessions</span><br><span class="line">│   └── tmp</span><br><span class="line">├── sqlite</span><br><span class="line">│   └── gitea.db</span><br><span class="line">└── ssh</span><br><span class="line">    ├── ssh_host_dsa_key</span><br><span class="line">    ├── ssh_host_dsa_key.pub</span><br><span class="line">    ├── ssh_host_ecdsa_key</span><br><span class="line">    ├── ssh_host_ecdsa_key.pub</span><br><span class="line">    ├── ssh_host_ed25519_key</span><br><span class="line">    ├── ssh_host_ed25519_key.pub</span><br><span class="line">    ├── ssh_host_rsa_key</span><br><span class="line">    └── ssh_host_rsa_key.pub</span><br></pre></td></tr></table></figure>

<p><strong>本文为作者原创转载时请注明出处 谢谢</strong></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em><a href="https://code.newban.cn/">乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</a></em></p>
]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>国内代码托管厂商汇总</title>
    <url>/365.html</url>
    <content><![CDATA[<h3 id="汇总如下"><a href="#汇总如下" class="headerlink" title="汇总如下"></a>汇总如下</h3><ol>
<li><p><strong>Gitee</strong></p>
<p><a href="https://gitee.com" target="_blank" rel="noopener">点击进入</a></p>
<p>开源中国旗下的产品, 算是国内老牌厂商了</p>
</li>
<li><p><strong>Coding.net</strong></p>
<p><a href="https://coding.net" target="_blank" rel="noopener">点击进入</a></p>
<p>目前属于腾讯旗下的产品</p>
</li>
<li><p><strong>CodeUp</strong></p>
<p><a href="https://codeup.aliyun.com" target="_blank" rel="noopener">点击进入</a></p>
<p>阿里云旗下的产品</p>
</li>
<li><p><strong>GitCode</strong></p>
<p><a href="https://gitcode.nett" target="_blank" rel="noopener">点击进入</a></p>
<p>CSDN旗下的产品</p>
</li>
<li><p><strong>小程序代码托管</strong></p>
<p><a href="https://git.weixin.qq.com" target="_blank" rel="noopener">点击进入</a></p>
<p>也是腾讯旗下的 主要用于微信小程序代码托管</p>
</li>
<li><p><strong>极狐 JihuLab</strong></p>
<p><a href="https://jihulab.com" target="_blank" rel="noopener">点击进入</a></p>
<p>基于<code>Gitlab</code>搭建的托管平台</p>
</li>
</ol>
<p><strong>本文为作者原创转载时请注明出处 谢谢</strong></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em><a href="https://code.newban.cn/">乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</a></em></p>
]]></content>
      <tags>
        <tag>代码托管</tag>
      </tags>
  </entry>
  <entry>
    <title>关于使用ssh进行仓库clone端口号非22的解决办法</title>
    <url>/369.html</url>
    <content><![CDATA[<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>我们在使用<code>docker</code>搭建私有<code>git</code>仓库时, 会将容器的<code>22</code>端口映射到宿主的其他端口上, 此时如果我们使用<code>ssh</code>地址进行仓库<code>clone</code>, 则会报错 提示<code>ssh: connect to host localhost port 22: Connection refused</code>:</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20220920121534132.png" alt="image-20220920121534132"></p>
<p>假设映射到宿主的端口号为<code>10022</code>, 那么解决方案如下:</p>
<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><ol>
<li><p><strong>第一种 <code>clone</code>时指定端口号:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone ssh://git@localhost:10022/songjian/ggg.git</span><br></pre></td></tr></table></figure>

<p>注意: 需要带上<code>ssh://</code>这个协议头</p>
</li>
<li><p><strong>第二种 在<code>.ssh</code>目录下的<code>config</code>文件中增加<code>port</code>字段指定端口访问:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Host localhost</span><br><span class="line">HostName localhost</span><br><span class="line">Port 10022</span><br><span class="line">PreferredAuthentications publickey</span><br><span class="line">IdentityFile ~/.ssh/id_rsa</span><br></pre></td></tr></table></figure>

<p>由于<code>git</code>默认<code>port</code>是<code>22</code>, 此时我们修改后则可以按照正常的形式进行仓库的克隆:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone git@localhost/songjian/ggg.git</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>第三种 使用<code>nginx</code>反向代理</strong></p>
<p>在<code>nginx.conf</code>文件中配置如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">stream &#123;</span><br><span class="line">    upstream ssh-proxy &#123;</span><br><span class="line">      server 服务器ip:10022;</span><br><span class="line">    &#125;</span><br><span class="line">    server &#123;</span><br><span class="line">      listen 22;</span><br><span class="line">      proxy_pass ssh-proxy;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>配置好后, 直接正常形式<code>clone</code>:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone git@localhost/songjian/ggg.git</span><br></pre></td></tr></table></figure>











</li>
</ol>
<p><strong>本文为作者原创转载时请注明出处 谢谢</strong></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em><a href="https://code.newban.cn/">乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</a></em></p>
]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>自建 Git 服务器：Gitea 与 Gitlab 部署踩坑经历与对比总结</title>
    <url>/366.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这一周我都在折腾在自己的内网服务器中部署私有 Git 服务器，对于目前用的最广泛的 <a href="https://link.zhihu.com/?target=https://github.com/go-gitea/gitea" target="_blank" rel="noopener">Gitea</a> 与 <a href="https://link.zhihu.com/?target=http://gitlab.com/" target="_blank" rel="noopener">GitLab</a> 都进行了实际部署，并邀请了多人进行试用。</p>
<p>对于这两个被广泛使用的可自托管的 Git 托管方案，网上似乎都是几张清单式的功能对比表，所以我想在这篇文章中对比两者在我实践中感受到的的差别，以及说说这几天我趟过的坑，为准备自建 Git 托管网站的用户提供参考与建议。</p>
<p>在正文开始前，我先提醒一件事情：<strong>不推荐在非自己托管的 Gitea 上使用 GitHub TOKEN 等个人敏感信息，目前（v1.16.4） Gitea 的隐私管理缺陷可能会向站点管理员泄露你的隐私。</strong>这个问题可以说是我遇到的最大的坑，也是让我转向 GitLab 的主因，我会在正文中详细说明这个问题。</p>
<p><strong>更新：Gitea v1.16.6 已经修复了泄露 TOKEN 的问题，但对于切记注意第三方 Gitea 托管站点的版本。</strong></p>
<p>在本文发布后，Gitea 作者已经看到了部分对 Gitea 缺失功能的吐槽，并开始在新版本中实现它们，所以部分内容可能有所过时。</p>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>作为可以自己部署的 Git 托管服务器方案，Gitea 与 GitLab 有很多相似之处：有着和 GitHub 相似的仓库界面，一样有着基本的 Git Server 功能，一样同时支持 http(s) 与 ssh，一样支持 Issue 和 Pull requests……</p>
<p>Gitea 是完全开源免费的项目，而 GitLab 有着开源并免费的版本 GitLab CE，也有付费并有闭源功能的 GitLab EE。它们也都提供了由各自的官方托管版网站，你可以前往 <a href="https://link.zhihu.com/?target=http://gitea.com/" target="_blank" rel="noopener">gitea.com</a> 与 <a href="https://link.zhihu.com/?target=http://gitlab.com/" target="_blank" rel="noopener">gitlab.com</a> 体验它们的用法。</p>
<p>这些最基础的东西双方都很相似，只看双方提供的功能对比表很难感受出它们有多大差别，但在实际部署它们后，你可以很直观地感受到它们骨子里就是不同的，它们之间的区别就和 <code>com.sun.net.httpserver</code> 和 Spring 全家桶一样，是单一功能的库与一个生态的区别。</p>
<p>Gitea 是一个功能较为单一的 Git 托管服务器，所有功能都围绕着 Git 托管而来，而且给出了较高的可定制性。在部署 Gitea 的时候，我很明确自己的目的是实现 Git 托管功能，部署后我再根据自己的需求去组合其他工具来满足我的工作流。</p>
<p>GitLab 则是一个大而全的解决方案整合，将 Git 托管、持续集成/部署等功能做在了一起，试图解决你的所有需求。在我部署它之后，我需要探索它的功能，学习它的工作流，适应它来完成我的工作。</p>
<h2 id="资源占用"><a href="#资源占用" class="headerlink" title="资源占用"></a>资源占用</h2><p>作为 Git 托管服务器使用时，Gitea 资源占用明显要低得多。</p>
<p>静态硬盘占用上，Gitea 核心是一个 100 MiB 上下的可执行文件，外加上作为必要依赖的 Git（如果内置 SQLite 不够的话也需要单独部署一个 MySQL 或者 PostgreSQL 做数据库），而 GitLab 光 Docker image 大小就 GiB 级了……不用我多说，截一下 GitLab 的日志文件夹就知道这玩意有多重量级了：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ ls ./gitlab/logs</span><br><span class="line">alertmanager     gitlab-kas    gitlab-workhorse  nginx              prometheus   redis           sshd</span><br><span class="line">gitaly           gitlab-rails  grafana           postgres-exporter  puma         redis-exporter</span><br><span class="line">gitlab-exporter  gitlab-shell  logrotate         postgresql         reconfigure  sidekiq</span><br></pre></td></tr></table></figure>

<p>我断断续续跑了两天，这日志就快 200MiB 了……</p>
<p>内存方面，我这里 Gitea 日常占用内存通常在几百 MiB 浮动，而 GitLab 的 Docker 容器目前内存占用是 14GiB。</p>
<p>GitLab CPU 占用率（相对于一个核心计算）日常待机在 35% 上下，而 Gitea 通常是 0.2% 左右。（<em>这些都是日常无负载状态下的情况，如果有机会的话我试试进一步比较，现在正在停用 GItea，懒得折腾了。）</em></p>
<h2 id="网站配置"><a href="#网站配置" class="headerlink" title="网站配置"></a>网站配置</h2><p>Gitea 大部分配置都要通过修改 <code>app.ini</code> 并重启 Gitea 服务器来应用，后台管理面板基本没有可修改的配置，不能进行配置热修改。</p>
<p>GitLab 部分网络相关的配置（域名，端口，代理，邮箱等）需要修改 <code>gitlab.rb</code> 并重启 GitLab，剩下的大多选项都是在管理员面板里通过 Web UI 进行热修改并及时生效。</p>
<p>对于要稳定运行的 Git 托管服务器来说，Gitea 每次修改配置后想要生效都要离线一段时间，好在 Gitea 启动很快，我这里从启动到能正常访问大概只要 10 秒钟（数据库跑在另一个容器里，没有计算它的启动时间），而 GitLab 启动一次要一分多钟，但由于 GitLab 大部分配置都是热修改，除了最开始部署时需要修改配置，运行中基本没有重启的需求。</p>
<p>想要自定义页面布局在 GitLab 上非常困难，除了首页内容可以通过管理面板修改外，剩下的地方似乎都无法用常规手段修改。Gitea 放开了很多 tmpl 文件可配置，我想要给站点每个页面底部添加一条链接，自己提供一个 <code>extra_links_footer.tmpl</code> 就能完成，但在 GitLab 我是没有找到什么好办法去实现。（似乎能改 <code>/var/opt/gitlab</code> 里的东西来修改布局，但我改了这个文件夹里的一些配置后再重启后，我修改的地方都被还原了，有空再做进一步的探索。）</p>
<p>另外有一点就是，Gitea 内几乎所有链接都在使用基于 <code>ROOT_URL</code> 的绝对链接，所以基本绑死在这个 ROOT_URL 上，配置好后基本没办法用多个域名访问同一个 Gitea。准备使用内网穿透的用户要注意一下这个问题，很多内网穿透服务分配给用户的都是非标准端口，如果想在内外网都能良好访问自己的 Gitea 服务器，最好让 Gitea 内网的端口与公网端口一致，不然很多麻烦事情。</p>
<p>GitLab 会检测你用来访问 GitHub 所用的域名，而且很多地方都会根据这个更改显示，不会因为用不同于 <code>external_url</code> 的地址访问而出现问题，这方面问题会比 Gitea 少很多。 （注意一下，如果你在 <code>external_url</code> 中写了带端口号的地址，GitLab 的侦听端口也会跟着变更。不想改侦听端口的话记着覆盖 <code>nginx[&#39;listen_port&#39;]</code> 设置）</p>
<h2 id="隐私保护"><a href="#隐私保护" class="headerlink" title="隐私保护"></a>隐私保护</h2><p>隐私保护方面我觉得是 Gitea 最值得诟病的问题，也是我转而投向 GitLab 的主因。</p>
<p>Gitea 的一些功能需要 GitHub TOKEN 实现（譬如从 GitHub 导入私有项目等），GitHub TOKEN 作为用户隐私，本身应该受到良好保护，但我在实际使用过程中发现，目前版本（v1.16.4）的 Gitea 有严重的安全问题：</p>
<p>当用户正在进行使用 GitHub TOKEN 访问 GitHub 仓库的任务时，包含了 GitHub TOKEN 的 URL 直接明文出现在管理后台中，管理员可以轻松的从后台看到这些隐私信息：</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/v2-9ec85b637e3aad5f79c1c1f684767d53_720w.jpg" alt="img"></p>
<p>这应该开发者考虑不周造成的问题，相对而言能明显感受到 GitLab 要更关心用户的隐私保护问题，涉及到隐私信息时都高度敏感，在不修改服务器本身的情况下，管理员也无法触及它们。（当然在管理员能接触到 GitLab 服务器的情况下，依然可以通过篡改服务器来窃取用户隐私，所以对第三方托管的服务器并不能无保留的信任。）</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/v2-07b3c70a9f44bacceee9f377b8291bf8_720w.jpg" alt="img">GitLab 中带有用户 TOKEN 的 URL 显示</p>
<h2 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h2><h3 id="消息通知"><a href="#消息通知" class="headerlink" title="消息通知"></a>消息通知</h3><p>GitLab 与 Gitea 都能配置邮件消息通知。</p>
<p>GitLab 每个用户都能设置自己接受的通知，或者完全拒绝邮件通知，设置的粒度可以细分到组/项目级别，管理员还能通过管理后台对用户手动群发邮件通知。</p>
<p>Gitea 的用户无法控制自己接受的通知，只能由管理员配置通知的类型，而且也只能进行全局范围的配置，无法细分到用户身上，而且所有通知都是 Gitea 的自动通知，管理员无法发送自定义通知。</p>
<p>对于 Gitea 这个邮件通知，不能说不能用，但对于多用户的服务器来说，我觉得难用到很难接受的程度，我在配好邮箱后尝试了一会就关掉了。</p>
<h3 id="存储库导入与镜像"><a href="#存储库导入与镜像" class="headerlink" title="存储库导入与镜像"></a>存储库导入与镜像</h3><p>Gitea 和 GitLab 也都支持导入第三方 Git 仓库，特别是提供了原生的迁移 GitHub 仓库的办法，可以连带着 Issue、PR 等其他数据一同导入进来。</p>
<p>此项功能需要 GitHub TOKEN 来完成，Gitea 有泄露 TOKEN 的问题，这点在前面已经说过了，所以不建议在第三方托管的 Gitea 上进行此操作。</p>
<p>但如果在你自己的 Gitea 上执行，不需要担心隐私问题的话，我尝试下来的体验非常好，仓库内容基本都能原模原样地导入过来。</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/v2-804b34a97620ab2aa0953722a53291db_720w.jpg" alt="img">Gitea 导入的 Issue</p>
<p>而 GitLab 的迁移功能个人体验就比较差了。Issue 虽然也能搬过来，但是无法做到 Gitea 这样保持创建者信息，所有的 Issue 创建者都会变成进行导入的用户，然后在内容中添加一条 <code>Created by</code> 信息来标识原创建者。</p>
<p>问题更大的是，GitLab 的 Issue Markdown 语法和 GitHub 有一定差别。最典型的问题是，GitHub Issue 中单个换行符就能换行，GitLab 则是保持了标准的 Markdown 语法，需要连续两个换行才可以，这导致导入的 Issue 格式全都乱成一团，根本没法看：</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/v2-6a46517a40ebc45bfb3686f7e14d5840_720w.jpg" alt="img">GitLab 导入后的样子</p>
<p>除此之外，Gitea 和 GitLab 还支持存储库镜像功能，能够让一个 Gitea/GitLab 存储库与一个外部的存储库（譬如 GitHub 上的存储库）保持关联。它们都支持这两种镜像模式：</p>
<ul>
<li>Push 镜像：以当前仓库为主要仓库，在当前仓库发生修改后自动将修改推送到外部仓库中。</li>
<li>Pull 镜像：以外部仓库为主要仓库，在固定间隔后或者手动触发时从外部仓库拉取内容更新当前仓库中。</li>
</ul>
<p>在镜像功能上，GitLab 很离谱的把 Pull 镜像归属到了 EE 功能中，也就是要付费才能使用，这一点我是完全没有想到的，因为这个功能怎么看都应该属于 CE 的范畴，这也是我对 GitLab CE 意见最大的地方。我自己部署的是 GitLab CE，所以无法尝试 Pull 镜像了。</p>
<p>GitLab 的 Push 镜像功能会在每次用户修改仓库或者手动触发时进行推送，我使用下来体验良好。</p>
<p>Gitea 的 Pull 镜像当然是完全能免费使用的，基本的定时与手动更新仓库功能都可用，就是可惜无法同时同步 wiki、Issue 和 PR。</p>
<p>而 Gitea 的 Push 镜像，我自己没有尝试过，但看文档的描述，Gitea 的 Push 镜像同步是定时触发的，我觉得这就挺迷惑的，还是 GitLab 的策略更好用。</p>
<p>而且特别要注意，Gitea 同步时唯一的认证方式是账号密码认证，但 GitHub 现在禁止账密认证，导致无法正常进行认证，唯一的解决方案是把 GitHub TOKEN 写在 URL 里，但除非是你自部署的 Gitea 并且其他人无法访问这个仓库，否则就会导致你的 GitHub TOKEN 泄露。</p>
<p>GitLab 原生就支持使用 GitHub TOKEN 或者通过 SSH 进行认证。SSH 不知道为什么我这里配好公钥也无法通过认证，但用 GitHub TOKEN 认证的方式工作一切正常，而且对 TOKEN 也有应有的保护，作为主要仓库使用并用它同步到 GitHub 上是没问题的。（SSH 地址必须是 <code>ssh://git@github.com/&lt;group name&gt;/&lt;repo name&gt;.git</code> 的形式，GitHub 的 Code 按钮里那个地址不能直接用，前面要补上 <code>ssh://</code>，中间的冒号也要改成正斜杠）</p>
<h3 id="CI-CD"><a href="#CI-CD" class="headerlink" title="CI/CD"></a>CI/CD</h3><p>谈 Gitea 与 GitLab 的区别，那肯定少不了 CI/CD 这个重头戏。</p>
<p>Gitea 没有提供内置的 CI/CD 支持，但是可以用 Gitea 提供的 API 与其他 CI 集成，目前推荐的比较多的似乎是是自部署 <a href="https://link.zhihu.com/?target=https://drone.io/" target="_blank" rel="noopener">Drone CI</a>，但也可以与 <a href="https://link.zhihu.com/?target=https://travis-ci.org/" target="_blank" rel="noopener">Travis CI</a> 这类现成的 CI 集成。</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/v2-12a6c7f2d58a04d4f7a24160b9fd58a7_720w.jpg" alt="img">Gitea 与 Drone CI 的集成</p>
<p>Gitea 与 CI 的集成我没有亲自尝试过，但可以参考上面 <a href="https://link.zhihu.com/?target=http://gitea.com/" target="_blank" rel="noopener">gitea.com</a> 里现成的例子。我本来想尝试部署 <a href="https://link.zhihu.com/?target=https://www.jetbrains.com/teamcity/" target="_blank" rel="noopener">JetBrains TeamCity</a>，但 Gitea 目前的 API 并不足以与 TeamCity 集成，这在后续版本中可能会改进。</p>
<p>而 GitLab 原生就集成了一套强大的 CI 功能，而且就像 GitHub Action 与 GitHub 那样，它与 GitLab 有着极为紧密的结合。</p>
<p>GitLab 用于执行 GitLab CI 的程序叫做 GitLab Runner。在刚开始看文档的时候，我一直很疑惑为什么 GitLab Runner 的介绍在用户指南里，而非管理员的配置指南中，在配置好后我才豁然开朗，因为 GitLab 不止允许管理员注册全局可用的共享 GitLab Runner，它还允许一般用户为自己或者组注册自托管的 GitLab Runner 实例，让 CI 仅跑在自己的机器上。</p>
<p>目前我只是简单的配置并跑了一些简单的样例，尝试后我觉得很喜欢这样一套高度集成而且灵活易配置的 CI 方案，我认为这方面 GitLab 要比 Gitea强很多。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>根据到目前为止我自己的实际体验，对于仅个人或者小型团队内部的 Git 服务器来说，我更推荐 Gitea，它更轻量，更容易定制化，GitLab 相对来说太吃资源了，而且很多高级功能一般用户可能永远用不上。</p>
<p>如果是中大型团队/企业，或者是要搭建公开服务的站点，那么我只推荐 GitLab。Gitea 对于隐私的保护实在有很多欠缺，而且用起来的时候经常能感受到很多设计并不适合向大量用户提供稳定的服务。GitLab 虽然重，但是整体考虑更加完善，更适合作为商业化的产品使用。</p>
<p>目前我还没有来得及尝试更多功能，所以暂时也给不了更多建议，以后或许会继续更新踩坑经历，希望能帮到更多用户。</p>
<p><strong>本文转载自</strong>: <a href="https://zhuanlan.zhihu.com/p/486410391" target="_blank" rel="noopener">知乎</a></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em><a href="https://code.newban.cn/">乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</a></em></p>
]]></content>
      <tags>
        <tag>代码托管</tag>
      </tags>
  </entry>
  <entry>
    <title>使用内网云进行内网穿透实现外网访问局域网中的服务器</title>
    <url>/371.html</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>有时候我可能会借助家里的电脑临时充当服务器供外网访问, 此时需要进行内网穿透才能实现</p>
<p>网上偶然发现一个提供内网穿透服务的网站, 名为<a href="https://www.neiwangyun.net/" target="_blank" rel="noopener">内网云</a>:</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20220920162143938.png" alt="image-20220920162143938"></p>
<p>如果是临时使用 那么完全免费, 付费的话5块钱一个月</p>
<p>接下来给大家介绍 如何使用</p>
<h3 id="使用指南"><a href="#使用指南" class="headerlink" title="使用指南"></a>使用指南</h3><h4 id="http映射"><a href="#http映射" class="headerlink" title="http映射"></a>http映射</h4><p>假设我的电脑上开了一个<code>Web</code>服务, 地址为<code>:http://localhost:3000</code>, 我们想实现外网访问到这个地址的内容, 此时我们可以在电脑的命令窗口中输入以下指令:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh -R 80:127.0.0.1:3000 sh@sh3.neiwangyun.net</span><br></pre></td></tr></table></figure>

<p><strong>指令解析:</strong></p>
<ul>
<li><strong>ssh</strong>：<code>ssh</code>远程命令</li>
<li><strong>-R：</strong>远程端口绑定</li>
<li><strong>80：</strong>固定端口</li>
<li><strong>127.0.0.1</strong>：固定的本机网络</li>
<li><strong>3000：</strong>你需要转发的网络端口，自行更改</li>
<li><strong>sh：</strong>默认匿名账号，不需要密码验证</li>
<li><strong>sh3.neiwangyun.net：</strong>内网云服务器节点的地址，固定值</li>
</ul>
<p>简而言之 这句指令的意思就是将<code>sh3.neiwangyun.net</code>服务器的<code>80</code>端口转发到本地的<code>3000</code></p>
<p>执行完毕后出现以下内容:</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20220920162759901.png" alt="image-20220920162759901"></p>
<p><strong>结果解析：</strong></p>
<ul>
<li><strong>username</strong>:<code>sh</code>账号名称</li>
<li><strong>type</strong>:<code>anonymous</code>账号类型</li>
<li><strong>subdomain</strong>: <code>xxxxxxxxxx.neiwangyun.net</code> 子域名</li>
<li><strong>bandwidth</strong>: <code>random</code> 网络带宽</li>
<li><strong>expire_time</strong>: <code>random</code>过期时间</li>
<li><strong>unid</strong>: 唯一识别码</li>
<li><strong>http</strong>：<code>http</code>链接</li>
<li><strong>https</strong>：<code>https</code>链接</li>
<li><strong>ipport</strong>：直连用的<code>ip</code>和端口</li>
<li><strong>remote_ip</strong>：客户端<code>ip</code>，服务器看到的连接者<code>IP</code></li>
</ul>
<p>此时 我们在浏览器中输入<code>http/https</code>的地址则可以访问到<code>http://localhost:3000</code>的内容</p>
<h4 id="ssh映射"><a href="#ssh映射" class="headerlink" title="ssh映射"></a>ssh映射</h4><p>假如我们需要在外网中对家里的电脑进行<code>ssh</code>连接, 那么我们需要更改指令端口,如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh -R 80:127.0.0.1:22 sh@sh3.neiwangyun.net</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20220920164300687.png" alt="image-20220920164300687"></p>
<p>执行完毕后  我们需要用<code>ipport</code>的值进行<code>ssh</code>访问, 如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh hostname@olveddnzffdhshsh3.neiwangyun.net:31258</span><br></pre></td></tr></table></figure>

<p><strong>本文为作者原创转载时请注明出处 谢谢</strong></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em><a href="https://code.newban.cn/">乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</a></em></p>
]]></content>
      <tags>
        <tag>内网穿透</tag>
      </tags>
  </entry>
  <entry>
    <title>python连接MySql数据库</title>
    <url>/37.html</url>
    <content><![CDATA[<p>由于 MySQLdb 模块还不支持 Python3.x，所以 Python3.x 如果想连接MySQL需要安装 pymysql 模块。</p>
<p>pymysql 模块可以通过 pip 安装。但如果你使用的是 pycharm IDE，则可以使用 project python 安装第三方模块。</p>
<p>[<strong>File</strong>] &gt;&gt; [<strong>settings</strong>] &gt;&gt; [<strong>Project: python</strong>] &gt;&gt; [<strong>Project Interpreter</strong>] &gt;&gt; [<strong>Install按钮</strong>]</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/875028-20161002000403750-123452875.png" alt="img"></p>
<p>由于Python统一了数据库连接的接口，所以 pymysql 和 MySQLdb 在使用方式上是类似的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#创建数据库连接</span><br><span class="line">pymysql.Connect()参数说明</span><br><span class="line">host(str):      MySQL服务器地址</span><br><span class="line">port(int):      MySQL服务器端口号</span><br><span class="line">user(str):      用户名</span><br><span class="line">passwd(str):    密码</span><br><span class="line">db(str):        数据库名称</span><br><span class="line">charset(str):   连接编码，存在中文的时候，连接需要添加charset=&apos;utf8&apos;，否则中文显示乱码。</span><br><span class="line"></span><br><span class="line">connection对象支持的方法</span><br><span class="line">cursor()        使用该连接创建并返回游标</span><br><span class="line">commit()        提交当前事务，不然无法保存新建或者修改的数据</span><br><span class="line">rollback()      回滚当前事务</span><br><span class="line">close()         关闭连接</span><br><span class="line"></span><br><span class="line">cursor对象支持的方法</span><br><span class="line">execute(op)     执行SQL，并返回受影响行数</span><br><span class="line">fetchone()      取得结果集的下一行</span><br><span class="line">fetchmany(size) 获取结果集的下几行</span><br><span class="line">fetchall()      获取结果集中的所有行</span><br><span class="line">rowcount()      返回数据条数或影响行数</span><br><span class="line">close()         关闭游标对象</span><br></pre></td></tr></table></figure>



<p>==================<strong>MySQL</strong>===================</p>
<p>首先在连接数据库之前，先创建一个交易表，方便测试 pymysql 的功能：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DROP TABLE IF EXISTS trade;</span><br><span class="line"></span><br><span class="line">CREATE TABLE trade (</span><br><span class="line">  id int(4) unsigned NOT NULL AUTO_INCREMENT,</span><br><span class="line">  name varchar(6) NOT NULL COMMENT &apos;用户真实姓名&apos;,</span><br><span class="line">  account varchar(15) NOT NULL COMMENT &apos;银行储蓄账号&apos;,</span><br><span class="line">  saving decimal(8,2) unsigned NOT NULL DEFAULT &apos;0.00&apos; COMMENT &apos;账户储蓄金额&apos;,</span><br><span class="line">  expend decimal(8,2) unsigned NOT NULL DEFAULT &apos;0.00&apos; COMMENT &apos;账户支出总计&apos;,</span><br><span class="line">  income decimal(8,2) unsigned NOT NULL DEFAULT &apos;0.00&apos; COMMENT &apos;账户收入总计&apos;,</span><br><span class="line">  PRIMARY KEY (id),</span><br><span class="line">  UNIQUE KEY name_UNIQUE (name)</span><br><span class="line">) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8;</span><br><span class="line">INSERT INTO trade VALUES (1,&apos;乔布斯&apos;,&apos;18012345678&apos;,0.00,0.00,0.00);</span><br></pre></td></tr></table></figure>



<p>==================<strong>Python</strong>===================</p>
<p>使用Python脚本实现增删改查和事务处理，源码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import pymysql.cursors</span><br><span class="line"></span><br><span class="line"># 连接数据库</span><br><span class="line">connect = pymysql.Connect(</span><br><span class="line">    host=&apos;localhost&apos;,</span><br><span class="line">    port=3310,</span><br><span class="line">    user=&apos;woider&apos;,</span><br><span class="line">    passwd=&apos;3243&apos;,</span><br><span class="line">    db=&apos;python&apos;,</span><br><span class="line">    charset=&apos;utf8&apos;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"># 获取游标</span><br><span class="line">cursor = connect.cursor()</span><br><span class="line"></span><br><span class="line"># 插入数据</span><br><span class="line">sql = &quot;INSERT INTO trade (name, account, saving) VALUES ( &apos;%s&apos;, &apos;%s&apos;, %.2f )&quot;</span><br><span class="line">data = (&apos;雷军&apos;, &apos;13512345678&apos;, 10000)</span><br><span class="line">cursor.execute(sql % data)</span><br><span class="line">connect.commit()</span><br><span class="line">print(&apos;成功插入&apos;, cursor.rowcount, &apos;条数据&apos;)</span><br><span class="line"></span><br><span class="line"># 修改数据</span><br><span class="line">sql = &quot;UPDATE trade SET saving = %.2f WHERE account = &apos;%s&apos; &quot;</span><br><span class="line">data = (8888, &apos;13512345678&apos;)</span><br><span class="line">cursor.execute(sql % data)</span><br><span class="line">connect.commit()</span><br><span class="line">print(&apos;成功修改&apos;, cursor.rowcount, &apos;条数据&apos;)</span><br><span class="line"></span><br><span class="line"># 查询数据</span><br><span class="line">sql = &quot;SELECT name,saving FROM trade WHERE account = &apos;%s&apos; &quot;</span><br><span class="line">data = (&apos;13512345678&apos;,)</span><br><span class="line">cursor.execute(sql % data)</span><br><span class="line">for row in cursor.fetchall():</span><br><span class="line">    print(&quot;Name:%s\tSaving:%.2f&quot; % row)</span><br><span class="line">print(&apos;共查找出&apos;, cursor.rowcount, &apos;条数据&apos;)</span><br><span class="line"></span><br><span class="line"># 删除数据</span><br><span class="line">sql = &quot;DELETE FROM trade WHERE account = &apos;%s&apos; LIMIT %d&quot;</span><br><span class="line">data = (&apos;13512345678&apos;, 1)</span><br><span class="line">cursor.execute(sql % data)</span><br><span class="line">connect.commit()</span><br><span class="line">print(&apos;成功删除&apos;, cursor.rowcount, &apos;条数据&apos;)</span><br><span class="line"></span><br><span class="line"># 事务处理</span><br><span class="line">sql_1 = &quot;UPDATE trade SET saving = saving + 1000 WHERE account = &apos;18012345678&apos; &quot;</span><br><span class="line">sql_2 = &quot;UPDATE trade SET expend = expend + 1000 WHERE account = &apos;18012345678&apos; &quot;</span><br><span class="line">sql_3 = &quot;UPDATE trade SET income = income + 2000 WHERE account = &apos;18012345678&apos; &quot;</span><br><span class="line"></span><br><span class="line">try:</span><br><span class="line">    cursor.execute(sql_1)  # 储蓄增加1000</span><br><span class="line">    cursor.execute(sql_2)  # 支出增加1000</span><br><span class="line">    cursor.execute(sql_3)  # 收入增加2000</span><br><span class="line">except Exception as e:</span><br><span class="line">    connect.rollback()  # 事务回滚</span><br><span class="line">    print(&apos;事务处理失败&apos;, e)</span><br><span class="line">else:</span><br><span class="line">    connect.commit()  # 事务提交</span><br><span class="line">    print(&apos;事务处理成功&apos;, cursor.rowcount)</span><br><span class="line"></span><br><span class="line"># 关闭连接</span><br><span class="line">cursor.close()</span><br><span class="line">connect.close()[![复制代码](https://common.cnblogs.com/images/copycode.gif)</span><br></pre></td></tr></table></figure>

<p>==================<strong>测试结果</strong>===================</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/875028-20161002001957094-148578946.png" alt="img"></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em>乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</em></p>
]]></content>
      <tags>
        <tag>django</tag>
      </tags>
  </entry>
  <entry>
    <title>本地nginx反向代理localhost端口转发失败的解决方案</title>
    <url>/370.html</url>
    <content><![CDATA[<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>有时候为了方便 懒得开虚拟机直接将<code>nginx</code>部署在了本地, 在进行端口映射测试时可能会出现访问<code>502 Bad Getway</code>的问题</p>
<p>我们先来分析一下<code>nginx</code>的配置:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http&#123;</span><br><span class="line"></span><br><span class="line">upstream gitea&#123;</span><br><span class="line">server 127.0.0.1:13000;</span><br><span class="line">&#125;</span><br><span class="line">server&#123;</span><br><span class="line">        listen       80;</span><br><span class="line">    server_name localhost;</span><br><span class="line">    location / &#123;</span><br><span class="line">            proxy_redirect off;</span><br><span class="line">            proxy_set_header Host $host;</span><br><span class="line">            proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line">            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">            proxy_pass http://gitea;</span><br><span class="line">            break;</span><br><span class="line">                 &#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里我们将<code>127.0.0.1:13000</code>映射给了<code>localhost:80</code>, 如果我们在浏览器中输入<code>localhost</code>显然是无法访问的</p>
<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>如果想要正常访问 需要将<code>127.0.0.1</code>改成局域网<code>ip</code>地址, 修改后的配置如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http&#123;</span><br><span class="line"></span><br><span class="line">upstream gitea&#123;</span><br><span class="line">server 192.168.13.155:13000;</span><br><span class="line">&#125;</span><br><span class="line">server&#123;</span><br><span class="line">        listen       80;</span><br><span class="line">    server_name localhost;</span><br><span class="line">    location / &#123;</span><br><span class="line">            proxy_redirect off;</span><br><span class="line">            proxy_set_header Host $host;</span><br><span class="line">            proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line">            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">            proxy_pass http://gitea;</span><br><span class="line">            break;</span><br><span class="line">                 &#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>重启<code>nginx</code>使配置生效, 此时即可正常转发访问了</p>
<p><strong>本文为作者原创转载时请注明出处 谢谢</strong></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em><a href="https://code.newban.cn/">乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</a></em></p>
]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>如何使用supervisor实现内网穿透持久化</title>
    <url>/373.html</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>使用内网穿透时 可能会出现各种不稳定因素导致服务中断, 一旦中断 那么外网就无法对内网进行访问了</p>
<p>为了保证连接的持久稳定性, 我们需要对进程进行监控, 一旦发现服务掉线或者出错 就自动重启程序</p>
<p>为了实现这个需求, 我们可以用<code>supervisor</code>, 它是由<code>python</code>写的一个进程管理工具, 主要功能有:</p>
<ul>
<li>启动、重启、关闭进程</li>
<li>服务挂掉后,自动重启</li>
<li>可执行文件或者配置文件修改后,服务自动重启</li>
<li>内置可视化界面管理</li>
</ul>
<p>上一章给大家介绍了《<a href="https://code.newban.cn/372.html">使用frp进行内网穿透实现外网访问局域网中的服务器</a>》</p>
<p>由于服务端使用的是第三方的中转服务器, 服务器的稳定性暂不考虑, 目前只需关心客户端这一块, 这里 我以内网中<code>Mac</code>机器为例给大家介绍<code>supervisor</code>的使用</p>
<h3 id="开始实现"><a href="#开始实现" class="headerlink" title="开始实现"></a>开始实现</h3><ol>
<li><p>安装<code>supervisor</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">brew install supervisor</span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo pip3 install supervisor</span><br></pre></td></tr></table></figure>
</li>
<li><p>检查是否安装成功</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">brew info supervisor</span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">brew info supervisor</span><br></pre></td></tr></table></figure>

<p>显示版本号则说明安装成功</p>
</li>
<li><p>创建配置文件</p>
<p>在<code>/usr/local/etc/</code>目录下创建一个配置文件名为<code>supervisord.conf</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">touch supervisord.conf</span><br></pre></td></tr></table></figure>
</li>
<li><p>配置服务</p>
<p>在配置文件中添加以下内容</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="section">[inet_http_server]</span>         <span class="comment">;开启http服务 </span></span><br><span class="line"><span class="attr">port</span>=<span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">9001</span>         <span class="comment">;指定端口号为9001</span></span><br><span class="line"><span class="attr">username</span>=user              <span class="comment">; 用户名</span></span><br><span class="line"><span class="attr">password</span>=<span class="number">123</span>               <span class="comment">; 密码</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="section">[supervisord]</span></span><br><span class="line"><span class="attr">logfile</span>=/tmp/supervisord.log <span class="comment">; 日志文件</span></span><br><span class="line"><span class="attr">logfile_maxbytes</span>=<span class="number">50</span>MB        <span class="comment">; 日志文件最大50Mb</span></span><br><span class="line"><span class="attr">logfile_backups</span>=<span class="number">10</span>           <span class="comment">; 日志备份数量</span></span><br><span class="line"><span class="attr">loglevel</span>=info                <span class="comment">; 打印日志的等级 默认为info 除此之外还有 debug,warn,trace</span></span><br><span class="line"><span class="attr">pidfile</span>=/tmp/supervisord.pid <span class="comment">;pid文件路径</span></span><br><span class="line"><span class="attr">nodaemon</span>=<span class="literal">false</span>               <span class="comment">; 是否在前台运行</span></span><br><span class="line"><span class="attr">silent</span>=<span class="literal">false</span>                 <span class="comment">;是否关闭日志打印</span></span><br><span class="line"><span class="attr">minfds</span>=<span class="number">1024</span>                 </span><br><span class="line"><span class="attr">minprocs</span>=<span class="number">200</span>              </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="section">[supervisorctl]</span></span><br><span class="line"><span class="attr">serverurl</span>=http://<span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">9001</span> <span class="comment">;访问这个服务进行进程管理</span></span><br><span class="line"><span class="attr">username</span>=user              <span class="comment">; 需要和http用户名保持一致 </span></span><br><span class="line"><span class="attr">password</span>=<span class="number">123</span>                <span class="comment">; 需要和http密码保持一致 用于管理工具的连接 如果不配置的话 每次使用supervisorctl都得手动输入用户名密码 </span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="section">[rpcinterface:supervisor]</span> <span class="comment">;这个配置必须要有 </span></span><br><span class="line"><span class="attr">supervisor.rpcinterface_factory</span> = supervisor.rpcinterface:make_main_rpcinterface</span><br></pre></td></tr></table></figure>

<p>配置详解:</p>
<ul>
<li><strong>[inet_http_server]</strong>: 开启<code>http</code>服务 提供可视化监控界面</li>
<li><strong>[supervisord]</strong>:<code>supervisor</code>服务配置 缺少它<code>supervisor</code>无法启动</li>
<li><strong>[supervisorctl]</strong>:<code>supervisor</code>管理工具 </li>
</ul>
</li>
</ol>
<ol start="5">
<li><p>启动<code>supervisor</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">supervisord -c /usr/local/etc/supervisord.conf</span><br></pre></td></tr></table></figure>

<p>启动后 我们在浏览器中输入<code>http://127.0.0.1:9001</code>, 填入配置文件中的<code>username</code>和<code>password</code>, 进入到守护进程管理页面</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20220921152026301.png" alt="image-20220921152026301"></p>
<p>我们在页面中为发现进程信息, 因为还没有配置需要进行守护的进程</p>
</li>
<li><p>添加需要进行监测并守护的进程</p>
<p>在配置文件中追加以下内容:</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="section">[program:frpc]</span> <span class="comment">;名称为frpc  这个可以自定义 但是不能重复</span></span><br><span class="line"><span class="attr">command</span>=/Users/songjian/frp/frpc/frpc -c ./frpc.ini             <span class="comment">; 需要运行的程序指令</span></span><br><span class="line"><span class="attr">directory</span>=/Users/songjian/frp/frpc               <span class="comment">;程序目录</span></span><br><span class="line"><span class="attr">autostart</span>=<span class="literal">true</span>                <span class="comment">;  supervisor 启动时跟随启动</span></span><br><span class="line"><span class="attr">autorestart</span>=<span class="literal">true</span>            <span class="comment">; 程序崩溃时自动重启</span></span><br><span class="line"><span class="attr">startsecs</span>=<span class="number">5</span>                   <span class="comment">; # of secs prog must stay up to be running (def. 1)</span></span><br><span class="line"><span class="attr">startretries</span>=<span class="number">3</span>                <span class="comment">;重试次数</span></span><br><span class="line"><span class="attr">stdout_logfile</span>=/Users/songjian/frp/frpc/supervisord.log        <span class="comment">; 日志文件路径</span></span><br><span class="line"><span class="attr">stdout_logfile_maxbytes</span>=<span class="number">20</span>MB   <span class="comment">; 日志文件最大容量</span></span><br><span class="line"><span class="attr">stdout_logfile_backups</span>=<span class="number">10</span>     <span class="comment">; # 日志备份数量</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>重载配置文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">supervisorctl</span><br></pre></td></tr></table></figure>

<p>执行后提示需要验证 输入用户名和密码后进入子命令窗口, 然后输入<code>reload</code>进行重载:</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20220921172100244.png" alt="image-20220921172100244"></p>
<p>此时我们刷新浏览器可以看到守护的程序已经启动:</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20220921173043546.png" alt="image-20220921173043546"></p>
<p>我们可以直接在浏览其中直接对其进行重启 停止 以及日志查看等操作</p>
<p>至此 我们<code>supervisor</code>对<code>frpc</code>的守护已初步实现</p>
</li>
</ol>
<h3 id="supervisor开机自启"><a href="#supervisor开机自启" class="headerlink" title="supervisor开机自启"></a>supervisor开机自启</h3><p>我们希望内网机器开机后自动启动<code>supervisor</code>, 在Mac平台实现很简单, 只需执行以下指令即可:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">brew services start supervisor</span><br></pre></td></tr></table></figure>

<p><code>brew services</code>内部使用的是<code>launchctl</code>, 简化了<code>launchctl</code>的繁琐操作, <code>brew services</code>的常用命令有:</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">brew services list  # 查看使用brew安装的服务列表</span><br><span class="line">brew services run formula|--all  # 启动服务（仅启动不注册）</span><br><span class="line">brew services <span class="built_in">start</span> formula|--all  # 启动服务，并注册</span><br><span class="line">brew services stop formula|--all   # 停止服务，并取消注册</span><br><span class="line">brew services restart formula|--all  # 重启服务，并注册</span><br><span class="line">brew services cleanup  # 清除已卸载应用的无用的配置</span><br></pre></td></tr></table></figure>

<h3 id="supervisorctl管理工具提供的功能"><a href="#supervisorctl管理工具提供的功能" class="headerlink" title="supervisorctl管理工具提供的功能"></a>supervisorctl管理工具提供的功能</h3><p>我们可以利用<code>supervisorctl</code>对我们的守护进行进行启动 停止 重启等操作, 具体的可以输入<code>help</code>进行查看:</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20220921172300446.png" alt="image-20220921172300446"></p>
<ol>
<li><p>停止 <code>supervisor</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">shutdown</span><br></pre></td></tr></table></figure>

<p>该指令不仅会停止 <code>supervisor</code>, 还会停止其守护的所有程序</p>
</li>
<li><p>停止某个守护进程</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">stop 进程名</span><br></pre></td></tr></table></figure>
</li>
<li><p>停止所有守护进程</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">stop all</span><br></pre></td></tr></table></figure>
</li>
<li><p>重启某个守护进程</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">restart 进程名</span><br></pre></td></tr></table></figure>
</li>
<li><p>重载整个配置文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">reload</span><br></pre></td></tr></table></figure>

<p>所有子进程会重启</p>
</li>
<li><p>更新配置文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">update</span><br></pre></td></tr></table></figure>

<p>配置文件中有改动的进程会被重启 没有改动的不受影响</p>
</li>
</ol>
<p><strong>本文为作者原创转载时请注明出处 谢谢</strong></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em><a href="https://code.newban.cn/">乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</a></em></p>
]]></content>
      <tags>
        <tag>进程守护</tag>
      </tags>
  </entry>
  <entry>
    <title>使用frp进行内网穿透实现外网访问局域网中的服务器</title>
    <url>/372.html</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>之前给大家介绍过使用内网云实现内网穿透的方案, 一行指令搞定, 详见《<a href="https://code.newban.cn/371.html">使用内网云进行内网穿透实现外网访问局域网中的服务器</a>》</p>
<p>今天给大家介绍如何使用<code>frp</code>实现内网穿透</p>
<p><code>frp</code>是一个免费开源的内网穿透工具, 包含服务端(<code>frps</code>)和客户端( <code>frpc</code>)</p>
<p><a href="https://github.com/fatedier/frp" target="_blank" rel="noopener">Github</a></p>
<p>假如你自己有云服务器, 那么将服务端安装到具有公网ip的服务器中, 将客户端安装到内网的机器上, 即可实现内网穿透功能</p>
<p>当然  如果你没有云服务也没有关系 网上有些热心肠的大佬们给我们提供了中转服务器 比如: <a href="https://freefrp.net/" target="_blank" rel="noopener">freefrp</a>:</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20220920172928529.png" alt="image-20220920172928529"></p>
<p>而我们要做的仅仅就是在内网的机器上安装用于连接的客户端即可</p>
<p>接下来我以本地的<code>Mac</code>电脑为例 充当内网机器 介绍使用方法</p>
<h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><h4 id="http穿透"><a href="#http穿透" class="headerlink" title="http穿透"></a>http穿透</h4><ol>
<li><p><strong>首先下载客户端程序</strong></p>
<p><a href="https://github.com/fatedier/frp/releases" target="_blank" rel="noopener">点击下载</a></p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20220920173201984.png" alt="image-20220920173201984"></p>
<p>由于是<code>Mac</code>系统 因此我们选择<code>Darwin_amd64</code>, 下载后解压:</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20220920174602538.png" alt="image-20220920174602538"></p>
<p> 客户端只用<code>frpc</code>开头的文件, 其他的可以移除, </p>
</li>
<li><p><strong>修改配置文件</strong></p>
<p>打开配置文件<code>frpc.ini</code>, 然后修改成以下内容:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[common]</span><br><span class="line">server_addr = frp.freefrp.net</span><br><span class="line">server_port = 7000</span><br><span class="line">token = freefrp.net</span><br><span class="line"></span><br><span class="line">[mac_http]</span><br><span class="line">type = http</span><br><span class="line">local_ip = 127.0.0.1</span><br><span class="line">local_port = 13000</span><br><span class="line">custom_domains = git.newban.cn</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20220921101048772.png" alt="image-20220921101048772"></p>
<p><strong>参数详解:</strong></p>
<ul>
<li><p>中括号中的名称可以自定义 但不能重复</p>
</li>
<li><p><strong>type</strong>: 表示连接类型, 支持<code>http/https</code> <code>udp</code>  <code>tcp</code>  等协议</p>
</li>
<li><p><strong>server_addr</strong>:服务器 IP 地址或者域名地址 </p>
</li>
<li><p>*<em>server_port *</em>:服务端口号</p>
</li>
<li><p><strong>token</strong>:服务端访问密码</p>
</li>
<li><p><strong>local_ip</strong>: 需要进行穿透的内网ip, 通常为<code>127.0.0.1</code> 如果使用虚拟机或者<code>docker</code> 建议改成局域网<code>ip</code></p>
</li>
<li><p><strong>local_port</strong>: 需要进行穿透的内网端口号</p>
</li>
<li><p><strong>custom_domains</strong>: 自定义域名 需要将域名解析到服务器地址 这样使用域名就能直接访问到内网程序了</p>
</li>
</ul>
</li>
</ol>
<ol start="3">
<li><p><strong>域名解析</strong></p>
<p>将配置文件中的自定义域名以<code>CNAME</code>的方式解析到<code>frp.freefrp.net</code></p>
</li>
<li><p><strong>启动<code>frpc</code>客户端程序</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">./frpc</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>浏览器访问</strong></p>
<p>此时 我们通过域名就能直接在任意浏览器上访问到<code>127.0.0.1:3000</code></p>
</li>
<li><p><strong>多域名解析</strong> </p>
<p>假如我们需要将多个不同域名同时解析到同一个内网程序, 那么只需增加一个新模块, 配置如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[common]</span><br><span class="line">server_addr = frp.freefrp.net</span><br><span class="line">server_port = 7000</span><br><span class="line">token = freefrp.net</span><br><span class="line"></span><br><span class="line">[mac_http]</span><br><span class="line">type = http</span><br><span class="line">local_ip = 127.0.0.1</span><br><span class="line">local_port = 13000</span><br><span class="line">custom_domains = git.newban.cn</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[mac_http2]</span><br><span class="line">type = http</span><br><span class="line">local_ip = 127.0.0.1</span><br><span class="line">local_port = 13000</span><br><span class="line">custom_domains = git.insoan.com</span><br></pre></td></tr></table></figure>


</li>
</ol>
<ol start="7">
<li><p><strong>实现以<code>Web</code>的形式可视化配置客户端</strong></p>
<p>只需在<code>common</code>的节点下配置<code>admin</code>参数即可, 如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[common]</span><br><span class="line">server_addr = frp.freefrp.net</span><br><span class="line">server_port = 7000</span><br><span class="line">token = freefrp.net</span><br><span class="line">admin_addr = 127.0.0.1  #客户端Web管理地址</span><br><span class="line">admin_port = 7122   #客户端Web管理端口</span><br><span class="line">admin_user = admin   #客户端Web管理用户名</span><br><span class="line">admin_pwd = 123456  #客户端Web管理密码</span><br></pre></td></tr></table></figure>

<p>配置完后重启<code>frp</code>, 然后在浏览器输入<code>http://127.0.0.1:7122</code>, 即可以<code>Web</code>的形式监控当前正在穿透的程序:</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20220922115156138.png" alt="image-20220922115156138"></p>
</li>
</ol>
<h4 id="ssh穿透"><a href="#ssh穿透" class="headerlink" title="ssh穿透"></a>ssh穿透</h4><ol>
<li><p><strong>配置<code>TCP</code>连接</strong></p>
<p>如果我们需要进行<code>ssh</code>访问, 那么我们需要在客户端配置<code>tcp</code>协议, 配置如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[common]</span><br><span class="line">server_addr = frp.freefrp.net</span><br><span class="line">server_port = 7000</span><br><span class="line">token = freefrp.net</span><br><span class="line"></span><br><span class="line">[mac_http]</span><br><span class="line">type = http</span><br><span class="line">local_ip = 127.0.0.1</span><br><span class="line">local_port = 13000</span><br><span class="line">custom_domains = git.newban.cn</span><br><span class="line"></span><br><span class="line">[mac_ssh]</span><br><span class="line">type = tcp</span><br><span class="line">local_ip = 127.0.0.1</span><br><span class="line">local_port = 22</span><br><span class="line">remote_port = 12323</span><br></pre></td></tr></table></figure>

<p><strong>参数解析:</strong></p>
<ul>
<li><strong>remote_port</strong>: 服务器端口映射 意思就是将服务器的<code>12323</code>端口映射到内网的<code>22</code>端口</li>
</ul>
</li>
<li><p><strong><code>ssh</code>访问</strong></p>
<p>此时 我们在命令窗口执行以下指令就可以进行<code>ssh</code>连接了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh -p 12323 root@frp.freefrp.net</span><br></pre></td></tr></table></figure>

<p>由于我们之前将自定义域名以<code>CNAME</code>形式解析到了<code>frp.freefrp.net</code>, 所以 我们也可以用自定义域名进行连接, 如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh -p 12323 root@git.newban.cn</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>至此 我们的内网穿透客户端配置就ok了, 相比内网云 使用<code>frpc</code>+<code>freefrp.net</code>中转服务器的模式进行内网穿透可以实现完全免费且稳定的服务</p>
<p>下一章 给大家介绍《<a href="https://code.newban.cn/373.html">如何使用supervisor实现内网穿透持久化</a>》</p>
<p><strong>本文为作者原创转载时请注明出处 谢谢</strong></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em><a href="https://code.newban.cn/">乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</a></em></p>
]]></content>
      <tags>
        <tag>内网穿透</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS逆向篇-Clang交叉编译</title>
    <url>/377.html</url>
    <content><![CDATA[<h2 id="本篇我们的目标是在IPHONE上运行ARM64，C语言，C-和OC程序！"><a href="#本篇我们的目标是在IPHONE上运行ARM64，C语言，C-和OC程序！" class="headerlink" title="本篇我们的目标是在IPHONE上运行ARM64，C语言，C++和OC程序！"></a>本篇我们的目标是在IPHONE上运行ARM64，C语言，C++和OC程序！</h2><ol>
<li><strong>Clang</strong><br>对于iOS开发者来说，Clang编译器一点也不陌生，Clang是一个C语言、C++、Objective-C、C++语言的轻量级编译器。源代码发布于BSD协议下，是基于LLVM的,也是Xcode 第一的编译器。</li>
<li><strong>交叉编译</strong><br>指在一个平台上生成另一个平台上的可执行代码。现在我们就在Mac上写代码，在iPhone上运行，想想都刺激！</li>
<li><strong>设备环境</strong><br>使用的是Mac和越狱iOS13.2.2的iPhoneX</li>
</ol>
<h2 id="ARM64"><a href="#ARM64" class="headerlink" title="ARM64"></a><strong>ARM64</strong></h2><ol>
<li>新建一个hello.txt文本</li>
<li>把下面代码复制进去，保存退出</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.extern _printf</span><br><span class="line">.align 4</span><br><span class="line"></span><br><span class="line">.text  </span><br><span class="line">.global _main</span><br><span class="line"></span><br><span class="line">_main:</span><br><span class="line"></span><br><span class="line">  stp x29, x30, [sp,#-0x10]!  ;保存 x29 和 x30 寄存器到栈，!用来控制基址变址寻址的最终新地址是否进行回写操作</span><br><span class="line">  mov x29, sp           ;将 sp 寄存器放入 x29 寄存器</span><br><span class="line">  sub sp,sp,#0x20       ;分配栈空间</span><br><span class="line"></span><br><span class="line">  adr x0,msg			;第一个参数</span><br><span class="line">  bl _printf</span><br><span class="line"></span><br><span class="line">  add sp,sp,#0x20       ;释放栈空间</span><br><span class="line">  mov sp,x29			;将 x29 给 sp</span><br><span class="line">  ldp x29,x30,[sp],0x10  ;出栈给 x29 和 x30</span><br><span class="line"></span><br><span class="line">  ret  ;返回</span><br><span class="line">  </span><br><span class="line">msg:</span><br><span class="line">      .asciz &quot;Hello,world!\n&quot; ; data段有一个标号msg，代表字符串&quot;Hello,world!\n&quot;的首地址,类型为.asciz的字符串</span><br></pre></td></tr></table></figure>

<ol>
<li>改文本后缀，改为hello.asm文件</li>
<li>打开终端，使开始编译</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1、查看sdk安装路径</span><br><span class="line">$xcrun --sdk iphoneos --show-sdk-path</span><br><span class="line"></span><br><span class="line">2、clang编译</span><br><span class="line">clang -arch arm64 -isysroot &quot;sdk&quot; -o hello hello.asm</span><br><span class="line"></span><br><span class="line"> // &quot;-arch arm64&quot; 指定框架</span><br><span class="line"> // &quot; -isysroot&quot; 指定sdk</span><br><span class="line"> // &quot;-o&quot; 输出目标文件</span><br></pre></td></tr></table></figure>

<ol>
<li>签名,在iOS系统中运行程序需要代码签名，所以要增加一个签名步骤。<br>a.新建ent.plist<br>b.把下面代码复制进去，保存在hello.asm同一目录下</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE plist PUBLIC &quot;-//Apple//DTD PLIST 1.0//EN&quot; &quot;http://www.apple.com/DTDs/PropertyList-1.0.dtd&quot;&gt;</span><br><span class="line">&lt;plist version=&quot;1.0&quot;&gt;</span><br><span class="line">&lt;dict&gt;</span><br><span class="line">	&lt;key&gt;platform-application&lt;/key&gt;</span><br><span class="line">	&lt;true/&gt;</span><br><span class="line">	&lt;key&gt;com.apple.springboard.debugapplications&lt;/key&gt;</span><br><span class="line">	&lt;true/&gt;</span><br><span class="line">	&lt;key&gt;run-unsigned-code&lt;/key&gt;</span><br><span class="line">	&lt;true/&gt;</span><br><span class="line">	&lt;key&gt;get-task-allow&lt;/key&gt;</span><br><span class="line">	&lt;true/&gt;</span><br><span class="line">	&lt;key&gt;task_for_pid-allow&lt;/key&gt;</span><br><span class="line">	&lt;true/&gt;</span><br><span class="line">&lt;/dict&gt;</span><br><span class="line">&lt;/plist&gt;</span><br><span class="line">12345678910111213141516</span><br></pre></td></tr></table></figure>

<ol>
<li>对hello文件进行签名</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">codesign -s - --entitlements ent.plist -f hello</span><br><span class="line">1</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/2dd103dc1c357d5d1ea8bb7d840518ce.JPEG" alt="在这里插入图片描述"></p>
<ol>
<li>把签名后的hello文件拷进iPhone的/usr/bin/目录下,好像很多目录下都可以的</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">scp hello root@192.168.0.170:/usr/bin</span><br><span class="line">1</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/7e7d0abd60194a6e64d876c1871c8537.JPEG" alt="在这里插入图片描述">)<img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/8ce834f5b5cec7fdb086382a142b8940.JPEG" alt="在这里插入图片描述"></p>
<ol>
<li>运行hello文件，完美！</li>
</ol>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/79ae29624564c9f6db37b5fea3718518.JPEG" alt="在这里插入图片描述">)<img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/6081a490fa4061887df9bc39d25190d3.JPEG" alt="在这里插入图片描述"></p>
<p>———————-华丽的分割线————————</p>
<h2 id="C语言"><a href="#C语言" class="headerlink" title="C语言"></a><strong>C语言</strong></h2><ol>
<li>新建1.txt</li>
<li>复制代码保存，文件改为1.c</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"> </span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;C：Hello, World! \n&quot;);</span><br><span class="line"> </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">12345678</span><br></pre></td></tr></table></figure>

<ol>
<li>编译签名</li>
</ol>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/be50c62a919e896d0336d02a4bc0e007.JPEG" alt="在这里插入图片描述"></p>
<ol>
<li>拷贝到iPhone上，运行， 完美！</li>
</ol>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/f0f22be0ecec07d66b5916554327098e.JPEG" alt="在这里插入图片描述">)<img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/44af9d6b724615d208f69404a1818461.JPEG" alt="img"></p>
<p>———————-华丽的分割线————————</p>
<h2 id="OBJECT-C"><a href="#OBJECT-C" class="headerlink" title="OBJECT-C"></a><strong>OBJECT-C</strong></h2><ol>
<li>新建2.txt</li>
<li>复制代码保存，文件改为2.m</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#import &lt;Foundation/Foundation.h&gt;</span><br><span class="line"></span><br><span class="line">        int main(int argc, const char * argv[]) &#123;</span><br><span class="line">         @autoreleasepool &#123;</span><br><span class="line">           // insert code here...</span><br><span class="line">            NSLog(@&quot;OC：Hello World！&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        return 0;</span><br><span class="line">     &#125;</span><br><span class="line">123456789</span><br></pre></td></tr></table></figure>

<ol>
<li>编译签名<br>oc的编译有点不一样，因为导入了foundation框架，在Clang编译的时候需要指定一下</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">clang -arch arm64 -framework Foundation -isysroot &quot;sdk&quot; 2.m -o 2</span><br><span class="line">1</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/3bc3ff95de53be81cce573b94ccd0a59.JPEG" alt="在这里插入图片描述"></p>
<ol>
<li>拷贝到iPhone上，运行， 完美！</li>
</ol>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/1db06346858b6396546c6a502ec1e8fc.JPEG" alt="在这里插入图片描述">)<img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/7b9987dbdf25593d93f6d88aaa45198f.JPEG" alt="img"></p>
<p>———————-华丽的分割线————————</p>
<h2 id="C"><a href="#C" class="headerlink" title="C++"></a><strong>C++</strong></h2><ol>
<li>新建3.txt</li>
<li>复制代码保存，文件改为3.cpp</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; &quot;C++：Hello, world!&quot; &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">1234567</span><br></pre></td></tr></table></figure>

<ol>
<li>编译签名<br>因为clang完美兼容g++，gcc，所以一些命令可以完美继承!<br><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/3827caa2134a46a20f58bcea96bdaa3e.JPEG" alt="在这里插入图片描述"></li>
<li>拷贝到iPhone上，运行， 完美！</li>
</ol>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/e22db07f3b819e2b790e8b297ccafad0.JPEG" alt="在这里插入图片描述">)<img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/1cb74b158340e69bc3287c2c492d88bc.JPEG" alt="img"><br>———————-华丽的分割线————————</p>
<p>好了，今天的代码就敲到这里了，更多Clang的用法可以去看看文档。<br>文档：<a href="https://clang.llvm.org/docs/UsersManual.html" target="_blank" rel="noopener">http://clang.llvm.org/docs/UsersManual.html</a></p>
<p><strong>本文转载自</strong>: <a href="https://blog.csdn.net/Heaven_OY/article/details/108387011" target="_blank" rel="noopener">CSDN</a></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em><a href="https://code.newban.cn/">乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</a></em></p>
]]></content>
      <tags>
        <tag>ios逆向</tag>
      </tags>
  </entry>
  <entry>
    <title>VST音频插件的开发</title>
    <url>/379.html</url>
    <content><![CDATA[<h3 id="关于"><a href="#关于" class="headerlink" title="关于"></a>关于</h3><p><code>JUCE</code>是一个开源的跨平台 <code>C++</code> 应用程序框架，适用于桌面和移动应用程序，包括<code>VST</code>、<code>VST3</code>、<code>AU</code>、<code>AUv</code>3、<code>RTAS</code> 和 <code>AAX</code>音频插件。</p>
<p><a href="https://github.com/juce-framework/JUCE" target="_blank" rel="noopener">GITHUB地址</a></p>
<p><a href="https://juce.com/" target="_blank" rel="noopener">JUCE官网</a></p>
<h3 id="开发前的准备工作"><a href="#开发前的准备工作" class="headerlink" title="开发前的准备工作"></a>开发前的准备工作</h3><ol>
<li><p>下载<code>juce</code></p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20220928095652701.png" alt="image-20220928095652701"></p>
<p><a href="https://juce.com/get-juce/download" target="_blank" rel="noopener">点击进入下载页面</a></p>
</li>
<li><p>解压启动<code>Porjucer</code>, 并创建新工程</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20220928095935785.png" alt="image-20220928095935785"></p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20220928101600349.png" alt="image-20220928101600349"></p>
</li>
<li><p>使用本地<code>IDE</code>编辑插件源码</p>
<p><code>Mac</code>平台支持<code>Xcode</code>,<code>windows</code>平台支持<code>visual studio</code></p>
</li>
</ol>
<p><strong>本文为作者原创转载时请注明出处 谢谢</strong></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em><a href="https://code.newban.cn/">乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</a></em></p>
]]></content>
      <tags>
        <tag>音频插件</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Gradle将lua源码构建编译成可执行文件</title>
    <url>/376.html</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>对于<code>lua</code>的构建 官方默认使用<code>make</code>工具, 常见的构建工具有:</p>
<ul>
<li><code>Make</code>:又指<code>GNU Make</code>, 是<code>Linux</code>系统下的通用构建工具, 延伸的构建工具还有<code>nmake</code>, <code>dmake</code>, <code>cmake</code>, <code>xmake</code>等等</li>
<li><code>Scons</code>: 以<code>python</code>语言编写的一款跨平台构建工具 对标<code>make</code> 容易学习快速上手</li>
<li><code>Ant</code>:  基于<code>java</code>的构建工具, 被认为是<code>make</code>工具的替代品, 早期<code>eclipse</code>采用的构建工具就是它</li>
<li><code>maven</code>: 同样是基于<code>java</code>, 它不单单是构建工具 还是项目管理工具, 属于<code>Ant</code>进化版, 目前<code>Idea</code>平台中 <code>java</code>的构建基本用的就是它</li>
<li><code>Gradle:</code> 基于<code>Groovy</code>的构建工具, 被认为是Ant和Maven的替代品, 目前<code>Android</code>编译使用的构建工具就是它</li>
</ul>
<h3 id="什么是构建工具"><a href="#什么是构建工具" class="headerlink" title="什么是构建工具"></a>什么是构建工具</h3><p>以<code>java</code>程序为例, 我们在写好代码后, 需要使用<code>javac</code>指令对源码进行编译, 然后使用<code>java</code>指令执行</p>
<p>这个过程叫做编译, 如果一两个文件还好, 代码文件一多, 手动敲指令进行编译是会死人的🤪, 于是乎自动化的构建工具出现了, 目的就是为了取代人工编译</p>
<h3 id="构建工具的发展"><a href="#构建工具的发展" class="headerlink" title="构建工具的发展"></a>构建工具的发展</h3><p>早期的<code>make</code>–&gt;<code>java</code>的<code>ant</code>–&gt;后来的<code>maven</code>–&gt;现在的<code>gradle</code></p>
<p>每一代构建工具的诞生, 都是为了解决上一代工具存在的痛点</p>
<p><code>Gradle</code>, 用过的都说好!!😆</p>
<h3 id="对Lua源码进行构建编译"><a href="#对Lua源码进行构建编译" class="headerlink" title="对Lua源码进行构建编译"></a>对Lua源码进行构建编译</h3><p>我这边直接使用<code>Android Studio</code>, 具体步骤如下:</p>
<ol>
<li><p><strong>首先 去<code>lua</code>官网下载源码, 这里我使用的是<code>5.4</code>的源码</strong></p>
<p><a href="http://www.lua.org/" target="_blank" rel="noopener">lua官网</a></p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20220926170825041.png" alt="image-20220926170825041"></p>
</li>
<li><p><strong>然后 在Studio中新建一个空工程, 然后将<code>lua</code>源码拖进<code>src</code>目录中</strong></p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20220926163907555.png" alt="image-20220926163907555"></p>
</li>
<li><p><strong>紧接着 对<code>build.gradle</code>文件进行配置</strong></p>
<p><code>lua</code>一共包含两个可执行文件, 一个是<code>lua</code>另一个是<code>luac</code>, 所以这两个执行文件我们需要分开构建, 具体的<code>gradle</code>配置如下:</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">apply <span class="string">plugin:</span> <span class="string">'c'</span>  <span class="comment">//使用c构建模式</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">model &#123;</span><br><span class="line"></span><br><span class="line">    components &#123;</span><br><span class="line">				<span class="comment">//创建一个lua执行文件构建入口</span></span><br><span class="line">        lua(NativeExecutableSpec) &#123;</span><br><span class="line">            sources &#123;</span><br><span class="line">                c &#123;<span class="comment">//指定源码位置以及需要包含和排除的问价</span></span><br><span class="line">                    source &#123;</span><br><span class="line">                        srcDir <span class="string">"src/main/c/lua"</span></span><br><span class="line">                        include <span class="string">'*.c'</span></span><br><span class="line">                        exclude <span class="string">'luac.c'</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    exportedHeaders &#123;</span><br><span class="line">                        include <span class="string">'lauxlib.h'</span>, <span class="string">'lua.h'</span>, <span class="string">'lua.hpp'</span>, <span class="string">'luaconf.h'</span>, <span class="string">'lualib.h'</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">	<span class="comment">//创建一个luac执行文件构建入口</span></span><br><span class="line">        luac(NativeExecutableSpec) &#123;</span><br><span class="line">            sources &#123;</span><br><span class="line">                c &#123;</span><br><span class="line">                    source &#123;</span><br><span class="line">                        srcDir <span class="string">"src/main/c/lua"</span></span><br><span class="line">                        include <span class="string">'*.c'</span></span><br><span class="line">                        exclude <span class="string">'lua.c'</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    exportedHeaders &#123;</span><br><span class="line">                        include <span class="string">'lauxlib.h'</span>, <span class="string">'lua.h'</span>, <span class="string">'lua.hpp'</span>, <span class="string">'luaconf.h'</span>, <span class="string">'lualib.h'</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>最后 开始编译</strong><br><code>gradle</code>刷新同步后, 我们在右侧<code>gradle</code>任务面板可以看到多出<code>lua</code>和<code>luac</code>相关的<code>task</code>, 此时我们执行<code>build</code>任务开始对<code>lua</code>源码进行编译:</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20220926164804018.png" alt="image-20220926164804018"></p>
<p>编译完成后, 我们可以在<code>build</code>文件中查看到生成的可执行文件:</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20220926165101437.png" alt="image-20220926165101437"></p>
<p>双击可正常运行:</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20220926165135047.png" alt="image-20220926165135047"></p>
<p>至此 我们的<code>lua</code>编译完毕</p>
</li>
</ol>
<h3 id="附加"><a href="#附加" class="headerlink" title="附加"></a>附加</h3><ol>
<li><p>如果你只想编译<code>lu</code>a而不编译<code>luac</code>, 那么可以单独运行<code>luaExecutable</code>:</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20220926172451757.png" alt="image-20220926172451757"></p>
</li>
</ol>
<ol start="2">
<li><p>在<code>gradle</code>配置文件中的组件的名称可以自定义</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20220926172714010.png" alt="image-20220926172714010"></p>
</li>
</ol>
<h3 id="关于编译工具"><a href="#关于编译工具" class="headerlink" title="关于编译工具"></a>关于编译工具</h3><p>编译工具和构建工具是两个不同的东西:</p>
<ul>
<li><p><code>C/C++/Object-C</code>语言常用的编译工具有: <code>GCC</code>,<code>Clang</code></p>
</li>
<li><p><code>Java</code>语言的编译工具为<code>Javac</code>, 当然<code>GCC</code>也能编译<code>java</code>语言</p>
</li>
<li><p><code>Android</code>的编译工具为<code>aapt</code>,<code>so</code>库的编译早期采用的是<code>GCC</code>, 现在是<code>Clang</code></p>
</li>
</ul>
<p>上面对于<code>lua</code>的编译, 由于我测试时使用的是<code>Mac</code>平台, 同时电脑还装了<code>Xcode</code>, 所以内部默认采用的编译器是<code>clang</code></p>
<p>关于<code>Clang</code>和<code>GCC</code>的介绍, 可以参见之前的文章《<a href="https://code.newban.cn/222.html">xcode中三种编译器的区别</a>》</p>
<p><strong>本文为作者原创转载时请注明出处 谢谢</strong></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em><a href="https://code.newban.cn/">乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</a></em></p>
]]></content>
      <tags>
        <tag>gradle</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Clang对lua源码进行交叉编译</title>
    <url>/378.html</url>
    <content><![CDATA[<h3 id="什么是交叉编译"><a href="#什么是交叉编译" class="headerlink" title="什么是交叉编译"></a>什么是交叉编译</h3><p>在一个平台上编译生成其他平台可运行的程序, 我们称之为交叉编译</p>
<p>以<code>c</code>语言为例, 在<code>Mac</code>平台编译出来的程序只能在<code>Mac</code>平台运行, 将其拷贝到<code>Windows</code>平台则无法识别, 解决这个问题的办法就是将源代码移至<code>Windows</code>平台 然后重新编译一次  这种做法属于原始的常规编译</p>
<p>那能不能在<code>Mac</code>平台编译生成能在<code>Windows</code>平台运行的程序呢, 可以, 只要借助交叉编译工具即可实现, 而这种非常规编译手段也叫做交叉编译</p>
<p>关于交叉编译实操, 详见之前的文章《<a href="https://code.newban.cn/201.html">android设备上如何运行C语言原生程序</a>》</p>
<p>针对<code>C/C++</code>语言目前主流的交叉编译有:</p>
<ul>
<li><strong>GCC:</strong> <code>GNU</code>旗下的一款编译工具</li>
<li><strong>CLANG:</strong> 苹果主导编写的一款基于<code>LLVM</code>的编译工具</li>
<li><strong>MSVC:</strong> 微软旗下的一款编译工具</li>
</ul>
<h3 id="为什么使用Clang"><a href="#为什么使用Clang" class="headerlink" title="为什么使用Clang"></a>为什么使用Clang</h3><p>相较之下, <code>Clang</code>编译速度更快, 占用内存更小, 错误提示更加人性化</p>
<h4 id="Clang常规使用"><a href="#Clang常规使用" class="headerlink" title="Clang常规使用"></a>Clang常规使用</h4><p>我们先以一个<code>C</code>语言小程序来示范<code>clang</code>的编译流程</p>
<ol>
<li><p><strong>编写<code>c</code>程序代码 文件名为<code>main,c</code></strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Hello World!\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>编译程序源码为当前平台可执行文件</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">clang main.c -o main</span><br></pre></td></tr></table></figure>

<p><code>-o</code>:指定输出执行文件路径和程序名称</p>
</li>
<li><p><strong>编译时顺带打印编译日志</strong></p>
<p>添加一个<code>-v</code>即可</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">clang main.c -o main -v</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>编译生成预处理文件</strong></p>
<p>使用<code>-E</code>, 区分大小写</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">clang -E main.c -o main</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>编译生成汇编代码</strong></p>
<p>使用<code>-s</code>, 区分大小写</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">clang -S main.c -o main</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>编译生成obj文件</strong></p>
<p>使用<code>-c</code>, 区分大小写</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">clang -c main.c -o main</span><br></pre></td></tr></table></figure>






</li>
</ol>
<h3 id="Clang交叉编译"><a href="#Clang交叉编译" class="headerlink" title="Clang交叉编译"></a>Clang交叉编译</h3><ol>
<li><p><strong>指定<code>cpu</code>架构</strong></p>
<p>使用<code>-arch</code>, 比如我们要编译生成<code>arm64</code>位架构平台可执行的程序</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">clang  main.c -o main -arch arm64</span><br></pre></td></tr></table></figure>

<p>正常情况下 上述指令会执行失败, 那是因为<code>clang</code>默认会使用本平台的<code>SDK</code>进行链接编译, 而本平台的<code>SDK</code>如果不支持<code>arm</code>的话自然无法编译 目前大部分电脑用的<code>cpu</code>依然还是<code>x86</code>架构的</p>
<p>既然如此 倘若我们需要编译能在<code>iPhone</code>上运行的程序, 那么就需要指定可以支持<code>arm</code>的<code>SDK</code>来进行编译, 比如<code>iphoneOS_SDK</code></p>
</li>
<li><p><strong>指定编译SDK</strong></p>
<p>在<code>clang</code>中, 通过来<code>-isysroot</code>指定编译<code>SDK</code>, 如下:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">clang -isysroot  /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS13.5.sdk main.c -o main -arch arm64</span><br></pre></td></tr></table></figure>

<p>编译成功后 生成的可执行文件即可在苹果手机上运行</p>
</li>
<li><p><strong>指定操作系统</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">clang  main.c -o main -target x86_64-apple-darwin-eabi</span><br></pre></td></tr></table></figure>

<p>这里使用<code>-target</code>同时指定<code>cpu</code>架构和操作系统,<code>-target</code>的参数一共分为四部分:</p>
<ul>
<li><strong>arch:</strong><code>cpu</code>架构 比如<code>arm</code>,<code>x86_64</code></li>
<li><strong>vendor:</strong>  工具连提供厂商 比如<code>pc</code>, <code>apple</code>,<code>nvidia</code>,<code>ibm</code>,等</li>
<li><strong>os:</strong> 操作系统 比如<code>darwin</code>,<code>linux</code> ,<code>win32</code></li>
<li><strong>abi:</strong>应用程序二进制接口, 描述了程序在目标平台的运行规则, 比如<code>eabi</code>, <code>androidabi</code> ,<code>gnueabi</code>等</li>
</ul>
<p>每部分用横杆隔开, 合起来就是<code>arch-vendor-os-abi</code></p>
</li>
</ol>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><ol>
<li><p><code>Mac</code>编译<code>android</code>平台程序</p>
<p>这里我使用的是<code>ndk</code>包下的<code>clang</code>进行编译</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ndk/21.0.6113669/toolchains/llvm/prebuilt/darwin-x86_64/bin/clang --target=armv7-none-linux-androideabi16 --sysroot=/Users/songjian/Library/Android/sdk/ndk/21.0.6113669/toolchains/llvm/prebuilt/darwin-x86_64/sysroot main.c -o androidExc</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>Mac</code>编译<code>iphone</code>平台程序</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">clang -isysroot  /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS13.5.sdk main.c -o main -arch arm64</span><br></pre></td></tr></table></figure>



</li>
</ol>
<h3 id="lua源码交叉编译"><a href="#lua源码交叉编译" class="headerlink" title="lua源码交叉编译"></a>lua源码交叉编译</h3><p>接下来 我们在<code>Mac</code>平台上编译生成<code>android</code>上可执行的<code>lua</code>程序</p>
<p>由于<code>lua</code>源码文件比较多, 手敲命令编译太过繁琐, 因此我这里使用<code>gradle</code>+<code>cmake</code>构建工具进行快速编译</p>
<p>其中<code>build.gradle</code>配置如下:</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">apply <span class="string">plugin:</span> <span class="string">'c'</span></span><br><span class="line">apply <span class="string">plugin:</span> <span class="string">'com.android.application'</span></span><br><span class="line"></span><br><span class="line">android &#123;</span><br><span class="line">    compileSdkVersion <span class="number">30</span></span><br><span class="line">    externalNativeBuild &#123;</span><br><span class="line">           cmake &#123;</span><br><span class="line">               path <span class="string">"CMakeLists.txt"</span></span><br><span class="line">           &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    defaultConfig &#123;</span><br><span class="line">        <span class="comment">//需要限制最小库版本不能太低 不然有些c库可能缺失</span></span><br><span class="line">        minSdkVersion <span class="number">21</span></span><br><span class="line">        targetSdkVersion <span class="number">30</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里 我将所有<code>lua</code>源码放置在了<code>lua</code>目录当中</p>
<p><code>CMakeLists.txt</code>配置如下:</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 限定cmake最小版本号 当前使用的版本必须在这个之上</span></span><br><span class="line">cmake_minimum_required(VERSION 3.10.2)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 描述工程名称</span></span><br><span class="line">project(<span class="string">"cproject"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 自定义变量  使用$&#123;变量名&#125;进行引用</span></span><br><span class="line">set(EXEC_LUA <span class="string">"lua"</span>)</span><br><span class="line">set(EXEC_LUAC <span class="string">"luac"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#获取指定目录下源文件列表，保存到 `DIR_SRCS` 变量中</span></span><br><span class="line">aux_source_directory($&#123;PROJECT_SOURCE_DIR&#125;/src/main/c/lua DIR_SRCS )</span><br><span class="line"></span><br><span class="line"><span class="comment">#lua有两个主程序 单独抽出来</span></span><br><span class="line">set(LUA_MAIN $&#123;PROJECT_SOURCE_DIR&#125;/src/main/c/lua/lua.c)</span><br><span class="line">set(LUAC_MAIN $&#123;PROJECT_SOURCE_DIR&#125;/src/main/c/lua/luac.c)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#排除文件</span></span><br><span class="line">list(REMOVE_ITEM DIR_SRCS $&#123;PROJECT_SOURCE_DIR&#125;/src/main/c/lua2/luac.c)</span><br><span class="line">list(REMOVE_ITEM DIR_SRCS $&#123;PROJECT_SOURCE_DIR&#125;/src/main/c/lua2/luac.c)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成可执行文件</span></span><br><span class="line">add_executable($&#123;EXEC_LUA&#125;</span><br><span class="line">        $&#123;DIR_SRCS&#125; $&#123;LUA_MAIN&#125;)</span><br><span class="line"></span><br><span class="line">add_executable($&#123;EXEC_LUAC&#125;</span><br><span class="line">        $&#123;DIR_SRCS&#125; $&#123;LUAC_MAIN&#125;)</span><br></pre></td></tr></table></figure>

<p>编译工程后我们在<code>build</code>目录可以查看到生成的程序:</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20220929105030969.png" alt="image-20220929105030969"></p>
<p>将其<code>push</code>到<code>root</code>过的<code>android</code>设备上即可正常运行</p>
<p>关于工程配置, 如有疑问 可参考文章《<a href="http://code.newban.cn/363.html">使用Android Studio进行C/C++的开发</a>》</p>
<h3 id="附加"><a href="#附加" class="headerlink" title="附加"></a>附加</h3><ol>
<li><p><code>Mac</code>平台上查看可执行文件的架构</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">file 程序名 或 lipo –info 程序名</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果你的电脑安装了<code>xcode</code>, 那么可以使用<code>xcrun</code>来查看<code>sdk</code>路径</p>
<p>查看当前平台<code>SDK</code>路径:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">xcrun --show-sdk-path</span><br></pre></td></tr></table></figure>

<p>查看<code>iphone</code>平台<code>SDK</code>路径:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">xcrun --sdk iphoneos --show-sdk-path</span><br></pre></td></tr></table></figure>

<p>甚至可以用<code>xcrun</code>配合<code>clang</code>简化编译指令:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">xcrun -sdk iphoneos clang -arch arm64 -o main main.c</span><br><span class="line">或者</span><br><span class="line">clang -isysroot `xcrun --sdk iphoneos --show-sdk-path` main.c -o main -arch arm64</span><br></pre></td></tr></table></figure>

<p>以及本机平台</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">clang -isysroot `xcrun --show-sdk-path` main.c -o main -arch x86_64</span><br></pre></td></tr></table></figure>
</li>
<li><p>目前<code>iphoneOS_SDK</code>支持的<code>cpu</code>架构有</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">arm64</span><br><span class="line">armv7s</span><br><span class="line">armv7</span><br><span class="line">armv6</span><br></pre></td></tr></table></figure>

<p><code>x86</code>系列处理器暂不支持</p>
</li>
</ol>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><h5 id="关于GCC和Clang的使用对比"><a href="#关于GCC和Clang的使用对比" class="headerlink" title="关于GCC和Clang的使用对比:"></a>关于GCC和Clang的使用对比:</h5><p><code>GCC</code> 会针对每一个编译主机和目标架构提供一套完整的套件，包含了二进制、头文件和库等。所以通常使用起来比较简单</p>
<p>而<code>Clang</code>  是复用一套编译系统去负责多个目标的编译任务，通过 <code>-target</code>选项来区分, 各个平台对应的头文件和库需要自己单独准备 编译的时候将路径通过参数告知给<code>Clang</code>, 使用起来相对会麻烦一些</p>
<p><strong>本文为作者原创转载时请注明出处 谢谢</strong></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em><a href="https://code.newban.cn/">乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</a></em></p>
]]></content>
      <tags>
        <tag>clang</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 系统下使用 systemd 控制 frps 及配置开机自启</title>
    <url>/375.html</url>
    <content><![CDATA[<h3 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h3><p>这个示例将会演示在 Linux 系统下使用 systemd 控制 frps 及配置开机自启。</p>
<p>在 Linux 系统下，使用<code>systemd</code> 可以方便地控制 frp 服务端 <code>frps</code> 的启动和停止、配置后台运行和开启自启。</p>
<p>要使用 <code>systemd</code> 来控制 <code>frps</code>，需要先安装 <code>systemd</code>，然后在 <code>/etc/systemd/system</code> 目录下创建一个 frps.service 文件。</p>
<ol>
<li><p>如Linux服务端上没有安装 <code>systemd</code>，可以使用 <code>yum</code> 或 <code>apt</code> 等命令安装 <code>systemd</code>。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># yum</span></span><br><span class="line">yum install systemd</span><br><span class="line"><span class="comment"># apt</span></span><br><span class="line">apt install systemd</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用文本编辑器，如 <code>vim</code> 创建并编辑 <code>frps.service</code> 文件。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ vim /etc/systemd/system/frps.service</span><br></pre></td></tr></table></figure>

<p>写入内容</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="section">[Unit]</span></span><br><span class="line"><span class="comment"># 服务名称，可自定义</span></span><br><span class="line"><span class="attr">Description</span> = frp server</span><br><span class="line"><span class="attr">After</span> = network.target syslog.target</span><br><span class="line"><span class="attr">Wants</span> = network.target</span><br><span class="line"></span><br><span class="line"><span class="section">[Service]</span></span><br><span class="line"><span class="attr">Type</span> = simple</span><br><span class="line"><span class="comment"># 启动frps的命令，需修改为您的frps的安装路径</span></span><br><span class="line"><span class="attr">ExecStart</span> = /path/to/frps -c /path/to/frps.ini</span><br><span class="line"></span><br><span class="line"><span class="section">[Install]</span></span><br><span class="line"><span class="attr">WantedBy</span> = multi-user.target</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用 <code>systemd</code> 命令，管理 frps。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 启动frp</span></span><br><span class="line">systemctl start frps</span><br><span class="line"><span class="comment"># 停止frp</span></span><br><span class="line">systemctl stop frps</span><br><span class="line"><span class="comment"># 重启frp</span></span><br><span class="line">systemctl restart frps</span><br><span class="line"><span class="comment"># 查看frp状态</span></span><br><span class="line">systemctl status frps</span><br></pre></td></tr></table></figure>
</li>
<li><p>配置 frps 开机自启。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl <span class="built_in">enable</span> frps</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p><strong>本文转载自</strong>: <a href="https://gofrp.org/docs/setup/systemd/" target="_blank" rel="noopener">gofrp文档</a></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em><a href="https://code.newban.cn/">乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</a></em></p>
]]></content>
      <tags>
        <tag>进程守护</tag>
      </tags>
  </entry>
  <entry>
    <title>supervisor和systemd的对比</title>
    <url>/374.html</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>过去我们项目组的应用都是用 <code>supervisord</code> 托管的。最近因为某些因素，无法使用 <code>supervisord</code>，因此考虑改用 <code>systemd</code>。</p>
<p><code>systemd</code>作为主流 <code>Linux</code> 发行版的默认选项，之前多多少少用过一点 <code>systemd</code>。不过这次需要上生产环境，所以抽空深入研究一番。</p>
<p>为什么要用<code>supervisord</code>?</p>
<ol>
<li>实现进程的分组管理，比如支持一同启动/停止多个生产者/消费者实例。</li>
<li>进程崩溃的时候可以重启</li>
</ol>
<p>要想改用 <code>systemd</code>，需要看下<code>systemd</code> 如何应对这两个问题。<br>（如无指明，在本文中，<code>supervisord</code> 的配置项在 <code>[program:x]</code> 下面，而 <code>systemd</code> 的配置项则位于 <code>[Service]</code>）</p>
<h3 id="进程控制"><a href="#进程控制" class="headerlink" title="进程控制"></a>进程控制</h3><p>无论 <code>supervisord</code> 还是 <code>systemd</code>，都采用 <code>ini</code>作为配置文件的格式。跟 <code>supervisord</code> 不同的是，<code>systemd</code> 每个程序都要单独开一个<code>unit</code>文件。</p>
<p><code>supervisord</code> 可以同时启动/停止配置文件中所有的进程（或者某个进程组配置中的进程）。<code>systemd</code>可以用依赖来实现这一点。下面例子中，我们<br>就创建了一个可以同时管理的进程组：</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="comment">; group.target</span></span><br><span class="line"><span class="section">[Unit]</span></span><br><span class="line"><span class="attr">Description</span>=Application</span><br><span class="line"><span class="attr">Wants</span>=prog1.service prog2.service</span><br><span class="line"><span class="comment">; prog1.service</span></span><br><span class="line"><span class="section">[Unit]</span></span><br><span class="line"><span class="attr">Description</span>=prog1</span><br><span class="line"><span class="attr">PartOf</span>=group.target</span><br><span class="line"></span><br><span class="line"><span class="section">[Service]</span></span><br><span class="line"><span class="attr">ExecStart</span>=/usr/bin/prog1</span><br><span class="line"><span class="attr">Restart</span>=<span class="literal">on</span>-failure</span><br><span class="line"><span class="comment">; prog2.service</span></span><br><span class="line"><span class="section">[Unit]</span></span><br><span class="line"><span class="attr">Description</span>=prog2</span><br><span class="line"><span class="attr">PartOf</span>=group.target</span><br><span class="line"></span><br><span class="line"><span class="section">[Service]</span></span><br><span class="line"><span class="attr">ExecStart</span>=/usr/bin/prog2</span><br><span class="line"><span class="attr">Restart</span>=<span class="literal">on</span>-failure</span><br></pre></td></tr></table></figure>

<p><code>systemctl start group.target</code>，<code>prog1</code> 和 <code>prog2</code> 也会带起来。<code>systemctl restart group.target</code>，<code>prog1</code> 和 <code>prog2</code> 也会跟着重启。</p>
<p>相对来说，<code>supervisord</code> 的做法更加直观一些。</p>
<p>如果要更改<code>supervisord</code>的配置文件，<code>supervisord</code> 需要运行 <code>supervisorctl reread</code> 才会生效。<br>而 systemd 则需要 <code>systemctl daemon-reload</code>。半斤八两吧。</p>
<p>不过 <code>supervisord</code> 有一个好。如果你不知道哪些程序的配置改变了，简单地执行 <code>supervisorctl update</code>，所有涉及的进程都会被重启。<br>而 <code>systemd</code> 貌似做不到这一点。</p>
<p><code>systemd</code> 可以指定 <code>stop</code> 操作时可以选择的命令（<code>ExecStop=</code>）。另外它还提供了 <code>ExecReload=</code>，可以自定义调用 <code>systemctl reload xxx</code> 重新读取程序配置文件时的操作。<br><code>supervisord</code>不支持 reload 指定进程。同时对于 <code>stop</code>操作，它只允许你选择要发送哪种信号…</p>
<p><code>supervisord</code> 的 <code>stopwaitsecs</code> 可以控制<code>stop</code> 操作后等待程序退出的耐心（以秒衡量）。待给定的耐心都消耗完毕后，<code>supervisord</code> 才会痛下杀手，发送 <code>SIGKILL</code>。</p>
<p><code>systemd</code> 对应的配置项是 <code>TimeoutStopSec=</code>。<code>systemd</code> 会给多一次机会，在下最后通牒之前，会先发送 <code>SIGTERM</code>，过另一个<code>TimeoutStopSec</code>之后才发送 <code>SIGKILL</code>。</p>
<h3 id="进程重启"><a href="#进程重启" class="headerlink" title="进程重启"></a>进程重启</h3><p>为了避免在<code>supervisord</code> 和 <code>systemd</code>两套术语间迷糊，请允许我抛弃所有术语，用自己的话描述。<br><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/bVNlB3.png" alt="life-cycle"></p>
<p>从上图可以看到，进程在 RUNNING 之前，会有一个 STARTING 的过程。在 STARTING 过程中，进程可能会读取配置文件，进行初始化。<br>这一过程中的错误处理，跟 RUNNING 状态的应当有所不同。<br>以上是<code>supervisord</code>的想法。</p>
<p>所以<code>supervisord</code> 提供了单独的 <code>startretries</code> 配置项，用来配置 STARTING 阶段的重启次数。<br><code>systemd</code> 对此没有特殊处理。</p>
<p>一个程序，从 RUNNING 到 EXITED，有两种可能：正常退出或异常退出…（废话）<br>这两种情况，是通过配置的退出码来区分的。对于 supervisord，这个配置项是 <code>exitcodes</code>。systemd 则通过 <code>SuccessExitStatus</code> 来控制。<br>有趣的是，<code>exitcodes</code> 的默认值是 <code>0,2</code>，不知道为何它会认为 2 也是正常的退出码。</p>
<p>如果配置了 <code>autorestart = true</code>，只要程序退出，supervisord 都会把它启动起来。相对的，如果配置的是 <code>autorestart = unexpected</code>，则只有<br>异常退出才会重启。这两个选项，在 systemd 里对应 <code>Restart=always</code> 和 <code>Restart=on-failure</code>。systemd 还提供了 <code>Restart=on-success</code>（只有正常<br>退出才重启）和 <code>Restart=on-abort</code>（只有收到异常信号才重启）。</p>
<p>对于重启次数，supervisord 没有作限定。因为重启一个程序时，supervisord 会先让它处于 STARTING 状态。这个状态的持续时间，是由配置项<br>中的 <code>startsecs</code> 决定的，默认 1 秒。如果是不可恢复的错误，程序就不可能成功进入到 RUNNING 状态。当然也许存在这样的情况，程序运行 1 秒<br>后，就会崩溃。那么它就会陷于不停重启的无间地狱。</p>
<p>systemd 对此一如既往，提供了 N 多选项以供采用。你可以用 <code>RestartSec</code> 控制每次重启的间隔，可以用 <code>StartLimitInterval</code> 和 <code>StartLimitBurst</code> 设定<br>给定周期内能够重启的次数。比如指定 <code>StartLimitInterval=1s</code>，<code>StartLimitBurst=3</code>，就可以实现跟 supervisord 一致的默认重启策略。</p>
<p>比较完最基本的两种功能，让我们继续看看，两者在一些小细节上的对对碰。</p>
<h3 id="控制实例数"><a href="#控制实例数" class="headerlink" title="控制实例数"></a>控制实例数</h3><p>supervisord 可以用 <code>numprocs</code> 来控制单个程序对应的实例数。systemd 也可以做到这一点，虽然有点麻烦（某种意义上，更加强大）。<br>systemd 会把以 <code>@</code> 结尾的 <code>service</code> 文件当作模板，在运行时根据给定的参数展开成多个实例。</p>
<p>具体实现方式见：<a href="https://link.segmentfault.com/?enc=nJSR4eNZaRtjZIvOJtXQHQ%3D%3D.N0wfD2e5Vr7MGW4z%2Fm795uHR0ndfEbdXn2L08LFtC0dMNHNilvEGb%2BHk6cD6UiK5" target="_blank" rel="noopener">http://0pointer.de/blog/proje…</a></p>
<h3 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h3><p><code>supervisord</code> 能够重定向被托管的程序的 stdout 和 stderr 到日志文件中，并提供日志切割服务。<code>systemd</code> 也支持这一点，尽管它的实现有很大的不同。</p>
<p>根据鄙人的经验，基于定期检查的日志切割服务，不是个好的选择。<br>一旦遇上突发高峰，有可能会出现日志无法及时切割的情况；而调小检查间隔，大部分情况下都在无意义地空转。（说的就是你，logroated）<br>好在无论是 <code>supervisord</code>，还是<code>systemd</code>，提供的切割服务都是实时的。每当写入内容会超过上限时，就会自动切割。</p>
<p>systemd 的日志服务是通过 journald 组件实现的。你可以在 <code>/etc/systemd/journald.conf</code> 中配置它。<br>journald 默认的日志存储形式是 <code>Storage=auto</code>。这个选项比较奇妙，如果你创建了 <code>/var/log/journal</code> 文件夹，那么它就会把日志写到这个文件夹下。否则不进行持久化。</p>
<p>持久化后的日志是这个样子的：</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line"><span class="regexp">/var/</span>log<span class="regexp">/journal/</span>c4010ceea79847afbedecb60a775db96<span class="regexp">/</span></span><br><span class="line"><span class="regexp">├── system.journal</span></span><br><span class="line"><span class="regexp">├── user-1000.journal</span></span><br><span class="line"><span class="regexp">└── user-65534.journal</span></span><br></pre></td></tr></table></figure>

<p>第一次看到这样的目录结构，说不定你会大吃一惊。journald 设计者脑洞不是一般的大。从这个结构上，根本看不出应用日志在哪里嘛。<br>不，完全没有这样的必要，因为所有的程序的日志都会写到一块去。不分彼此，全变成一团浆糊。随便一提，日志默认都是压缩的。</p>
<p>要看日志，你得用 <code>journalctl</code>。比如看 <code>prog1.service</code> 的日志，需要 <code>journalctl -u prog1.service</code>。要看特定时期的日志，需要 <code>journalctl --since $timestamp --until $timestamp</code>。</p>
<p>这么前卫的设计我可接受无能。这种 <code>journalctl</code> 控制一切的方式，导致 systemd 日志无法集成到传统的日志收集工具中。<br>程序员工具箱中各种 <code>text base</code> 处理工具，对此也大眼瞪小眼，只能对着 <code>journalctl</code> 低三下四，接受对方的小脾气。</p>
<p>journald 提供了三个配置项，<code>RuntimeMaxFileSize=</code> 和 <code>RuntimeMaxFiles=</code>。顾名思义，就是单个日志文件大小和允许的日志数。<br>另外，<code>RuntimeMaxUse=</code> 和 <code>RuntimeKeepFree=</code> 可以控制总大小的上限。</p>
<p>supervisord 在这方面做的要好得多。通过 <code>stdout/stderr_logfile_maxbytes</code> 和 <code>stdout/stderr_logfile_backups</code>，你可以规划每一个程序的日志文件的切割粒度。<br>不同程序的日志不会挤一起，产生日志少的程序也不会被产生日志多的程序干扰。</p>
<h3 id="开机自启"><a href="#开机自启" class="headerlink" title="开机自启"></a>开机自启</h3><p><code>systemd</code> 支持开机自启, 而<code>supervisor</code>开机自启需依赖其他程序实现, 其本身也是被监控的对象</p>
<h3 id="systemd-vs-supervisord"><a href="#systemd-vs-supervisord" class="headerlink" title="systemd vs supervisord"></a>systemd vs supervisord</h3><p>除了以上几点外，还有一些没有具体提到的功能。<br>比如 supervisord 通过 priority 配置进程启动顺序，以及 systemd 对应的 Before/After 依赖机制。<br>比如 supervisord 的 events 功能，和与之相对应的 systemd 的 notify 机制。<br>比如 supervisord 可以管理 fastcgi（真有人这么做吗）。<br>比如 systemd 提供的基于 cgroup 的资源限制。<br>由于没有使用经验，对这些功能就不作一一比较了。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><code>systemd</code>和 <code>supervisord</code> 各有长短，不存在哪一方绝对的碾压。</p>
<p><code>systemd</code> 跟<code>Linux</code> 紧密结合，所需的依赖少，其提供的保障自然比 <code>supervisord</code> 更可靠。然而在强大的能力背后，也有配置复杂、不易上手等问题。</p>
<p><code>supervisord</code>偏于应用层，却因此有独特的用武之地。</p>
<p>举个例子，许多人会往 <code>docker</code>打包里面封入一份<code>supervisord</code>，让它来做 <code>PID 1</code>，以此稍微增强下健壮性。<br>换 <code>systemd</code> 做同样的事，就像用园艺剪刀裁纸，即使能够顺利完成，也难免事倍功半。毕竟这样的方式跟<code>systemd</code> 的设计是背道而驰的。</p>
<p><strong>本文转载自</strong>: <a href="https://segmentfault.com/a/1190000009338835" target="_blank" rel="noopener">segmentfault</a></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em><a href="https://code.newban.cn/">乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</a></em></p>
]]></content>
      <tags>
        <tag>进程守护</tag>
      </tags>
  </entry>
  <entry>
    <title>cmake的使用以及语法</title>
    <url>/380.html</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>我们使用 <code>Make</code> 工具构建项目时，需要编写 <code>Makefile</code>，但不同的平台 <code>Make</code>工具是不一样的，比如<code>Linux</code>的<code>GNU Make</code> ，<code>Windows</code> 的 <code>nmake</code>，它们对 <code>Makefile</code>的规范也是不一样的，如果软件要跨平台，则需要针对每一种 <code>Make</code>工具写一份 <code>Makefile</code>，非常浪费时间</p>
<p>而且当软件比较庞大时，<code>Makefile</code>的编写也会变的复杂。</p>
<h3 id="CMake-简介"><a href="#CMake-简介" class="headerlink" title="CMake 简介"></a>CMake 简介</h3><p><code>CMake（Cross-Platform-Make</code>）是一个开源、跨平台的软件构建工具，它使用与平台独立的配置文件来对软件编译过程进行控制，根据用户所需，生成 <code>Makefile</code> 或者<code>IDE</code>的<code>project。</code></p>
<h3 id="CMake-构建过程"><a href="#CMake-构建过程" class="headerlink" title="CMake 构建过程"></a>CMake 构建过程</h3><ol>
<li><p>编写<code>CMake</code> 配置文件<code>CMakeLists.txt</code>，一般放在项目的最顶层目录下</p>
</li>
<li><p>运行 <code>cmake</code> 命令，参数为 <code>CMakeLists.txt</code> 所在根路径，执行完成后得到 <code>Makefile</code> 文件。</p>
</li>
<li><p>使用<code>make</code> 命令进行编译。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkdir -p build &amp;&amp; <span class="built_in">cd</span> build</span><br><span class="line">cmake ..</span><br><span class="line">make</span><br></pre></td></tr></table></figure>





</li>
</ol>
<h3 id="cmake基本语法"><a href="#cmake基本语法" class="headerlink" title="cmake基本语法"></a>cmake基本语法</h3><ol>
<li><p>指定最小版本 </p>
<p>如果使用的 <code>CMake</code>版本低于该版本，则会发出致命错误</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cmake_minimum_required(VERSION 3.9)</span><br></pre></td></tr></table></figure>
</li>
<li><p>设置工程名 可以同时指定工程版本和语言，<code>CXX</code>代表<code>C++</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">project(sunflower VERSION 0.0.1 LANGUAGES C CXX)</span><br></pre></td></tr></table></figure>
</li>
<li><p>单行注释</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 我是注释</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>多行注释</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#[[我是多行注释</span></span><br><span class="line">我是多行注释</span><br><span class="line">]]</span><br></pre></td></tr></table></figure>
</li>
<li><p>设置 <code>c/c++</code>版本</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">set</span>(CMAKE_C_STANDARD 11)</span><br><span class="line"><span class="built_in">set</span>(CMAKE_CXX_STANDARD 11)</span><br></pre></td></tr></table></figure>
</li>
<li><p>设置编译选项</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">set</span>(CMAKE_C_FLAGS   <span class="string">"<span class="variable">$&#123;CMAKE_C_FLAGS&#125;</span> -g -w -O3"</span>)</span><br><span class="line"><span class="built_in">set</span>(CMAKE_CXX_FLAGS <span class="string">"<span class="variable">$&#123;CMAKE_CXX_FLAGS&#125;</span> -g -w -O3"</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>添加宏定义</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">add_definitions(-DSPDLOG_ACTIVE_LEVEL=SPDLOG_LEVEL_INFO)</span><br></pre></td></tr></table></figure>
</li>
<li><p>设置头文件搜索目录 </p>
<p>实现编译时的 <code>[-I]</code> 选项，设置后引用头文件不需要使用相对路径，直接引用文件名</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">include_directories(</span><br><span class="line">  <span class="string">"<span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/include"</span></span><br><span class="line">  <span class="string">"<span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/depends/json/"</span></span><br><span class="line">  <span class="string">"<span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/depends/leveldb/include"</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
</li>
<li><p>设置库文件搜索目录 </p>
<p>实现编译时的[-L]选项，项目内部明确路径的库文件，可以通过该命令指定</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">link_directories(</span><br><span class="line">    <span class="string">"<span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/depends/json/lib"</span></span><br><span class="line">    <span class="string">"<span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/depends/leveldb"</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
</li>
<li><p>查找指定库文件 </p>
<p>查找到指定的预编译库，并将它的路径存储在变量中。</p>
<p>默认的搜索路径为 <code>cmake</code> 包含的系统库，因此如果是<code>NDK</code>的公共库只需要指定库的<code>name</code> 即可（不需<code>path</code>），类似的命令还有<code>find_file()</code>、<code>find_path()</code>、<code>find_program()</code>、<code>find_package()</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">find_library(<span class="built_in">log</span>-lib,<span class="built_in">log</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>查找指定目录下源文件<br>获取指定目录下源文件列表，保存到 <code>DIR_SRCS</code> 变量中，后续编译构建目标可执行文件</p>
<p>注意这里不能递归获取子目录下的源文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">aux_source_directory(<span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/src DIR_SRCS)</span><br></pre></td></tr></table></figure>
</li>
<li><p>添加子目录源文件<br>使用命令 <code>add_subdirectory</code> 指明本项目包含一个子目录，这样子目录下<code>的 CMakeLists.txt</code>文件和源文件也会被处理。</p>
<p>项目包含多个子目录时，通常可以在子目录下也定义<code>CMakeLists.txt</code> 文件，并通过 <code>add_library</code> 生成包含子目录源码的库文件，并最终链接到目标可执行文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">add_subdirectory(utils)</span><br><span class="line">add_subdirectory(config)</span><br></pre></td></tr></table></figure>
</li>
<li><p>递归查找目录下的所有源文件<br>可以通过 <code>file</code>命令递归获取指定目录下的所有源文件，这样可以不用为子目录专门定义<code>CMakeLists.txt</code>，也不需要通过链接的方式集成各个子目录，而是统一编译构建</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">file(GLOB_RECURSE DIR_SRCS</span><br><span class="line">    <span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/src/*.c</span><br><span class="line">    <span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/src/*.cc</span><br><span class="line">    <span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/src/*.cpp</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
</li>
<li><p>设置可执行文件输出路径</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">set</span>(EXECUTABLE_OUTPUT_PATH <span class="variable">$&#123;PROJECT_BINARY_DIR&#125;</span>/bin)</span><br></pre></td></tr></table></figure>
</li>
<li><p>生成可执行文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">add_executable(<span class="variable">$&#123;PROJECT_NAME&#125;</span> <span class="variable">$&#123;DIR_SRCS&#125;</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>生成库文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">add_library(<span class="variable">$&#123;PROJECT_NAME&#125;</span> STATIC <span class="variable">$&#123;DIR_SRCS&#125;</span>)</span><br><span class="line">add_library(<span class="variable">$&#123;PROJECT_NAME&#125;</span> SHARED <span class="variable">$&#123;DIR_SRCS&#125;</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>链接库文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">set</span>(EXTRA_LIBS</span><br><span class="line">    sasl2</span><br><span class="line">    libleveldb.a</span><br><span class="line">)</span><br><span class="line">target_link_libraries(<span class="variable">$&#123;PROJECT_NAME&#125;</span></span><br><span class="line">    <span class="variable">$&#123;EXTRA_LIBS&#125;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="常用变量"><a href="#常用变量" class="headerlink" title="常用变量"></a>常用变量</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">PROJECT_SOURCE_DIR：工程的根目录</span><br><span class="line"></span><br><span class="line">PROJECT_BINARY_DIR：运行cmake命令的目录，通常为<span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/build</span><br><span class="line"></span><br><span class="line">PROJECT_NAME：返回通过 project 命令定义的项目名称</span><br><span class="line"></span><br><span class="line">CMAKE_CURRENT_SOURCE_DIR：当前处理的 CMakeLists.txt 所在的路径</span><br><span class="line"></span><br><span class="line">CMAKE_CURRENT_BINARY_DIR：target 编译目录</span><br><span class="line"></span><br><span class="line">CMAKE_CURRENT_LIST_DIR：CMakeLists.txt 的完整路径</span><br><span class="line"></span><br><span class="line">EXECUTABLE_OUTPUT_PATH：重新定义目标二进制可执行文件的存放位置</span><br><span class="line"></span><br><span class="line">LIBRARY_OUTPUT_PATH：重新定义目标链接库文件的存放位置</span><br></pre></td></tr></table></figure>

<h3 id="自定义变量"><a href="#自定义变量" class="headerlink" title="自定义变量"></a>自定义变量</h3><p>使用<code>SET</code>, 比如:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">set</span>(BINARY_NAME <span class="string">"juce_jni"</span>)</span><br><span class="line"></span><br><span class="line">add_library( <span class="variable">$&#123;BINARY_NAME&#125;</span></span><br><span class="line"></span><br><span class="line">    SHARED</span><br><span class="line"></span><br><span class="line">    <span class="string">"../../../Source/Main.cpp"</span></span><br><span class="line">    )</span><br></pre></td></tr></table></figure>

<h3 id="支持-Debug-版本"><a href="#支持-Debug-版本" class="headerlink" title="支持 Debug 版本"></a>支持 Debug 版本</h3><ol>
<li><p>设置不同版本的编译选项</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">set</span>(CMAKE_CXX_FLAGS_DEBUG <span class="string">"<span class="variable">$ENV</span>&#123;CXXFLAGS&#125; -O0 -Wall -g -ggdb"</span>)</span><br><span class="line"><span class="built_in">set</span>(CMAKE_CXX_FLAGS_RELEASE <span class="string">"<span class="variable">$ENV</span>&#123;CXXFLAGS&#125; -O3 -Wall"</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>cmake 时指定版本</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cmake .. -DCMAKE_BUILD_TYPE=Debug</span><br><span class="line">cmake .. -DCMAKE_BUILD_TYPE=Release</span><br></pre></td></tr></table></figure>




</li>
</ol>
<h3 id="完整示例"><a href="#完整示例" class="headerlink" title="完整示例"></a>完整示例</h3><h4 id="工程结构"><a href="#工程结构" class="headerlink" title="工程结构"></a>工程结构</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">+-- CMakeTest</span><br><span class="line">    |</span><br><span class="line">    +-- CMakeList.txt</span><br><span class="line">    +-- src</span><br><span class="line">        |</span><br><span class="line">        +--  main.cc</span><br><span class="line">        +--- utils/</span><br><span class="line">             |</span><br><span class="line">             +--- utils.cc</span><br><span class="line">             +--- utils.h</span><br><span class="line">        +-- config/</span><br><span class="line">            |</span><br><span class="line">            +-- config.cc</span><br><span class="line">            +-- config.h</span><br><span class="line">    +-- libs</span><br><span class="line">        |</span><br><span class="line">        +-- libleveldb.a</span><br></pre></td></tr></table></figure>

<h4 id="CMakeList-txt"><a href="#CMakeList-txt" class="headerlink" title="CMakeList.txt"></a>CMakeList.txt</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cmake_minimum_required(VERSION 3.7.1)</span><br><span class="line"> </span><br><span class="line">project(CMakeTest VERSION 0.0.1 LANGUAGES C CXX)</span><br><span class="line"> </span><br><span class="line"><span class="built_in">set</span>(CMAKE_C_STANDARD 11)</span><br><span class="line"><span class="built_in">set</span>(CMAKE_CXX_STANDARD 11)</span><br><span class="line"> </span><br><span class="line"><span class="built_in">set</span>(CMAKE_C_FLAGS   <span class="string">"<span class="variable">$&#123;CMAKE_C_FLAGS&#125;</span> -g -w -O3"</span>)</span><br><span class="line"><span class="built_in">set</span>(CMAKE_CXX_FLAGS <span class="string">"<span class="variable">$&#123;CMAKE_CXX_FLAGS&#125;</span> -g -w -O3"</span>)</span><br><span class="line"> </span><br><span class="line"><span class="built_in">set</span>(EXECUTABLE_OUTPUT_PATH <span class="variable">$&#123;PROJECT_BINARY_DIR&#125;</span>/bin)</span><br><span class="line"> </span><br><span class="line">include_directories(</span><br><span class="line">    <span class="string">"utils"</span></span><br><span class="line">    <span class="string">"config"</span></span><br><span class="line">)</span><br><span class="line"> </span><br><span class="line">link_directories(</span><br><span class="line">    <span class="string">""</span><span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/libs<span class="string">""</span></span><br><span class="line">)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 子目录的CMakeList.txt也可以定义到主配置中</span></span><br><span class="line"><span class="comment"># 将utils和config两个子目录的源文件打包成库test_share</span></span><br><span class="line">aux_source_directory(<span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/src/utils SHARE_SRC_FILES)</span><br><span class="line">aux_source_directory(<span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/src/config SHARE_SRC_FILES)</span><br><span class="line">add_library(test_share STATIC <span class="variable">$&#123;SHARE_SRC_FILES&#125;</span> )</span><br><span class="line"> </span><br><span class="line">aux_source_directory(<span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/src DIR_SRCS)</span><br><span class="line">add_executable(<span class="variable">$&#123;PROJECT_NAME&#125;</span> <span class="variable">$&#123;DIR_SRCS&#125;</span>)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 也可以使用file命令递归获取目录下所有源文件</span></span><br><span class="line">file(GLOB_RECURSE DIR_SRCS</span><br><span class="line">    <span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/src/*.c</span><br><span class="line">    <span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/src/*.cc</span><br><span class="line">    <span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/src/*.cpp</span><br><span class="line">)</span><br><span class="line">add_executable(<span class="variable">$&#123;PROJECT_NAME&#125;</span> <span class="variable">$&#123;DIR_SRCS&#125;</span>)</span><br><span class="line"> </span><br><span class="line"><span class="built_in">set</span>(EXTRA_LIBS</span><br><span class="line">    ldl</span><br><span class="line">    pthread</span><br><span class="line">    libleveldb.a</span><br><span class="line">)</span><br><span class="line"> </span><br><span class="line">target_link_libraries(<span class="variable">$&#123;PROJECT_NAME&#125;</span></span><br><span class="line">    test_share</span><br><span class="line">    <span class="variable">$&#123;EXTRA_LIBS&#125;</span></span><br><span class="line"></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p><strong>本文转载自</strong>: <a href="https://blog.csdn.net/weixin_39773239/article/details/113052000" target="_blank" rel="noopener">CSDN</a></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em><a href="https://code.newban.cn/">乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</a></em></p>
]]></content>
      <tags>
        <tag>cmake</tag>
      </tags>
  </entry>
  <entry>
    <title>使用python利用第三方登录实现自动化简书发布文章</title>
    <url>/38.html</url>
    <content><![CDATA[<h3 id="话不多说-首先附上代码"><a href="#话不多说-首先附上代码" class="headerlink" title="话不多说 首先附上代码"></a>话不多说 首先附上代码</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.support.wait <span class="keyword">import</span> WebDriverWait</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> linecache</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Main</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="comment"># init</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, file)</span>:</span></span><br><span class="line">        self.title = <span class="string">''</span></span><br><span class="line">        self.content = <span class="string">''</span></span><br><span class="line">        self.category = <span class="string">''</span></span><br><span class="line">        self.tags = <span class="string">''</span></span><br><span class="line">        <span class="comment"># OsChina的系统分类, 设个默认值</span></span><br><span class="line">        self.osChina_sys_category = <span class="string">'编程语言'</span></span><br><span class="line">        <span class="comment"># CSDN的文章分类, 设个默认值</span></span><br><span class="line">        self.csdn_article_category = <span class="string">'原创'</span></span><br><span class="line">        <span class="comment"># CSDN的博客分类, 设个默认值</span></span><br><span class="line">        self.csdn_blog_category = <span class="string">'后端'</span></span><br><span class="line">        self.read_file(file)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 读取MD中的title, content, self_category, self_tags, osChina_sys_category, csdn_article_category, csdn_blog_category</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">read_file</span><span class="params">(self, markdown_file)</span>:</span></span><br><span class="line">        self.title = linecache.getline(markdown_file, <span class="number">2</span>).split(<span class="string">'title: '</span>)[<span class="number">1</span>].strip(<span class="string">'\n'</span>)</span><br><span class="line">        <span class="keyword">with</span> open(markdown_file, <span class="string">'r'</span>, encoding=<span class="string">'UTF-8'</span>) <span class="keyword">as</span> f:</span><br><span class="line">            self.content = f.read().split(<span class="string">'--&gt;\n'</span>)[<span class="number">1</span>]</span><br><span class="line">            <span class="comment"># 重置文件指针偏移量</span></span><br><span class="line">            f.seek(<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">for</span> line <span class="keyword">in</span> f.readlines():</span><br><span class="line">                <span class="keyword">if</span> re.search(<span class="string">'self_category: '</span>, line) <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                    self.category = line.split(<span class="string">'self_category: '</span>)[<span class="number">1</span>].strip(<span class="string">'\n'</span>)</span><br><span class="line">                <span class="keyword">elif</span> re.search(<span class="string">'self_tags: '</span>, line) <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                    self.tags = line.split(<span class="string">'self_tags: '</span>)[<span class="number">1</span>].strip(<span class="string">'\n'</span>)</span><br><span class="line">                <span class="keyword">elif</span> re.search(<span class="string">'osChina_sys_category: '</span>, line) <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                    self.osChina_sys_category = line.split(<span class="string">'osChina_sys_category: '</span>)[<span class="number">1</span>].strip(<span class="string">'\n'</span>)</span><br><span class="line">                <span class="keyword">elif</span> re.search(<span class="string">'csdn_article_category: '</span>, line) <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                    self.csdn_article_category = line.split(<span class="string">'csdn_article_category: '</span>)[<span class="number">1</span>].strip(<span class="string">'\n'</span>)</span><br><span class="line">                <span class="keyword">elif</span> re.search(<span class="string">'csdn_blog_category: '</span>, line) <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                    self.csdn_blog_category = line.split(<span class="string">'csdn_blog_category: '</span>)[<span class="number">1</span>].strip(<span class="string">'\n'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># QQ授权登录, 使用前提是QQ客户端在线</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">qq</span><span class="params">(driver, timeout)</span>:</span></span><br><span class="line">    <span class="comment"># 切换到最新打开的窗口</span></span><br><span class="line">    window_handles = driver.window_handles</span><br><span class="line">    driver.switch_to.window(window_handles[<span class="number">-1</span>])</span><br><span class="line"></span><br><span class="line">    print(<span class="string">'qq authorize title is '</span>, driver.title)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 切换iframe</span></span><br><span class="line">    iframe = WebDriverWait(driver, timeout).until(<span class="keyword">lambda</span> d: d.find_element_by_id(<span class="string">'ptlogin_iframe'</span>))</span><br><span class="line">    driver.switch_to.frame(iframe)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 点击头像进行授权登录</span></span><br><span class="line">    login = WebDriverWait(driver, timeout).until(<span class="keyword">lambda</span> d: d.find_element_by_xpath(<span class="string">'//*[@id="qlogin_list"]/a[1]'</span>))</span><br><span class="line">    login.click()</span><br><span class="line"><span class="comment"># 简书</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">JianShu</span><span class="params">(object)</span>:</span></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">post</span><span class="params">(main, timeout, self_timeout=<span class="number">3</span>)</span>:</span></span><br><span class="line">        <span class="comment"># 1.跳转登陆</span></span><br><span class="line">        login = <span class="string">'https://www.jianshu.com/sign_in'</span></span><br><span class="line">        driver = webdriver.Chrome()</span><br><span class="line">        driver.get(login)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 2.窗口最大化</span></span><br><span class="line">        driver.maximize_window()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 3.使用QQ授权登录</span></span><br><span class="line">        driver.find_element_by_xpath(<span class="string">'/html/body/div[1]/div[2]/div/div/ul/li[3]/a/i'</span>).click()</span><br><span class="line">        driver.close()</span><br><span class="line">        qq(driver, timeout)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 4.点击"写文章"</span></span><br><span class="line">        write_blog = WebDriverWait(driver, timeout).until(<span class="keyword">lambda</span> d: d.find_element_by_xpath(<span class="string">'/html/body/nav/div/a[2]'</span>))</span><br><span class="line">        write_blog = WebDriverWait(driver, timeout).until(<span class="keyword">lambda</span> d: d.find_elements_by_class_name(<span class="string">'/html/body/nav/div/a[2]'</span>))</span><br><span class="line">        write_blog.click()</span><br><span class="line">        driver.close()</span><br><span class="line">        time.sleep(<span class="number">3</span>)</span><br><span class="line">       <span class="comment"># window_handles = driver.window_handles</span></span><br><span class="line">        <span class="comment">#driver.switch_to.window(window_handles[-1])</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 5.点击指定分类</span></span><br><span class="line">        classify = WebDriverWait(driver, timeout).until(<span class="keyword">lambda</span> d: d.find_elements_by_class_name(<span class="string">'_3DM7w'</span>))</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> classify:</span><br><span class="line">            html = c.get_attribute(<span class="string">'innerHTML'</span>)</span><br><span class="line">            <span class="keyword">if</span> main.category <span class="keyword">in</span> html:</span><br><span class="line">                c.click()</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># TODO 如果分类不存在，还可以直接新建分类</span></span><br><span class="line">                <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 6.点击'新建文章'</span></span><br><span class="line">        time.sleep(self_timeout)</span><br><span class="line">        new_article = WebDriverWait(driver, timeout).until(</span><br><span class="line">            <span class="keyword">lambda</span> d: d.find_element_by_xpath(<span class="string">'//*[@id="root"]/div/div[2]/div[1]/div/div/div/div[1]/i'</span>))</span><br><span class="line">        new_article.click()</span><br><span class="line">        article = WebDriverWait(driver, timeout).until(</span><br><span class="line">            <span class="keyword">lambda</span> d: d.find_element_by_xpath(<span class="string">'//*[@id="root"]/div/div[2]/div[1]/div/div/div/ul/li[1]'</span>))</span><br><span class="line">        article.click()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 7.填写标题, 内容</span></span><br><span class="line">        time.sleep(self_timeout)</span><br><span class="line">        title = driver.find_element_by_class_name(<span class="string">'_24i7u'</span>)</span><br><span class="line">        title.clear()</span><br><span class="line">        title.send_keys(main.title)</span><br><span class="line">        content = driver.find_element_by_id(<span class="string">'arthur-editor'</span>)</span><br><span class="line">        content.clear()</span><br><span class="line">        content.send_keys(main.content)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 8.保存草稿</span></span><br><span class="line">        driver.find_element_by_xpath(<span class="string">'//*[@id="root"]/div/div[2]/div[2]/div/div/div/div/ul/li[8]/a'</span>).click()</span><br><span class="line">        <span class="comment"># 8.发布文章</span></span><br><span class="line">        <span class="comment"># driver.find_element_by_xpath('//*[@id="root"]/div/div[2]/div[2]/div/div/div/div/ul/li[1]/a').click()</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    md_file = <span class="string">'auto.md'</span></span><br><span class="line">    print(<span class="string">"Markdown File is "</span>, md_file)</span><br><span class="line"></span><br><span class="line">    timeout = <span class="number">30</span></span><br><span class="line">    main = Main(md_file)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 简书</span></span><br><span class="line">    jian_shu = JianShu()</span><br><span class="line">    jian_shu.post(main, timeout)</span><br></pre></td></tr></table></figure>

<p>PS：<code>Selenium</code>操纵浏览器是依赖于浏览器驱动程序的，不同版本的浏览器需要下载不同版本的驱动, 否则程序无法运行, 下面贴出的是谷歌和火狐浏览器驱动程序的下载地址。</p>
<table>
<thead>
<tr>
<th>Chrome ( chromedriver )</th>
<th>Firefox ( geckodriver )</th>
</tr>
</thead>
<tbody><tr>
<td><a href="http://chromedriver.storage.googleapis.com/index.html" target="_blank" rel="noopener">官方下载</a></td>
<td><a href="https://github.com/mozilla/geckodriver/releases" target="_blank" rel="noopener">官方下载</a></td>
</tr>
<tr>
<td><a href="https://npm.taobao.org/mirrors/chromedriver/" target="_blank" rel="noopener">淘宝镜像</a></td>
<td><a href="https://npm.taobao.org/mirrors/geckodriver/" target="_blank" rel="noopener">淘宝镜像</a></td>
</tr>
<tr>
<td><a href="http://image.mariojd.cn/chromedriver.exe" target="_blank" rel="noopener">备用下载</a></td>
<td><a href="http://image.mariojd.cn/geckodriver.exe" target="_blank" rel="noopener">备用下载</a></td>
</tr>
</tbody></table>
<p>关于谷歌驱动的下载安装, 详情可参见文章《<a href="https://code.newban.cn/292.html">Web自动化框架selenium的介绍与使用</a>》</p>
<p><strong>本文为作者原创 转载时请注明出处 谢谢</strong></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em>乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</em></p>
]]></content>
      <tags>
        <tag>python自动化</tag>
      </tags>
  </entry>
  <entry>
    <title>C语言中静态库static和动态库shared的区别</title>
    <url>/381.html</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>在<code>c/c++</code>语言编译时 我们经常能碰到关于静态库(static)和动态库(shared)的链接</p>
<p>那它们有什么区别呢</p>
<h3 id="静态库"><a href="#静态库" class="headerlink" title="静态库"></a>静态库</h3><p>静态库(static)是程序在编译期间进行链接的, 它会被打包进可执行程序当中</p>
<h3 id="动态库"><a href="#动态库" class="headerlink" title="动态库"></a>动态库</h3><p>动态库(shared)也叫共享库, 它是在程序运行是进行链接的, 以独立的文件存在, 不会被打包进可执行程序中, 但是程序在执行时需要能找到这个库的具体位置, 否则程序可能出错</p>
<h3 id="不同系统中动态库的文件类型"><a href="#不同系统中动态库的文件类型" class="headerlink" title="不同系统中动态库的文件类型"></a>不同系统中动态库的文件类型</h3><table>
<thead>
<tr>
<th>系统</th>
<th>动态库后缀</th>
<th>静态库后缀</th>
</tr>
</thead>
<tbody><tr>
<td>Linux</td>
<td>.so</td>
<td>.a</td>
</tr>
<tr>
<td>Mac</td>
<td>.dylib</td>
<td>.a</td>
</tr>
<tr>
<td>Windows</td>
<td>.dll</td>
<td>.lib</td>
</tr>
</tbody></table>
<h3 id="两种库的优势和劣势"><a href="#两种库的优势和劣势" class="headerlink" title="两种库的优势和劣势"></a>两种库的优势和劣势</h3><h4 id="静态库-1"><a href="#静态库-1" class="headerlink" title="静态库"></a>静态库</h4><p><strong>优势:</strong></p>
<ul>
<li>将依赖的静态库直接打包进可执行文件中, 不用担心对方的机器找不到库导致无法运行</li>
<li>由于直接嵌入到了执行程序中 因此运行速度较快</li>
</ul>
<p><strong>劣势:</strong></p>
<ul>
<li>会导致可执行文件的体积过大</li>
<li>如果多个程序使用了同一个静态库 一旦静态库出现bug, 那么与之相关的所有可执行程序都要进行重新编译</li>
</ul>
<h4 id="动态库-1"><a href="#动态库-1" class="headerlink" title="动态库"></a>动态库</h4><p><strong>优势:</strong></p>
<ul>
<li>能有效减少可执行程序的体积</li>
<li>一旦库出现<code>bug</code>, 只需修复并重新编译库即可</li>
</ul>
<p><strong>劣势:</strong></p>
<ul>
<li>需要将库放到指定路径下 供主程序调用 操作起来相对麻烦</li>
<li>运行速度相对静态库会慢一些</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>静态库和动态库, 没有孰优孰劣一说, 具体看实际的应用场景, 每种库都有它的用武之地</p>
<p><strong>本文为作者原创转载时请注明出处 谢谢</strong></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em><a href="https://code.newban.cn/">乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</a></em></p>
]]></content>
      <tags>
        <tag>c/c++</tag>
      </tags>
  </entry>
  <entry>
    <title>CURL工具使用问题汇总</title>
    <url>/382.html</url>
    <content><![CDATA[<h3 id="问题1"><a href="#问题1" class="headerlink" title="问题1"></a>问题1</h3><p>下载时提示<code>SSL certificate problem</code>:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">curl: (60) SSL certificate problem: certificate has expired</span><br><span class="line">More details here: https://curl.haxx.se/docs/sslcerts.html</span><br><span class="line"></span><br><span class="line">curl failed to verify the legitimacy of the server and therefore could not</span><br><span class="line">establish a secure connection to it. To learn more about this situation and</span><br><span class="line">how to fix it, please visit the web page mentioned above.</span><br></pre></td></tr></table></figure>

<p><strong>原因:</strong></p>
<p>这是证书认证缺失导致，可以在请求时关闭ssl证书认证</p>
<p><strong>解决方案:</strong></p>
<p>命令行中加上<code>-k</code>即可, 如:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">curl -fsSL https://xmake.io/shget.text -k</span><br></pre></td></tr></table></figure>

<p><strong>本文为作者原创转载时请注明出处 谢谢</strong></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em><a href="https://code.newban.cn/">乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</a></em></p>
]]></content>
      <tags>
        <tag>c/c++</tag>
      </tags>
  </entry>
  <entry>
    <title>使用xmake交叉编译生成各个平台可执行程序</title>
    <url>/384.html</url>
    <content><![CDATA[<h3 id="xmake介绍"><a href="#xmake介绍" class="headerlink" title="xmake介绍"></a>xmake介绍</h3><p><code>xmake</code> 是一个基于 <code>Lua</code> 的轻量级跨平台构建工具，使用 <code>xmake.lua</code>维护项目构建, 相当于是<code>cmake</code>的增强版, 其优点如下:</p>
<ul>
<li>简单易用</li>
<li>能够像 <code>Make/Ninja</code> 那样可以直接编译项目</li>
<li>可以像<code>CMake/Meson</code> 那样生成工程文件</li>
<li>内置的包管理系统来帮助用户解决 <code>C/C++</code>依赖库的集成使用问题</li>
<li>可以实现跟<code>C/C++</code>进行混合编译</li>
<li>编译速度也是非常的快，可以跟<code>Ninja</code>持平</li>
<li>简化了交叉编译</li>
</ul>
<p><a href="https://xmake.io/#/zh-cn/about/introduction" target="_blank" rel="noopener">官方文档</a></p>
<p><a href="https://github.com/xmake-io/xmake" target="_blank" rel="noopener">GITHUB</a></p>
<h3 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h3><ul>
<li><p><strong>编译宿主平台</strong>: MAC</p>
</li>
<li><p><strong>交叉编译目标平台</strong>: Linux, Windows, IOS, Android ….</p>
</li>
</ul>
<ol>
<li><p>下载<code>xmake</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">bash &lt;(curl -fsSL https://xmake.io/shget.text -k)</span><br></pre></td></tr></table></figure>
</li>
<li><p>测试<code>c</code>代码准备 文件取名为<code>main</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Hello World!\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
</ol>
<ol start="3">
<li><p>在源码目录下新建<code>xmake.lua</code>文件 </p>
<p>并加入以下配置</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">add_rules(<span class="string">"mode.debug"</span>, <span class="string">"mode.release"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 编译项目名称</span></span><br><span class="line">target(<span class="string">"main"</span>)</span><br><span class="line">		<span class="comment">-- 指定编译形式 可执行文件 还是静态库or动态库</span></span><br><span class="line">    set_kind(<span class="string">"binary"</span>)</span><br><span class="line">    <span class="comment">-- 指定需要参与编译的源码文件</span></span><br><span class="line">    add_files(<span class="string">"src/main/c/main.c"</span>)</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>编译前的环境准备好了,那接下来 咱们挨个来实现目标平台的可执行文件生成</p>
<h3 id="生成phone平台程序"><a href="#生成phone平台程序" class="headerlink" title="生成phone平台程序"></a>生成phone平台程序</h3><ol>
<li><p><strong>下载<code>xcode</code></strong></p>
<p>直接应用市场下载</p>
</li>
<li><p><strong>给<code>xmake</code>指定编译目标平台</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">xmake f -p iphoneos</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>编译程序</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">xmake build main</span><br></pre></td></tr></table></figure>

<p>编译成功后 可以在<code>build</code>目录中找到对应的可执行文件</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20220929172751417.png" alt="image-20220929172751417"></p>
</li>
</ol>
<h3 id="生成Mac平台的程序"><a href="#生成Mac平台的程序" class="headerlink" title="生成Mac平台的程序"></a>生成Mac平台的程序</h3><ol>
<li><p><strong>给<code>xmake</code>指定编译目标平台</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">xmake f -p macosx</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>编译程序</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">xmake build main</span><br></pre></td></tr></table></figure>

<p>编译成功后 可以在<code>build</code>目录中找到对应的可执行文件</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20220929173058827.png" alt="image-20220929173058827"></p>
</li>
<li><p><strong>执行程序</strong></p>
<p>由于编译宿主平台刚好是<code>Mac</code> 所以我们可以直接执行程序</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">xmake run main</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20220929173203142.png" alt="image-20220929173203142"></p>
</li>
</ol>
<h3 id="生成Windows平台程序"><a href="#生成Windows平台程序" class="headerlink" title="生成Windows平台程序"></a>生成Windows平台程序</h3><ol>
<li><p><strong>下载<code>mingw-w64</code></strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">brew install mingw-w64</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>给<code>xmake</code>指定编译目标平台</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">xmake f -p mingw</span><br></pre></td></tr></table></figure>

<p>或者使用图形化界面配置</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">xmake f --menu</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/68747470733a2f2f786d616b652e696f2f6173736574732f696d672f696e6465782f6d656e75636f6e662e706e67.png" alt="img"></p>
<p>配置完后 我们查看<code>xmake</code>的配置显示当前平台为<code>mingw</code>:</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20220930102409815.png" alt="image-20220930102409815"></p>
</li>
<li><p><strong>编译程序</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">xmake build main</span><br></pre></td></tr></table></figure>

<p>编译成功后  我们可以在<code>build</code>目录下找到生成的<code>exe</code>可执行文件:<img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20220930101946291.png" alt="image-20220930101946291"></p>
</li>
<li><p><strong>关于mingw内部编译器</strong></p>
<p>我们打印编译信息会发现<code>mingw</code>内部采用的是<code>gcc</code>编译工具</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20220930102723811.png" alt="image-20220930102723811"></p>
</li>
</ol>
<h3 id="生成Android平台程序"><a href="#生成Android平台程序" class="headerlink" title="生成Android平台程序"></a>生成Android平台程序</h3><ol>
<li><p><strong>下载NDK</strong></p>
<p><a href="https://developer.android.google.cn/ndk/downloads/" target="_blank" rel="noopener">点击进入下载页面</a></p>
</li>
<li><p><strong>给<code>xmake</code>指定编译目标平台</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">xmake f -p android --ndk=ndk路径</span><br></pre></td></tr></table></figure>

<p>此时我们查看<code>xmake</code>配置显示当前编译平台为<code>android</code>:</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20220930101224522.png" alt="image-20220930101224522"></p>
</li>
<li><p><strong>编译程序</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">xmake build main</span><br></pre></td></tr></table></figure>

<p>编译成功后  可以在编译目录查看到生成的可执行文件</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20220930101319392.png" alt="image-20220930101319392"></p>
</li>
</ol>
<h3 id="xmake常用指令"><a href="#xmake常用指令" class="headerlink" title="xmake常用指令"></a>xmake常用指令</h3><ol>
<li><p><strong>重置配置</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">xmake f -c</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>指定交叉编译工具</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">xmake f --toolchain=clang</span><br><span class="line">或者</span><br><span class="line">xmake f --toolchain=gcc</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>查看当前工程信息和xmake信息</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">xmake show</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>编译过程中查看完整的编译选项</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">xmake -rv</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>查看当前配置</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">xmake config -v</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20220929181646806.png" alt="image-20220929181646806"></p>
</li>
<li><p><strong>卸载<code>xmake</code></strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">xmake update --uninstall</span><br></pre></td></tr></table></figure>



</li>
</ol>
<h3 id="常见问题汇总"><a href="#常见问题汇总" class="headerlink" title="常见问题汇总"></a>常见问题汇总</h3><ol>
<li><p>交叉编译报错 <code>unknown platform for xcode!</code></p>
<p>解决方案: 卸载<code>xmake</code>重装</p>
</li>
</ol>
<p><strong>本文为作者原创转载时请注明出处 谢谢</strong></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em><a href="https://code.newban.cn/">乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</a></em></p>
]]></content>
      <tags>
        <tag>交叉编译</tag>
      </tags>
  </entry>
  <entry>
    <title>Godot游戏开发之如何将图片铺满整个背景</title>
    <url>/386.html</url>
    <content><![CDATA[<h3 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h3><p>当前素材库中只有一张小草地图片, 如下:</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/GrassBackground.png" alt="GrassBackground"></p>
<p>如何将其铺满整个背景, 得到如下效果:</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20220930152341903.png" alt="image-20220930152341903"></p>
<p>我们可能第一时间会想到使用<code>Tilemap</code>, 不过手动绘制相对来说有些费时间, 在<code>Godot</code>中我们有更好的方法可以实现</p>
<h3 id="实现方式一"><a href="#实现方式一" class="headerlink" title="实现方式一"></a>实现方式一</h3><p>使用<code>Sprite+图片repeat</code>的方式实现</p>
<ol>
<li><p>首先创建一个<code>Sprite</code>节点</p>
</li>
<li><p>将草地图片添加至该节点的<code>Texture</code>属性上</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20220930153243013.png" alt="image-20220930153243013"></p>
</li>
<li><p>启用<code>Region</code>属性</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20220930153318292.png" alt="image-20220930153318292"></p>
</li>
<li><p>在纹理区域框选需要进行<code>repeat</code>的区域</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20220930153401635.png" alt="image-20220930153401635"></p>
</li>
<li><p>选中草地文件 然后在导入面板开启重复功能, 最后点击重新导入</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20220930153526042.png" alt="image-20220930153526042"></p>
</li>
<li><p>此时我们在纹理区域拉伸选框, 则可以对草地小图片进行重复并铺满整个背景</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20220930153638246.png" alt="image-20220930153638246"></p>
</li>
</ol>
<h3 id="实现方式二"><a href="#实现方式二" class="headerlink" title="实现方式二"></a>实现方式二</h3><p>使用<code>TextureRect</code>+<code>Tile</code>实现</p>
<ol>
<li><p>创建<code>TextureRect</code>节点</p>
</li>
<li><p>将图片拖拽至该节点的<code>Texture</code>属性上</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20220930154030277.png" alt="image-20220930154030277"></p>
</li>
<li><p><code>Stretch Mode</code>属性选择<code>Tile</code></p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20220930154057353.png" alt="image-20220930154057353"></p>
</li>
<li><p>此时拉伸图片则自动重复</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20220930154121259.png" alt="image-20220930154121259"></p>
</li>
</ol>
<p><strong>本文为作者原创转载时请注明出处 谢谢</strong></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em><a href="https://code.newban.cn/">乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</a></em></p>
]]></content>
      <tags>
        <tag>Godot</tag>
      </tags>
  </entry>
  <entry>
    <title>Godot游戏开发之角色动画</title>
    <url>/388.html</url>
    <content><![CDATA[<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>在<code>Godot</code>中角色动画我们通常会使用<code>AnimationPlayer</code>这个节点去实现, 该节点支持关键帧</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20220930172408017.png" alt="image-20220930172408017"></p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20220930173110937.png" alt="image-20220930173110937"></p>
<h3 id="关于动画的一些注意事项"><a href="#关于动画的一些注意事项" class="headerlink" title="关于动画的一些注意事项"></a>关于动画的一些注意事项</h3><ol>
<li><p>通常我们会让动画在运动帧开始, 然后在闲置帧结束, </p>
<p>如此一来 当玩家按下按钮时 不管时间有多短 都能看到明显的动画, 而不是你已经移动了 然而角色的脚却还没动</p>
</li>
</ol>
<p><strong>本文为作者原创转载时请注明出处 谢谢</strong></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em><a href="https://code.newban.cn/">乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</a></em></p>
]]></content>
      <tags>
        <tag>Godot</tag>
      </tags>
  </entry>
  <entry>
    <title>使用brew安装程序是提示No such file or directory @ rb_sysopen</title>
    <url>/385.html</url>
    <content><![CDATA[<h3 id="原因一"><a href="#原因一" class="headerlink" title="原因一"></a>原因一</h3><p>使用国内镜像而该镜像未完全同步 导致包找不到</p>
<p><strong>解决方法:</strong></p>
<p>临时去除镜像即可:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> HOMEBREW_BOTTLE_DOMAIN=<span class="string">''</span></span><br></pre></td></tr></table></figure>

<h3 id="原因二"><a href="#原因二" class="headerlink" title="原因二"></a>原因二</h3><p>依赖程序缺失 </p>
<p><strong>解决方法:</strong></p>
<p>需要进行单独安装, 比如报错<code>Error: No such file or directory @ rb_sysopen - xxxxxxxc–jasper</code>, 此时单独安装<code>jasper</code>:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">brew install jasper</span><br></pre></td></tr></table></figure>

<p>安装完后 再次运行之前的安装之前的指令即可</p>
<p><strong>本文为作者原创转载时请注明出处 谢谢</strong></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em><a href="https://code.newban.cn/">乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</a></em></p>
]]></content>
      <tags>
        <tag>交叉编译</tag>
      </tags>
  </entry>
  <entry>
    <title>C/C++交叉编译各个平台可执行程序</title>
    <url>/383.html</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>目前主流的平台有:</p>
<ul>
<li>Windows</li>
<li>Mac</li>
<li>Linux</li>
<li>Android</li>
<li>IOS</li>
</ul>
<p>当<code>C/C++</code>程序写好后 如何快速在当前平台编译出各个平台的可执行文件 </p>
<p>现在比较成熟的方案有:</p>
<ul>
<li>利用<code>docker</code>容器编译</li>
<li>利用<code>cmake</code>构建交叉编译环境</li>
</ul>
<h3 id="利用docker容器编译"><a href="#利用docker容器编译" class="headerlink" title="利用docker容器编译"></a>利用<code>docker</code>容器编译</h3><p>基于<code>GCC</code>套件, 可实现对<code>Android</code>, <code>Linux</code>, <code>Windows</code>, <code>Web</code>平台的交叉编译, 详细介绍如下:</p>
<ul>
<li><p><strong>dockcross/base</strong></p>
<p>Base image for other toolchain images. From Debian Jessie with GCC, make, autotools, CMake, Ninja, Git, and Python.</p>
</li>
<li><p><strong>dockcross/android-arm</strong></p>
<p>The Android NDK standalone toolchain for the arm architecture.</p>
</li>
<li><p><strong>dockcross/android-arm64</strong></p>
<p>The Android NDK standalone toolchain for the arm64 architecture.</p>
</li>
<li><p><strong>dockcross/linux-arm64</strong></p>
<p> Cross compiler for the 64-bit ARM platform on Linux, also known as AArch64.</p>
</li>
<li><p><strong>dockcross/linux-armv5</strong></p>
<p> Linux armv5 cross compiler toolchain for legacy devices like the Parrot AR Drone.</p>
</li>
<li><p><strong>dockcross/linux-armv5-musl</strong></p>
<p> Linux armv5 cross compiler toolchain using <a href="https://www.musl-libc.org/" target="_blank" rel="noopener">musl</a> as base “libc”.</p>
</li>
<li><p><strong>dockcross/linux-armv6</strong></p>
<p> Linux ARMv6 cross compiler toolchain for the Raspberry Pi, etc.</p>
</li>
<li><p><strong>dockcross/linux-armv7</strong></p>
<p> Generic Linux armv7 cross compiler toolchain.</p>
</li>
<li><p><strong>dockcross/linux-armv7a</strong></p>
<p> Toolchain configured for ARMv7-A used in Beaglebone Black single board PC with TI SoC AM3358 on board, Cortex-A8.</p>
</li>
<li><p><strong>dockcross/linux-mipsel</strong></p>
<p> Linux mipsel cross compiler toolchain for little endian MIPS GNU systems.</p>
</li>
<li><p><strong>dockcross/linux-mips</strong></p>
<p> Linux mips cross compiler toolchain for big endian 32-bit hard float MIPS GNU systems.</p>
</li>
<li><p><strong>dockcross/linux-s390x</strong></p>
<p> Linux s390x cross compiler toolchain for S390X GNU systems.</p>
</li>
<li><p><strong>dockcross/linux-ppc64le</strong></p>
<p> Linux PowerPC 64 little endian cross compiler toolchain for the POWER8, etc. Important: Due to Issue #430, automatic build of newer images has been disabled.</p>
</li>
<li><p><strong>dockcross/linux-x64</strong></p>
<p> Linux x86_64 / amd64 compiler. Since the Docker image is natively x86_64, this is not actually a cross compiler.</p>
</li>
<li><p><strong>dockcross/linux-x86</strong></p>
<p> Linux i686 cross compiler.</p>
</li>
<li><p><strong>dockcross/manylinux2014-x64</strong></p>
<p> Docker <a href="https://github.com/pypa/manylinux" target="_blank" rel="noopener">manylinux2014</a> image for building Linux x86_64 / amd64 <a href="http://pythonwheels.com/" target="_blank" rel="noopener">Python wheel packages</a>. It includes Python 3.5, 3.6, 3.7, 3.8, and 3.9. Also has support for the dockcross script, and it has installations of CMake, Ninja, and  <a href="http://scikit-build.org/" target="_blank" rel="noopener">scikit-build</a>. For CMake, it sets MANYLINUX2014 to “TRUE” in the toolchain.</p>
</li>
<li><p><strong>dockcross/manylinux2014-x86</strong></p>
<p> Docker <a href="https://github.com/pypa/manylinux" target="_blank" rel="noopener">manylinux2014</a> image for building Linux i686 <a href="http://pythonwheels.com/" target="_blank" rel="noopener">Python wheel packages</a>. It includes Python 3.5, 3.6, 3.7, 3.8, and 3.9. Also has support for the dockcross script, and it has installations of CMake, Ninja, and  <a href="http://scikit-build.org/" target="_blank" rel="noopener">scikit-build</a>. For CMake, it sets MANYLINUX2014 to “TRUE” in the toolchain.</p>
</li>
<li><p><strong>dockcross/manylinux2014-aarch64</strong></p>
<p> Docker <a href="https://github.com/pypa/manylinux" target="_blank" rel="noopener">manylinux2014</a> image for building Linux aarch64 / arm64 <a href="http://pythonwheels.com/" target="_blank" rel="noopener">Python wheel packages</a>. It includes Python 3.5, 3.6, 3.7, 3.8, and 3.9. Also has support for the dockcross script, and it has installations of CMake, Ninja, and  <a href="http://scikit-build.org/" target="_blank" rel="noopener">scikit-build</a>. For CMake, it sets MANYLINUX2014 to “TRUE” in the toolchain.</p>
</li>
<li><p><strong>dockcross/manylinux2010-x64</strong></p>
<p> Docker <a href="https://github.com/pypa/manylinux" target="_blank" rel="noopener">manylinux2010</a> image for building Linux x86_64 / amd64 <a href="http://pythonwheels.com/" target="_blank" rel="noopener">Python wheel packages</a>. It includes Python 2.7, 3.4, 3.5, 3.6, 3.7 and 3.8. Also has support for the dockcross script, and it has installations of CMake, Ninja, and  <a href="http://scikit-build.org/" target="_blank" rel="noopener">scikit-build</a>. For CMake, it sets MANYLINUX2010 to “TRUE” in the toolchain.</p>
</li>
<li><p><strong>dockcross/manylinux2010-x86</strong></p>
<p> Docker <a href="https://github.com/pypa/manylinux" target="_blank" rel="noopener">manylinux2010</a> image for building Linux i686 <a href="http://pythonwheels.com/" target="_blank" rel="noopener">Python wheel packages</a>. It includes Python 2.7, 3.4, 3.5, 3.6, 3.7 and 3.8. Also has support for the dockcross script, and it has installations of CMake, Ninja, and  <a href="http://scikit-build.org/" target="_blank" rel="noopener">scikit-build</a>. For CMake, it sets MANYLINUX2010 to “TRUE” in the toolchain.</p>
</li>
<li><p><strong>dockcross/manylinux1-x64</strong></p>
<p> Docker <a href="https://github.com/pypa/manylinux/tree/manylinux1" target="_blank" rel="noopener">manylinux1</a> image for building Linux x86_64 / amd64 <a href="http://pythonwheels.com/" target="_blank" rel="noopener">Python wheel packages</a>. It includes Python 2.7, 3.4, 3.5, 3.6, 3.7 and 3.8. Also has support for the dockcross script, and it has installations of CMake, Ninja, and  <a href="http://scikit-build.org/" target="_blank" rel="noopener">scikit-build</a>. For CMake, it sets MANYLINUX1 to “TRUE” in the toolchain.</p>
</li>
<li><p><strong>dockcross/manylinux1-x86</strong></p>
<p> Docker <a href="https://github.com/pypa/manylinux/tree/manylinux1" target="_blank" rel="noopener">manylinux1</a> image for building Linux i686 <a href="http://pythonwheels.com/" target="_blank" rel="noopener">Python wheel packages</a>. It includes Python 2.7, 3.4, 3.5, 3.6, 3.7 and 3.8. Also has support for the dockcross script, and it has installations of CMake, Ninja, and [ <a href="http://scikit-build.org/" target="_blank" rel="noopener">scikit-build</a>](http:// <a href="http://scikit-build.org/" target="_blank" rel="noopener">scikit-build</a>.org/). For CMake, it sets MANYLINUX1 to “TRUE” in the toolchain.</p>
</li>
<li><p><strong>dockcross/web-wasm</strong></p>
<p> The Emscripten WebAssembly/asm.js/JavaScript cross compiler.</p>
</li>
<li><p><strong>dockcross/windows-static-x64</strong></p>
<p> 64-bit Windows cross-compiler based on  <a href="https://mxe.cc/" target="_blank" rel="noopener">MXE/MinGW-w64</a>  with win32 threads and static linking.</p>
</li>
<li><p><strong>dockcross/windows-static-x64-posix</strong></p>
<p> 64-bit Windows cross-compiler based on  <a href="https://mxe.cc/" target="_blank" rel="noopener">MXE/MinGW-w64</a>  with posix threads and static linking.</p>
</li>
<li><p><strong>dockcross/windows-static-x86</strong></p>
<p> 32-bit Windows cross-compiler based on  <a href="https://mxe.cc/" target="_blank" rel="noopener">MXE/MinGW-w64</a>  with win32 threads and static linking.</p>
</li>
<li><p><strong>dockcross/windows-shared-x64</strong></p>
<p> 64-bit Windows cross-compiler based on  <a href="https://mxe.cc/" target="_blank" rel="noopener">MXE/MinGW-w64</a>  with win32 threads and dynamic linking.</p>
</li>
<li><p><strong>dockcross/windows-shared-x64-posix</strong></p>
<p> 64-bit Windows cross-compiler based on  <a href="https://mxe.cc/" target="_blank" rel="noopener">MXE/MinGW-w64</a>  with posix threads and dynamic linking.</p>
</li>
<li><p><strong>dockcross/windows-shared-x86</strong></p>
<p> 32-bit Windows cross-compiler based on  <a href="https://mxe.cc/" target="_blank" rel="noopener">MXE/MinGW-w64</a>  with win32 threads and dynamic linking.</p>
</li>
</ul>
<p>具体使用可参见<a href="https://github.com/cicerops/dockcross" target="_blank" rel="noopener">Github</a></p>
<h3 id="使用cmake构建交叉编译环境"><a href="#使用cmake构建交叉编译环境" class="headerlink" title="使用cmake构建交叉编译环境"></a>使用<code>cmake</code>构建交叉编译环境</h3><p>首先我们需要下载<code>cmake</code>构建工具</p>
<p>然后下载用于交叉编译的套件</p>
<p>以<code>Mac</code>平台为例, 如果我需要编译各个平台的可执行文件, 那么首先需要下载能在<code>Mac</code>平台运行的目标平台编译包, 比如:</p>
<ul>
<li><p><code>android</code>平台:下载 <code>Mac</code>平台可运行的<code>NDK</code> (基于<code>clang</code>)</p>
</li>
<li><p><code>ios</code>平台: 下载<code>iphoneos SDK</code>, xcode自带 我们只需下载<code>xcode</code>即可 (基于<code>clang</code>)</p>
</li>
<li><p><code>windows</code>平台:下载<code>MinGW</code> 或者 <a href="https://mxe.cc/" target="_blank" rel="noopener">MXE/MinGW-w64</a> (基于<code>GCC</code>)</p>
</li>
<li><p><code>Linux</code>平台:如 <code>arm/x86-Linux-gnueabi</code>套件(基于<code>GCC</code>)</p>
</li>
</ul>
<p><strong>本文为作者原创转载时请注明出处 谢谢</strong></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em><a href="https://code.newban.cn/">乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</a></em></p>
]]></content>
      <tags>
        <tag>交叉编译</tag>
      </tags>
  </entry>
  <entry>
    <title>wireshark怎么抓包、wireshark抓包详细图文教程</title>
    <url>/39.html</url>
    <content><![CDATA[<p>wireshark是非常流行的网络封包分析软件，功能十分强大。可以截取各种网络封包，显示网络封包的详细信息。使用wireshark的人必须了解网络协议，否则就看不懂wireshark了。<br>为了安全考虑，wireshark只能查看封包，而不能修改封包的内容，或者发送封包。</p>
<p>wireshark能获取HTTP，也能获取HTT<a href="http://www.cr173.com/k/photoshopcs5/" target="_blank" rel="noopener">PS</a>，但是不能解密HTTPS，所以wireshark看不懂HTTPS中的内容，总结，如果是处理HTTP,HTTPS 还是用Fiddler, <strong>其他协议比如TCP,UDP 就用wireshark.</strong></p>
<p><strong>wireshark 开始抓包</strong></p>
<p>开始界面</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/1605493-20190314094522754-103175516-20200907102049320.png" alt="img"></p>
<p><strong>wireshark是捕获机器上的某一块网卡的网络包</strong>，当你的机器上有多块网卡的时候，你需要选择一个网卡。</p>
<p>点击Caputre-&gt;Interfaces.. 出现下面对话框，选择正确的网卡。然后点击”Start”按钮, 开始抓包</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/1605493-20190314094604914-1384393003-20200907102059133.png" alt="img"></p>
<p>Wireshark 窗口介绍</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/1605493-20190314094626016-1952370119-20200907102110400.png" alt="img"></p>
<p><strong>WireShark 主要分为这几个界面</strong></p>
<p>\1. Display Filter(显示过滤器)， 用于过滤</p>
<p>\2. Packet List Pane(封包列表)， 显示捕获到的封包， 有源地址和目标地址，端口号。 颜色不同，代表</p>
<p>\3. Packet Details Pane(封包详细信息), 显示封包中的字段</p>
<p>\4. Dissector Pane(16进制数据)</p>
<p>\5. Miscellanous(地址栏，杂项)</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/1605493-20190314094730951-683976121-20200907102121831.png" alt="img"></p>
<p>使用过滤是非常重要的， 初学者使用wireshark时，将会得到大量的冗余信息，在几千甚至几万条记录中，以至于很难找到自己需要的部分。搞得晕头转向。</p>
<p>过滤器会帮助我们在大量的数据中迅速找到我们需要的信息。</p>
<p>过滤器有两种，</p>
<p>一种是显示过滤器，就是主界面上那个，用来在捕获的记录中找到所需要的记录</p>
<p>一种是捕获过滤器，用来过滤捕获的封包，以免捕获太多的记录。 在Capture -&gt; Capture Filters 中设置</p>
<p>保存过滤</p>
<p>在Filter栏上，填好Filter的表达式后，点击Save按钮， 取个名字。比如”Filter 102”,</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/1605493-20190314094843076-11407886-20200907102136609.png" alt="img"></p>
<p>Filter栏上就多了个”Filter 102” 的按钮。</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/1605493-20190314094913816-449630993-20200907102143988.png" alt="img"></p>
<p><strong>过滤表达式的规则</strong></p>
<p>表达式规则</p>
<p> \1. 协议过滤</p>
<p>比如TCP，只显示TCP协议。</p>
<p>\2. IP 过滤</p>
<p>比如 ip.src ==192.168.1.102 显示源地址为192.168.1.102，</p>
<p>ip.dst==192.168.1.102, 目标地址为192.168.1.102</p>
<p>\3. 端口过滤</p>
<p>tcp.port ==80, 端口为80的</p>
<p>tcp.srcport == 80, 只显示TCP协议的愿端口为80的。</p>
<p>\4. Http模式过滤</p>
<p>http.request.method==”GET”,  只显示HTTP GET方法的。</p>
<p>\5. 逻辑运算符为 AND/ OR</p>
<p>常用的过滤表达式</p>
<table>
<thead>
<tr>
<th>过滤表达式</th>
<th>用途</th>
</tr>
</thead>
<tbody><tr>
<td>http</td>
<td>只查看HTTP协议的记录</td>
</tr>
<tr>
<td>ip.src ==192.168.1.102 or ip.dst==192.168.1.102</td>
<td>源地址或者目标地址是192.168.1.102</td>
</tr>
<tr>
<td>snmp &amp;&amp; udp.dstport == 162</td>
<td>抓取SNMP Trap包</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
</tbody></table>
<p> 封包列表(Packet List Pane)</p>
<p> 封包列表的面板中显示，编号，时间戳，源地址，目标地址，协议，长度，以及封包信息。 你可以看到不同的协议用了不同的颜色显示。</p>
<p>你也可以修改这些显示颜色的规则， View -&gt;Coloring Rules.</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/1605493-20190314095213546-1355213248-20200907102153795.png" alt="img"></p>
<p>封包详细信息 (Packet Details Pane)</p>
<p>这个面板是我们最重要的，用来查看协议中的每一个字段。</p>
<p>各行信息分别为</p>
<p>Frame:  物理层的数据帧概况</p>
<p>Ethernet II: 数据链路层以太网帧头部信息</p>
<p>Internet Protocol Version 4: 互联网层IP包头部信息</p>
<p>Transmission Control Protocol: 传输层T的数据段头部信息，此处是TCP</p>
<p>Hypertext Transfer Protocol: 应用层的信息，此处是HTTP协议</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/1605493-20190314095310963-1075553187-20200907102202302.png" alt="img"></p>
<p><strong>TCP包的具体内容</strong></p>
<p> 从下图可以看到wireshark捕获到的TCP包中的每个字段。</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/1605493-20190314095338514-530749525-20200907102211935.png" alt="img"></p>
<p>看到这， 基本上对wireshak有了初步了解， 现在我们看一个TCP三次握手的实例</p>
<p> 三次握手过程为</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/1605493-20190314095410815-1870221073-20200907102219789.png" alt="img"></p>
<p>这图我都看过很多遍了， 这次我们用wireshark实际分析下三次握手的过程。</p>
<p>打开wireshark, 打开浏览器输入 <a href="http://www.cr173.com" target="_blank" rel="noopener">http://www.cr173.com</a></p>
<p>在wireshark中输入http过滤， 然后选中GET /tankxiao HTTP/1.1的那条记录，右键然后点击”Follow TCP Stream”,</p>
<p>这样做的目的是为了得到与浏览器打开网站相关的数据包，将得到如下图</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/1605493-20190314095516884-1091678120-20200907102228684.png" alt="img"></p>
<p>图中可以看到wireshark截获到了三次握手的三个数据包。第四个包才是HTTP的， 这说明HTTP的确是使用TCP建立连接的。</p>
<p><strong>第一次握手数据包</strong></p>
<p>客户端发送一个TCP，标志位为SYN，序列号为0， 代表客户端请求建立连接。 如下图</p>
<p><strong><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/20200907104442.png" alt>第二次握手的数据包</strong></p>
<p>服务器发回确认包, 标志位为 SYN,ACK. 将确认序号(Acknowledgement Number)设置为客户的I S N加1以.即0+1=1, 如下图</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/20200907104507.png" alt></p>
<p><strong>第三次握手的数据包</strong></p>
<p>客户端再次发送确认包(ACK) SYN标志位为0,ACK标志位为1.并且把服务器发来ACK的序号字段+1,放在确定字段中发送给对方.并且在数据段放写ISN的+1, 如下图:</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/20200907104521.png" alt></p>
<p> 就这样通过了TCP三次握手，建立了连接</p>
<p><strong>本文为作者原创 转载时请注明出处 谢谢</strong></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em>乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</em></p>
]]></content>
      <tags>
        <tag>抓包</tag>
      </tags>
  </entry>
  <entry>
    <title>Android开发之图片取色工具</title>
    <url>/389.html</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>我们在开发过程中经常会遇到需要对图片进行取色的情况</p>
<p>如果你也嫌弃下载取色软件麻烦</p>
<p>那么有一些顺手的工具可以满足我们的取色需求</p>
<h3 id="使用Android-Studio自带取色工具"><a href="#使用Android-Studio自带取色工具" class="headerlink" title="使用Android Studio自带取色工具"></a>使用Android Studio自带取色工具</h3><p>在<code>VCS</code>版本管理关卡页面, 有一个取色工具</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20230106102842956.png" alt="image-20230106102842956"></p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20230106102709895.png" alt="image-20230106102709895"></p>
<h3 id="使用Chorme浏览器自带取色工具"><a href="#使用Chorme浏览器自带取色工具" class="headerlink" title="使用Chorme浏览器自带取色工具"></a>使用Chorme浏览器自带取色工具</h3><p>进入控制台, 随便点击一个色块, 会弹出取色工具</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20230106103019125.png" alt="image-20230106103019125"></p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20230106103118581.png" alt="image-20230106103118581"></p>
<p><strong>本文为作者原创转载时请注明出处 谢谢</strong></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em><a href="https://code.newban.cn/">乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</a></em></p>
]]></content>
      <tags>
        <tag>实用工具</tag>
      </tags>
  </entry>
  <entry>
    <title>不小心关闭谷歌浏览器怎么恢复(快速恢复所有被关闭的网页)</title>
    <url>/390.html</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>在使用浏览器访问网页的时候，有没有遇到因一时手残关闭所有浏览器网页的情况？</p>
<p>打开的网页有点多还能恢复吗？不要着急，下面就给大家分享四种恢复谷歌浏览器已经关闭的网页的方法。</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/20230208015030959.jpg" alt="不小心关闭谷歌浏览器怎么恢复(快速恢复所有被关闭的网页)"></p>
<h3 id="第一种方法：快捷键"><a href="#第一种方法：快捷键" class="headerlink" title="第一种方法：快捷键"></a>第一种方法：快捷键</h3><p>很多人不知道Chrome浏览器撤销关闭页面的快捷键是什么，其实这是一个组合键，即<code>Crtl+Shift+T</code>。对于习惯使用快捷键的朋友，这是最快的恢复<code>chrome</code>已关闭网页的方法。</p>
<h3 id="第二种方法"><a href="#第二种方法" class="headerlink" title="第二种方法"></a>第二种方法</h3><p>从历史浏览记录里选取已关闭网页。打开历史记录的方法是从“菜单”选择“历史记录”，或者使用快捷键<code>Ctrl+H</code>。还有一个快捷方法是，长按或者往下拉“后退键”，即可打开<code>Chrome</code>历史浏览页面。所谓的“后退键”在浏览器页面左上角，找到一个形状为向左的箭头，就是它了。</p>
<h3 id="第三种方法：标签页右键点击"><a href="#第三种方法：标签页右键点击" class="headerlink" title="第三种方法：标签页右键点击"></a>第三种方法：标签页右键点击</h3><p>其实这个方法也是属于从历史浏览记录中恢复已关闭网页，不同是的，单手即可操作。在任意标签页上点击右键，可以看到菜单中一个选项“重新打开关闭的标签页”，点击之即可自动在新标签页中打开前面一个刚关闭的页面。</p>
<h3 id="第四种方法：使用插件"><a href="#第四种方法：使用插件" class="headerlink" title="第四种方法：使用插件"></a>第四种方法：使用插件</h3><p> 对于插件党而言，一切的方法都可以使用万能的插件来解决。恢复已关闭页面的<code>Chrome</code>插件有很多，类似<code>Sexy Undo Close Tab</code>，<code>Simple Undo Close</code>等等，可以直接去<code>Chrome</code>网上应用商店搜索安装即可使用。</p>
<p><strong>本文为作者原创转载时请注明出处 谢谢</strong></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em><a href="https://code.newban.cn/">乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</a></em></p>
]]></content>
      <tags>
        <tag>实用技巧</tag>
      </tags>
  </entry>
  <entry>
    <title>临时手机号&amp;邮箱大合集</title>
    <url>/391.html</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>最近<code>ChatGPT</code>大火, 很多小伙伴都想尝一尝鲜, 可惜国内账号无法注册, 只能借助国外手机号</p>
<p>考虑到个人的隐私安全, 我们可以使用一些临时的手机号或者邮箱进行使用</p>
<p>其中有收费和免费的  不用多想 收费的肯定要稳定好用一些</p>
<h3 id="临时手机号"><a href="#临时手机号" class="headerlink" title="临时手机号"></a>临时手机号</h3><ol>
<li><p><strong>sms-activate</strong></p>
<p>收费接码平台 稳定好用</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20230404141409473.png" alt="image-20230404141409473"></p>
<p>官网: <a href="https://sms-activate.org/cn" target="_blank" rel="noopener">点击进入</a></p>
</li>
<li><p><strong>阿里小号</strong></p>
<p>阿里推出的虚拟手机号平台, 可绑定真实手机号, 保护个人隐私</p>
</li>
</ol>
<h3 id="临时邮箱"><a href="#临时邮箱" class="headerlink" title="临时邮箱"></a>临时邮箱</h3><ol>
<li><p><strong>temp-mail</strong></p>
<p>免费临时邮箱</p>
<p>有了它, 不用再担心垃圾邮件，广告邮件，黑客和机器人攻击。让您真实的邮箱保持干净和安全。Temp Mail提供临时、安全、匿名、免费的一次性电子邮件地址。</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20230404141741513.png" alt="image-20230404141741513"></p>
<p>网站: <a href="https://temp-mail.org/zh/" target="_blank" rel="noopener">点击进入</a></p>
</li>
<li><p><strong>24mail</strong></p>
<p>国内临时邮箱服务站</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20230606102623501.png" alt="image-20230606102623501"></p>
<p>网站: <a href="http://24mail.chacuo.net/" target="_blank" rel="noopener">点击进入</a></p>
</li>
</ol>
<p><strong>本文为作者原创转载时请注明出处 谢谢</strong></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em><a href="https://code.newban.cn/">乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</a></em></p>
]]></content>
      <tags>
        <tag>实用技巧</tag>
      </tags>
  </entry>
  <entry>
    <title>AI和硬件开发</title>
    <url>/392.html</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>国内有不少已经接入<code>ChatGPT</code>相关<code>API</code>并做成了独立<code>Web</code>形式的网站, 比如</p>
<p><a href="https://talkai.cc/" target="_blank" rel="noopener">https://talkai.cc/</a></p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20230404145647933.png" alt="image-20230404145647933"></p>
<p>想尝鲜的可以体验一下</p>
<h3 id="AI和硬件"><a href="#AI和硬件" class="headerlink" title="AI和硬件"></a>AI和硬件</h3><p>AI归根结底还是一个软件, 未来必须结合硬件才能大展拳脚, 更进一步</p>
<p>所以硬件开发在接下来的时间里会有一个迅速的进步</p>
<p>以前我们所谓的智能家居, 其实还是相对简陋了一些, 只不过是从原来的机械控制转变成了数字控制, 但实际操作还是离不开人</p>
<p>未来有AI的参与, 那智能家居才算是真正意义上的智能, AI就是生活管家</p>
<h3 id="硬件开发"><a href="#硬件开发" class="headerlink" title="硬件开发"></a>硬件开发</h3><p>关于硬件开发 涉及的技术点不少 比如单片机知识  汇编语言 C语言等等</p>
<p>在20年的时候有幸录过一套汇编语言相关的视频, 该套视频全部上传至B站供大家免费观看</p>
<p><strong>《程序员进阶之三大架构汇编语言入门视频教程-胖薯出品》</strong></p>
<ul>
<li>录制时间 2020年12月14日</li>
<li>B站:<a href="https://www.bilibili.com/video/BV1CK411u76E/" target="_blank" rel="noopener">点击跳转</a></li>
<li>网易云课堂: <a href="https://study.163.com/course/introduction/1211547802.htm" target="_blank" rel="noopener">点击跳转</a></li>
</ul>
<p>更多教程可前往 <a href="https://shop.newban.cn/" target="_blank" rel="noopener">有瓣杂货铺</a></p>
<p><strong>本文为作者原创转载时请注明出处 谢谢</strong></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em><a href="https://code.newban.cn/">乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</a></em></p>
]]></content>
      <tags>
        <tag>人工智能</tag>
      </tags>
  </entry>
  <entry>
    <title>Godot游戏开发之Node和Node2d节点的区别</title>
    <url>/387.html</url>
    <content><![CDATA[<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p><code>Node2D</code>节点继承自<code>Node</code>节点, 功能比<code>Node</code>丰富 这个不必多说, 从<code>Godot</code>右侧面板上可以很清晰地看清它们之间的继承关系, 以及暴露出来可供修改的属性:</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20220930164400556.png" alt="image-20220930164400556"></p>
<p>在实际开发中我们通常会使用<code>Node2d</code>节点, 从开发角度上它有以下优势:</p>
<ul>
<li>当我们将子场景拖拽进入<code>Node</code>节点中时, 自场景物体会自定移动到原点位置, 而<code>Node2d</code>则不存在该问题</li>
<li>通过移动<code>Node2d</code>节点位置, 我们可以将整个场景进行移动, 然而Node节点不具备移动属性, 因此无法实现该效果</li>
</ul>
<p><strong>本文为作者原创转载时请注明出处 谢谢</strong></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em><a href="https://code.newban.cn/">乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</a></em></p>
]]></content>
      <tags>
        <tag>Godot</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Python语言进行硬件开发</title>
    <url>/394.html</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p><a href="https://cool-js.com/admin/introduce.htm" target="_blank" rel="noopener">cool-admin V6.0</a>开始接入了物联网开发，默认集成了MQTT服务。在这个万物互联的时代，我们多掌握一种技能就多一分优势。</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/show.gif" alt="Show"></p>
<h3 id="选型"><a href="#选型" class="headerlink" title="选型"></a>选型</h3><p>目前市面上大多数开发物联网的都是c系列的语言，但是随着硬件性能的提升其实我们对编程语言的选择已经慢慢趋向于考虑好用、方便、简单，而不是性能。</p>
<p>对于没接触过c语言的开发者，他们大部分习惯用<code>java</code>、<code>php</code>、<code>go</code>、<code>python</code>等比较上层的语言，学c的话花的时间可能比较久。因此综合cool的粉丝和其他考虑，我们选用 <a href="https://micropython.org/" target="_blank" rel="noopener">MicroPython</a>来作为我们开发物联网的语言，使用起来和python几乎无差别。</p>
<p><code>python</code>做为一门工具语言，是很多开发着需要去掌握的！！！</p>
<h3 id="MicroPython"><a href="#MicroPython" class="headerlink" title="MicroPython"></a>MicroPython</h3><p><code>MicroPython</code>是一种基于<code>Python</code>的精简版嵌入式操作系统，它能够在小型的嵌入式系统中运行<code>Python</code>解释器。MicroPython支持各种硬件平台，包括单片机，<code>Wi-Fi</code>模块，以及其他各种嵌入式设备。</p>
<p><code>MicroPython</code>被设计成轻量级的、高效的，并且可以非常容易地与各种传感器、执行器和其他外部硬件设备进行通信。它支持许多标准Python库，同时还具有一些专门为嵌入式设备设计的库和工具。</p>
<p><code>MicroPython</code>的目标是提供一个方便的<code>Python</code>环境，可以让开发人员在嵌入式设备上轻松地编写代码，并且可以直接在设备上运行代码，而不需要在外部计算机上编译或调试代码。</p>
<p><code>MicroPython</code>可以通过串口或者<code>Wi-Fi</code>连接进行编程和调试，还可以使用<code>MicroPython</code>的交互式REPL环境（Read-Eval-Print-Loop）来进行快速原型开发。同时，<code>MicroPython</code>还支持<code>Python 3</code>语法，并且具有自动垃圾回收功能，这使得编写代码更加简单和高效。</p>
<h3 id="硬件设备"><a href="#硬件设备" class="headerlink" title="硬件设备"></a>硬件设备</h3><p>对比了市面上很多种设备，最终选用<code>Esp32</code>，来作为我们的硬件设备，它有以下特点(看不懂的同学不要着急，大概了解就行)：</p>
<ol>
<li><strong>高性能</strong>：<code>ESP32</code>拥有两个<code>Tensilica LX6</code>内核，主频高达240MHz，能够提供高性能的计算能力，可以处理复杂的算法和任务。</li>
<li><strong>低功耗</strong>：<code>ESP32</code>的功耗非常低，它具有多种节能模式，可以延长电池寿命，从而使其成为无线传感器、物联网设备和移动设备的理想选择。</li>
<li><strong>内置<code>Wi-Fi</code>和蓝牙</strong>：<code>ESP32</code>具有内置的<code>Wi-Fi</code>和蓝牙模块，支持多种无线协议和标准，可以实现快速、稳定的网络通信，从而扩展了应用场景。</li>
<li><strong>丰富的外设</strong>：<code>ESP32</code>集成了多个外设，包括多个通用输入输出口、<code>ADC</code>、<code>DAC</code>、<code>PWM</code>、<code>SPI</code>、<code>I2C</code>、<code>UART</code>、定时器等，可以满足不同应用的需求。</li>
<li><strong>安全性</strong>：<code>ESP32</code>支持多种安全特性，包括加密算法、安全引导和安全存储，可以保证系统的安全性。</li>
<li><strong>易于开发</strong>：<code>ESP32</code>可以使用<code>Arduino</code>、<code>MicroPython</code>、<code>JavaScript</code>等多种编程语言进行开发，同时还有丰富的开发工具和社区支持，可以方便快速地进行原型设计和开发。</li>
</ol>
<p>总的来说，<code>ESP32</code>硬件具有高性能、低功耗、内置无线通信、丰富的外设、安全性高和易于开发等优点，可以满足各种物联网和嵌入式应用的需求。</p>
<p><img src="https://cool-js.com/iot/esp32.png" alt="Eps32"></p>
<h3 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h3><ul>
<li>一个模拟开发板的网站，支持<code>Esp32</code>和<code>MicroPython</code>：<a href="https://wokwi.com/" target="_blank" rel="noopener">https://wokwi.com/open in new window</a></li>
<li>一个入门学习错的教程：<a href="https://doc.itprojects.cn/0006.zhishi.esp32/02.doc/index.html#/" target="_blank" rel="noopener">https://doc.itprojects.cn/0006.zhishi.esp32/02.doc/index.html#/open in new window</a></li>
<li>制作定制电路板：<a href="https://www.jlc.com/" target="_blank" rel="noopener">https://www.jlc.com/open in new window</a></li>
</ul>
<h3 id="附加"><a href="#附加" class="headerlink" title="附加"></a>附加</h3><p>除了<code>MicroPython</code>之外, 目前还有<a href="https://gitee.com/Lyon1998/pikapython" target="_blank" rel="noopener">pikapython</a></p>
<p>具体文档: <a href="http://pikascript.com/" target="_blank" rel="noopener">点击进入</a></p>
<p><strong>本文转载自</strong>: <a href="https://cool-js.com/iot/introduce.html" target="_blank" rel="noopener">COOL-JS</a></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em><a href="https://code.newban.cn/">乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</a></em></p>
]]></content>
      <tags>
        <tag>硬件开发</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot工程根据实体类自动创建数据库表</title>
    <url>/397.html</url>
    <content><![CDATA[<h3 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤"></a>实现步骤</h3><ol>
<li><p><strong>集成<code>jpa</code>依赖包</strong></p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">implementation <span class="string">"org.springframework.boot:spring-boot-starter-data-jpa"</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>给实体类添加注解</strong></p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Table(name = <span class="meta-string">"user"</span>)</span></span><br><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span></span>(</span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@GeneratedValue(strategy = GenerationType.IDENTITY)</span></span><br><span class="line">    <span class="keyword">val</span> id: <span class="built_in">Long</span>? = <span class="literal">null</span>,</span><br><span class="line">    <span class="meta">@Column(name = <span class="meta-string">"nickName"</span>,nullable = false)</span></span><br><span class="line">    <span class="keyword">val</span> nickName: String? = <span class="literal">null</span>,</span><br><span class="line">    <span class="meta">@Transient</span> <span class="comment">//表中不生成对应字段</span></span><br><span class="line">    <span class="keyword">val</span> qqAccount: String? = <span class="literal">null</span>,</span><br><span class="line">    <span class="keyword">val</span> avatar: String? = <span class="literal">null</span>,</span><br><span class="line">    <span class="keyword">val</span> realName: String? = <span class="literal">null</span>,</span><br><span class="line"> <span class="keyword">val</span> password: String? = <span class="literal">null</span>,</span><br><span class="line">    )</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong><code>在application.yml</code>配置文件中对<code>jpa</code>进行相关配置</strong></p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">    jpa:</span></span><br><span class="line"><span class="attr">      hibernate:</span></span><br><span class="line"><span class="attr">      ddl-auto:</span> <span class="string">update</span> <span class="comment"># 当实体类发生改变时更新表</span></span><br><span class="line"><span class="attr">      show-sql:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p> <code>ddl-auto</code>枚举参数介绍:</p>
<ul>
<li><code>create</code>：每次运行程序时，都会重新创建表，故而数据会丢失</li>
<li><code>create-drop</code>：每次运行程序时会先创建表结构，然后程序结束时清空表</li>
<li><code>update</code>：每次运行程序，没有表时会创建表，如果对象发生改变会更新表结构，原有数据不会清空，只会更新（推荐使用）</li>
<li><code>validate</code>：运行程序会校验数据于数据库的字段类型是否相同，字段不同会报错</li>
<li><code>none</code>：禁用DDL处理, 此为默认模式</li>
</ul>
</li>
<li><p><strong>启动工程</strong></p>
<p>配置完后, 每次启动工程则会检查相关实体类, 如有新增实体类则自动创建表</p>
<p>需要注意的是: <strong>只能自动创建表和新增字段 删除字段和修改字段类型需要手动处理</strong></p>
</li>
</ol>
<p><strong>本文为作者原创转载时请注明出处 谢谢</strong></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em><a href="https://code.newban.cn/">乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</a></em></p>
]]></content>
      <tags>
        <tag>Web开发</tag>
      </tags>
  </entry>
  <entry>
    <title>Go语言性能为何还无法赶上C语言</title>
    <url>/393.html</url>
    <content><![CDATA[<h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><p>Go语言也能生成二进制可执行文件, 然而性能之所以还不如C 主要还是因为GC功能拖慢了运行速度, <strong>但凡是带有GC的语音 性能都不可能超过C</strong></p>
<p><strong>本文为作者原创转载时请注明出处 谢谢</strong></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em><a href="https://code.newban.cn/">乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</a></em></p>
]]></content>
      <tags>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title>SSH链接失败提示REMOTE HOST IDENTIFICATION HAS CHANGED</title>
    <url>/395.html</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>昨天在使用<code>Git</code>推送代码的时候, 莫名其妙突然报错,提示:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@</span><br><span class="line">@    WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED!     @</span><br><span class="line">@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@</span><br><span class="line">IT IS POSSIBLE THAT SOMEONE IS DOING SOMETHING NASTY!</span><br><span class="line">Someone could be eavesdropping on you right now (man-in-the-middle attack)!</span><br><span class="line">It is also possible that the RSA host key has just been changed.</span><br><span class="line">The fingerprint for the RSA key sent by the remote host is SHA256:uNiVztksCsDhcc0u9e8BujQXVUpKZIDTMc</span><br><span class="line">Please contact your system administrator.</span><br><span class="line">Add correct host key in /root/.ssh/known_hosts to get rid of this message.</span><br><span class="line">Offending key in /root/.ssh/known_hosts:3</span><br></pre></td></tr></table></figure>

<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><ol>
<li><p>第一种 直接删除<code>.ssh</code>目录下的<code>known_hosts</code>文件</p>
</li>
<li><p>第二种 修改<code>.ssh</code>目录下的<code>config</code>配置文件, 添加如下配置:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">StrictHostKeyChecking no  # 不进行主机检查</span><br><span class="line">UserKnownHostsFile /dev/null #不保存在known_hosts中</span><br></pre></td></tr></table></figure>
</li>
<li><p>第三种 只删除<code>known_hosts</code>文件中对应<code>ip</code>的相关<code>rsa</code>信息</p>
</li>
</ol>
<p><strong>本文为作者原创转载时请注明出处 谢谢</strong></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em><a href="https://code.newban.cn/">乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</a></em></p>
]]></content>
      <tags>
        <tag>ssh</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot中的Fliter和Interceptor</title>
    <url>/399.html</url>
    <content><![CDATA[<h3 id="两者区别"><a href="#两者区别" class="headerlink" title="两者区别"></a>两者区别</h3><p>两者区别:</p>
<ul>
<li><code>Filter</code>属于<code>servlet</code>组件, <code>interceptor</code>属于<code>Spring</code>内置组件</li>
<li>多个<code>Filter</code>存在时按照文件的排列顺序依次执行</li>
<li><code>Filter</code>会拦截所有的资源而<code>interceptor</code>只拦截<code>Spring</code>环境中的资源</li>
<li><code>Filter</code>的执行流程在<code>interceptor</code>之前, 也就是先执行过滤器再执行拦截器</li>
</ul>
<p>执行流程图如下:</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20230410143454632.png" alt="image-20230410143454632"></p>
<h3 id="Filter实现"><a href="#Filter实现" class="headerlink" title="Filter实现"></a>Filter实现</h3><ol>
<li><p>第一步 定义过滤器, 实现<code>servlet</code>包下的<code>Filter</code>接口, 并重写其所有方法</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@WebFilter(urlPatterns = [<span class="meta-string">"/*"</span>])</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LoginFilter</span>:<span class="type">Filter &#123;</span></span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 请求拦截</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">doFilter</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        request: <span class="type">ServletRequest</span>?,</span></span></span><br><span class="line"><span class="function"><span class="params">        response: <span class="type">ServletResponse</span>?,</span></span></span><br><span class="line"><span class="function"><span class="params">        chain: <span class="type">FilterChain</span>?</span></span></span><br><span class="line"><span class="function"><span class="params">    )</span></span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//放行</span></span><br><span class="line">        chain?.doFilter(request,response)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 服务启动时调用 只调用一次</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">init</span><span class="params">(filterConfig: <span class="type">FilterConfig</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(filterConfig)</span><br><span class="line">            </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 服务关闭时调用</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">destroy</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.destroy()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="2">
<li><p>第二步 项目启动入口类上添加<code>@ServletComponentScan</code>开启<code>servlet</code>组件支持</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ServletComponentScan</span> /</span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">MainApplication</span> </span>&#123;</span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="meta">@JvmStatic</span></span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">            SpringApplication.run(MainApplication::<span class="class"><span class="keyword">class</span>.<span class="title">java</span>, <span class="type">*args)</span></span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ol>
<h3 id="Interceptor实现"><a href="#Interceptor实现" class="headerlink" title="Interceptor实现"></a>Interceptor实现</h3><h3 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h3><ol>
<li><p>第一步 定义拦截器, 实现<code>HandlerInterceptor</code>接口 并重写其所有方法</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LoginCheckInterceptor</span> :<span class="type">HandlerInterceptor &#123;</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在目标方法执行前执行 返回true放行 否则不放行</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">preHandle</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        request: <span class="type">HttpServletRequest</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">        response: <span class="type">HttpServletResponse</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">        handler: <span class="type">Any</span></span></span></span><br><span class="line"><span class="function"><span class="params">    )</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在目标方法执行后执行</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">postHandle</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        request: <span class="type">HttpServletRequest</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">        response: <span class="type">HttpServletResponse</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">        handler: <span class="type">Any</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">        modelAndView: <span class="type">ModelAndView</span>?</span></span></span><br><span class="line"><span class="function"><span class="params">    )</span></span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 最后执行</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">afterCompletion</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        request: <span class="type">HttpServletRequest</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">        response: <span class="type">HttpServletResponse</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">        handler: <span class="type">Any</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">        ex: <span class="type">Exception</span>?</span></span></span><br><span class="line"><span class="function"><span class="params">    )</span></span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="2">
<li><p>第二步 创建配置类 并将刚定义的拦截器添加进配置类中</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">WebConfig</span> : <span class="type">WebMvcConfigurer &#123;</span></span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">lateinit</span> <span class="keyword">var</span> loginCheckInterceptor: LoginCheckInterceptor</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">addInterceptors</span><span class="params">(registry: <span class="type">InterceptorRegistry</span>)</span></span> &#123;</span><br><span class="line">        registry.addInterceptor(loginCheckInterceptor).addPathPatterns(<span class="string">"/**"</span>) <span class="comment">//拦截所有路径</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p><strong>本文为作者原创转载时请注明出处 谢谢</strong></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em><a href="https://code.newban.cn/">乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</a></em></p>
]]></content>
      <tags>
        <tag>Web开发</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot实现自动生成接口文档</title>
    <url>/396.html</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>需要使用<code>knife4j</code>这个框架来实现我们的需求, 这里我使用的是<code>Gradle</code>构建环境, 具体步骤如下</p>
<h3 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤"></a>实现步骤</h3><ol>
<li><p><strong>添加依赖</strong></p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">implementation <span class="string">"com.github.xiaoymin:knife4j-spring-boot-starter:2.0.9"</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>定义配置类</strong></p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableSwagger2WebMvc</span></span><br><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">SwaggerConfiguration</span> : <span class="type">WebMvcConfigurer&#123;</span></span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">addResourceHandlers</span><span class="params">(registry: <span class="type">ResourceHandlerRegistry</span>?)</span></span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建Docket存入容器，Docket代表一个接口文档</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">open</span> <span class="function"><span class="keyword">fun</span> <span class="title">webApiConfig</span><span class="params">()</span></span>: Docket? &#123;</span><br><span class="line">        <span class="keyword">return</span> Docket(DocumentationType.SWAGGER_2) <span class="comment">// 创建接口文档的具体信息</span></span><br><span class="line">            .apiInfo(webApiInfo()) <span class="comment">// 创建选择器，控制哪些接口被加入文档</span></span><br><span class="line">            .select() <span class="comment">// 指定@ApiOperation标注的接口被加入文档</span></span><br><span class="line">            .apis(RequestHandlerSelectors.withMethodAnnotation(ApiOperation::<span class="class"><span class="keyword">class</span>.<span class="title">java</span>))</span></span><br><span class="line">            .build()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建接口文档的具体信息，会显示在接口文档页面中</span></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">webApiInfo</span><span class="params">()</span></span>: ApiInfo? &#123;</span><br><span class="line">        <span class="keyword">return</span> ApiInfoBuilder() <span class="comment">// </span></span><br><span class="line">            .title(<span class="string">"文档标题"</span>) <span class="comment">// </span></span><br><span class="line">            .description(<span class="string">"文档描述"</span>) </span><br><span class="line">            .version(<span class="string">"1.0"</span>)<span class="comment">// 版本</span></span><br><span class="line">            .contact(Contact(<span class="string">"联系人信息"</span>, <span class="string">"http://baidu.com"</span>, <span class="string">"baidu@qq.com"</span>)) <span class="comment">// 版权</span></span><br><span class="line">            .license(<span class="string">"版权地址"</span>) </span><br><span class="line">            .licenseUrl(<span class="string">"http://www.baidu.com"</span>)</span><br><span class="line">            .build()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>给<code>Controller</code>添加文档注解</strong></p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Api(tags = [<span class="meta-string">"文件管理"</span>])</span></span><br><span class="line"><span class="meta">@ApiSupport(author = <span class="meta-string">"开发者名称"</span>, order = 1)</span></span><br><span class="line"><span class="meta">@CrossOrigin</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(<span class="meta-string">"/file"</span>)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FileController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">lateinit</span> <span class="keyword">var</span> service: FileService</span><br><span class="line">    <span class="meta">@ApiOperation(value = <span class="meta-string">"文件上传"</span>, notes = <span class="meta-string">"这是注释"</span>)</span></span><br><span class="line">    <span class="meta">@PostMapping(value = [<span class="meta-string">"/upload"</span>])</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">uploadFile</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="meta">@RequestParam(value = <span class="meta-string">"file"</span>, required = true)</span> file: <span class="type">MultipartFile</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    )</span></span>: BaseEntity&lt;String&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">val</span> url = service.uploadFile(file)</span><br><span class="line">            BaseEntity(<span class="keyword">data</span> = url)</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e: Exception) &#123;</span><br><span class="line">            BaseEntity(code = <span class="number">505</span>, msg = e.message.orEmpty(), <span class="keyword">data</span> = <span class="string">""</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong><code>在application.yml</code>配置文件中对<code>knife4j</code>进行相关配置</strong></p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">knife4j:</span></span><br><span class="line"><span class="attr">  enable:</span> <span class="literal">true</span> <span class="comment">#开启文档自动生成功能</span></span><br><span class="line"><span class="attr">  production:</span> <span class="literal">false</span> <span class="comment"># 生产版本时 无权限访问</span></span><br><span class="line"><span class="attr">  basic:</span> <span class="comment"># 设置访问密码</span></span><br><span class="line"><span class="attr">    enable:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">    username:</span> <span class="string">abc</span></span><br><span class="line"><span class="attr">    password:</span> <span class="number">123</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>运行工程, 查看文档</strong></p>
<p>浏览器输入<code>http://ip:端口/doc.html</code>查看自动生成的文档, 如下:</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20230410114636451.png" alt="image-20230410114636451"></p>
</li>
</ol>
<h3 id="文档参考"><a href="#文档参考" class="headerlink" title="文档参考"></a>文档参考</h3><p>官方文档: <a href="https://doc.xiaominfo.com/" target="_blank" rel="noopener">点击进入</a></p>
<p><strong>本文为作者原创转载时请注明出处 谢谢</strong></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em><a href="https://code.newban.cn/">乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</a></em></p>
]]></content>
      <tags>
        <tag>Web开发</tag>
      </tags>
  </entry>
  <entry>
    <title>个人开发者收款方案汇总</title>
    <url>/401.html</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>网站或者APP收款问题始终是大部分个人开发者的一个痛点, 目前支付宝和微信收款业务只面向企业和个体户开放, 个人无法申请</p>
<p>在产品盈利状况不明的情况下, 如果特地为此去注册一家公司, 那么前期的维护成本太高了,并不推荐</p>
<p>此时 我们可以考虑先接入第三方的收款平台, 等产品步入稳定盈利阶段后, 再考虑注册公司或者个体户</p>
<p>目前市面上有许多供个人申请的收款平台, 这里做了个汇总, 供大家查阅</p>
<h3 id="国内首款方案"><a href="#国内首款方案" class="headerlink" title="国内首款方案"></a>国内首款方案</h3><ol>
<li><p><strong>虎皮椒</strong></p>
<p>官网: <a href="https://www.xunhupay.com/" target="_blank" rel="noopener">点击进入</a></p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20230412115844779.png" alt="image-20230412115844779"></p>
</li>
<li><p><strong>PayJs</strong></p>
<p>官网: <a href="https://payjs.cn/" target="_blank" rel="noopener">点击进入</a></p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20230412111136593.png" alt="image-20230412111136593"></p>
</li>
<li><p><strong>XorPay</strong></p>
<p>官网: <a href="http://xorpay.com/" target="_blank" rel="noopener">点击进入</a></p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20230412105948282.png" alt="image-20230412105948282"></p>
</li>
<li><p><strong>微豆付</strong></p>
<p>官网: <a href="https://www.weidoufu.com/" target="_blank" rel="noopener">点击进入</a></p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20230412110538451.png" alt="image-20230412110538451"></p>
</li>
<li><p><strong>叮咚支付</strong></p>
<p>官网: <a href="https://codepay.ddmzf.cn/" target="_blank" rel="noopener">点击进入</a></p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20230412110437720.png" alt="image-20230412110437720"></p>
</li>
<li><p><strong>云免签</strong></p>
<p>官网: <a href="https://www.yunmianqian.com/" target="_blank" rel="noopener">点击进入</a></p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20230412110957697.png" alt="image-20230412110957697"></p>
</li>
<li><p><strong>V免签</strong></p>
<p>开源项目, 采用app监控+服务端回调的方式</p>
<p>Github: <a href="https://github.com/szvone/vmqphp" target="_blank" rel="noopener">点击进入</a></p>
<p>演示地址：<a href="http://pay.vmianqian.com/houtai" target="_blank" rel="noopener">点击进入</a><br>测试支付地址：<a href="https://pay.vmianqian.com/SDK/" target="_blank" rel="noopener">点击进入</a></p>
<p>V免签软件工具网盘：<a href="https://pan.6la.cn/" target="_blank" rel="noopener">点击进入</a></p>
<p>备用网盘：<a href="http://vmianqian.uupan.net/" target="_blank" rel="noopener">vmianqian.uupan.net</a>  登录密码：66666</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20230412112520373.png" alt="image-20230412112520373"></p>
</li>
<li><p><strong>面包多</strong></p>
<p>官网: <a href="https://doc.mbd.pub/" target="_blank" rel="noopener">点击进入</a></p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20230412122804341.png" alt="image-20230412122804341"></p>
</li>
<li><p><strong>爱发电</strong></p>
<p>官网: <a href="https://afdian.net/" target="_blank" rel="noopener">点击进入</a></p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20230412140048731.png" alt="image-20230412140048731"></p>
</li>
<li><p><strong>YunGouOS</strong></p>
<p>官网: <a href="https://www.yungouos.com/" target="_blank" rel="noopener">点击进入</a></p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20230412120842858.png" alt="image-20230412120842858"></p>
</li>
<li><p><strong>h5zhifu</strong></p>
<p>官网: <a href="https://h5zhifu.com/" target="_blank" rel="noopener">点击进入</a></p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20230412122647173.png" alt="image-20230412122647173"></p>
</li>
</ol>
<h3 id="全球首款方案"><a href="#全球首款方案" class="headerlink" title="全球首款方案"></a>全球首款方案</h3><ol>
<li><p><strong>Paddle支付</strong></p>
<p>官网：<a href="[https://www.paddle.com](https://www.paddle.com/)">点击进入</a><br>沙盒测试环境：<a href="https://sandbox-vendors.paddle.com/" target="_blank" rel="noopener">点击进入</a></p>
</li>
</ol>
<p><strong>本文为作者原创转载时请注明出处 谢谢</strong></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em><a href="https://code.newban.cn/">乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</a></em></p>
]]></content>
      <tags>
        <tag>Web开发</tag>
      </tags>
  </entry>
  <entry>
    <title>关于几种Web会话跟踪技术的对比分析</title>
    <url>/398.html</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>正常情况下, 当浏览器打开访问某个网站时一个新会话便创建了, 当浏览器关闭, 那该会话便结束</p>
<p>会话跟踪技术: 检查多个或多次接口请求是否属于同一个会话的技术, 简而言之就是判断这些请求是否来自同一个用户的技术</p>
<p>常见的会话跟踪技术有:</p>
<ul>
<li>Cookie </li>
<li>Session</li>
<li>JWT</li>
</ul>
<h3 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h3><p><strong>优势:</strong></p>
<ul>
<li><code>HTTP</code>协议中支持的技术</li>
<li>全程自动跟踪</li>
</ul>
<p><strong>劣势:</strong></p>
<ul>
<li>移动端APP无法使用<code>Cookie</code></li>
<li>不支持跨域</li>
<li>不安全 用户可以手动禁用<code>Cookie</code></li>
<li>前端收到的<code>Cookie</code>数据为明文 信息不安全</li>
</ul>
<h3 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h3><p><strong>优势:</strong></p>
<ul>
<li><code>HTTP</code>协议中支持的技术</li>
<li>信息相对安全 前端收到的<code>Cookie</code>数据为密文, 真实数据存在后端 </li>
<li>全程自动跟踪</li>
</ul>
<p><strong>劣势:</strong></p>
<ul>
<li>移动端APP无法使用<code>Session</code></li>
<li>不支持跨域</li>
<li>由于<code>Session</code>是基于Cookie实现的, 所以用户同样可以手动禁用<code>Cookie</code>使得<code>Session</code>无法使用</li>
<li>由于数据存在后端 加大了后端了存储压力</li>
<li>服务器集群环境下无法共享<code>Session</code></li>
</ul>
<h3 id="JWT"><a href="#JWT" class="headerlink" title="JWT"></a>JWT</h3><p>全称<code>json web token</code>,</p>
<p><strong>优势:</strong></p>
<ul>
<li>支持PC端和移动端</li>
<li>解决集群环境下的认证问题</li>
<li>减轻了服务端的存储压力</li>
<li>不存在跨域问题</li>
<li>数据为密文 防篡改 安全性高</li>
</ul>
<p><strong>劣势:</strong></p>
<ul>
<li>需要手动存储<code>token</code>到本地</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><code>Cookie</code>和<code>Session</code>属于传统的会话跟踪技术, 如果只做Web端, 可以采用</p>
<p>如果是面对多平台的开发, 推荐目前主流的<code>jwt</code>技术</p>
<p><strong>本文为作者原创转载时请注明出处 谢谢</strong></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em><a href="https://code.newban.cn/">乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</a></em></p>
]]></content>
      <tags>
        <tag>Web开发</tag>
      </tags>
  </entry>
  <entry>
    <title>使用docker部署tomcat</title>
    <url>/4.html</url>
    <content><![CDATA[<h2 id="部署Tomcat"><a href="#部署Tomcat" class="headerlink" title="部署Tomcat"></a>部署Tomcat</h2><ol>
<li>搜索tomcat镜像</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker search tomcat</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>拉取tomcat镜像</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker pull tomcat</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>创建容器 设置端口映射</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 在/root目录下创建tomcat目录用于存储tomcat数据信息</span><br><span class="line">mkdir ~/tomcat</span><br><span class="line">cd ~/tomcat</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run -id \</span><br><span class="line">-p 8080:8080 \</span><br><span class="line">--name=c_tomcat \</span><br><span class="line">-v $PWD:/usr/local/tomcat/webapps \</span><br><span class="line">tomcat:latest</span><br></pre></td></tr></table></figure>

<ul>
<li>参数说明<ul>
<li><strong>-p 8080：8080 将容器的8080端口映射到主机的8080端口</strong></li>
<li><strong>-v $PWD:/usr/local/tomcat/webapps 将主机中当前目录挂载到容器webapps</strong></li>
<li><strong>-h 设置容器的hostname</strong> </li>
<li><strong>$PWD表示当前所在目录</strong></li>
</ul>
</li>
</ul>
<h4 id="小提示"><a href="#小提示" class="headerlink" title="小提示"></a>小提示</h4><p>如果你是使用的阿里云ECS 测试tomcat和mysql的时候可能会无法访问， 这是因为 阿里云ECS处于安全考虑，默认的安全组规则只开通了22和3389号端口，而我们在实际使用当中可能会需要80、8888、21等端口号，这时只要去阿里云管理后台进行安全组设置新增开放端口号即可</p>
<p><strong>本文为作者原创 转载时请注明出处 谢谢</strong></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em>乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</em></p>
]]></content>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>解决homebrew长时间停在Updating Homebrew 这个步骤</title>
    <url>/40.html</url>
    <content><![CDATA[<p>在国内的网络环境下使用 Homebrew 安装软件的过程中可能会长时间卡在 Updating Homebrew 这个步骤。</p>
<p>例：执行 brew install composer 命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜  ~ brew install composer</span><br><span class="line">Updating Homebrew... # 如果碰到长时间卡在这里，参考以下 2 种处理方法</span><br></pre></td></tr></table></figure>



<h2 id="方法-1：按住-control-c-取消本次更新操作"><a href="#方法-1：按住-control-c-取消本次更新操作" class="headerlink" title="方法 1：按住 control + c 取消本次更新操作"></a>方法 1：按住 control + c 取消本次更新操作</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜  ~ brew install composer</span><br><span class="line">Updating Homebrew...</span><br><span class="line">^C</span><br></pre></td></tr></table></figure>

<p>按住 control + c 之后命令行会显示 ^C，就代表已经取消了 Updating Homebrew 操作</p>
<p>大概不到 1 秒钟之后就会去执行我们真正需要的安装操作了</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜  ~ brew install composer</span><br><span class="line">Updating Homebrew...</span><br><span class="line">^C==&gt; Satisfying dependencies</span><br><span class="line">==&gt; Downloading https://getcomposer.org/download/1.7.2/composer.phar</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>这个方法是临时的、一次性的</p>
<h2 id="方法-2：使用-Alibaba-的-Homebrew-镜像源进行加速"><a href="#方法-2：使用-Alibaba-的-Homebrew-镜像源进行加速" class="headerlink" title="方法 2：使用 Alibaba 的 Homebrew 镜像源进行加速"></a>方法 2：使用 Alibaba 的 Homebrew 镜像源进行加速</h2><p>平时我们执行 brew 命令安装软件的时候，跟以下 3 个仓库地址有关：</p>
<ol>
<li>brew.git</li>
<li>homebrew-core.git</li>
<li>homebrew-bottles</li>
</ol>
<p>通过以下操作将这 3 个仓库地址全部替换为 Alibaba 提供的地址</p>
<h3 id="1-替换-还原-brew-git-仓库地址"><a href="#1-替换-还原-brew-git-仓库地址" class="headerlink" title="1. 替换 / 还原 brew.git 仓库地址"></a>1. 替换 / 还原 brew.git 仓库地址</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 替换成阿里巴巴的 brew.git 仓库地址:</span></span><br><span class="line">cd "$(brew --repo)"</span><br><span class="line">git remote set-url origin https://mirrors.aliyun.com/homebrew/brew.git</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">=======================================================</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 还原为官方提供的 brew.git 仓库地址</span></span><br><span class="line">cd "$(brew --repo)"</span><br><span class="line">git remote set-url origin https://github.com/Homebrew/brew.git</span><br></pre></td></tr></table></figure>



<h3 id="2-替换-还原-homebrew-core-git-仓库地址"><a href="#2-替换-还原-homebrew-core-git-仓库地址" class="headerlink" title="2. 替换 / 还原 homebrew-core.git 仓库地址"></a>2. 替换 / 还原 homebrew-core.git 仓库地址</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 替换成阿里巴巴的 homebrew-core.git 仓库地址:</span></span><br><span class="line">cd "$(brew --repo)/Library/Taps/homebrew/homebrew-core"</span><br><span class="line">git remote set-url origin https://mirrors.aliyun.com/homebrew/homebrew-core.git</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">=======================================================</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 还原为官方提供的 homebrew-core.git 仓库地址</span></span><br><span class="line">cd "$(brew --repo)/Library/Taps/homebrew/homebrew-core"</span><br><span class="line">git remote set-url origin https://github.com/Homebrew/homebrew-core.git</span><br></pre></td></tr></table></figure>



<h3 id="3-替换-还原-homebrew-bottles-访问地址"><a href="#3-替换-还原-homebrew-bottles-访问地址" class="headerlink" title="3. 替换 / 还原 homebrew-bottles 访问地址"></a>3. 替换 / 还原 homebrew-bottles 访问地址</h3><p>这个步骤跟你的 macOS 系统使用的 shell 版本有关系</p>
<p>所以，先来查看当前使用的 shell 版本</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo $SHELL</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 如果你的输出结果是 /bin/zsh，参考?的 zsh 终端操作方式</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 如果你的输出结果是 /bin/bash，参考?的 bash 终端操作方式</span></span><br></pre></td></tr></table></figure>



<h4 id="3-1-zsh-终端操作方式"><a href="#3-1-zsh-终端操作方式" class="headerlink" title="3.1 zsh 终端操作方式"></a>3.1 zsh 终端操作方式</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 替换成阿里巴巴的 homebrew-bottles 访问地址:</span></span><br><span class="line">echo 'export HOMEBREW_BOTTLE_DOMAIN=https://mirrors.aliyun.com/homebrew/homebrew-bottles' &gt;&gt; ~/.zshrc</span><br><span class="line">source ~/.zshrc</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">=======================================================</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 还原为官方提供的 homebrew-bottles 访问地址</span></span><br><span class="line">vi ~/.zshrc</span><br><span class="line"><span class="meta">#</span><span class="bash"> 然后，删除 HOMEBREW_BOTTLE_DOMAIN 这一行配置</span></span><br><span class="line">source ~/.zshrc</span><br></pre></td></tr></table></figure>



<h4 id="3-2-bash-终端操作方式"><a href="#3-2-bash-终端操作方式" class="headerlink" title="3.2 bash 终端操作方式"></a>3.2 bash 终端操作方式</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 替换 homebrew-bottles 访问 URL:</span></span><br><span class="line">echo 'export HOMEBREW_BOTTLE_DOMAIN=https://mirrors.aliyun.com/homebrew/homebrew-bottles' &gt;&gt; ~/.bash_profile</span><br><span class="line">source ~/.bash_profile</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">=======================================================</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 还原为官方提供的 homebrew-bottles 访问地址</span></span><br><span class="line">vi ~/.bash_profile</span><br><span class="line"><span class="meta">#</span><span class="bash"> 然后，删除 HOMEBREW_BOTTLE_DOMAIN 这一行配置</span></span><br><span class="line">source ~/.bash_profile</span><br></pre></td></tr></table></figure>

<h3 id="HomeBrew快速安装"><a href="#HomeBrew快速安装" class="headerlink" title="HomeBrew快速安装"></a>HomeBrew快速安装</h3><p>自动脚本(全部国内地址)（在Mac os终端中复制粘贴回车下面这句话)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/bin/zsh -c &quot;$(curl -fsSL https://gitee.com/cunkai/HomebrewCN/raw/master/Homebrew.sh)&quot;</span><br></pre></td></tr></table></figure>

<p>这行命令就是这位大佬发布的：<a href="https://zhuanlan.zhihu.com/p/111014448" target="_blank" rel="noopener">金牛肖马</a></p>
<p><strong>本文为作者原创 转载时请注明出处 谢谢</strong></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em>乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</em></p>
]]></content>
      <tags>
        <tag>实用技巧</tag>
      </tags>
  </entry>
  <entry>
    <title>个人开发者全球收款方案之--Paddle支付</title>
    <url>/402.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文仅讨论WEB端(包括H5、浏览器扩展)售卖虚拟商品(激活码)，且支持全程自动化的收款方案。</p>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>“Paddle”成立于2012年，是英国一家专门提供支付及订阅管理服务的公司。支持全球收款，支持个人开发者，且支持上传自定义的license，适合激活码软件开发者。</p>
<p>官网：<a href="https://www.paddle.com/" target="_blank" rel="noopener">https://www.paddle.com</a><br>沙盒测试环境：<a href="https://sandbox-vendors.paddle.com/" target="_blank" rel="noopener">https://sandbox-vendors.paddle.com/</a></p>
<h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><p><strong>优点</strong>：全球收款(支持PayPal、Apple Pay、Google Pay、iDEAL)、支持个人、独立沙盒测试环境、软件内部完成支付</p>
<p><strong>缺点</strong>：非实时到账、提现有门槛（全球收款通病）</p>
<h2 id="价格费用"><a href="#价格费用" class="headerlink" title="价格费用"></a>价格费用</h2><p>每笔交易：5% + 50¢</p>
<p>（注意：PayPal或Payoneer提现费用另算）</p>
<p>官方提现说明：<a href="https://www.paddle.com/help/manage/get-paid/when-and-how-do-i-get-paid" target="_blank" rel="noopener">https://www.paddle.com/help/manage/get-paid/when-and-how-do-i-get-paid</a></p>
<h2 id="对接过程"><a href="#对接过程" class="headerlink" title="对接过程"></a>对接过程</h2><p>流程:(开发者)创建商品、上传激活码[非必须]–&gt;(用户)支付–&gt;(平台)发送激活码到用户邮箱–&gt;(用户)使用激活码。</p>
<p>官方帮助文档：<a href="https://www.paddle.com/help" target="_blank" rel="noopener">https://www.paddle.com/help</a></p>
<h3 id="第一步：创建商品"><a href="#第一步：创建商品" class="headerlink" title="第一步：创建商品"></a>第一步：创建商品</h3><p>在Paddle后台新建商品，操作路径：Catalog–Products</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/1535071863.jpg" alt="个人开发者全球收款方案实践之--Paddle支付"></p>
<h3 id="第二步：上传Licenses-激活码"><a href="#第二步：上传Licenses-激活码" class="headerlink" title="第二步：上传Licenses(激活码)"></a>第二步：上传Licenses(激活码)</h3><p>文件为.txt格式，命名随意，每行就是一个激活码。激活码在后台可随时上传补充，自带排重功能。</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/3925442145.jpg" alt="个人开发者全球收款方案实践之--Paddle支付"></p>
<p>此外，还支持Coupons(折扣券)，最多可打折到免费，方便测试。</p>
<h3 id="第三步：用户支付"><a href="#第三步：用户支付" class="headerlink" title="第三步：用户支付"></a>第三步：用户支付</h3><p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/3751865639.jpg" alt="个人开发者全球收款方案实践之--Paddle支付"></p>
<h3 id="第四步：Paddle发送激活码到用户邮箱"><a href="#第四步：Paddle发送激活码到用户邮箱" class="headerlink" title="第四步：Paddle发送激活码到用户邮箱"></a>第四步：Paddle发送激活码到用户邮箱</h3><p>每完成一笔支付，用户就会收到一个带激活码的邮件。</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/1270396227.jpg" alt="个人开发者全球收款方案实践之--Paddle支付"></p>
<p>ps. Paddle后台支持几个主要的事件提醒，比如订阅、下单、支付等等事件。</p>
<h3 id="第四步：用户使用激活码"><a href="#第四步：用户使用激活码" class="headerlink" title="第四步：用户使用激活码"></a>第四步：用户使用激活码</h3><p>（略）</p>
<h2 id="核心代码"><a href="#核心代码" class="headerlink" title="核心代码"></a>核心代码</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//第一步：引入paddle.js</span><br><span class="line">&lt;script src=&quot;https://cdn.paddle.com/paddle/paddle.js&quot;&gt;&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">//第二步：初始化（vendor 在Developer Tools--Authentication里）</span><br><span class="line">Paddle.Setup(&#123; vendor: 3498x &#125;);</span><br><span class="line"></span><br><span class="line">//第三步：开始支付（product_id在商品列表页里）</span><br><span class="line">Paddle.Checkout.open(&#123; product: 77447x &#125;);</span><br></pre></td></tr></table></figure>

<p>如果是测试环境，可以加个判断：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if (location.hostname === &apos;localhost&apos;) &#123;</span><br><span class="line">  Paddle.Environment.set(&apos;sandbox&apos;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="踩坑"><a href="#踩坑" class="headerlink" title="踩坑"></a>踩坑</h2><p>在测试环境的联调过程相当顺利，一切都是理想的样子，可到了生产环境却始终报错“Page Not Found. Sorry, the page you were looking for could not be found.”。查找资料后发现需要域名认证,（后台设置Checkout–Request Domain Approval）。</p>
<p>提交域名苦等两周后，收到驳回邮件：</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/3015006346.jpg" alt="个人开发者全球收款方案实践之--Paddle支付"></p>
<p>因为在等待审核期间，自己对接的另外一些支付方式都已经上线，已经有替代品，遂不再折腾Paddle。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Paddle算是个不错的全球收款方案，功能丰富，无需梯子，暂未看到有无故封号的案例。如果你愿意花时间去审核域名，可以考虑。</p>
<h2 id="其它方案"><a href="#其它方案" class="headerlink" title="其它方案"></a>其它方案</h2><p><a href="https://code.newban.cn/403.html">《个人开发者收款方案实践之–面包多》</a></p>
<p><strong>本文转载自:</strong> <a href="https://denghao.me/index.php/archives/paddle.html" target="_blank" rel="noopener">前端邓浩</a></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em><a href="https://code.newban.cn/">乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</a></em></p>
]]></content>
      <tags>
        <tag>Web开发</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot报错lateinit property mapper has not been initialized</title>
    <url>/400.html</url>
    <content><![CDATA[<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p><code>SpringBoot</code>工程突然莫名其妙报错:<code>lateinit property mapper has not been initialized</code></p>
<p>最后发现是事务注解<code>@Transactional</code>导致的</p>
<p>由于<code>kotlin</code>方法访问权限默认为<code>final</code>, 而事务注解使用的是反射, 两者冲突</p>
<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><ol>
<li><p>第一种 去除事务注解(不推荐)</p>
</li>
<li><p>第二种 给报错的方法添加<code>open</code>权限, 如下:</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="function"><span class="keyword">fun</span> <span class="title">userLogin</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    userAccount: <span class="type">String</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    userPassword: <span class="type">String</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    request: <span class="type">HttpServletRequest</span>?,</span></span></span><br><span class="line"><span class="function"><span class="params">    response: <span class="type">HttpServletResponse</span>?</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>: String &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">""</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ol>
<p><strong>本文为作者原创转载时请注明出处 谢谢</strong></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em><a href="https://code.newban.cn/">乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</a></em></p>
]]></content>
      <tags>
        <tag>Web开发</tag>
      </tags>
  </entry>
  <entry>
    <title>盘点目前主流的跨平台开发引擎</title>
    <url>/405.html</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>我曾想, 有没有一款引擎可以实现PC端, 移动端, Web端和小程序的应用开发</p>
<p>那么对于大型应用而言, 我最先想到的就是使用游戏开发引擎, 即实现了跨平台又保证了程序性能, 生产效率大幅提高</p>
<p>比如目前有一些跨平台的桌面程序就是用<code>Godot</code>游戏引擎开发的</p>
<p>但是面对日常的展示类应用, 使用游戏引擎就有种牛刀杀鸡的感觉, 由于游戏引擎设计的初衷不同, 导致了使用游戏引擎开发日常应用会存在一些难点, 比如:</p>
<ul>
<li>UI组件的不完善 需要自己造轮子</li>
<li>第三方SDK的支持度不够, 同样需要自己造轮子</li>
<li>游戏引擎默认的UI自刷新机制和日常应用的响应式刷新不同, 开发者需要具备对引擎修改调优的能力</li>
</ul>
<p>除非有现成的框架能直接上手使用, 否则 前期开发的时间成本会比较大, 不过后期轮子造出来了这一部分的问题会得到有效解决</p>
<p>接下来咱们列举一下目前市面上主流的跨平台开发引擎:</p>
<h3 id="跨平台开发框架"><a href="#跨平台开发框架" class="headerlink" title="跨平台开发框架"></a>跨平台开发框架</h3><p><strong>日常应用引擎:</strong></p>
<table>
<thead>
<tr>
<th>引擎名称</th>
<th>Web端</th>
<th>移动端</th>
<th>PC端</th>
<th>小程序</th>
</tr>
</thead>
<tbody><tr>
<td>flutter</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td></td>
</tr>
<tr>
<td>uni-app</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
</tr>
</tbody></table>
<ul>
<li><p><code>uni-app</code>官方默认支持<code>Web</code>, 移动, 小程序三端, 和<code>Electron</code>结合后可实现桌面程序的开发, 具体文章参考: 《<a href="https://blog.csdn.net/Me_FF/article/details/125688885" target="_blank" rel="noopener">Uniapp+Vite+Vue3+Electron 快速构建桌面应用</a>》</p>
</li>
<li><p><code>flutter</code>很强 性能媲美原生, 唯一不足是不支持小程序, 目前有团队在研究小程序+<code>flutter</code>容器的方案, 也就是将开发小程序嵌入到<code>flutter</code>应用中,从而实现跨全平台, 对于企业而言只需开发和维护一套小程序即可, 具体参见:《<a href="https://www.finclip.com/mop/document/runtime-sdk/android/android-intro.html" target="_blank" rel="noopener">FinClip 实现小程序反向生成 App</a>》</p>
<p>这种方案能方便现有的前端开发者快速上手, 不过感觉和<code>uni-app</code>有点类似, 可能内部交互原理不太一样, 这一块有兴趣的可自行研究</p>
</li>
<li><p><a href="https://mpflutter.com/" target="_blank" rel="noopener">MPFlutter</a> :是基于<code>Flutter</code>延伸出来的一个支持小程序的框架, 从而实现全平台开发, 不过仅适合展示类应用的开发, 而且得掌握Dart语言, 对于纯前端开发者来说有一定的学习成本, <code>MPFlutter</code>未来发展如何 咱们拭目以待</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20230414140355841.png" alt="image-20230414140355841"></p>
</li>
</ul>
<p><strong>游戏引擎:</strong></p>
<table>
<thead>
<tr>
<th>引擎名称</th>
<th>Web端</th>
<th>移动端</th>
<th>PC端</th>
<th>小程序</th>
</tr>
</thead>
<tbody><tr>
<td>cocos</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>godot</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td></td>
</tr>
<tr>
<td>unity</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
</tr>
</tbody></table>
<p>关于游戏引擎开发日常应用的方案, 由于本人并未实操过, 暂不做评价, 等后续体验过了再来补充  </p>
<p>关于其他游戏引擎可参考文章《<a href="https://www.bilibili.com/read/cv19766236/" target="_blank" rel="noopener">常用游戏开发引擎汇总</a>》</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>展示类应用推荐<code>uniapp</code>和<code>MPFlutter</code>, 高性能应用的开发推荐原生<code>flutter</code></p>
<p>游戏和大型桌面程序的开发使用游戏引擎进行开发</p>
<p><strong>本文为作者原创转载时请注明出处 谢谢</strong></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em><a href="https://code.newban.cn/">乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</a></em></p>
]]></content>
      <tags>
        <tag>跨平台开发</tag>
      </tags>
  </entry>
  <entry>
    <title>一些好用的静态文档网站生成框架</title>
    <url>/406.html</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>对于开发者而言, 可能需要编写一些框架或者某个产品的使用说明文档, 一般这种文档都是系统化的由多个页面组成</p>
<p>此时如果使用博客的形式, 就显得比较零散不成体系, 我们如果将其整合成一个带目录的文档手册, 比如这种:</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20230414122658260.png" alt="image-20230414122658260"></p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20230414140619279.png" alt="image-20230414140619279"></p>
<p>不仅让阅读者一目了然, 对于编写者而言也能起到规范作用</p>
<p>这种文档不仅适合开发者使用, 同样适合其他文字创作者, 比如作家, 小说家等等 对于普通人而言 一开始就使用这种文档式的创作模式能有效培养体系化的创作思维, 为未来创作长篇文章打下良好基础😁</p>
<p>好了 回归主题 如何快速生成这种静态文档网站呢?</p>
<p>这里给大家推荐几款框架</p>
<h3 id="静态文档生成框架"><a href="#静态文档生成框架" class="headerlink" title="静态文档生成框架"></a>静态文档生成框架</h3><ol>
<li><p><strong>Docusaurus</strong></p>
<p>是<code>Facebook</code>专门为开源项目开发者提供的一款易于维护的静态网站创建工具,使用 <code>Markdown</code>即可更新网站</p>
<p>官网: <a href="https://www.docusaurus.cn/" target="_blank" rel="noopener">点击进入</a></p>
<p>Github: <a href="https://github.com/facebook/docusaurus" target="_blank" rel="noopener">点击进入</a></p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20230418112631177.png" alt="image-20230418112631177"></p>
<p>示例网站: <a href="https://github.com/mpflutter/mpflutter.github.io/" target="_blank" rel="noopener">MPFlutter</a></p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20230414140619279.png" alt="image-20230414140619279"></p>
</li>
<li><p><strong>Gitbook</strong></p>
<p>示例网站: <a href="https://doc.mbd.pub/" target="_blank" rel="noopener">面包多</a></p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20230412122804341.png" alt="image-20230412122804341"></p>
</li>
<li><p><strong>Read the Docs</strong></p>
<p>国外的一个文档托管网站</p>
<p>官网: <a href="https://readthedocs.org/" target="_blank" rel="noopener">点击进入</a></p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20230418164731019.png" alt="image-20230418164731019"></p>
</li>
<li><p><strong>VuePress</strong></p>
<p>官网: <a href="https://vuepress.vuejs.org/zh/" target="_blank" rel="noopener">点击进入</a></p>
<p>Github: <a href="https://github.com/vuejs/vuepress" target="_blank" rel="noopener">点击进入</a></p>
<p>一款由<code>Vue</code>驱动的静态网站生成器</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20230418110720504.png" alt="image-20230418110720504"></p>
</li>
<li><p><strong>vuepress-theme-vdoing</strong></p>
<p>🚀一款基于<code>VuePress</code>修改和拓展的知识管理&amp;博客(blog)主题 </p>
<p>官网: <a href="https://doc.xugaoyi.com/" target="_blank" rel="noopener">点击进入</a></p>
<p>Github: <a href="https://github.com/xugaoyi/vuepress-theme-vdoing" target="_blank" rel="noopener">点击进入</a></p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20230418110531972.png" alt="image-20230418110531972"></p>
<p>示例网站: <a href="https://baomidou.com/" target="_blank" rel="noopener">MyBatis-Plus</a>, <a href="https://www.vform666.com/" target="_blank" rel="noopener">Variant Form</a></p>
</li>
<li><p><strong>VuePress Theme Hope</strong></p>
<p>一个具有强大功能的 vuepress 主题✨</p>
<p>官网: <a href="https://theme-hope.vuejs.press/zh/" target="_blank" rel="noopener">点击进入</a></p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20230418162654493.png" alt="image-20230418162654493"></p>
<p>示例网站: <a href="https://dromara.org/fast-request/" target="_blank" rel="noopener">FastRequest</a></p>
</li>
</ol>
<h3 id="大图镇楼"><a href="#大图镇楼" class="headerlink" title="大图镇楼"></a>大图镇楼</h3><p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/76024c75-2c5e-4787-b2f5-8c5fc32531d4.jpeg" alt="76024c75-2c5e-4787-b2f5-8c5fc32531d4"></p>
<p><strong>本文为作者原创转载时请注明出处 谢谢</strong></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em><a href="https://code.newban.cn/">乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</a></em></p>
]]></content>
      <tags>
        <tag>Web开发</tag>
      </tags>
  </entry>
  <entry>
    <title>让APP实现小程序能力FinClip Uniapp mPaaS三大小程序容器技术比较</title>
    <url>/407.html</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>想要让自己的APP也想微信一样具有装载小程序的功能, 可以借助<code>FinClip</code>,<code>Uniapp</code>或者<code>mPaaS</code>来实现</p>
<p>今天我们来对比一下三者各自的优势</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/8d28c245b5b4ca0d907291370dcf00c4.png" alt="FinClip 与 uniapp：轻应用平台与前端开发框架"></p>
<h3 id="Uniapp"><a href="#Uniapp" class="headerlink" title="Uniapp"></a>Uniapp</h3><p>一款优秀的前端框架, 实现了一套代码多端运行, 不仅支持移动端和小程序, 还能给APP实现小程序能力</p>
<p>其优势:</p>
<ul>
<li>一套代码 多端运行 (Web端 移动端 小程序)</li>
<li>小程序支持厂商众多(微信小程序, 抖音小程序, 百度小程序…….)</li>
<li>赋予App小程序能力</li>
<li>以前端跨平台为核心</li>
<li>提供各种增值服务 比如广告联盟，插件市场，云打包增值服务方便开发者快速变现</li>
<li>框架使用完全免费</li>
</ul>
<p>官网: <a href="https://uniapp.dcloud.net.cn/" target="_blank" rel="noopener">点击进入</a></p>
<h3 id="FinClip"><a href="#FinClip" class="headerlink" title="FinClip"></a>FinClip</h3><p>一个小程序容器, 可以将这个容器集成到原生<code>APP</code>或者桌面程序甚至<code>uniapp</code>应用中, 让应用实现小程序能力, <code>Flutter+FinClip</code>容器的结合弥补了<code>Flutter</code>不支持小程序的缺陷, 实现真正意义上的一次开发 到处运行, 对于开发者而言只需维护一套小程序代码即可</p>
<p><code>FinClip</code>工作原理如图:</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/zucheng002.5de2ec84.png" alt="img"></p>
<p>其优势:</p>
<ul>
<li>一套代码 全平台运行 (宿主为<code>Flutter</code>的情况下 可实现Web端 移动端 PC端 小程序四端跨平台)</li>
<li>赋予App小程序能力</li>
<li>以小程序为核心 反向生成各个平台应用  方便企业快速升级</li>
<li>可兼容基于 Taro，kbone 或 uni-app 框架生成的全部小程序</li>
<li>按流量和就看调用收费</li>
</ul>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20230414164600163.png" alt="image-20230414164600163"></p>
<p>官网: <a href="https://www.finclip.com" target="_blank" rel="noopener">点击进入</a></p>
<p>Github: <a href="https://gitee.com/finclip/finclip-uniapp-demo" target="_blank" rel="noopener">点击进入</a></p>
<h3 id="mPaaS"><a href="#mPaaS" class="headerlink" title="mPaaS"></a>mPaaS</h3><p><code>mPaaS</code> 小程序容器，源自于支付宝小程序框架，继承了支付宝小程序框架的易开发性、跨平台性以及 Native 性能，不仅帮助开发者实现面向自有 App 投放小程序，还可快速构建打包，覆盖支付宝、淘宝、钉钉等应用。</p>
<ul>
<li>一套代码 多端运行 (Web端 移动端 小程序)</li>
<li>市场验证 容器稳定可靠</li>
<li>按使用流量和接口调用次数收费</li>
<li>小程序只能投放至阿里系平台宿主中比如付宝、淘宝、钉钉等, 无法给微信使用</li>
</ul>
<p>官网: <a href="http://mpaas.com/mini-program.html" target="_blank" rel="noopener">点击进入</a></p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20230414163702998.png" alt="image-20230414163702998"></p>
<h3 id="三者对比"><a href="#三者对比" class="headerlink" title="三者对比"></a>三者对比</h3><table>
<thead>
<tr>
<th></th>
<th>uniMPSDK</th>
<th>mPaaS</th>
<th>FinClip SDK</th>
</tr>
</thead>
<tbody><tr>
<td>SDK支持小程序开发框架</td>
<td>仅支持使用uni-app开发框架开发的小程序</td>
<td>仅支持基于支付宝小程序语法开发的小程序</td>
<td>支持微信小程序，也支持基于Taro、kbone、uniapp等三方框架生成的小程序</td>
</tr>
<tr>
<td>SDK支持集成的系统类型</td>
<td>仅提供iOS、Android两种类型的SDK</td>
<td>仅支持iOS、Android两种平台</td>
<td>提供iOS、Android、Flutter、.ReactNative、Windows等多种SDK</td>
</tr>
<tr>
<td>集成SDK后，App体积增大多少</td>
<td>集成后，App体积可能会增大7~16M左右</td>
<td>集成后，ApP体积可能会增大30M左右</td>
<td>集成后，App体积可能会增大3M左右</td>
</tr>
<tr>
<td>是否有小程序全生命周期管理平台</td>
<td>没有小程序的全生命周期管理平台</td>
<td>仅提供部分，如灰度发布与统计分析</td>
<td>拥有完善的管理平台，便于管理小程开发、测试、上下架等流程</td>
</tr>
<tr>
<td>渲染技术架构</td>
<td>采用了webview渲染或者原生渲染(React Native/,weex)</td>
<td>采用了webview渲染或者原生渲染(React Native/,weex)</td>
<td>采用与微信小程序一致的逻辑层与渲染层分离架构</td>
</tr>
</tbody></table>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/3e986727bf0eb1da538f78382e8391a5.png" alt="img"></p>
<p>我们换个角度进行分析补充:</p>
<table>
<thead>
<tr>
<th></th>
<th>FinClip</th>
<th>uniapp</th>
<th>mPaaS</th>
</tr>
</thead>
<tbody><tr>
<td>容器的吸收包容能力</td>
<td>更倾向于吸收和包容, 它能兼容运行外部平台开发的小程序, 比如<code>uniapp</code>, 微信小程序等  当然支付宝小程序也可兼容 使用转换工具转换成微信小程序代码后即可</td>
<td>只能运行自身开发的小程序</td>
<td>只能运行自身开发的小程序</td>
</tr>
<tr>
<td>小程序分发能力</td>
<td>分发功能比较薄弱, 也就是由它开发的小程序只能运行在微信和自身容器</td>
<td>比较擅长分发 支持的小程序平台众多</td>
<td>局限于阿里系APP和自身容器上</td>
</tr>
<tr>
<td>容器可运行的宿主平台</td>
<td>iOS、Android、Flutter、.ReactNative、Windows, uniapp</td>
<td>仅支持iOS、Android两种平台</td>
<td>仅支持iOS、Android两种平台</td>
</tr>
<tr>
<td>容器的运行性能</td>
<td>在性能上<code>FinClip</code>要更胜一筹</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结|"></a>总结|</h3><p><code>FinClip</code>更倾向于吸收和包容, 它能兼容运行外部平台开发的小程序, 比如<code>uniapp</code>, 微信小程序等 当然支付宝小程序也可兼容 使用转换工具转换成微信小程序代码后即可</p>
<p>但是<code>FinClip</code>分发功能比较薄弱, 也就是由它开发的小程序只能运行在微信和自身容器上, 这一点<code>uniapp</code>比较擅长</p>
<p><code>mPaaS</code>只能运行支付宝系的小程序, 另外分发也局限于阿里系APP</p>
<p>因此 我们可以取长补短, 开发小程序我们使用<code>uniapp</code>, 运行小程序使用<code>FinClip</code>, 完美😝</p>
<p><strong>具体开发方案思考🤔:</strong></p>
<ol>
<li>我们用<code>uniapp</code>进行跨平台应用开发时, 不用官方提供的<code>uniMPSDK</code>, 而是选择<code>FinClip</code>来实现应用的小程序能力, <code>Webview</code>基础上套一层小程序容器, 性能不知如何 </li>
<li>我们用<code>uniapp</code>进行小程序开发, 然后使用<code>Flutter</code>宿主+<code>FinClip</code>容器运行小程序, 最后实现全平台分发(PC端 移动端 Web端 各大平台小程序), 🐂🍺</li>
</ol>
<p>参考资料:</p>
<p>《<a href="https://blog.csdn.net/Chenduzi/article/details/122307679" target="_blank" rel="noopener">FinClip 与 uniapp：轻应用平台与前端开发框架</a>》</p>
<p>《<a href="https://zhuanlan.zhihu.com/p/456695670" target="_blank" rel="noopener">系统对比下 FinClip 与 mPaaS</a>》</p>
<p><strong>本文为作者原创转载时请注明出处 谢谢</strong></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em><a href="https://code.newban.cn/">乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</a></em></p>
]]></content>
      <tags>
        <tag>Web开发</tag>
      </tags>
  </entry>
  <entry>
    <title>一些可视化的开发工具推荐</title>
    <url>/410.html</url>
    <content><![CDATA[<h3 id="工具推荐"><a href="#工具推荐" class="headerlink" title="工具推荐"></a>工具推荐</h3><ol>
<li><p><strong><code>Nginx</code>可视化配置工具</strong></p>
<p>官网: <a href="https://www.digitalocean.com/community/tools/nginx?global.app.lang=zhCN" target="_blank" rel="noopener">点击进入</a></p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20230418145011544.png" alt="image-20230418145011544"></p>
</li>
<li><p><strong>可视化表单生成工具</strong></p>
<p>官网: <a href="https://www.vform666.com/" target="_blank" rel="noopener">点击进入</a></p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20230418150430126.png" alt="image-20230418150430126"></p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20230418150456156.png" alt="image-20230418150456156"></p>
</li>
<li><p><strong>正则可视化工具</strong></p>
<p>官网: <a href="https://regex101.com/" target="_blank" rel="noopener">点击进入</a></p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20230418150559813.png" alt="image-20230418150559813"></p>
</li>
<li><p><strong>CSS动画可视化</strong></p>
<p>官网: <a href="https://animista.net/" target="_blank" rel="noopener">点击进入</a></p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20230418151815374.png" alt="image-20230418151815374"></p>
</li>
</ol>
<p><strong>本文为作者原创转载时请注明出处 谢谢</strong></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em><a href="https://code.newban.cn/">乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</a></em></p>
]]></content>
      <tags>
        <tag>开发</tag>
      </tags>
  </entry>
  <entry>
    <title>去哪儿找好用的轮子</title>
    <url>/411.html</url>
    <content><![CDATA[<h3 id="开源大轮子聚集地"><a href="#开源大轮子聚集地" class="headerlink" title="开源大轮子聚集地"></a>开源大轮子聚集地</h3><ol>
<li><p><strong>Dromara社区</strong></p>
<p>官网: <a href="https://dromara.org/zh/projects" target="_blank" rel="noopener">点击进入</a></p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20230418163057817.png" alt="image-20230418163057817"></p>
</li>
<li><p><strong>Gitee GVP</strong></p>
<p>官网: <a href="https://gitee.com/gvp" target="_blank" rel="noopener">点击进入</a></p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20230418165000336.png" alt="image-20230418165000336"></p>
</li>
<li><p><strong>Github 中文社区排行榜</strong></p>
<p>官网: <a href="https://www.githubs.cn/top" target="_blank" rel="noopener">点击进入</a></p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20230418172752082.png" alt="image-20230418172752082"></p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20230418172823761.png" alt="image-20230418172823761"></p>
</li>
</ol>
<p><strong>本文为作者原创转载时请注明出处 谢谢</strong></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em><a href="https://code.newban.cn/">乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</a></em></p>
]]></content>
      <tags>
        <tag>开发</tag>
      </tags>
  </entry>
  <entry>
    <title>基于Algolia实现网站全文搜索</title>
    <url>/408.html</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>目前，我的 个人网站 是基于 VuePress 搭建的，其中 VuePress 内置的搜索只会提取文档的标题（h1、h2、h3）构建搜索索引，我个人觉得不太好用，因此想借助第三方提供的免费搜索服务 Algolia DocSearch 来实现个人网站的全文搜索。</p>
<h3 id="Algolia"><a href="#Algolia" class="headerlink" title="Algolia"></a>Algolia</h3><p>Algolia 是一个数据库实时搜索服务，能够提供毫秒级的数据库搜索服务，并且其服务能以 API 的形式方便地布局到网页、客户端、APP 等多种场景。</p>
<p>VuePress 的官方文档就是使用的 Algolia 搜索，使用 Algolia 搜索最大的好处就是方便，它会自动爬取网站的页面内容并构建索引，你只用申请一个 Algolia 服务，在网站上添加一些代码，就像添加统计代码一样，然后就可以实现一个全文搜索功能。</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/20230418114534.png" alt></p>
<h5 id="Algolia-DocSearch"><a href="#Algolia-DocSearch" class="headerlink" title="Algolia DocSearch"></a>Algolia DocSearch</h5><p>Algolia DocSearch 是 Algolia 提供的自动化的全文搜索服务，DocSearch 会定时爬取指定网站（通常就是我们的文档网站）上的内容，自动构建搜索索引，不需要繁琐的配置，操作简单，用户只需要用相关的 API 直接调用就行了。</p>
<h5 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h5><p>Algolia 服务器会 定期抓取 我们指定的 文档地址 中的内容进行分析并 建立索引，这样在网站搜索框中输入关键词后，前端会调用 Algolia DocSearch 的接口并显示搜索结果。这些请求、结果显示的相关逻辑都封装好了，我们要做的就是按要求插入代码、配置好网站样式以及搜索框。</p>
<blockquote>
<p>备注：根据 Algolia DocSearch 的官方文档，默认情况下它通常一周爬取一次网站内容，用户也可自行触发爬取，详见：DocSearch 的快速描述。</p>
</blockquote>
<h5 id="使用要求"><a href="#使用要求" class="headerlink" title="使用要求"></a>使用要求</h5><p>Algolia DocSearch 提供的免费服务是需要申请的，当我们的网站满足下列条件时，Algolia 那边的工作人员才会让我们的申请通过：</p>
<p>我们必须是云文档网站的 所有者，网站必须是 公开的。<br>网站内容必须是 开源项目的技术文档 或 技术博客。<br>网站申请服务时必须有 完整稳定的设计和内容，即确认网站做好生产准备。</p>
<h3 id="实现全文搜索"><a href="#实现全文搜索" class="headerlink" title="实现全文搜索"></a>实现全文搜索</h3><h5 id="申请Algolia-DocSearch服务"><a href="#申请Algolia-DocSearch服务" class="headerlink" title="申请Algolia DocSearch服务"></a>申请Algolia DocSearch服务</h5><p>前往 Algolia DocSearch Apply 网站，填写网站地址、邮箱、仓库地址等信息，然后提交申请。</p>
<blockquote>
<p>备注：这里填写的网站地址必须是公开的、且设计完整、内容稳定。如果网站还处于测试阶段，申请通过的概率很小。</p>
</blockquote>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/20230418114617.png" alt></p>
<h5 id="回复确认邮件"><a href="#回复确认邮件" class="headerlink" title="回复确认邮件"></a>回复确认邮件</h5><p>申请通过后，Algolia DocSearch 官方会发送确认邮件到上一个步骤中填写的邮箱，收到后需要回复一下这个网站是我们负责开发维护的，并且可以修改网站代码。</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/20230418114643.png" alt></p>
<p>回复邮件内容：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Thanks!</span><br><span class="line"></span><br><span class="line">I am the maintatiner of the website, I can modify the code.</span><br></pre></td></tr></table></figure>

<h5 id="启动搜索服务"><a href="#启动搜索服务" class="headerlink" title="启动搜索服务"></a>启动搜索服务</h5><p>通过确认后，Algolia DocSearch 会再发一封使用邮件，其中包含 appId、apiKey 和 indexName，用于在网站生成框架中配置使用，例如在 VuePress 中配置如下，其他框架类似：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    themeConfig: &#123;</span><br><span class="line">        algolia: &#123;</span><br><span class="line">            appId: <span class="string">'请看邮件'</span>,</span><br><span class="line">            apiKey: <span class="string">'请看邮件'</span>,</span><br><span class="line">            indexName: <span class="string">'请看邮件'</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>并且该邮件还会提供接受邀请的链接，前往该链接重新设置密码后（账号是申请时填的邮箱），即可登录 Algolia。</p>
<h3 id="后台管理数据"><a href="#后台管理数据" class="headerlink" title="后台管理数据"></a>后台管理数据</h3><p>申请 Algolia DocSearch 成功后，我们也可以前往 Algolia 管理自己的后台数据。步骤如下：</p>
<p>步骤一：登录账号后，点击右上角的 “Dashboard” 按钮前往后台。</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/20230418114713.png" alt></p>
<p>步骤二：点击左侧列表里的”Search”，可以查看对应的 “indexName” 数据，如果 “Browse” 里面没有显示数据，那么说明 DocSearch 的爬虫有点问题，导致没有生成对应的 Records：</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/20230418114800.png" alt></p>
<p>步骤三：前往 Algolia 的爬虫后台，同样需要登录。在首页进入我们需要修改的爬虫，可以看到右侧的 Records 数据为 0 条，很明显爬虫有问题：</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/20230418114812.png" alt></p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/20230418114824.png" alt></p>
<p>步骤四：点击左侧菜单中的”Editor”查看并编辑爬虫代码，注意看代码中的 pathsToMatch 路径，很明显是不对的，后面多了个 docs，将它改成正确的网站路径 <a href="https://rainmic1019.github.io/**：" target="_blank" rel="noopener">https://rainmic1019.github.io/**：</a></p>
<p>修改前：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Crawler(&#123;</span><br><span class="line">  actions: [&#123;</span><br><span class="line">      ...</span><br><span class="line">      pathsToMatch: [<span class="string">"https://rainmic1019.github.io/docs/**"</span>],</span><br><span class="line">      ...</span><br><span class="line">    &#125;],</span><br><span class="line">  ...</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>修改后：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Crawler(&#123;</span><br><span class="line">  actions: [&#123;</span><br><span class="line">      ...</span><br><span class="line">      pathsToMatch: [<span class="string">"https://rainmic1019.github.io/**"</span>],</span><br><span class="line">      ...</span><br><span class="line">    &#125;],</span><br><span class="line">  ...</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>步骤五：修改完成后，进行测试，如果能成功提取到数据则表示没问题，点击右上角的”Save”按钮保存代码：</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/20230418114916.png" alt></p>
<p>步骤六：切换回”Overview”，点击右上角的 “Restart crawling” 重新爬取数据即可。</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/20230418114933.png" alt></p>
<h3 id="添加CSS和JavaScript"><a href="#添加CSS和JavaScript" class="headerlink" title="添加CSS和JavaScript"></a>添加CSS和JavaScript</h3><p>如果使用的是 VuePress 的默认主题，那么按照 VuePress 官方文档中的方法直接配置好 appId、apiKey 和 indexName 就可以了。但在其他主题中，比如 vuepress-theme-rec，它是自己实现的搜索框，所以按 VuePress 官方文档进行配置是没有效果的，此时就需要按照 Algolia 发给我们的邮件里的方法，给网站添加 CSS 和 JavaScript，然后在加载完毕的时候调用提供的 API。</p>
<h5 id="修改config-js"><a href="#修改config-js" class="headerlink" title="修改config.js"></a>修改config.js</h5><p>.vuepress/config.js 是 VuePress 中最重要的文件，它是 VuePress 项目的配置文件入口，导出一个 JavaScript 对象，其中设置 head 属性可以指定额外需要被注入到当前页面的 HTML <head><meta name="generator" content="Hexo 3.9.0"> 中的标签，每个标签都可以以 [tagName, { attrName: attrValue }, innerHTML?] 的格式指定，比如这里我们把 Algolia 邮件中指定的 HTML 标记添加进去：<link rel="alternate" href="atom.xml" title="乱码三千 – 分享实用IT技术" type="application/atom+xml">
</head></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    head: [</span><br><span class="line">        ......</span><br><span class="line">        <span class="comment">/* 添加 Algolia 搜索框的 CSS 和 JavaScript 文件*/</span></span><br><span class="line">        [<span class="string">'link'</span>, &#123; <span class="attr">href</span>: <span class="string">"https://cdn.jsdelivr.net/npm/@docsearch/css@3"</span>, <span class="attr">rel</span>: <span class="string">"stylesheet"</span> &#125;],</span><br><span class="line">        [<span class="string">'script'</span>, &#123; <span class="attr">src</span>: <span class="string">"https://cdn.jsdelivr.net/npm/@docsearch/js@3"</span> &#125;],</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="修改enhanceApp-js"><a href="#修改enhanceApp-js" class="headerlink" title="修改enhanceApp.js"></a>修改enhanceApp.js</h5><p><code>.vuepress/enhanceApp.js</code> 文件是 VuePress 中仅次于 config.js 的第二重要的文件，我们可以通过修改该文件来对 VuePress 应用进行拓展配置。这个文件应当 export default 一个钩子函数，并接受一个包含了一些应用级别属性的对象作为参数。我们可以使用这个钩子来安装一些附加的 Vue 插件、注册全局组件，或者增加额外的路由钩子等，比如这里我们把 Algolia 邮件中的代码添加进去：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> (&#123;</span><br><span class="line">    Vue,      <span class="comment">/* VuePress 正在使用的 Vue 构造函数*/</span></span><br><span class="line">    options,  <span class="comment">/* 附加到根实例的一些选项 */</span></span><br><span class="line">    router,   <span class="comment">/* 当前应用的路由实例 */</span></span><br><span class="line">    siteData  <span class="comment">/* 站点元数据 */</span></span><br><span class="line">&#125;) =&gt; &#123;</span><br><span class="line">    <span class="comment">/* 应用级别的拓展优化 */</span></span><br><span class="line">    Vue.mixin(&#123;</span><br><span class="line">        mounted() &#123;</span><br><span class="line">            setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;  <span class="comment">/* 添加 setTimeout 避免报错（该报错不影响效果） */</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    docsearch(&#123;  <span class="comment">/* 添加 Algolia DocSearch 提供的代码 */</span></span><br><span class="line">                        appId: <span class="string">"请看邮件"</span>,</span><br><span class="line">                        apiKey: <span class="string">"请看邮件"</span>,</span><br><span class="line">                        indexName: <span class="string">"请看邮件"</span>,</span><br><span class="line">                        container: <span class="string">'.search-box'</span>,</span><br><span class="line">                        debug: <span class="literal">false</span></span><br><span class="line">                    &#125;);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">                    <span class="built_in">console</span>.log(e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, <span class="number">100</span>)</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>注意：其中的 container，参考 docsearch 的 官方仓库，这里提供的不是 input 输入框的选择器，而是一个挂载节点，比如 div 的选择器。</p>
<h3 id="修改搜索框样式"><a href="#修改搜索框样式" class="headerlink" title="修改搜索框样式"></a>修改搜索框样式</h3><p><code>VuePress</code> 提供了一种添加额外样式的简便方法。我们可以创建一个 <code>.vuepress/styles/index.styl</code>文件。这是一个<code>Stylus</code>文件，但也可以使用正常的<code>CSS</code> 语法。</p>
<p>此处我们通过该文件来设置一下 <code>Algolia</code> 搜索框的样式：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">.search-box .DocSearch.DocSearch-Button &#123;</span><br><span class="line">    cursor: text;</span><br><span class="line">    width: <span class="number">10</span>rem;</span><br><span class="line">    height: <span class="number">2</span>rem;</span><br><span class="line">    color: #5b5b5b;</span><br><span class="line">    border: <span class="number">1</span>px solid <span class="keyword">var</span>(--border-color);</span><br><span class="line">    border-radius: <span class="number">0.25</span>rem;</span><br><span class="line">    font-size: <span class="number">0.9</span>rem;</span><br><span class="line">    padding: <span class="number">0</span> <span class="number">0.5</span>rem <span class="number">0</span> <span class="number">0</span>rem;</span><br><span class="line">    outline: none;</span><br><span class="line">    transition: all <span class="number">0.2</span>s ease;</span><br><span class="line">    background: transparent;</span><br><span class="line">    background-size: <span class="number">1</span>rem;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.search-box .DocSearch-Button-Container &#123;</span><br><span class="line">    margin-left: <span class="number">0.4</span>rem;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.search-box .DocSearch-Button .DocSearch-Search-Icon &#123;</span><br><span class="line">    width: <span class="number">16</span>px;</span><br><span class="line">    height: <span class="number">16</span>px;</span><br><span class="line">    position: relative;</span><br><span class="line">    top: <span class="number">0.1</span>rem;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.search-box .DocSearch-Button-Placeholder &#123;</span><br><span class="line">    font-size: <span class="number">0.8</span>rem;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.search-box .DocSearch-Button-Keys &#123;</span><br><span class="line">    display: flex;</span><br><span class="line">    position: absolute;</span><br><span class="line">    right: <span class="number">0.1</span>rem;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.search-box .DocSearch-Button-Key &#123;</span><br><span class="line">    font-size: <span class="number">12</span>px;</span><br><span class="line">    line-height: <span class="number">20</span>px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最终显示的效果如下图所示：</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/20230418115124.png" alt></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><code>Algolia DocSearch</code> 可以说真的跟官网描述一样，算是目前构建可在线搜索文档的最简单的方式之一了。我们只需要关注文档本身，进行少量的配置，其它的 Algolia 全包了。另外，<code>Algolia</code> 还有一些其它优秀产品及服务，感兴趣的也可以前往官网自行探索。</p>
<p>本文以自己的 个人网站 为例，但 <code>Algolia DocSearch</code>适合很多类型的网站，更方便的是许多网站构建器本身就内置了对<code>Algolia</code> 的支持，比如 <code>Hexo</code>、 <code>VuePress</code>、<code>Docusaurus</code> 等等。</p>
<p><strong>本文转载自:</strong> <a href="https://blog.csdn.net/weixin_40026797/article/details/126063524" target="_blank" rel="noopener">CSDN</a></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em><a href="https://code.newban.cn/">乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</a></em></p>
]]></content>
      <tags>
        <tag>Web开发</tag>
      </tags>
  </entry>
  <entry>
    <title>个人开发者收款方案之--面包多</title>
    <url>/403.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>收款，是大多数个人开发者的梦想。如果你正在搜寻这方面的内容，恭喜你，至少说明你的项目有赢收的可能。作为一个WEB前端开发者，我对接过目前一些比较常见的收款方案，并应用于自己的项目中，现在把自己对接的过程记录下来，希望对你有所帮助。</p>
<p>本文仅讨论WEB端(包括H5、浏览器扩展)售卖虚拟商品(激活码)，且支持全程自动化的收款方案。</p>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>“面包多”属于创业团队作品，作者@greatdk偶尔活跃于V2等论坛，个人博客偶有更新，是个喜欢思考的人。</p>
<p>官网：<a href="https://mbd.pub/" target="_blank" rel="noopener">点击进入</a></p>
<h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><p><strong>优点</strong>：申请免费、对接简单、实时提现<br><strong>缺点</strong>：入驻需实名认证、支付流程在平台进行，且用户需登录</p>
<h2 id="价格费用"><a href="#价格费用" class="headerlink" title="价格费用"></a>价格费用</h2><p>普通模式：5%服务费+1%的第三方支付手续费。<br>闪电结算：5.7%的服务费。</p>
<p>ps：官方预告2022-10-01之后服务费将提高到13%<br>官方价格说明：<a href="https://mbd.pub/help/#/withdraw" target="_blank" rel="noopener">https://mbd.pub/help/#/withdraw</a></p>
<h2 id="对接过程"><a href="#对接过程" class="headerlink" title="对接过程"></a>对接过程</h2><p>流程:(开发者)创建商品–&gt;(用户)登录后支付–&gt;(平台)发送回调通知–&gt;(开发者)获取通知、查询订单、完成入库、发货。<br>官方帮助文档：<a href="https://mbd.pub/help" target="_blank" rel="noopener">https://mbd.pub/help</a></p>
<h4 id="第一步：入驻申请"><a href="#第一步：入驻申请" class="headerlink" title="第一步：入驻申请"></a>第一步：入驻申请</h4><p>填写基础资料、实名认证后，拿到Developer Key。</p>
<h4 id="第二步：创建作品"><a href="#第二步：创建作品" class="headerlink" title="第二步：创建作品"></a>第二步：创建作品</h4><p>(略)</p>
<h4 id="第二步：接收回调请求（非必须）"><a href="#第二步：接收回调请求（非必须）" class="headerlink" title="第二步：接收回调请求（非必须）"></a>第二步：接收回调请求（非必须）</h4><p>在面包多后台设置回调地址，用户支付后平台会主动向开发者推送回调请求，内容如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;order_id&quot;: &quot;3faa1cfd5a364d29a5d2aec8606a2fxa&quot;,     //面包多订单号</span><br><span class="line">    &quot;out_order_id&quot;: &quot;211234132&quot;,       //独立订单号</span><br><span class="line">    &quot;product_name&quot;: &quot;新品小报第123期&quot;,  //作品名称</span><br><span class="line">    &quot;product_url_key&quot;: &quot;usdas&quot;,        //作品urlkey</span><br><span class="line">    &quot;amount&quot;: 0,1,      //支付金额</span><br><span class="line">    &quot;state&quot;: 1,         //支付状态，成功支付则为1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：如果担心回调通知有延迟或失败，可引导用户手动复制订单号进行查询以入库。</p>
<h4 id="第三步：主动查询订单信息"><a href="#第三步：主动查询订单信息" class="headerlink" title="第三步：主动查询订单信息"></a>第三步：主动查询订单信息</h4><p>在收到面包多的支付通知回调后，开发者可以主动去查询一次订单支付信息，双重验证后入库。</p>
<p>订单查询接口地址：<code>https://x.mianbaoduo.com/api/order-detail</code><br>请求方式：<code>GET</code><br>Header公参：<code>x-token</code> (string, 必须，即第一步拿到的Developer Key)<br>入参：<code>order_id</code> (string, 必须)<br>出参：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;code&quot;: 200,</span><br><span class="line">    &quot;result&quot;: &#123;</span><br><span class="line">        &quot;ordertime&quot;: 1590508123,</span><br><span class="line">        &quot;orderamount&quot;: 3,</span><br><span class="line">        &quot;payway&quot;: &quot;alipay&quot;,</span><br><span class="line">        &quot;orderid&quot;: &quot;d878ee7909c902b19d193fb8fd0af695&quot;,</span><br><span class="line">        &quot;creatorid&quot;: &quot;a2w=&quot;,</span><br><span class="line">        &quot;state&quot;: &quot;success&quot;,</span><br><span class="line">        &quot;expire_at&quot;: 1593186560,</span><br><span class="line">        &quot;rounds&quot;: 1,</span><br><span class="line">        &quot;urlkey&quot;: &quot;Y5ublZk=&quot;,</span><br><span class="line">        &quot;re&quot;: &#123;</span><br><span class="line">            &quot;ordertime&quot;: 1594108875,</span><br><span class="line">            &quot;orderamount&quot;: 3,</span><br><span class="line">            &quot;payway&quot;: &quot;alipay&quot;,</span><br><span class="line">            &quot;orderid&quot;: &quot;4a03d948c448fb8b5f51a31ab33011e0&quot;,</span><br><span class="line">            &quot;creatorid&quot;: &quot;a2w=&quot;,</span><br><span class="line">            &quot;state&quot;: &quot;success&quot;,</span><br><span class="line">            &quot;expire_at&quot;: 1596787295,</span><br><span class="line">            &quot;rounds&quot;: 1,</span><br><span class="line">            &quot;urlkey&quot;: &quot;Y5ublZk=&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;error_info&quot;: &quot;&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="第四步：入库、发货"><a href="#第四步：入库、发货" class="headerlink" title="第四步：入库、发货"></a>第四步：入库、发货</h4><p>入数据库、发激活码(略)</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>面包多最大的问题在于支付全程在平台进行，且用户必须登录，体验不是很好。类似的还有“爱发电”、“Buy Me A Coffee”等。</p>
<p>流程调通之后，我因为上面的原因，选择了其它方案。但如果仅作为打赏捐赠平台，还是可以考虑。目前面包多的功能还在更新迭代，可以持续关注。</p>
<h2 id="其它方案"><a href="#其它方案" class="headerlink" title="其它方案"></a>其它方案</h2><p><a href="https://code.newban.cn/402.html">《个人开发者全球收款方案实践之–Paddle支付》</a></p>
<p><strong>本文转载自:</strong> <a href="https://denghao.me/index.php/archives/mianbaoduo.html" target="_blank" rel="noopener">前端邓浩</a></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em><a href="https://code.newban.cn/">乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</a></em></p>
]]></content>
      <tags>
        <tag>Web开发</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Vercel+Github免费部署国内可访问的ChatGPT网站（ChatGPT3.5版本API）</title>
    <url>/409.html</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>总所周知，Chat GPT不管是注册、登录还是使用，都需要国外科学环境，且国内、香港、俄罗斯等IP无法使用，本文介绍使用Vercel+Github免费部署国内可访问的ChatGPT网站，APi采用Chat GPT3.5版本</p>
<h2 id="工具介绍"><a href="#工具介绍" class="headerlink" title="工具介绍"></a>工具介绍</h2><p>Chat GPT API KEY（SK） 获取方法：<a href="https://blog.ahayu.cn/2023/03/17/获取chatgpt账号的api-keysk/" target="_blank" rel="noopener">获取ChatGPT账号的API KEY(sk)</a></p>
<p>Github账号</p>
<p>Github仓库，可参考本人仓库：<a href="https://github.com/fastdragon18/chat" target="_blank" rel="noopener">Github仓库</a></p>
<p>vercel账号，可使用Github直接登录</p>
<h2 id="Fork仓库"><a href="#Fork仓库" class="headerlink" title="Fork仓库"></a>Fork仓库</h2><p>登录自己的Github账号，进入Github仓库，选择右上角第二个图标Fork</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/Fork%E4%BB%93%E5%BA%93.png" alt="img"></p>
<p>跳转后的页面可自行修改仓库名称，建议不修改</p>
<p>直接点击左下角Authorize Vercel</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/20230418141129.png" alt></p>
<h2 id="使用Vercel部署"><a href="#使用Vercel部署" class="headerlink" title="使用Vercel部署"></a>使用Vercel部署</h2><p>入口：<a href="https://vercel.com/signup" target="_blank" rel="noopener">https://vercel.com/signup</a></p>
<p>登录前，请先注册，本次教程教学内容为注册</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/20230418141148.png" alt></p>
<p>进入页面后，选择第一个Github账号登录</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/20230418141200.png" alt></p>
<p>点击右下角Authorize Vercel</p>
<p>等待一会后，跳转至Vercel主页</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/20230418141217.png" alt></p>
<p>选择Select a Git Namespace</p>
<p>在下拉框中选择Add GitHub Account</p>
<p>再次跳转至Github页面</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/yes.png" alt="img"></p>
<p>点击左下角Install进行授权安装</p>
<p>等待授权完成，自动跳转至Vercel页面，在此可看到Github中的仓库</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/import.jpg" alt="img"></p>
<p>点击右边Import，进行部署</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/%E9%83%A8%E7%BD%B2.png" alt="img"></p>
<p>注：在此页面不建议修改其他参数，只需修改环境变量即可</p>
<p>点击Environment Variables</p>
<p>第一个空填入OPENAI_API_KEY</p>
<p>第二个空填入你的ChatGPT API KEY（sk-开头）</p>
<p>点击右边Add按钮</p>
<p>点击底部Deploy</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/%E9%83%A8%E7%BD%B2%E4%B8%AD.png" alt="img"></p>
<p>进入这个页面即表明正在部署当中，一般耗时3-5分钟</p>
<p>部署成功后自动跳转至成功页面</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/Success.png" alt="img"></p>
<p>点击右上角黑色Continue to Dashboard按钮</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/Url.png" alt="img"></p>
<p>点击中间DOMAINS中的URL</p>
<p>即可跳转至你个人所有的Chat GPT国内版</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/ChatGPT.png" alt="img"></p>
<h3 id="自此，部署步骤全部完成，后续更新将Vercel域名更换为自有域名"><a href="#自此，部署步骤全部完成，后续更新将Vercel域名更换为自有域名" class="headerlink" title="自此，部署步骤全部完成，后续更新将Vercel域名更换为自有域名~"></a>自此，部署步骤全部完成，后续更新将Vercel域名更换为自有域名~</h3><p><strong>本文转载自:</strong> <a href="https://blog.ahayu.cn/" target="_blank" rel="noopener">速龙博客</a></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em><a href="https://code.newban.cn/">乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</a></em></p>
]]></content>
      <tags>
        <tag>ChatGPT</tag>
      </tags>
  </entry>
  <entry>
    <title>解决pip下载速度慢的问题</title>
    <url>/41.html</url>
    <content><![CDATA[<p>在我们经常使用pip安装插件模块的时候，有没有发现下载速度很慢，但有些有强迫症的人面对几k几十k每秒的速度绝对忍不了，是不是，那么，方法来了。</p>
<h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>一句话就是使用pip下载过慢，想要快起来，起来，来。</p>
<h3 id="解决过程"><a href="#解决过程" class="headerlink" title="解决过程"></a>解决过程</h3><p><strong>问题分析</strong></p>
<p>pip下载速度过慢的原因就是pip默认使用的是国外的镜像源，那么，我使用国内的镜像源，问题不就解决了。</p>
<p>有两种方法，方法一临时有效，方法二永久生效。</p>
<h3 id="方法一：下载时加入参数-i-镜像源地址"><a href="#方法一：下载时加入参数-i-镜像源地址" class="headerlink" title="方法一：下载时加入参数-i [镜像源地址]"></a>方法一：下载时加入参数<code>-i [镜像源地址]</code></h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip install -i https://pypi.tuna.tsinghua.edu.cn/simple jieba</span><br><span class="line">或者</span><br><span class="line">pip install jieba -i https://pypi.tuna.tsinghua.edu.cn/simple</span><br></pre></td></tr></table></figure>

<h3 id="方法二：设置源"><a href="#方法二：设置源" class="headerlink" title="方法二：设置源"></a>方法二：设置源</h3><p>使用方法一，需要每次在下载时都要带参数，不想麻烦的试试方法二吧。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip config set global.index-url https://pypi.tuna.tsinghua.edu.cn/simple</span><br><span class="line">pip config set install.trusted-host mirrors.aliyun.com</span><br></pre></td></tr></table></figure>

<p><a href="https://img-blog.csdnimg.cn/20200312204633456.png" target="_blank" rel="noopener"><img src="https://img-blog.csdnimg.cn/20200312204633456.png" alt="img"></a></p>
<h3 id="附-国内镜像源地址"><a href="#附-国内镜像源地址" class="headerlink" title="附: 国内镜像源地址"></a>附: 国内镜像源地址</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># pip国内镜像源。</span><br><span class="line">#</span><br><span class="line"># 阿里云	http://mirrors.aliyun.com/pypi/simple/</span><br><span class="line"># 中国科技大学 	https://pypi.mirrors.ustc.edu.cn/simple/</span><br><span class="line"># 豆瓣	 http://pypi.douban.com/simple</span><br><span class="line"># Python官方	 https://pypi.python.org/simple/</span><br><span class="line"># v2ex	 http://pypi.v2ex.com/simple/</span><br><span class="line"># 中国科学院 	http://pypi.mirrors.opencas.cn/simple/</span><br><span class="line"># 清华大学	 https://pypi.tuna.tsinghua.edu.cn/simple/</span><br></pre></td></tr></table></figure>

<p><strong>本文为作者原创 转载时请注明出处 谢谢</strong></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em>乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</em></p>
]]></content>
      <tags>
        <tag>实用技巧</tag>
      </tags>
  </entry>
  <entry>
    <title>ChatGPT于我而言有如神助 如虎添翼</title>
    <url>/414.html</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>在<code>ChatGPT</code>诞生之前, 如果我们想获取信息一般是通过搜索引擎, 在鱼龙混杂的网页中筛选相对有用的信息, 光是信息筛选甄别就极其消耗时间和脑力</p>
<p><code>ChatGPT</code>出来后, 大大地简化了这一操作, 它可以帮我们进行大部分的垃圾信息过滤, 从而使得知识的获取变得简单直接</p>
<p><strong>以前的操作流程:</strong></p>
<p>关键词搜索👉鱼龙混杂的信息👉筛选得到各种碎片化的可用信息👉对得到的碎片信息进行可用性验证👉总结归纳</p>
<p><strong>借助<code>ChatGPT</code>的操作流程:</strong></p>
<p>关键词询问👉得到相对合理可靠的信息👉可用性验证-&gt;总结归纳</p>
<h3 id="尝试"><a href="#尝试" class="headerlink" title="尝试"></a>尝试</h3><ol>
<li><p>周杰伦的主持水平如何😀</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20230420103305473.png" alt="image-20230420103305473"></p>
</li>
<li><p>乱码三千这个博客你觉得怎么样👀</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20230420103323216.png" alt="image-20230420103323216"></p>
</li>
<li><p>你觉得歌手十二越写的歌如何🌹</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20230420103336800.png" alt="image-20230420103336800"></p>
</li>
<li><p>给码box这个平台写一句吸引人的宣传语🤩</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20230420103737735.png" alt="image-20230420103737735"></p>
</li>
</ol>
<p><strong>本文为作者原创转载时请注明出处 谢谢</strong></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em><a href="https://code.newban.cn/">乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</a></em></p>
]]></content>
      <tags>
        <tag>人工智能</tag>
      </tags>
  </entry>
  <entry>
    <title>推荐一些免费无需登录的ChatGPT网站</title>
    <url>/417.html</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>目前使用<code>ChatGPT</code>进行问题搜索的频率越来越高, 配合百度搜索, 感觉爽到飞起</p>
<p>这里给大家推荐几个目前可以免费使用的<code>ChatGPT</code>网站, 它们大部分都是基于<code>ChatGPT3.5</code>的引擎</p>
<h3 id="免费ChatGPT网站"><a href="#免费ChatGPT网站" class="headerlink" title="免费ChatGPT网站"></a>免费ChatGPT网站</h3><ol>
<li><p>Letsearches</p>
<p>官网: <a href="https://chatgpt.letsearches.com/" target="_blank" rel="noopener">点击进入</a></p>
</li>
<li><p>Extk</p>
<p>官网: <a href="https://mirrorchat.extkj.cn/" target="_blank" rel="noopener">点击进入</a></p>
</li>
<li><p>Aidutu</p>
<p>官网: <a href="https://chat.aidutu.cn/" target="_blank" rel="noopener">点击进入</a></p>
</li>
<li><p>Wuguokai</p>
<p>官网: <a href="https://chat.wuguokai.cn/" target="_blank" rel="noopener">点击进入</a></p>
</li>
<li><p>Aichatos</p>
<p>官网: <a href="https://chat6.aichatos.com/" target="_blank" rel="noopener">点击进入</a></p>
</li>
<li><p>Xeasy</p>
<p>官网: <a href="https://chat14.xeasy.me/" target="_blank" rel="noopener">点击进入</a></p>
</li>
<li><p>Binjie</p>
<p>官网: <a href="http://chat.binjie.site/" target="_blank" rel="noopener">点击进入</a></p>
</li>
</ol>
<p>注意: 免费通道存在一定的不稳定性, 如果某个网站无法正常访问, 说明该网站已不可用, 不必太过纠结, 换一个即可</p>
<h3 id="收费的ChatGPT网站"><a href="#收费的ChatGPT网站" class="headerlink" title="收费的ChatGPT网站"></a>收费的ChatGPT网站</h3><p>收费的相对来说要稳定许多, 访问速度也相对较快一些</p>
<ol>
<li><p>TalkAI</p>
<p>官网: <a href="https://talkai.cc/" target="_blank" rel="noopener">点击进入</a></p>
<p>每日有两次免费的问答机会, 超出需要包月购买</p>
</li>
<li><p>Vqlai</p>
<p>官网: [点击进入](<a href="https://static.vqlai.com/apps/vchat/" target="_blank" rel="noopener">https://static.vqlai.com/apps/vchat/</a>)</p>
<p>需要关注微信公众号才能使用, 首次关注赠送30额度</p>
</li>
</ol>
<h3 id="ChatGPT插件"><a href="#ChatGPT插件" class="headerlink" title="ChatGPT插件"></a>ChatGPT插件</h3><h5 id="vscode平台插件"><a href="#vscode平台插件" class="headerlink" title="vscode平台插件"></a>vscode平台插件</h5><ol>
<li><p><strong>ChatGPT中文版</strong></p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20230421154452646.png" alt="image-20230421154452646"></p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20230421161621252.png" alt="image-20230421161621252"></p>
</li>
</ol>
<h5 id="IntelliJ-IDEA平台插件"><a href="#IntelliJ-IDEA平台插件" class="headerlink" title="IntelliJ IDEA平台插件"></a>IntelliJ IDEA平台插件</h5><ol>
<li><p><strong>NextChatGPT</strong></p>
<p>收费插件, 这个需要关注公众号才能使用, 首次赠送30额度</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20230421154640851.png" alt="image-20230421154640851"></p>
</li>
</ol>
<h3 id="AI导航"><a href="#AI导航" class="headerlink" title="AI导航"></a>AI导航</h3><p>官网: <a href="https://123.lingduquan.com/" target="_blank" rel="noopener">点击进入</a></p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20230421173531299.png" alt="image-20230421173531299"></p>
<p><strong>本文为作者原创转载时请注明出处 谢谢</strong></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em><a href="https://code.newban.cn/">乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</a></em></p>
]]></content>
      <tags>
        <tag>ChatGPT</tag>
      </tags>
  </entry>
  <entry>
    <title>关于Web server failed to start. Port 8080 was already in use</title>
    <url>/415.html</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p><code>Web</code>开发时偶尔会碰到这种错误, 主要是上一次服务未关闭导致的</p>
<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><h5 id="Windows平台"><a href="#Windows平台" class="headerlink" title="Windows平台"></a>Windows平台</h5><ol>
<li><p><strong>打开<code>cmd</code>命令窗口,查看被占用端口号所对应的进程</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">netstat -aon|findstr "端口号"</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>终止对应进程</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">taskkill /pid 这里填查询到的pid /f</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h5 id="Mac平台"><a href="#Mac平台" class="headerlink" title="Mac平台"></a>Mac平台</h5><ol>
<li><p><strong>查看被占用端口号所对应的进程</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">lsof -i:端口号</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20230420122833156.png" alt="image-20230420122833156"></p>
</li>
<li><p><strong>终止对应进程</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kill PID</span><br></pre></td></tr></table></figure>





</li>
</ol>
<p><strong>本文为作者原创转载时请注明出处 谢谢</strong></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em><a href="https://code.newban.cn/">乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</a></em></p>
]]></content>
      <tags>
        <tag>Web开发</tag>
      </tags>
  </entry>
  <entry>
    <title>CURL的使用技巧</title>
    <url>/412.html</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p><code>curl</code>是一个命令行下工作的文件传输工具, 支持网络请求和文件的上传下载, 非常强大, 很多操作系统默认安装了<code>curl</code>, 比如<code>macOS</code>,<code>Windows</code>, <code>Linux</code>等</p>
<p>当我们在使用无界面的操作系统时, 如果想要模拟网络请求, 此时没有浏览器也没有<code>Postman</code>, 那么<code>curl</code>这个工具就能派上大用场</p>
<h3 id="网络请求"><a href="#网络请求" class="headerlink" title="网络请求"></a>网络请求</h3><ol>
<li><p><strong>GET请求</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl -X GET http://baidu.com</span><br></pre></td></tr></table></figure>

<p><code>curl</code>默认是<code>GET</code>请求, 所以可以简写成:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl  http://baidu.com</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>POST请求</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl -X POST http://baidu.com</span><br></pre></td></tr></table></figure>

<p>同理, 如果是<code>PUT, DELETE</code>请求, 只需修改<code>-X</code>后面的参数即可</p>
</li>
<li><p><strong>指定请求头</strong></p>
<p>使用<code>-H</code>指令, 注意大小写:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl -X POST -H  "Accept:*/*"  http://baidu.con</span><br></pre></td></tr></table></figure>

<p>如果需要指定多个请求头, 那么需要填多次<code>-H</code>指令, 如:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl -X POST -H  "Accept:*/*" -H  "Content-Type:multipart/form-data" http://baidu.com</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>请求时携带请求参数</strong></p>
<p>使用<code>-d</code>指令, 注意大小写:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl -X POST -d "password=11111111&amp;username=3333" http://baidu.con</span><br></pre></td></tr></table></figure>

<p>默认是以<code>Content-Type:application/x-www-form-urlencoded</code>的形式对参数进行编码</p>
<p>如果我们需要携带<code>json</code>格式的数据, 那么我们指定相应请求头即可, 如下:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl -X POST  -H  "Content-Type:application/json" -d '&#123;"content":"发送一条消息"&#125;'  http://baidu.con</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>文件上传</strong></p>
<p>修改<code>Content-Type</code>为<code>multipart/form-data</code>, 使用<code>-F</code>指令指定需要上传的文件,注意大小写:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl -X POST  -H  "Content-Type:multipart/form-data" -F  "file=@文件名称.png"  http://baidu.com</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>文件下载</strong></p>
<p>使用<code>-o</code>指令保存请求到的文件, 注意大小写:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl -o "baidu.html" http://www.baidu.com/index.html</span><br></pre></td></tr></table></figure>

<p>如果使用大写的<code>-O</code>, 同样也能下载, 它会将<code>URL</code> 的最后部分当作文件名, 此时URL`必须写具体, 否则报错:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl -O http://www.baidu.com/index.html</span><br></pre></td></tr></table></figure>


</li>
</ol>
<ol start="7">
<li><p><strong>断点续传</strong></p>
<p>使用<code>-C</code>指令, 一般我们会配合文件下载一起使用:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl -C -o "baidu.html" http://www.baidu.com/index.html</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>请求跟随服务器的重定向</strong></p>
<p>使用<code>-L</code>指令, 一般我们会配合文件下载一起使用:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl -L -o "baidu.html" http://www.baidu.com/index.html</span><br></pre></td></tr></table></figure>









</li>
</ol>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://catonmat.net/cookbooks/curl" target="_blank" rel="noopener">Curl Cookbook</a></p>
<p><strong>本文为作者原创转载时请注明出处 谢谢</strong></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em><a href="https://code.newban.cn/">乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</a></em></p>
]]></content>
      <tags>
        <tag>CURL</tag>
      </tags>
  </entry>
  <entry>
    <title>关于POST请求的一些细节</title>
    <url>/413.html</url>
    <content><![CDATA[<h3 id="请求传递参数的方式"><a href="#请求传递参数的方式" class="headerlink" title="请求传递参数的方式"></a>请求传递参数的方式</h3><p><strong><code>POST</code> 请求传递参数有两种方式：</strong> </p>
<ol>
<li><p><strong>将数据放在请求体（body）中</strong></p>
<p>一般用<code>form-urlencoded</code>格式进行编码传递，例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">name=value&amp;age=20&amp;gender=male</span><br></pre></td></tr></table></figure>

<p>这种方式的优点是可以传递大量的数据，安全性较高，传递的数据类型也比较灵活，可以传递文本、文件等。 </p>
</li>
<li><p><strong>将数据放在 URL 查询字符串中</strong></p>
<p>例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https://www.example.com?name=value&amp;age=20&amp;gender=male</span><br></pre></td></tr></table></figure>

<p>这种方式的优点是简单易用，实现比较容易，不需要对数据进行编码，对于一些小规模数据传输比较恰当。</p>
</li>
</ol>
<p>以上两种方式在传递数据时都可能存在数据篡改、伪造等问题。一些安全敏感的数据（如密码等）应该采用更安全的传输方式（如加密传输）。 </p>
<p>使用请求体传输，数据会按照具体的编码方式进行编码，而使用查询字符串进行传输，数据会经过 <code>URL</code>编码处理，因为<code>URL</code>中只能使用一部分 ASCII 字符，其他字符需要进行转义。</p>
<h3 id="编码方式"><a href="#编码方式" class="headerlink" title="编码方式"></a>编码方式</h3><p><strong><code>POST</code>常用的编码方式有三种, 分别为:</strong></p>
<ol>
<li><p><strong>application/x-www-form-urlencoded</strong></p>
<p>这是最常用的编码方式，也是默认的编码方式。它将请求参数编码成 <code>key1=value1&amp;key2=value2</code> 的形式，并将每个键值对用 <code>&amp;</code> 连接起来。参数会被<code>URL</code> 编码，以便在传输时能够正确地处理特殊字符，例如空格会被转换为加号 <code>(+)</code>。</p>
</li>
<li><p><strong>multipart/form-data</strong></p>
<p>这种编码方式适用于上传文件或二进制数据。它将请求参数分割成多个部分，每个部分都有一个<code>Content-Disposition</code> 头部和一个<code>Content-Type 头</code>部来描述它的内容类型。这个 <code>Content-Disposition</code> 通常包含一个表单字段的名称和一些其他的元数据，例如上传文件的名称。 </p>
</li>
<li><p><strong>application/json</strong></p>
<p>这种编码方式适用于传输 <code>JSON</code>格式的数据。<code>JSON</code>格式是一种轻量且易于使用的数据表示格式，广泛用于 <code>Web</code> 应用程序中。请求参数将被作为 <code>JSON</code>对象发送，它们必须以正确的 <code>JSON</code>格式进行编码。 需要根据具体的场景和需求选择合适的编码方式。</p>
</li>
</ol>
<p><strong>注意:</strong> 使用查询字符串进行传输的数据只能使用<code>application/x-www-form-urlencoded</code>的编码格式,而使用请求体传输则可以使用各种编码格式</p>
<h3 id="GET请求和POST请求的区别"><a href="#GET请求和POST请求的区别" class="headerlink" title="GET请求和POST请求的区别"></a>GET请求和POST请求的区别</h3><p><code>POST</code> 请求和 <code>GET</code> 请求是<code>HTTP</code> 协议中常用的两种请求方法，它们之间的区别如下：    </p>
<ol>
<li><p>参数传递方式：<code>GET</code>请求只能通过 <code>URL</code> 中的查询字符串来传递参数，而 <code>POST</code> 请求不仅可以通过<code>URL</code>还可以将参数信息放在请求主体中。</p>
</li>
<li><p>请求参数长度：<code>GET</code> 请求传递参数的长度是有限制的，具体取决于浏览器和 Web 服务器的限制，而 <code>POST</code> 请求则没有这些限制。</p>
</li>
<li><p>对服务器数据的影响：<code>GET</code>请求不会改变服务器上的资源状态，只是请求该资源的数据，而 <code>POST</code> 请求可能会改变服务器上的资源状态，如在服务器上创建新的资源或更新已有资源。</p>
</li>
<li><p>安全性：<code>GET</code>请求会将参数暴露在 <code>URL</code> 中，比较容易被追踪和窃取，而 <code>POST</code> 请求的参数则放在请求主体中，安全性比 <code>GET</code>请求更高。 </p>
</li>
<li><p>使用场景：<code>GET</code> 请求通常用于请求数据，如获取某个页面的内容，而 <code>POST</code>请求用于提交数据，如提交表单信息。 </p>
</li>
</ol>
<p>总的来说，<code>GET</code> 请求适合请求数据，而 <code>POST</code>请求适合提交数据。需要根据具体的业务场景和需求选择合适的请求方法。</p>
<p><strong>本文为作者原创转载时请注明出处 谢谢</strong></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em><a href="https://code.newban.cn/">乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</a></em></p>
]]></content>
      <tags>
        <tag>Web开发</tag>
      </tags>
  </entry>
  <entry>
    <title>Springboot中关于如何设置实体类中的部分属性对用户可见性的方案</title>
    <url>/419.html</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>关于实体类的属性对用户的可见性问题, 我们第一时间可能会想到定义一个性的类, 里面只定义需要给用户看见的属性, 然后进行属性值拷贝</p>
<p>显然 这种做法极其不优雅, 实体类一旦增多, 后期维护会非常的累</p>
<p>那有没有轻松一点的方法呢, 能不能某个表的实体类就只创建一个, 然后复用呢</p>
<p>答案是 有的</p>
<p>我们可以使用注解来实现, 根据不同的需求, 选择不同的注解, 具体如下:</p>
<h3 id="需求一"><a href="#需求一" class="headerlink" title="需求一"></a>需求一</h3><p>用户在请求接口的时候, 实体类中的某些字段不给用户返回(序列化), 同时也不允许用户传值(反序列化), 比如大部分的实体类中我们都会有<code>createTime</code>和<code>updateTime</code>字段, 像这种是不需要给用户返回的, 同时也不允许用户传值</p>
<p>那么此时我们就可以用到<code>jackson</code>包中的<code>@JsonIgnore</code>注解来实现这一功能, 具体示例代码如下:</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Table(name = <span class="meta-string">"deleted_user"</span>)</span></span><br><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">DeleteUser</span></span>(</span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@GeneratedValue(strategy = GenerationType.IDENTITY)</span></span><br><span class="line">    <span class="keyword">val</span> id: <span class="built_in">Long</span>? = <span class="literal">null</span>,</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@JsonFormat(</span></span><br><span class="line"><span class="meta">        pattern = <span class="meta-string">"yyyy-MM-dd HH:mm:ss a"</span>,</span></span><br><span class="line"><span class="meta">        locale = <span class="meta-string">"zh"</span>,</span></span><br><span class="line"><span class="meta">        timezone = <span class="meta-string">"GMT+8"</span></span></span><br><span class="line"><span class="meta">    )</span></span><br><span class="line">    <span class="meta">@JsonIgnore</span></span><br><span class="line">    <span class="keyword">val</span> createTime: LocalDateTime = LocalDateTime.now(ZoneId.of(<span class="string">"GMT+8"</span>)),</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>使用该注解后, 哪怕用户刻意传了也不影响数据, 无论用户传与不传都写入的都是默认值</p>
<p>如果我们需要对多个字段进行可见性隐藏, 除了挨个属性添加<code>@JsonIgnore</code>, 我们还可以在类中使用<code>@JsonIgnoreProperties</code>注解来忽略某个属性, 其效果和<code>@JsonIgnore</code>一样, 具体示例代码如下:</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Table(name = <span class="meta-string">"deleted_user"</span>)</span></span><br><span class="line"><span class="meta">@JsonIgnoreProperties(value = [<span class="meta-string">"createTime"</span>])</span></span><br><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">DeleteUser</span></span>(</span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@GeneratedValue(strategy = GenerationType.IDENTITY)</span></span><br><span class="line">    <span class="keyword">val</span> id: <span class="built_in">Long</span>? = <span class="literal">null</span>,</span><br><span class="line"></span><br><span class="line">    <span class="meta">@JsonFormat(</span></span><br><span class="line"><span class="meta">        pattern = <span class="meta-string">"yyyy-MM-dd HH:mm:ss a"</span>,</span></span><br><span class="line"><span class="meta">        locale = <span class="meta-string">"zh"</span>,</span></span><br><span class="line"><span class="meta">        timezone = <span class="meta-string">"GMT+8"</span></span></span><br><span class="line"><span class="meta">    )</span></span><br><span class="line">    <span class="keyword">val</span> createTime: LocalDateTime = LocalDateTime.now(ZoneId.of(<span class="string">"GMT+8"</span>)),</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h3 id="需求二"><a href="#需求二" class="headerlink" title="需求二"></a>需求二</h3><p>用户在请求接口的时候, 实体类中的某些字段需要给用户返回, 但是不允许用户传值, 比如<code>id</code>字段, 那此时我们可以在类中使用<code>@JsonIgnoreProperties</code>注解, 并设置<code>allowGetters = true</code>即可, 具体代码如下:</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Table(name = <span class="meta-string">"deleted_user"</span>)</span></span><br><span class="line"><span class="meta">@JsonIgnoreProperties(value = [<span class="meta-string">"id"</span>],allowGetters = true)</span></span><br><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">DeleteUser</span></span>(</span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@GeneratedValue(strategy = GenerationType.IDENTITY)</span></span><br><span class="line">    <span class="keyword">val</span> id: <span class="built_in">Long</span>? = <span class="literal">null</span>,</span><br><span class="line"></span><br><span class="line">    <span class="meta">@JsonFormat(</span></span><br><span class="line"><span class="meta">        pattern = <span class="meta-string">"yyyy-MM-dd HH:mm:ss a"</span>,</span></span><br><span class="line"><span class="meta">        locale = <span class="meta-string">"zh"</span>,</span></span><br><span class="line"><span class="meta">        timezone = <span class="meta-string">"GMT+8"</span></span></span><br><span class="line"><span class="meta">    )</span></span><br><span class="line">    <span class="keyword">val</span> createTime: LocalDateTime = LocalDateTime.now(ZoneId.of(<span class="string">"GMT+8"</span>)),</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h3 id="需求三"><a href="#需求三" class="headerlink" title="需求三"></a>需求三</h3><p>用户在请求接口的时候, 实体类中的某些字段不给用户返回, 但是允许用户传值, 那此时我们可以在类中使用<code>@JsonIgnoreProperties</code>注解, 并设置<code>allowSetters = true</code>即可, 具体代码如下:</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Table(name = <span class="meta-string">"deleted_user"</span>)</span></span><br><span class="line"><span class="meta">@JsonIgnoreProperties(value = [<span class="meta-string">"content"</span>],allowSetters = true)</span></span><br><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">DeleteUser</span></span>(</span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@GeneratedValue(strategy = GenerationType.IDENTITY)</span></span><br><span class="line">    <span class="keyword">val</span> id: <span class="built_in">Long</span>? = <span class="literal">null</span>,</span><br><span class="line">	  <span class="keyword">val</span> content: String = <span class="string">""</span>,</span><br><span class="line">    <span class="meta">@JsonFormat(</span></span><br><span class="line"><span class="meta">        pattern = <span class="meta-string">"yyyy-MM-dd HH:mm:ss a"</span>,</span></span><br><span class="line"><span class="meta">        locale = <span class="meta-string">"zh"</span>,</span></span><br><span class="line"><span class="meta">        timezone = <span class="meta-string">"GMT+8"</span></span></span><br><span class="line"><span class="meta">    )</span></span><br><span class="line">    <span class="keyword">val</span> createTime: LocalDateTime = LocalDateTime.now(ZoneId.of(<span class="string">"GMT+8"</span>)),</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h3 id="需求四"><a href="#需求四" class="headerlink" title="需求四"></a>需求四</h3><p>用户在请求接口的时候, 实体类中的某些字段不给用户返回, 但是允许用户传值, 同时另外某些字段需要给用户返回, 但是不允许用户传值, 这种又该怎么办呢, 此时我们需要用到另外一个注解<code>@JsonProperty</code>, 在这个注解中配置<code>access</code>值, 具体代码如下:</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Table(name = <span class="meta-string">"deleted_user"</span>)</span></span><br><span class="line"><span class="meta">@JsonIgnoreProperties(value = [<span class="meta-string">"id"</span>],allowGetters = true)</span></span><br><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">DeleteUser</span></span>(</span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@GeneratedValue(strategy = GenerationType.IDENTITY)</span></span><br><span class="line">    <span class="keyword">val</span> id: <span class="built_in">Long</span>? = <span class="literal">null</span>,</span><br><span class="line">  	<span class="meta">@JsonProperty(access = JsonProperty.Access.WRITE_ONLY)</span></span><br><span class="line">	  <span class="keyword">val</span> content: String = <span class="string">""</span>,</span><br><span class="line">    <span class="meta">@JsonFormat(</span></span><br><span class="line"><span class="meta">        pattern = <span class="meta-string">"yyyy-MM-dd HH:mm:ss a"</span>,</span></span><br><span class="line"><span class="meta">        locale = <span class="meta-string">"zh"</span>,</span></span><br><span class="line"><span class="meta">        timezone = <span class="meta-string">"GMT+8"</span></span></span><br><span class="line"><span class="meta">    )</span></span><br><span class="line">    <span class="keyword">val</span> createTime: LocalDateTime = LocalDateTime.now(ZoneId.of(<span class="string">"GMT+8"</span>)),</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>这样一来, 我们在实现<code>id</code>字段只读的同时, 又实现了<code>content</code>字段的可写入但不可见</p>
<p><code>access</code>属性常用选项:</p>
<ul>
<li><p><code>JsonProperty.Access.WRITE_ONLY</code>: 只允许用户传值, 但不给用户返回</p>
</li>
<li><p><code>JsonProperty.Access.READ_ONLY</code>: 只给用户返回该字段, 但不允许用户传值</p>
</li>
</ul>
<p><strong>需要注意的是</strong>: <code>@JsonProperty(access = JsonProperty.Access.READ_ONLY</code>注解放置在父类的属性中无效. 具体原因我也不是太清楚</p>
<h3 id="需求五"><a href="#需求五" class="headerlink" title="需求五"></a>需求五</h3><p>假如需要给客户端出两个用户接口, 一个只返回用户名, 另一个返回用户名和用户<code>id</code>, 那这种情况下上面的方案就不适用了, 此时我们需要用到注解<code>@JsonView</code>, 分别作用在属性和<code>Controller</code>中的具体接口方法上, 代码如下:</p>
<p><strong>实体类:</strong></p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Table(name = <span class="meta-string">"user"</span>)</span></span><br><span class="line"><span class="meta">@JsonView(Views::class)</span> <span class="comment">//这个地方很关键 首先给所有属性一个默认视图 </span></span><br><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span></span>(</span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@GeneratedValue(strategy = GenerationType.IDENTITY)</span></span><br><span class="line">  	<span class="meta">@JsonView(Views.Detail::class)</span><span class="comment">//表示id归属于Detail视图</span></span><br><span class="line">	  <span class="keyword">var</span> id: <span class="built_in">Long</span>? = <span class="literal">null</span>,</span><br><span class="line">  </span><br><span class="line">  	<span class="meta">@JsonView(Views.Basic::class)</span><span class="comment">//表示username归属于Basic视图</span></span><br><span class="line">    <span class="keyword">val</span> userName: String = <span class="string">""</span>,</span><br><span class="line">)</span><br><span class="line"><span class="comment">//用接口来进行视图分类</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Views</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">interface</span> <span class="title">Basic</span></span></span><br><span class="line">    <span class="class"><span class="keyword">interface</span> <span class="title">Detail</span> : <span class="type">Basic</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Controller类:</strong></p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@CrossOrigin</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(<span class="meta-string">"/user"</span>)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">     </span><br><span class="line">    <span class="meta">@GetMapping(value = [<span class="meta-string">"/userInfoWithId"</span>])</span></span><br><span class="line">    <span class="meta">@JsonView(Views.Detail::class)</span><span class="comment">//返回归属于Detail视图的字段</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">getUserInfoWithId</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        request: <span class="type">HttpServletRequest</span></span></span></span><br><span class="line"><span class="function"><span class="params">    )</span></span>: BaseEntity&lt;EmptyModel&gt; &#123;</span><br><span class="line">            <span class="keyword">val</span> info = tokenUtil.parseToken(request)</span><br><span class="line">            <span class="keyword">val</span> user = service.getUserInfo(info.id, info.userAccount)</span><br><span class="line">            <span class="keyword">return</span> BaseEntity(<span class="keyword">data</span> = user)</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">   <span class="meta">@GetMapping(value = [<span class="meta-string">"/userInfo"</span>])</span></span><br><span class="line">    <span class="meta">@JsonView(Views.Basic::class)</span><span class="comment">//返回归属于Basic视图的字段</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">getUserInfo</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        request: <span class="type">HttpServletRequest</span></span></span></span><br><span class="line"><span class="function"><span class="params">    )</span></span>: BaseEntity&lt;EmptyModel&gt; &#123;</span><br><span class="line">            <span class="keyword">val</span> info = tokenUtil.parseToken(request)</span><br><span class="line">            <span class="keyword">val</span> user = service.getUserInfo(info.id, info.userAccount)</span><br><span class="line">            <span class="keyword">return</span> BaseEntity(<span class="keyword">data</span> = user)</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时如果你运行程序请求接口发现返回一个空对象<code>{}</code>, 这是由于没有配置<code>objectMapper</code>, 我们需要在<code>WebConfig</code>中进行配置, 具体代码如下:</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">WebConfig</span> : <span class="type">WebMvcConfigurer &#123;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> jsonConverter: MappingJackson2HttpMessageConverter? = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">configureMessageConverters</span><span class="params">(converters: <span class="type">MutableList</span>&lt;<span class="type">HttpMessageConverter</span>&lt;*&gt;&gt;)</span></span> &#123;</span><br><span class="line">        converters.removeIf &#123; mc -&gt; mc <span class="keyword">is</span> MappingJackson2HttpMessageConverter &#125;</span><br><span class="line">        converters.add(jsonConverter!!)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">open</span> <span class="function"><span class="keyword">fun</span> <span class="title">objectMapper</span><span class="params">()</span></span> : ObjectMapper = ObjectMapper().apply &#123;</span><br><span class="line">        setSerializationInclusion(JsonInclude.Include.NON_NULL)</span><br><span class="line">        registerModule(KotlinModule())</span><br><span class="line">        configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, <span class="literal">false</span>)</span><br><span class="line">        configure(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS, <span class="literal">false</span>)</span><br><span class="line">        configure(SerializationFeature.WRITE_DATES_WITH_ZONE_ID, <span class="literal">true</span>)</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">open</span> <span class="function"><span class="keyword">fun</span> <span class="title">jsonConverter</span><span class="params">(objectMapper: <span class="type">ObjectMapper</span>)</span></span>: MappingJackson2HttpMessageConverter =</span><br><span class="line">        MappingJackson2HttpMessageConverter(objectMapper)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面<code>WebConfig</code>类是我自己创建的, 你如果没有该类则手动创建一个,继承<code>WebMvcConfigurer</code>, 别忘了添加<code>@Configuration</code>注解</p>
<p><strong>本文为作者原创转载时请注明出处 谢谢</strong></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em><a href="https://code.newban.cn/">乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</a></em></p>
]]></content>
      <tags>
        <tag>Web开发</tag>
      </tags>
  </entry>
  <entry>
    <title>解决iframe标签插入视频无法禁止自动播放的问题</title>
    <url>/418.html</url>
    <content><![CDATA[<h3 id="问题与解决方案"><a href="#问题与解决方案" class="headerlink" title="问题与解决方案"></a>问题与解决方案</h3><p>最近发现有瓣音频博客出现多个视频合奏唱戏的问题, 非常影响阅读体验, 于是准备将视频自动播放给禁止了</p>
<p>尝试了几种方案, 不论是加入<code>&quot;allow=&quot;autoplay=false&quot;&quot;</code>属性还是<code>autoplay=false</code>乃至<code>sandbox</code>都不生效</p>
<p>最后通过在 <code>src</code> 属性的最后面加上<code>&amp;autoplay=no</code>, 问题解决</p>
<p><strong>本文为作者原创转载时请注明出处 谢谢</strong></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em><a href="https://code.newban.cn/">乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</a></em></p>
]]></content>
      <tags>
        <tag>Web开发</tag>
      </tags>
  </entry>
  <entry>
    <title>如何将vscode调教成IntelliJ IDEA风格的编辑器</title>
    <url>/416.html</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>最近项目需要使用到<code>vscode</code>, 对于习惯了<code>Android Studio</code>的我来说, 突然切换开发工具一时间有点难以适应, 主要还是<code>IntelliJIDEA</code>的编辑器太香了</p>
<p>之前本来想将<code>Android Studio</code>武装成兼容各种语言的开发神器, 无奈很多插件不兼容, 只能暂时作罢</p>
<p>所以 只能先凑合着用<code>vscode</code>先, 所谓工欲善其事必先利其器, 为了快速进入开发状态, 首先需要将<code>vscode</code>编辑器的风格设置成尽量接近<code>Android Studio</code></p>
<h3 id="vscode配置剖析"><a href="#vscode配置剖析" class="headerlink" title="vscode配置剖析"></a>vscode配置剖析</h3><p><code>vscode</code>配置主要分为四大块, 每一块的配置都对应一个<code>json</code>文件:</p>
<ul>
<li>基础设置: 使用<code>setting.json</code>, 主要包含一些编辑器的偏好设置</li>
<li>键盘快捷键设置: 使用<code>keybindings.json</code></li>
<li>扩展设置: 使用<code>extension.json</code></li>
<li>UI状态设置: 使用<code>globalState.json</code>, 主要包含一些全局UI状态的设置</li>
</ul>
<h3 id="对vscode进行改造"><a href="#对vscode进行改造" class="headerlink" title="对vscode进行改造"></a>对vscode进行改造</h3><h5 id="第一步-对快捷键进行改造"><a href="#第一步-对快捷键进行改造" class="headerlink" title="第一步 对快捷键进行改造"></a>第一步 对快捷键进行改造</h5><ol>
<li><p><strong>安装插件<code>IntelliJ IDEA Keybindings</code></strong></p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20230421141517074.png" alt="image-20230421141517074"></p>
<p>我们会发现 这个插件附带了一个通过<code>xml</code>文件快速导入的功能, 接下来我们需要用它</p>
</li>
<li><p><strong>将<code>Android Studio</code>的配置进行导出</strong></p>
<p>熟悉<code>IDEA</code>系编辑器的小伙伴应该都知道如何导出配置文件, 这里不过多解释, 直接上图:</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20230421141800980.png" alt="image-20230421141800980"></p>
<p>导出的配置文件是一个<code>zip</code>压缩包, 我们将其解压, 下一步我们会用到里面<code>keymap</code>目录下的<code>xml</code>文件</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20230421142945748.png" alt="image-20230421142945748"></p>
</li>
<li><p><strong>将<code>Android Studio</code>导出的快键键配置文件进行格式转换</strong></p>
<p>我们按住<code>ctrl+shift+p</code>打开动作指令面板, 然后输入<code>Import IntelliJ Keybindings</code>执行该动作:</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20230421142142565.png" alt="image-20230421142142565"></p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20230421142310878.png" alt="image-20230421142310878"></p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20230421142347063.png" alt="image-20230421142347063"></p>
<p>这里可以选择对导入的<code>xml</code>文件中的快捷键进行平台转换,</p>
<p>由于我的<code>AndroidStudio</code>的配置文件是<code>windows</code>平台导出的, 而我目前使用的是<code>Mac</code>平台,我想继续保持<code>windows</code>的快捷键习惯, 也就是依然使用<code>ctrl</code>而不是<code>cmd</code></p>
<p>所以这里我选择了<code>Windows to Windows</code></p>
<p>导入<code>xml</code>文件后, 会自动生成已经转换成<code>json</code>格式的快捷键配置:</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20230421143240522.png" alt="image-20230421143240522"></p>
</li>
<li><p><strong>将转换好的配置导入到<code>vscode</code>中</strong></p>
<p>我们只需要将里面的内容拷贝至<code>vscode</code>的<code>keybindings.json</code>文件中然后保存即可:</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20230421143526782.png" alt="image-20230421143526782"></p>
</li>
</ol>
<p>此时, 我们的快捷键就基本改造完毕了, 现在只需双击<code>shift</code>就能打开动作指令面板, 和<code>Android Studio</code>一致, 满意😊</p>
<h5 id="第二步-对vscode外观进行改造"><a href="#第二步-对vscode外观进行改造" class="headerlink" title="第二步 对vscode外观进行改造"></a>第二步 对vscode外观进行改造</h5><p>这一步, 具体改造因人而异, 毕竟每个人的需求和审美不同, 大家只需要了解如何修改即可</p>
<p>这里主要是对<code>setting.json</code>文件进行修改,简单说一下我的配置:</p>
<ol>
<li><p><strong>编辑器字体大小调整</strong></p>
<p>首先<code>vscode</code>默认的外观给我的第一印象就是字太小了, 看着特别费眼</p>
<p>那么我们进入设置面板, 输入字体, 然后找到<code>setting中编辑</code>字样点击它可以打开<code>setting.json</code>文件:</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20230421145930537.png" alt="image-20230421145930537"></p>
<p>在里面我输入<code>editor.fontSize&quot;: 14.5</code>, 将代码字体大小调整成<code>14.5</code>:</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20230421150213399.png" alt="image-20230421150213399"></p>
<p>同理, 如果需要修改字体风格则输入<code>editor.fontFamily</code></p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20230421150846461.png" alt="image-20230421150846461"></p>
<p>以此类推, 所有配置属性都有代码提示, 操作起来也很方便</p>
</li>
<li><p><strong>工作台字体大小调整</strong></p>
<p>我们会发现, 通过<code>setting.json</code>我们可以调整编辑器的字体大小, 但是工作台的字体没有提供相关属性配置, 只能通过快捷键<code>cmd+=</code>来进行缩放调整, 如果快捷键无法使用那就使用动作指令面板通过关键字 <code>放大</code> 或者<code>Zoom</code>进行搜索调用</p>
<p>记住一点 有问题先尝试在动作指令面板中搜一下</p>
</li>
<li><p><strong>工作目录图标修改</strong></p>
<p>接下来我们需要调整一下工作目录的图标, 先来看一下<code>vscode</code>默认的目录树长啥样:</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20230425101510482.png" alt="image-20230425101510482"></p>
<p>是不是立马让人感到崩溃, 哪个文件在哪个包下面, 估计得费劲辨别半天</p>
<p>这个要改的话, 需要在安装图标插件, 我们直接在插件市场搜索关键字<code>icon</code>就行, 可以找到很多:</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20230425102237084.png" alt="image-20230425102237084"></p>
<p>每个都尝试一下, 选一种自己喜欢的就行</p>
</li>
<li><p><strong>颜色主题选择</strong></p>
<p>最后我们对编辑器整体的配色进行调整, 可以直接选择现成的主题, 直接在插件市场搜索即可:</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20230425100404555.png" alt="image-20230425100404555"></p>
</li>
</ol>
<p>由于个人习惯, 最后我直接选择了<code>JetBrains</code>风格的主题和图标样式:</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20230425105302696.png" alt="image-20230425105302696"></p>
<p>调整后我的编辑器样子如下:</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20230425105836206.png" alt="image-20230425105836206"></p>
<h3 id="配置的同步功能"><a href="#配置的同步功能" class="headerlink" title="配置的同步功能"></a>配置的同步功能</h3><h5 id="官方自带云端同步"><a href="#官方自带云端同步" class="headerlink" title="官方自带云端同步"></a>官方自带云端同步</h5><p>目前<code>vscode</code>编辑器自带了配置同步功能, 实现多端配置同步, 非常方便, 只需要在编辑器左下角进行登录, 然后打开同步功能即可:</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20230421151643311.png" alt="image-20230421151643311"></p>
<p>这里支持<code>Github</code>或者微软账号登录</p>
<h5 id="云端同步历史恢复"><a href="#云端同步历史恢复" class="headerlink" title="云端同步历史恢复"></a>云端同步历史恢复</h5><p>当我们不小心将编辑器还原出厂设置了, 由于我们开启了自动同步功能, 此时所有配置已经同步到了云端, 旧的配置直接被覆盖了, 那么我们想恢复之前的配置该怎么办呢?</p>
<p>不用担心</p>
<p>首先我们打开命令窗口显示已同步的数据记录:</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20230421154920449.png" alt="image-20230421154920449"></p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20230421155009736.png" alt="image-20230421155009736"></p>
<p>然后选择对应时间下的历史配置文件, 将里面的内容拷贝至我们的当下的配置文件中即可: </p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20230421155426436.png" alt="image-20230421155426436"></p>
<p>手动拷贝有些繁琐, 不过我相信未来官方能实现一键恢复功能</p>
<p>除此之外 我们还可以通过资源管理器的时间线进行文件内容的快速恢复, 不过这种方案仅支持短期时间的恢复, 如果要恢复几个月甚至一年前的配置, 那么只能使用云端同步方案了:</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20230421171831669.png" alt="image-20230421171831669"></p>
<h5 id="配置文件导出本地"><a href="#配置文件导出本地" class="headerlink" title="配置文件导出本地"></a>配置文件导出本地</h5><p>如果你对于这种云端配置同步不是太放心, 还可以将配置文件导出到本地进行存储:</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20230421152109250.png" alt="image-20230421152109250"></p>
<p>官方默认支持导出到<code>Git</code>和本地</p>
<h3 id="配置文件同步到自己的云端"><a href="#配置文件同步到自己的云端" class="headerlink" title="配置文件同步到自己的云端"></a>配置文件同步到自己的云端</h3><p>如果你有更多的同步需求, 比如同步到云盘, 那么我推荐你安装<code>Sync Settings</code>这个插件, 它支持本地、本地<code>Git</code>仓库、远程<code>Git</code>仓库、服务器<code>rsync</code>甚至<code>Webdav</code>:</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20230421152755860.png" alt="image-20230421152755860">    </p>
<p><strong>具体使用方法:</strong></p>
<ol>
<li><p>对仓库进行配置</p>
<p>动作面板输入:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Sync Settings: Open the repository settings</span><br></pre></td></tr></table></figure>
</li>
<li><p>将配置文件上传同步至仓库:</p>
<p>动作面板输入:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Sync Settings: Download (repository -&gt; user)</span><br></pre></td></tr></table></figure>
</li>
<li><p>从仓库中同步配置文件到<code>vscode</code>:</p>
<p>动作面板输入:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Sync Settings: Download (repository -&gt; user)</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>如果你觉得手动同步太累人, 还可以配合<code>cron-tasks</code>插件开启定时任务, 实现配置文件的自动同步功能</p>
<h3 id="问题汇总"><a href="#问题汇总" class="headerlink" title="问题汇总"></a>问题汇总</h3><h5 id="关于回车快捷键无法设置的问题"><a href="#关于回车快捷键无法设置的问题" class="headerlink" title="关于回车快捷键无法设置的问题"></a>关于回车快捷键无法设置的问题</h5><p>由于两个编辑器的差异性存在, 导致部分快捷键和预想中的不太一致, 此时我们需要手动修改, 这里我需要将<code>acceptAlternativeSelectedSuggestion</code>的快捷键设置为回车, 另外将<code>acceptSelectedSuggestion</code>的快捷键改为<code>tab</code>, 在设置的过程中, 我发现回车无法设置, 这应该是个编辑器<code>bug</code>, 好在可以直接修改<code>json</code>文件:</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20230421170505429.png" alt="image-20230421170505429"></p>
<p><strong>本文为作者原创转载时请注明出处 谢谢</strong></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em><a href="https://code.newban.cn/">乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</a></em></p>
]]></content>
      <tags>
        <tag>实用技巧</tag>
      </tags>
  </entry>
  <entry>
    <title>解决国内访问github过慢的问题</title>
    <url>/42.html</url>
    <content><![CDATA[<p>通过查看下载链接，能够发现最终被指向到Amazon的服务器（<a href="http://github-cloud.s3.amazonaws.com）了。由于国内访问亚马逊网站非常慢，我们需要修改Hosts文件来实现流畅访问。" target="_blank" rel="noopener">http://github-cloud.s3.amazonaws.com）了。由于国内访问亚马逊网站非常慢，我们需要修改Hosts文件来实现流畅访问。</a></p>
<h3 id="第一步，打开本机上的Hosts文件"><a href="#第一步，打开本机上的Hosts文件" class="headerlink" title="第一步，打开本机上的Hosts文件"></a>第一步，打开本机上的Hosts文件</h3><p>首先，什么是Hosts文件？</p>
<blockquote>
<p>在互联网协议中，host表示能够同其他机器互相访问的本地计算机。一台本地机有唯一标志代码，同网络掩码一起组成IP地址，如果通过点到点协议通过ISP访问互联网，那么在连接期间将会拥有唯一的IP地址，这段时间内，你的主机就是一个host。</p>
<p>在这种情况下，host表示一个网络节点。host是根据TCP/IP for Windows 的标准来工作的，它的作用是包含IP地址和Host name(主机名)的映射关系，是一个映射IP地址和Host name(主机名)的规定，规定要求每段只能包括一个映射关系，IP地址要放在每段的最前面，空格后再写上映射的Host name主机名　。对于这段的映射说明用“#”分割后用文字说明。</p>
</blockquote>
<h4 id="Windows"><a href="#Windows" class="headerlink" title="~Windows"></a>~Windows</h4><p>Hosts文件的路径是：</p>
<blockquote>
<p><em>C:\Windows\System32\drivers\etc</em></p>
</blockquote>
<p>由于文件没有后缀名，可以利用鼠标右键点击，选择用记事本打开</p>
<h4 id="Mac"><a href="#Mac" class="headerlink" title="~Mac"></a>~Mac</h4><p>终端内输入：</p>
<blockquote>
<p>sudo vim /etc/hosts</p>
</blockquote>
<p>打开之后，我们就要向里面追加信息了。</p>
<h3 id="第二步，追加域名的IP地址"><a href="#第二步，追加域名的IP地址" class="headerlink" title="第二步，追加域名的IP地址"></a>第二步，追加域名的IP地址</h3><p>我们可以利用<a href="https://www.ipaddress.com/" target="_blank" rel="noopener">https://www.ipaddress.com/</a> 来获得以下两个GitHub域名的IP地址：</p>
<p>(1) github.com</p>
<p>(2) github.global.ssl.fastly.net</p>
<p>打开网页后，利用输入框内分别查询两个域名：<a href="http://github.global.ssl.fastly.net.ipaddress.com/#ipinfo" target="_blank" rel="noopener">
</a></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20200619140841.png" alt></p>
<p>先试一下github.com（也可直接访问）：<a href="http://github.com.ipaddress.com/#ipinfo" target="_blank" rel="noopener">http://github.com.ipaddress.com/#ipinfo</a> </p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20200619140934.png" alt></p>
<p> 在标注的IP地址中，任选一个记录下来。</p>
<p>再来是github.global.ssl.fastly.net（也可直接访问）：<a href="http://github.global.ssl.fastly.net.ipaddress.com/#ipinfo" target="_blank" rel="noopener">http://github.global.ssl.fastly.net.ipaddress.com/#ipinfo</a> </p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20200619140954.png" alt></p>
<p>将以上两段IP写入Hosts文件中：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">151.101.185.194 github.global.ssl.fastly.net</span><br><span class="line">192.30.253.112 github.com</span><br></pre></td></tr></table></figure>

<p> 保存。</p>
<h3 id="第三步，刷新-DNS-缓存"><a href="#第三步，刷新-DNS-缓存" class="headerlink" title="第三步，刷新 DNS 缓存"></a>第三步，刷新 DNS 缓存</h3><p>在终端或CMD中，执行以下命令：</p>
<blockquote>
<p>ipconfig /flushdns</p>
</blockquote>
<p>收工。</p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em>乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</em></p>
]]></content>
      <tags>
        <tag>实用技巧</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS的详细介绍和使用</title>
    <url>/422.html</url>
    <content><![CDATA[<h3 id="css样式常用属性都有哪些"><a href="#css样式常用属性都有哪些" class="headerlink" title="css样式常用属性都有哪些"></a>css样式常用属性都有哪些</h3><p><code>CSS</code> 样式属性有很多，以下列出其中一些常用的：</p>
<ol>
<li><code>color</code>：设置文本颜色；</li>
<li><code>font-size</code>：设置字体大小；</li>
<li><code>font-family</code>：设置字体类型；</li>
<li><code>background-color</code>：设置背景颜色；</li>
<li><code>margin</code>：设置元素外边距；</li>
<li><code>padding</code>：设置元素内边距；</li>
<li><code>width</code>：设置元素宽度；</li>
<li><code>height</code>：设置元素高度；</li>
<li><code>border</code>：设置元素边框；</li>
<li><code>text-align</code>：设置文本对齐方式；</li>
<li><code>display</code>：设置元素的显示方式；</li>
<li><code>position</code>：设置元素的定位方式。</li>
</ol>
<h3 id="CSS中文本对齐方式都有哪些"><a href="#CSS中文本对齐方式都有哪些" class="headerlink" title="CSS中文本对齐方式都有哪些"></a>CSS中文本对齐方式都有哪些</h3><p>在 <code>CSS</code>中，文本对齐方式包括左对齐（text-align: left）、右对齐（text-align: right）、居中对齐（text-align: center）和两端对齐（text-align: justify）。</p>
<p>具体应用场景如下：</p>
<ol>
<li><p>左对齐：适合于大部分的文字排版布局，特别是英文和数字等从左到右阅读的语言。</p>
</li>
<li><p>右对齐：一般用于某些需要强调文本末尾的情况，例如网页上的价格、日期、作者署名等信息。</p>
</li>
<li><p>居中对齐：适用于需要将文本内容水平居中显示的场景，如标题、图片描述等。</p>
</li>
<li><p>两端对齐：适用于长篇文章或段落，可以更好地利用页面空间并使每行长度相同，但需要注意单词间距可能不均匀。</p>
</li>
</ol>
<p>总之，选择何种文本对齐方式需根据实际的设计需求和内容特点来综合考虑。</p>
<h3 id="CSS中元素的显示方式都有哪些"><a href="#CSS中元素的显示方式都有哪些" class="headerlink" title="CSS中元素的显示方式都有哪些"></a>CSS中元素的显示方式都有哪些</h3><p>CSS中元素的显示方式（<code>display</code>）有以下常见值及其应用场景：</p>
<ol>
<li><code>block</code></li>
</ol>
<ul>
<li>特点：元素会被渲染为块级元素，即会占据一行并且默认宽度为父元素的<code>100%</code></li>
<li>应用场景：适用于需要在垂直方向上排列的元素，如段落、标题等</li>
</ul>
<ol start="2">
<li><code>inline</code></li>
</ol>
<ul>
<li>特点：元素会被渲染为内联元素，即不会独占一行，仅占据所需的宽度</li>
<li>应用场景：适用于需要水平排列的元素，如文本、超链接等</li>
</ul>
<ol start="3">
<li><code>inline-block</code></li>
</ol>
<ul>
<li>特点：元素会被渲染为内联块级元素，既可以设置宽高属性，又可以同时水平和垂直排列</li>
<li>应用场景：适用于需要水平和垂直排列并具有固定大小的元素，如图像、按钮等</li>
</ul>
<ol start="4">
<li><code>none</code></li>
</ol>
<ul>
<li>特点：元素不会被渲染，即元素被隐藏</li>
<li>应用场景：适用于需要在某些情况下隐藏指定元素，如响应式设计中的菜单栏</li>
</ul>
<ol start="5">
<li><code>flex</code></li>
</ol>
<ul>
<li>特点：元素会被渲染为弹性盒模型，子元素可以通过 flex 属性来调整自身的宽度和高度</li>
<li>应用场景：适用于需要灵活布局的元素，如导航菜单、栅格系统等</li>
</ul>
<ol start="6">
<li><code>grid</code></li>
</ol>
<ul>
<li>特点：元素会被渲染为网格盒模型，可将布局划分为行和列，并通过<code>grid-template-columns</code> 和 <code>grid-template-rows</code>属性来定义网格的大小和数量</li>
<li>应用场景：适用于复杂的布局，如表格、画廊等</li>
</ul>
<ol start="7">
<li><code>table</code></li>
</ol>
<ul>
<li>特点：元素会被渲染为表格</li>
<li>应用场景：适用于呈现类似于表格的数据结构</li>
</ul>
<p>除此之外，还有一些不常用的值，如<code>list-item</code>（将元素渲染为列表项）、<code>table-cell</code>（将元素渲染为表格单元格）等，具体应用场景可以根据实际需求灵活选择。</p>
<h3 id="关于flex显示方式的详细使用"><a href="#关于flex显示方式的详细使用" class="headerlink" title="关于flex显示方式的详细使用"></a>关于flex显示方式的详细使用</h3><p>Flexbox是一种用于布局的CSS模块，它可以让用户更轻松地创建响应式布局并自动调整元素的大小和位置。使用Flexbox，您可以通过指定容器的属性来控制其子元素的布局，而不是像传统布局方法那样直接操作子元素本身。</p>
<p>以下是使用Flexbox实现常见布局的示例：</p>
<ol>
<li>垂直居中</li>
</ol>
<p><code>HTML</code>代码：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"container"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"item"</span>&gt;</span>Item 1<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"item"</span>&gt;</span>Item 2<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"item"</span>&gt;</span>Item 3<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><code>CSS</code>代码：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">align-items</span>: center;</span><br><span class="line">  <span class="attribute">justify-content</span>: center;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">300px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#dcdcdc</span>;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">20px</span>;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">10px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解释：在这个示例中，我们将容器的<code>display</code>属性设置为<code>flex</code>，这意味着子元素将使用<code>Flexbox</code>进行布局。我们还使用<code>align-items</code>和<code>justify-content</code>属性将子元素垂直和水平居中。</p>
<ol start="2">
<li>左右布局</li>
</ol>
<p><code>HTML</code>代码：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"container"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"sidebar"</span>&gt;</span>Sidebar<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"main"</span>&gt;</span>Main Content<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><code>CSS</code>代码：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.sidebar</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#f1f1f1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.main</span> &#123;</span><br><span class="line">  <span class="attribute">flex</span>: <span class="number">1</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#dcdcdc</span>;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">20px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解释：在这个示例中，我们将容器的<code>display</code>属性设置为flex，并使用它来实现左右布局。我们将侧边栏的宽度设置为200像素并给它一个背景颜色，然后将主要内容的<code>flex</code>属性设置为1，这意味着它将占据剩余的空间。</p>
<ol start="3">
<li>等分布局</li>
</ol>
<p><code>HTML</code>代码：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"container"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"item"</span>&gt;</span>Item 1<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"item"</span>&gt;</span>Item 2<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"item"</span>&gt;</span>Item 3<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><code>CSS</code>代码：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">  <span class="attribute">flex</span>: <span class="number">1</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#dcdcdc</span>;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">20px</span>;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">10px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解释：在这个示例中，我们同样将容器的<code>display</code>属性设置为<code>flex</code>，并使用它来实现等分布局。我们将子元素的<code>flex</code>属性设置为1，这意味着它们将均匀地占据父容器的可用空间。</p>
<p>以上是<code>Flexbox</code>的一些基本示例。要深入学习<code>Flexbox</code>，请参考相关文档和教程。</p>
<h3 id="align-items和justify-content-的详细介绍"><a href="#align-items和justify-content-的详细介绍" class="headerlink" title="align-items和justify-content 的详细介绍"></a>align-items和justify-content 的详细介绍</h3><p><code>align-items</code> 和 <code>justify-content</code> 都是用于布局的 CSS 属性，它们可以控制容器中子元素在交叉轴和主轴上的对齐方式。</p>
<p><code>align-items</code> 控制子元素在交叉轴上的对齐方式。它可以取以下值：</p>
<ul>
<li><code>stretch</code>（默认值）：子元素将被拉伸以填充整个交叉轴。</li>
<li><code>center</code>：子元素在交叉轴上居中对齐。</li>
<li><code>flex-start</code>：子元素在交叉轴起点对齐。</li>
<li><code>flex-end</code>：子元素在交叉轴终点对齐。</li>
<li><code>baseline</code>：子元素在基线上对齐。</li>
</ul>
<p>例如，如果希望一个容器中的子元素在垂直方向上居中对齐，则可以使用以下 CSS 代码：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">align-items</span>: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>justify-content</code> 控制子元素在主轴上的对齐方式。它可以取以下值：</p>
<ul>
<li><code>flex-start</code>：子元素在主轴起点对齐。</li>
<li><code>flex-end</code>：子元素在主轴终点对齐。</li>
<li><code>center</code>：子元素在主轴上居中对齐。</li>
<li><code>space-between</code>：子元素平均分布在主轴上，首尾不留空隙。</li>
<li><code>space-around</code>：子元素平均分布在主轴上，每个子元素两侧留有相等的空隙。</li>
<li><code>space-evenly</code>：子元素平均分布在主轴上，每个子元素之间的空隙相等。</li>
</ul>
<p>例如，如果希望一个容器中的子元素在水平方向上平均分布，并且首尾不留空隙，则可以使用以下 CSS 代码：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">justify-content</span>: space-between;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这些属性通常用于响应式设计或者需要灵活对齐方式的 UI 布局中。</p>
<h3 id="主轴和交叉轴分别又是什么意思"><a href="#主轴和交叉轴分别又是什么意思" class="headerlink" title="主轴和交叉轴分别又是什么意思"></a>主轴和交叉轴分别又是什么意思</h3><p>在 <code>HTML</code> 中，交叉轴和主轴是用于布局的概念，在 <code>CSS</code> 式样中会频繁使用。</p>
<p>主轴指的是<code>flex</code> 容器的主要方向，即 <code>flex-direction</code> 属性所定义的方向。例如，如果<code>flex-direction: row</code>，则主轴是水平方向，如果<code>flex-direction: column</code>，则主轴是垂直方向。</p>
<p>交叉轴则相对于主轴垂直方向的轴线，与主轴方向垂直，宽度或高度由容器尺寸和其他属性决定。在 <code>flex</code>布局中，默认情况下，交叉轴始终垂直于主轴。</p>
<p>以下是一个示例：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"container"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"item item-1"</span>&gt;</span>Item 1<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"item item-2"</span>&gt;</span>Item 2<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"item item-3"</span>&gt;</span>Item 3<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"item item-4"</span>&gt;</span>Item 4<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css"><span class="selector-class">.container</span> &#123;</span></span><br><span class="line">  display: flex;</span><br><span class="line">  flex-direction: row;</span><br><span class="line"><span class="css">  <span class="selector-tag">align-items</span>: <span class="selector-tag">center</span>; <span class="comment">/* 将所有子项沿着交叉轴居中 */</span></span></span><br><span class="line"><span class="css">  <span class="selector-tag">justify-content</span>: <span class="selector-tag">space-between</span>; <span class="comment">/* 在主轴上将所有子项平均分布 */</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="css"><span class="selector-class">.item</span> &#123;</span></span><br><span class="line">  height: 100px;</span><br><span class="line">  width: 100px;</span><br><span class="line">&#125;</span><br><span class="line"><span class="css"><span class="selector-class">.item-1</span> &#123;</span></span><br><span class="line">  background-color: red;</span><br><span class="line">&#125;</span><br><span class="line"><span class="css"><span class="selector-class">.item-2</span> &#123;</span></span><br><span class="line">  background-color: blue;</span><br><span class="line">&#125;</span><br><span class="line"><span class="css"><span class="selector-class">.item-3</span> &#123;</span></span><br><span class="line">  background-color: green;</span><br><span class="line">&#125;</span><br><span class="line"><span class="css"><span class="selector-class">.item-4</span> &#123;</span></span><br><span class="line">  background-color: yellow;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在上面的示例中，我们创建了一个包含四个子项的 <code>flex</code>容器。由于设置了<code>flex-direction: row</code>，因此主轴是水平方向。同时，我们将 <code>align-items</code> 设置为 <code>center</code>，这使得所有子项都垂直居中对齐。而 <code>justify-content</code> 设置为<code>space-between</code>，则将所有子项在主轴上平均分布，呈现出类似于按钮组的效果。</p>
<h3 id="CSS中元素的定位方式都有哪些"><a href="#CSS中元素的定位方式都有哪些" class="headerlink" title="CSS中元素的定位方式都有哪些"></a>CSS中元素的定位方式都有哪些</h3><p>CSS中元素的定位方式主要包括以下几种：</p>
<ol>
<li><p>相对定位：使用 <code>position: relative</code> 属性来相对于其原本所在位置进行微调，可以通过 <code>top</code>、<code>bottom</code>、<code>left</code>、<code>right</code> 属性进行定位。主要应用场景是在元素原本的位置上做一些微小的调整，如添加一个图标或者文本。</p>
</li>
<li><p>绝对定位：使用 <code>position: absolute</code> 属性来相对于最近的带有 <code>position: relative</code> 或者 <code>position: absolute</code> 属性的祖先元素进行定位，也可以通过 <code>top</code>、<code>bottom</code>、<code>left</code>、<code>right</code> 属性精确定位。主要应用场景是需要脱离文档流（不占据原本位置）进行定位的元素，如弹出层、菜单等。</p>
</li>
<li><p>固定定位：使用 <code>position: fixed</code> 属性将元素固定在视口的某个位置，也可以通过 <code>top</code>、<code>bottom</code>、<code>left</code>、<code>right</code> 属性进行定位。主要应用场景是需要浮动在页面之上的元素，如导航栏、回到顶部按钮等。</p>
</li>
<li><p>粘性定位：使用 <code>position: sticky</code> 属性将元素粘在容器的指定位置，也可以通过 <code>top</code>、<code>bottom</code>、<code>left</code>、<code>right</code> 属性进行定位。主要应用场景是需要滚动时保持元素在容器内的位置，如表头、侧边栏等。</p>
</li>
</ol>
<p>以上是常见的元素定位方式及其应用场景，具体的使用方法需要结合实际情况进行选择。</p>
<h3 id="关于box-sizing属性"><a href="#关于box-sizing属性" class="headerlink" title="关于box-sizing属性"></a>关于box-sizing属性</h3><p><code>box-sizing</code>是<code>CSS</code>的一个属性，用于定义盒子模型的尺寸计算方式。它有两个可选值：<code>content-box</code>和<code>border-box</code>。</p>
<ul>
<li><code>content-box</code>：默认值。表示盒子的宽度和高度仅包含内容(content)，不包括边框(border)、内边距(padding)和外边距(margin)。当对一个具有指定宽度和内边距的元素应用边框时，其实际宽度会增加边框的大小，从而导致元素实际宽度比指定宽度更大。</li>
<li><code>border-box</code>：表示盒子的宽度和高度包括内容(content)、边框(border)和内边距(padding)，但不包括外边距(margin)。这意味着无论是否设置边框或内边距，元素的实际宽度都等于指定的宽度。</li>
</ul>
<p>使用<code>box-sizing</code>可以更方便地控制元素的尺寸计算方式，使布局更加灵活。</p>
<h3 id="关于cursor属性"><a href="#关于cursor属性" class="headerlink" title="关于cursor属性"></a>关于<code>cursor</code>属性</h3><p><code>CSS</code>中的<code>cursor</code>属性用于指定当用户将鼠标悬停在一个元素上时鼠标指针的样式。该属性接受多个值，每个值会对应一个不同的鼠标指针样式。</p>
<p>常用的<code>cursor</code>取值包括：</p>
<ul>
<li><code>auto</code>: 默认值，浏览器自动决定鼠标指针的样式。</li>
<li><code>pointer</code>: 表示链接或可点击元素，通常为手形指针。</li>
<li><code>default</code>: 表示默认状态，通常为箭头指针。</li>
<li><code>text</code>: 表示文本输入区域，通常为I型光标。</li>
<li><code>move</code>: 表示可移动元素，通常为十字箭头。</li>
<li><code>not-allowed</code>: 表示该元素不能被点击或选择，通常为圆圈加斜杠。</li>
</ul>
<p>除了上述常见的取值外，<code>cursor</code>属性还可以使用自定义样式。可以通过设置<code>url()</code>函数来指定一个图片作为鼠标指针，也可以使用<code>Webkit</code>内核的 <code>-webkit-grab</code> 和 <code>-webkit-grabbing</code> 等伪类来实现更加复杂的效果。</p>
<p>总之，<code>cursor</code>属性是一种控制鼠标指针样式的常用<code>CSS</code>属性，可以通过设置不同的取值来改变鼠标在页面中的交互方式和视觉效果。</p>
<h3 id="关于flex-wrap属性"><a href="#关于flex-wrap属性" class="headerlink" title="关于flex-wrap属性"></a>关于flex-wrap属性</h3><p><code>CSS</code>中的<code>flex-wrap</code>属性用于控制Flex容器中Flex项目的换行方式。它有3个可能的值：</p>
<ol>
<li><code>nowrap</code>：默认值。Flex项目不换行，尽可能地放在一行上。</li>
<li><code>wrap</code>：Flex项目在必要时换行，并将它们分配到多行中。</li>
<li><code>wrap-reverse</code>：与<code>wrap</code>类似，但是沿着交叉轴方向反转每一行。</li>
</ol>
<p>此外，<code>flex-wrap</code>还可以结合<code>flex-direction</code>属性来定义<code>Flex</code>容器中<code>Flex</code>项目的布局方向和换行方式。例如，<code>flex-direction: row; flex-wrap: wrap;</code>可以使<code>Flex</code>项目在水平方向上布局，并在必要时换行到下一行。</p>
<h3 id="关于overflow-y属性"><a href="#关于overflow-y属性" class="headerlink" title="关于overflow-y属性"></a>关于overflow-y属性</h3><p><code>CSS</code>中的<code>overflow-y</code>属性用于控制元素在垂直方向上溢出内容时的表现方式。它有以下几个可能的取值：</p>
<ol>
<li><code>visible</code>：默认值，不会裁剪任何内容，允许元素内容超出其容器，此时滚动条不会出现。</li>
<li><code>hidden</code>： 裁剪元素的超出部分，看不到溢出的内容，并禁止滚动。</li>
<li><code>scroll</code>： 允许元素内容溢出容器，并显示滚动条以让用户可以查看隐藏部分。</li>
<li><code>auto</code>：与scroll相似，但只为必须的滚动条添加滚动。</li>
</ol>
<p>例如，如果你想要一个容器始终只显示一定数量的内容，并使用滚动条向下滚动以查看余下的内容，则可以在CSS样式表中将<code>overflow-y</code>设置为<code>scroll</code>。</p>
<p><strong>本文内容来自</strong> : ChatGPT</p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em><a href="https://code.newban.cn/">乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</a></em></p>
]]></content>
      <tags>
        <tag>Web开发</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue3中关于组件之间的事件传递和数据共享</title>
    <url>/420.html</url>
    <content><![CDATA[<h2 id="事件传递"><a href="#事件传递" class="headerlink" title="事件传递"></a>事件传递</h2><ol>
<li><p><strong>子组件向父组件传递事件</strong></p>
<p>首先在父组件中定义一个用于接收事件的方法<code>handleContentPage</code>:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- 这是父组件 --&gt;</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div id=&quot;parent&quot;&gt;</span><br><span class="line">    &lt;!-- 接收子组件的消息 --&gt;</span><br><span class="line">    &lt;Navbar  @update-content-page=&quot;handleContentPage&quot;/&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;script&gt; </span><br><span class="line">import Navbar from &quot;@admin/views/Navbar.vue&quot;;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  components: &#123;</span><br><span class="line">    Navbar,</span><br><span class="line">  &#125;,</span><br><span class="line">  methods:&#123;</span><br><span class="line">    handleContentPage(page)&#123;</span><br><span class="line">      console.log(&quot;收到子组件传递过来的消息&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>然后在子组件中借助<code>$emit</code>来调用父组件的函数:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- 这是子组件 --&gt;</span><br><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div class=&quot;navbar&quot;&gt;</span><br><span class="line">        &lt;!-- 导航栏 --&gt;</span><br><span class="line">        &lt;nav&gt;</span><br><span class="line">            &lt;ul&gt;</span><br><span class="line">                &lt;li @click=&quot;navigateTo(&apos;Dashboard&apos;)&quot;&gt;仪表板&lt;/li&gt;</span><br><span class="line">                &lt;li @click=&quot;navigateTo(&apos;Users&apos;)&quot;&gt;用户&lt;/li&gt;</span><br><span class="line">                &lt;li @click=&quot;navigateTo(&apos;Settings&apos;)&quot;&gt;设置&lt;/li&gt;</span><br><span class="line">            &lt;/ul&gt;</span><br><span class="line">        &lt;/nav&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">    methods: &#123;</span><br><span class="line">        navigateTo(page) &#123;</span><br><span class="line">            console.log(&quot;点击了菜单栏&quot;);</span><br><span class="line">            //向父组件发送数据</span><br><span class="line">            this.$emit(&apos;update-content-page&apos;, page);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>: <code>$emit</code>闯入的第一个参数 <code>update-content-page</code> 需要和父组件中使用<code>@</code>进行一一对应</p>
</li>
<li><p><strong>父组件向子组件传递事件</strong></p>
<p>首先在子组件中定义一个供父组件调用的方法:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- 这是子组件 --&gt;</span><br><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div class=&quot;content&quot;&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">    methods: &#123;</span><br><span class="line">      //定义一个方法供父组件调用</span><br><span class="line">        updatePage(page) &#123;</span><br><span class="line">            console.log(&quot;收到来自父组件的数据&quot;+page);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>然后在父组件中通过对象引用的方式调取子组件的方法:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- 这是父组件 --&gt;</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div id=&quot;parent&quot;&gt;</span><br><span class="line">    	&lt;button @click=&quot;handleContentPage&quot;&gt;一键转换&lt;/button&gt;</span><br><span class="line">    </span><br><span class="line">        &lt;!-- 使用 ref 建立子组件的实例引用 方便调子组件方法 --&gt;</span><br><span class="line">        &lt;Content  ref=&quot;contentRef&quot;/&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt; </span><br><span class="line"></span><br><span class="line">import Content from &quot;@admin/views/Content.vue&quot;;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  components: &#123;</span><br><span class="line">    Content,</span><br><span class="line">  &#125;,</span><br><span class="line">  methods:&#123;</span><br><span class="line">    handleContentPage(page)&#123;</span><br><span class="line">      //调取子组件的函数</span><br><span class="line">      this.$refs.contentRef.updatePage(page)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>两个不相关的组件进行事件传递</strong></p>
<p>在<code>Vue 3</code>中，可以使用事件总线<code>Event Bus</code>来进行两个不相关的组件之间优雅地通信。</p>
<p>   首先在一个单独的<code>JavaScript</code>模块中创建事件总线：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createApp &#125; <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> eventBus = createApp(&#123;&#125;)</span><br></pre></td></tr></table></figure>

<p>   然后在需要发布事件的组件中导入事件总线并发送事件：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; eventBus &#125; <span class="keyword">from</span> <span class="string">'./event-bus'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  methods: &#123;</span><br><span class="line">    sendMessage() &#123;</span><br><span class="line">      eventBus.emit(<span class="string">'message-sent'</span>, <span class="keyword">this</span>.message)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>   最后，在接收事件的组件中也导入事件总线并监听事件：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; eventBus &#125; <span class="keyword">from</span> <span class="string">'./event-bus'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  created() &#123;</span><br><span class="line">    eventBus.on(<span class="string">'message-sent'</span>, message =&gt; &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">`Received message: <span class="subst">$&#123;message&#125;</span>`</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="数据传递"><a href="#数据传递" class="headerlink" title="数据传递"></a>数据传递</h2><p><code>Vue</code>中如果需要进行父子间数据的传递, 可以使用<strong>provide/inject</strong>来实现</p>
<p>在祖先组件中使用<code>provide</code>来提供数据：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; provide &#125; <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  setup() &#123;</span><br><span class="line">    <span class="keyword">const</span> name = <span class="string">'John Doe'</span>;</span><br><span class="line">    provide(<span class="string">'name'</span>, name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在后代组件中使用<code>inject</code>来获取数据：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; inject &#125; <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  setup() &#123;</span><br><span class="line">    <span class="keyword">const</span> name = inject(<span class="string">'name'</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(name); <span class="comment">// Output: John Doe</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样，后代组件就可以通过<code>inject</code>方法访问提供的数据了。</p>
<h2 id="全局数据共享"><a href="#全局数据共享" class="headerlink" title="全局数据共享"></a>全局数据共享</h2><p>如果我们需要在所有组件中共享数据, 比如用户的信息 缓存数据等等, </p>
<p>在<code>Vue3</code>中，介绍两种方案</p>
<h3 id="第一种-使用一个全局的provide-inject"><a href="#第一种-使用一个全局的provide-inject" class="headerlink" title="第一种 使用一个全局的provide/inject"></a>第一种 使用一个全局的<code>provide/inject</code></h3><p>具体步骤如下：</p>
<ol>
<li>在根组件中提供要共享的数据</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createApp, reactive &#125; <span class="keyword">from</span> <span class="string">'vue'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = createApp(&#123;</span><br><span class="line">  setup() &#123;</span><br><span class="line">    <span class="keyword">const</span> sharedState = reactive(&#123; <span class="attr">count</span>: <span class="number">0</span> &#125;);</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      sharedState,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.mount(<span class="string">'#app'</span>);</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>在需要使用该数据的子组件中注入它</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; inject &#125; <span class="keyword">from</span> <span class="string">'vue'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  setup() &#123;</span><br><span class="line">    <span class="keyword">const</span> sharedState = inject(<span class="string">'sharedState'</span>);</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      sharedState,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>在子组件中就可以直接使用这个共享的状态了，比如在模板中显示它的值或者修改它的值</li>
</ol>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    &#123;&#123; sharedState.count &#125;&#125;</span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"sharedState.count++"</span>&gt;</span>增加<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这样就可以实现一个简单的全局数据共享了。需要注意的是，<code>provide/inject</code> API并不是响应式的，如果需要响应式地共享数据，可以使用<code>reactive</code>或者<code>ref</code>等Vue3提供的响应式API来实现。</p>
<h3 id="使用Vuex"><a href="#使用Vuex" class="headerlink" title="使用Vuex"></a>使用Vuex</h3><p>在<code>Vue 3</code> 中，可以使用 <code>Vuex 4</code>来实现全局数据共享。</p>
<p>首先需要安装<code>Vuex</code>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install vuex@next</span><br></pre></td></tr></table></figure>

<p>然后在 main.js 中创建一个 store 实例：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createApp &#125; <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">'./App.vue'</span></span><br><span class="line"><span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">'./store'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = createApp(App)</span><br><span class="line">app.use(store)</span><br><span class="line">app.mount(<span class="string">'#app'</span>)</span><br></pre></td></tr></table></figure>

<p>接着在 src 目录下创建一个 store.js 文件，用于定义 store：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createStore &#125; <span class="keyword">from</span> <span class="string">'vuex'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> store = createStore(&#123;</span><br><span class="line">  state() &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      count: <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  mutations: &#123;</span><br><span class="line">    increment(state) &#123;</span><br><span class="line">      state.count++</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  actions: &#123;</span><br><span class="line">    increment(context) &#123;</span><br><span class="line">      context.commit(<span class="string">'increment'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  getters: &#123;</span><br><span class="line">    doubleCount(state) &#123;</span><br><span class="line">      <span class="keyword">return</span> state.count * <span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> store</span><br></pre></td></tr></table></figure>

<p>这里的<code>state</code> 定义了初始状态，<code>mutations</code> 定义了修改状态的方法，<code>actions</code> 定义了异步操作，<code>getters</code>定义了从状态中派生出来的值。</p>
<p>在组件中使用<code>store</code> 的数据和方法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;p&gt;Count: &#123;&#123; count &#125;&#125;&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">    &lt;p&gt;Double Count: &#123;&#123; doubleCount &#125;&#125;&lt;/</span>p&gt;</span><br><span class="line">    &lt;button @click=<span class="string">"increment"</span>&gt;Increment&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">  &lt;/</span>div&gt;</span><br><span class="line">&lt;<span class="regexp">/template&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;script&gt;</span></span><br><span class="line"><span class="regexp">import &#123; computed &#125; from 'vue'</span></span><br><span class="line"><span class="regexp">import &#123; useStore &#125; from 'vuex'</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default &#123;</span></span><br><span class="line"><span class="regexp">  setup() &#123;</span></span><br><span class="line"><span class="regexp">    const store = useStore()</span></span><br><span class="line"><span class="regexp">    const count = computed(() =&gt; store.state.count)</span></span><br><span class="line"><span class="regexp">    const doubleCount = computed(() =&gt; store.getters.doubleCount)</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">    const increment = () =&gt; &#123;</span></span><br><span class="line"><span class="regexp">      store.dispatch('increment')</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">    return &#123;</span></span><br><span class="line"><span class="regexp">      count,</span></span><br><span class="line"><span class="regexp">      doubleCount,</span></span><br><span class="line"><span class="regexp">      increment</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">&lt;/</span>script&gt;</span><br></pre></td></tr></table></figure>

<p>在组件中使用 <code>useStore</code> 获取<code>store</code> 实例，在 <code>setup</code>函数中使用<code>computed</code>函数将 <code>store</code> 中的数据和方法转化为响应式的值，然后在模板中使用即可。</p>
<p>以上是一个简单的示例，具体使用还可以根据实际需求进行修改和扩展。</p>
<p><strong>本文为作者原创转载时请注明出处 谢谢</strong></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em><a href="https://code.newban.cn/">乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</a></em></p>
]]></content>
      <tags>
        <tag>Web开发</tag>
      </tags>
  </entry>
  <entry>
    <title>Html标签的详细介绍和使用</title>
    <url>/421.html</url>
    <content><![CDATA[<h3 id="Html中常见的标签"><a href="#Html中常见的标签" class="headerlink" title="Html中常见的标签"></a>Html中常见的标签</h3><p>HTML（超文本标记语言）是一种用于创建Web页面的标记语言。以下是一些常见的HTML标签及其使用方法：</p>
<ol>
<li><code>&lt;html&gt;</code>：定义一个HTML文档。</li>
<li><code>&lt;head&gt;</code>：定义文档头部，包括标题等元数据。</li>
<li><code>&lt;title&gt;</code>：定义文档的标题，会显示在浏览器的标签页上。</li>
<li><code>&lt;body&gt;</code>：定义文档的主体部分。</li>
<li><code>&lt;h1&gt;-&lt;h6&gt;</code>：定义六级标题，从大到小依次排列。</li>
<li><code>&lt;p&gt;</code>：定义段落。</li>
<li><code>&lt;a&gt;</code>：定义一个超链接，其中href属性指定链接地址。</li>
<li><code>&lt;img&gt;</code>：定义一个图像，其中src属性指定图像的URL地址。</li>
<li><code>&lt;ul&gt;</code>：定义一个无序列表。</li>
<li><code>&lt;ol&gt;</code>：定义一个有序列表。</li>
<li><code>&lt;li&gt;</code>：定义列表中的一个项目。</li>
<li><code>&lt;table&gt;</code>：定义表格。</li>
<li><code>&lt;tr&gt;</code>：定义表格中的一行。</li>
<li><code>&lt;td&gt;</code>：定义表格中的一个单元格。</li>
<li><code>&lt;form&gt;</code>：定义表单，用于收集用户输入的数据。</li>
<li><code>&lt;input&gt;</code>：定义表单中的输入字段，<code>type</code>属性可以指定为<code>text</code>、<code>password</code>、<code>checkbox</code>等不同类型。</li>
<li><code>&lt;button&gt;</code>：定义按钮。</li>
<li><code>&lt;select&gt;</code>：定义下拉列表。</li>
<li><code>&lt;option&gt;</code>：定义下拉列表中的一个选项。</li>
<li><code>&lt;textarea&gt;</code>：定义多行文本输入框。</li>
</ol>
<p>还有很多其他的<code>HTML</code>标签，这里只列举了一些常见的。<code>HTML</code>标签可以通过属性来设置不同的样式和功能，如<code>class</code>、<code>id</code>、<code>style</code>等属性。使用这些标签和属性，可以创建出各种不同的<code>Web</code>页面。</p>
<h3 id="使用form表单标签有什么优势"><a href="#使用form表单标签有什么优势" class="headerlink" title="使用form表单标签有什么优势"></a>使用form表单标签有什么优势</h3><p>使用 <code>form</code>表单标签的优势如下：</p>
<ol>
<li><p>支持各种 <code>HTTP</code> 请求方法：<code>form</code>标签支持 <code>GET</code>、<code>POST</code>、<code>PUT</code>、<code>DELETE</code> 等 HTTP 请求方法，可以根据需求选择适合的请求方式提交数据。</p>
</li>
<li><p>支持文件上传：<code>form</code> 标签可以通过设置 <code>enctype</code> 属性为<code>&quot;multipart/form-data</code> 实现文件上传功能。</p>
</li>
<li><p>提供多种表单控件：<code>form</code> 标签提供多种类型的表单控件，包括文本框、密码框、单选框、复选框、下拉框等，可以满足各种表单需求。</p>
</li>
<li><p>支持表单验证：form 标签内的表单控件可以通过设置<code>required</code>、<code>maxlength</code>、<code>minlength</code>、<code>pattern</code> 等属性进行验证，保证用户输入的数据符合要求。</p>
</li>
<li><p>方便进行前端数据处理：通过使用 form 表单标签，可以方便地将用户提交的表单数据传递给后端服务器，实现前后端数据交互。</p>
</li>
</ol>
<p>总之，使用<code>form</code> 表单标签可以简化前端开发过程，提高用户体验和数据安全性。</p>
<h3 id="HTML中Label标签的应用场景"><a href="#HTML中Label标签的应用场景" class="headerlink" title="HTML中Label标签的应用场景"></a>HTML中Label标签的应用场景</h3><p><code>Label</code>标签通常用于为<code>HTML</code>表单元素添加可点击的文本标签。下面列出了几个具体的应用场景：</p>
<ol>
<li><p>关联表单控件：使用<code>for</code>属性将<code>label</code>与对应的表单控件绑定在一起，可以通过点击label来选中或激活相应的控件，提高用户体验。</p>
</li>
<li><p>提高可访问性：对于视力差或使用辅助技术（如屏幕阅读器）的用户，使用label可以更方便地读取表单控件相关信息。</p>
</li>
<li><p>增强可用性：在移动设备上，点击label标签比点击小的输入框更容易，并且可以避免误操作。另外，label标签可以通过CSS样式进行美化，提升页面整体的视觉效果。</p>
</li>
</ol>
<p>例如，以下代码演示了如何使用label标签关联一个文本输入框：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"username"</span>&gt;</span>用户名：<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">id</span>=<span class="string">"username"</span> <span class="attr">name</span>=<span class="string">"username"</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这里的<code>for</code>属性指定了它对应的输入框的<code>id</code>，当用户点击标签时，浏览器会自动将焦点聚焦到对应的输入框中。</p>
<h3 id="p标签也是块级元素-它可以替代div使用吗"><a href="#p标签也是块级元素-它可以替代div使用吗" class="headerlink" title="p标签也是块级元素 它可以替代div使用吗"></a>p标签也是块级元素 它可以替代div使用吗</h3><p>是的，<code>p</code>标签是块级元素，但它与<code>div</code>元素有一些不同之处。在语义上，<code>p</code>标签用于表示一个段落，而<code>div</code>标签只是一个容器，用于组织其他元素。</p>
<p>从布局的角度来看，<code>p</code>标签具有一些默认的样式和间距，这意味着使用<code>p</code>标签时，文本会有一些预设的格式。而<code>div</code>标签没有默认的样式或间距，需要手动设置<code>CSS</code>规则才能实现所需的布局。</p>
<p>因此，在某些情况下，可以使用<code>p</code>标签代替<code>div</code>标签。例如，当您希望创建一些纯文本内容时，<code>p</code>标签可能更适合，因为它提供了一些默认的样式和格式。但是，如果您需要创建自定义布局并且需要更多的控制，则应使用<code>div</code>标签。</p>
<p>总之，<code>p</code>标签可以替代<code>div</code>使用，但需要根据具体情况进行评估和选择。</p>
<h3 id="HTML中容器标签都有哪些"><a href="#HTML中容器标签都有哪些" class="headerlink" title="HTML中容器标签都有哪些"></a>HTML中容器标签都有哪些</h3><p>HTML中常用的容器标签包括：</p>
<ol>
<li><p><code>&lt;div&gt;</code>：通用块级容器，用于组织页面结构、布局和样式控制。</p>
</li>
<li><p><code>&lt;span&gt;</code>：通用行内容器，用于包裹少量文本或其他行内元素，并通过<code>CSS</code>进行样式控制。</p>
</li>
<li><p><code>&lt;section&gt;</code>：语义化的块级容器，用于划分文档内容的主题部分，例如章节、页眉、页脚等。</p>
</li>
<li><p><code>&lt;article&gt;</code>：语义化的块级容器，用于表示独立的内容单元，如博客文章、新闻报道等。</p>
</li>
<li><p><code>&lt;header&gt;</code>：语义化的块级容器，用于定义网页或区域的页眉，通常包含标题、logo、导航菜单等元素。</p>
</li>
<li><p><code>&lt;footer&gt;</code>：语义化的块级容器，用于定义网页或区域的页脚，通常包含版权信息、联系方式、社交媒体链接等元素。</p>
</li>
<li><p><code>&lt;nav&gt;</code>：语义化的块级容器，用于定义导航菜单。</p>
</li>
<li><p><code>&lt;aside&gt;</code>：语义化的块级容器，用于定义与主要内容相关但不属于主要流程的辅助内容，如侧栏、广告等。</p>
</li>
<li><p><code>&lt;main&gt;</code>：语义化的块级容器，用于标识文档或应用程序的主要内容区域。</p>
</li>
</ol>
<p>这些容器标签有助于提高HTML文档的可读性、可维护性和可访问性，并且能够帮助搜索引擎正确解析和索引网页内容。在实际应用中，应根据具体情况选择合适的容器标签进行包裹，以达到最佳的结构组织和样式控制效果。</p>
<h3 id="HTML中文本标签都有哪些"><a href="#HTML中文本标签都有哪些" class="headerlink" title="HTML中文本标签都有哪些"></a>HTML中文本标签都有哪些</h3><p>HTML 中常用的文本标签有以下几种：</p>
<ol>
<li><p><code>&lt;h1&gt;</code> 到 <code>&lt;h6&gt;</code>：用于定义标题，H1 是最高级别的标题，H6 是最低级别的标题，通常用于网页中的文章标题或分组标题。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>这是一个 H1 标题<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>&lt;p&gt;</code>：用于定义段落，通常用于网页中的正文内容。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>这是一个段落。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>&lt;a&gt;</code>：用于定义链接，可以指向其他网站、页面或同一页面内的特定内容。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"https://www.example.com"</span>&gt;</span>点击此处访问 Example 网站<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>&lt;ul&gt;</code> 和 <code>&lt;li&gt;</code>：用于定义无序列表，<code>&lt;ul&gt;</code> 表示整个列表，<code>&lt;li&gt;</code> 表示列表中的每一项。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>第一项<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>第二项<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>第三项<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>&lt;ol&gt;</code> 和 <code>&lt;li&gt;</code>：用于定义有序列表，与无序列表类似，只是每一项前面会显示一个数字。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ol</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>第一项<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>第二项<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>第三项<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>&lt;br&gt;</code>：用于插入换行符。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>这是第一行。<span class="tag">&lt;<span class="name">br</span>&gt;</span>这是第二行。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>&lt;strong&gt;</code> 和 <code>&lt;em&gt;</code>：分别用于定义加粗和斜体样式的文本。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>这是一段 <span class="tag">&lt;<span class="name">strong</span>&gt;</span>加粗<span class="tag">&lt;/<span class="name">strong</span>&gt;</span> 的文本，这是一段 <span class="tag">&lt;<span class="name">em</span>&gt;</span>斜体<span class="tag">&lt;/<span class="name">em</span>&gt;</span> 的文本。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>&lt;blockquote&gt;</code>：用于定义长的引用块。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">blockquote</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>这是一个引用。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">blockquote</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>&lt;pre&gt;</code>：用于保留文本中的空格和换行符，通常用于显示代码片段。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">pre</span>&gt;</span></span><br><span class="line">  console.log("Hello, world!");</span><br><span class="line"><span class="tag">&lt;/<span class="name">pre</span>&gt;</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>以上是 HTML 中较为常用的文本标签以及它们的使用场景和示例。</p>
<h3 id="css样式常用属性都有哪些"><a href="#css样式常用属性都有哪些" class="headerlink" title="css样式常用属性都有哪些"></a>css样式常用属性都有哪些</h3><p>CSS 样式属性有很多，以下列出其中一些常用的：</p>
<ol>
<li><code>color</code>：设置文本颜色；</li>
<li><code>font-size</code>：设置字体大小；</li>
<li><code>font-family</code>：设置字体类型；</li>
<li><code>background-color</code>：设置背景颜色；</li>
<li><code>margin</code>：设置元素外边距；</li>
<li><code>padding</code>：设置元素内边距；</li>
<li><code>width</code>：设置元素宽度；</li>
<li><code>height</code>：设置元素高度；</li>
<li><code>border</code>：设置元素边框；</li>
<li><code>text-align</code>：设置文本对齐方式；</li>
<li><code>display</code>：设置元素的显示方式；</li>
<li><code>position</code>：设置元素的定位方式。</li>
</ol>
<ol>
<li>color：用于设置文本的颜色，可以让用户更容易地阅读内容。</li>
<li>font-size：用于设置字体大小，可以让文字更加突出或更容易阅读。</li>
<li>font-family：用于设置字体类型，可以让用户更好的理解并品味页面内容。</li>
<li>background-color：用于设置背景颜色，可以增强页面的视觉效果以及提高用户体验。</li>
<li>margin：用于调整元素之间的距离和位置，达到更好的页面布局效果。</li>
<li>padding：用于调整元素内部元素之间的距离和位置，使页面更美观和易于阅读。</li>
<li>width：用于设置元素的宽度，可以让页面更加美观和易于阅读。</li>
<li>height：用于设置元素的高度，可以让页面更加美观和易于阅读。</li>
<li>border：用于设置元素的边框，可以增强页面的视觉效果以及提高用户体验。</li>
<li>text-align：用于设置文本对齐方式，使页面布局更清晰美观并提高易读性。</li>
<li>display：用于设置元素的显示方式，可以根据不同的应用场景来选择不同的显示方式。</li>
<li>position：用于设置元素的定位方式，可以允许将元素放置在网页上的任何位置。</li>
</ol>
<p><strong>本文内容来自</strong> : ChatGPT</p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em><a href="https://code.newban.cn/">乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</a></em></p>
]]></content>
      <tags>
        <tag>Web开发</tag>
      </tags>
  </entry>
  <entry>
    <title>关于Vue Router的详细介绍和使用</title>
    <url>/423.html</url>
    <content><![CDATA[<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p><code>Vue Router</code>是 <code>Vue.js</code>官方提供的路由管理工具，用于实现前端单页应用（Single Page Application，SPA）中的页面跳转和<code>URL</code> 管理。</p>
<h3 id="Vue-Router的使用方式"><a href="#Vue-Router的使用方式" class="headerlink" title="Vue Router的使用方式"></a>Vue Router的使用方式</h3><p><code>Vue Router</code>的使用方式可以分为两种：</p>
<ol>
<li>声明式路由：通过在<code>Vue</code>组件中声明路由对象，在模板中使用 <code>&lt;router-link&gt;</code> 组件生成跳转链接，同时使用 <code>&lt;router-view&gt;</code> 组件渲染当前路由匹配的组件。例如：</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> VueRouter <span class="keyword">from</span> <span class="string">'vue-router'</span></span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">'./App.vue'</span></span><br><span class="line"><span class="keyword">import</span> Home <span class="keyword">from</span> <span class="string">'./components/Home.vue'</span></span><br><span class="line"><span class="keyword">import</span> About <span class="keyword">from</span> <span class="string">'./components/About.vue'</span></span><br><span class="line"></span><br><span class="line">Vue.use(VueRouter)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> routes = [</span><br><span class="line">  &#123; <span class="attr">path</span>: <span class="string">'/'</span>, <span class="attr">component</span>: Home &#125;,</span><br><span class="line">  &#123; <span class="attr">path</span>: <span class="string">'/about'</span>, <span class="attr">component</span>: About &#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">  mode: <span class="string">'history'</span>,</span><br><span class="line">  routes</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  router,</span><br><span class="line">  render: <span class="function"><span class="params">h</span> =&gt;</span> h(App),</span><br><span class="line">&#125;).$mount(<span class="string">'#app'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// App.vue</span></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;router-link to=<span class="string">"/"</span>&gt;Home&lt;<span class="regexp">/router-link&gt;</span></span><br><span class="line"><span class="regexp">    &lt;router-link to="/</span>about<span class="string">"&gt;About&lt;/router-link&gt;</span></span><br><span class="line"><span class="string">    &lt;router-view&gt;&lt;/router-view&gt;</span></span><br><span class="line"><span class="string">  &lt;/div&gt;</span></span><br><span class="line"><span class="string">&lt;/template&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>编程式路由：通过调用 <code>$router.push()</code> 方法实现页面跳转，同时使用 <code>$route</code> 对象获取当前路由信息。例如：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// SomeComponent.vue</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  methods: &#123;</span><br><span class="line">    goToAboutPage() &#123;</span><br><span class="line">      this.$router.push(&apos;/about&apos;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>需要注意的是，在使用 Vue Router 时需要在 main.js 中全局注册插件，并在根组件中将 router 对象传递给 Vue 实例。同时需要配置路由规则，可以使用 path-to-regexp 库编写路由匹配规则，还可以通过 mode 属性设置路由模式（hash 模式或 history 模式）。</p>
<h3 id="Vue-Router的历史模式"><a href="#Vue-Router的历史模式" class="headerlink" title="Vue Router的历史模式"></a>Vue Router的历史模式</h3><p>历史模式<code>（history mode）</code>是一种 HTML5 原生 API，它通过使用浏览器 History API 来实现前端路由。在历史模式中，路由的 URL 不再有 # 符号，而是直接使用普通的 URL 地址。这种路由方式看起来更加美观，也更接近传统的多页应用程序的 URL 结构。</p>
<p>历史模式的优点包括：</p>
<ol>
<li>更好的用户体验：URL 中没有 # 符号，看起来更加美观、专业。</li>
<li>更利于 SEO：搜索引擎能够抓取到完整的 URL，从而更好地进行网站收录和优化。</li>
<li>支持浏览器后退操作：浏览器的后退按钮可以正常使用。</li>
<li>更适合目标浏览器：在某些低版本浏览器中，hash 模式可能会出现一些兼容性问题。</li>
</ol>
<p>不过，历史模式也有一定的缺点。由于在前端路由过程中，我们使用了浏览器的 History API 来修改 URL，因此可能会发生一些问题，例如：</p>
<ol>
<li>当用户直接访问某个子路由时，刷新页面会出现 404 错误，需要服务器端进行特殊配置。</li>
<li>当用户在浏览器的地址栏中手动输入 URL 时，也会出现 404 错误。</li>
</ol>
<p>因此，在使用历史模式时，我们需要在服务器端进行特殊配置来避免这些问题。具体来说，我们需要将所有请求都指向同一个 HTML 文件，然后通过前端路由来渲染不同的视图。</p>
<p><strong>本文内容来自</strong> : ChatGPT</p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em><a href="https://code.newban.cn/">乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</a></em></p>
]]></content>
      <tags>
        <tag>Web开发</tag>
      </tags>
  </entry>
  <entry>
    <title>Bearer token和jwt有什么区别</title>
    <url>/425.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><code>Bearer token</code>和<code>JWT</code>是两种不同的身份验证/授权机制，它们在设计和用途上有所不同。</p>
<p><code>Bearer Token</code>是一种简单的身份验证机制，它通常由服务器发放给客户端，用于标识客户端是否被授权执行某些操作。<code>Bearer Token</code>本质上是一个字符串，客户端将其包含在<code>HTTP</code>请求的<code>Authorization</code>头部中发送到服务器进行身份验证。</p>
<p>例如，一个典型的<code>Bearer Token</code>可能如下所示:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c</span><br></pre></td></tr></table></figure>

<p><code>Bearer Token</code>通常没有明确的过期时间，因此每次请求时，服务器都需要重新验证令牌的有效性</p>
<p>与之相反，<code>JWT（JSON Web Token</code>）是一种基于<code>JSON</code>的开放标准，用于在各个应用程序之间安全地传输信息。<code>JWT</code>通常由三个部分组成：头部、负载和签名。其中头部和负载都是<code>Base64</code>编码的<code>JSON</code>数据，签名则是使用私钥对头部和负载进行加密后得到的一串字符串。</p>
<p>例如，一个典型的JWT可能如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyLCJleHAiOjE1MTYyMzkwMjIsImRhdGEiOnsiYXBwbGljYXRpb24iOiJmb28ifX0.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c</span><br></pre></td></tr></table></figure>

<p><code>JWT</code>可以包含过期时间和其他自定义信息，使得服务器可以更有效地控制访问权限</p>
<p><code>Bearer Token</code>和<code>JWT</code>虽然都可以用于身份验证和授权，但它们的设计和用途存在很大的差异。<code>Bearer Token</code>只是一个简单的字符串，没有任何加密或解密的过程，因此不需要进行数据解密。而<code>JWT</code>则是经过加密的数据，需要使用私钥进行解密才能访问其中的负载数据。</p>
<p><strong>本文内容来自</strong> : ChatGPT</p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em><a href="https://code.newban.cn/">乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</a></em></p>
]]></content>
      <tags>
        <tag>Web开发</tag>
      </tags>
  </entry>
  <entry>
    <title>vue3中如何实现全局通用的js工具类 其他组件使用的时候无需导包</title>
    <url>/427.html</url>
    <content><![CDATA[<h2 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h2><h3 id="第一种-使用全局Properties"><a href="#第一种-使用全局Properties" class="headerlink" title="第一种 使用全局Properties"></a>第一种 使用全局Properties</h3><p>在<code>Vue 3</code>中，可以通过在全局<code>app.config.globalProperties</code>对象上添加方法或属性来创建一个通用的工具类。这样在应用的任何地方都可以直接使用。</p>
<p>以下是一个简单的示例：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; createApp &#125; <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">'./App.vue'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = createApp(App)</span><br><span class="line"></span><br><span class="line">app.config.globalProperties.$myUtil = &#123;</span><br><span class="line">  <span class="comment">//定义一个通用的方法</span></span><br><span class="line">  getDate: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Date</span>().toLocaleDateString()</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">//定义一个通用的属性</span></span><br><span class="line">  version: <span class="string">'1.0.0'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">app.mount(<span class="string">'#app'</span>)</span><br></pre></td></tr></table></figure>

<p>现在，我们已经在全局范围内定义了一个名为 <code>$myUtil</code> 的工具类，其中包含一个 <code>getDate</code> 方法和一个 <code>version</code> 属性。这使得我们可以在Vue组件中直接调用这些方法而无需导入它们。例如：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Today's date is: &#123;&#123; $myUtil.getDate() &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>This app uses version &#123;&#123; $myUtil.version &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line">  mounted() &#123;</span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.$myUtil.getDate())</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>需要注意的是，这种做法虽然方便，但容易导致代码的可读性变差。如果要写大量的工具函数，最好还是将它们放在单独的模块中，然后在需要的地方导入使用。</p>
<h3 id="第二种-使用全局mixin"><a href="#第二种-使用全局mixin" class="headerlink" title="第二种 使用全局mixin"></a>第二种 使用全局mixin</h3><p>在<code>Vue3</code>中可以使用全局混入（<code>global mixin</code>来编写通用的工具类，从而实现在不需要导包的情况下在所有组件中使用。</p>
<p>具体步骤如下：</p>
<p>1.创建一个单独的js文件，例如<code>utils.js</code>，编写你需要的工具函数，并将它们作为一个对象返回。例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// utils.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  formatDate(date) &#123;</span><br><span class="line">    <span class="comment">// 格式化日期，返回字符串</span></span><br><span class="line">  &#125;,</span><br><span class="line">  debounce(func, delay) &#123;</span><br><span class="line">    <span class="comment">// 防抖函数，返回函数</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 其他工具函数...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>在main.js文件中引入该文件，并将其作为一个全局混入。例如：</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; createApp &#125; <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">'./App.vue'</span></span><br><span class="line"><span class="keyword">import</span> utils <span class="keyword">from</span> <span class="string">'./utils.js'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = createApp(App)</span><br><span class="line"></span><br><span class="line">app.mixin(&#123;</span><br><span class="line">  methods: &#123;</span><br><span class="line">    ...utils,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.mount(<span class="string">'#app'</span>)</span><br></pre></td></tr></table></figure>

<p>以上代码中，我们通过调用<code>createApp()</code>函数创建了一个应用程序实例，然后通过<code>app.mixin()</code>方法将<code>utils.js</code>文件导出的所有工具函数添加到Vue实例的原型链上，使得在所有组件中都可以直接调用这些工具函数。</p>
<ol start="3">
<li>在组件中使用工具函数</li>
</ol>
<p>现在，我们可以在任何组件中使用<code>formatDate()</code>、<code>debounce()</code>和其他在<code>utils.js</code>文件中定义的工具函数，例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;p&gt;&#123;&#123; formatDate(<span class="keyword">new</span> <span class="built_in">Date</span>()) &#125;&#125;&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">    &lt;input type="text" @input="debounce(handleInput, 500)"&gt;</span></span><br><span class="line"><span class="regexp">  &lt;/</span>div&gt;</span><br><span class="line">&lt;<span class="regexp">/template&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;script&gt;</span></span><br><span class="line"><span class="regexp">export default &#123;</span></span><br><span class="line"><span class="regexp">  methods: &#123;</span></span><br><span class="line"><span class="regexp">    handleInput() &#123;</span></span><br><span class="line"><span class="regexp">      /</span><span class="regexp">/ ...</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">&lt;/</span>script&gt;</span><br></pre></td></tr></table></figure>

<p>在上面的代码中，我们直接调用了<code>formatDate()</code>和<code>debounce()</code>函数，并且不需要在组件中导入这些工具函数，因为它们已经被添加到Vue实例的原型链上了。</p>
<p>注意：全局混入虽然方便，但也有潜在的问题。因此，在使用该方法时应当谨慎，确保不会影响到其他组件的正常运行。</p>
<p><strong>本文内容来自</strong> : ChatGPT</p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em><a href="https://code.newban.cn/">乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</a></em></p>
]]></content>
      <tags>
        <tag>Web开发</tag>
      </tags>
  </entry>
  <entry>
    <title>nodeJs中如何实现全局通用的js工具类 其他组件使用的时候无需导包</title>
    <url>/426.html</url>
    <content><![CDATA[<h2 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h2><p>为了编写一个在 <code>Node.js</code> 中全局通用的工具类，有两种方法：</p>
<ol>
<li>使用全局对象 <code>global</code></li>
</ol>
<p>首先，可以将工具类定义为一个模块并导出。然后，在应用程序的入口文件中使用全局对象 <code>global</code> 将其设置为全局变量。这样，就可以在应用程序的任何地方使用该工具类。</p>
<p>例如，创建一个名为 <code>myUtils.js</code> 的工具类文件，其中包含以下函数：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHello</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Hello, world!'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  sayHello,</span><br><span class="line">  add</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来，在应用程序的入口文件中，如 <code>app.js</code> 文件中添加以下代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> myUtils = <span class="built_in">require</span>(<span class="string">'./myUtils'</span>);</span><br><span class="line">global.myUtils = myUtils;</span><br></pre></td></tr></table></figure>

<p>现在可以在应用程序的任何地方使用 <code>myUtils</code> 工具类，如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 不需要导入或引用</span></span><br><span class="line">myUtils.sayHello(); <span class="comment">// 输出 "Hello, world!"</span></span><br><span class="line"><span class="built_in">console</span>.log(myUtils.add(<span class="number">2</span>, <span class="number">3</span>)); <span class="comment">// 输出 5</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>修改原型对象</li>
</ol>
<p>另一种方法是在全局原型对象上添加方法或属性。这样，所有 JavaScript 对象都可以访问它们。但是，这种方法可能会影响到其他模块或库的行为，因此需要小心使用。</p>
<p>例如，创建一个名为 <code>myUtils.js</code> 的工具类文件，其中包含以下函数：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.prototype.sayHello = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Hello, world!'</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.prototype.add = <span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>现在可以在应用程序的任何地方使用 <code>sayHello</code> 和 <code>add</code> 方法，如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 不需要导入或引用</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123;&#125;;</span><br><span class="line">obj.sayHello(); <span class="comment">// 输出 "Hello, world!"</span></span><br><span class="line"><span class="built_in">console</span>.log(obj.add(<span class="number">2</span>, <span class="number">3</span>)); <span class="comment">// 输出 5</span></span><br></pre></td></tr></table></figure>

<p>请注意，这种方法会将新方法添加到所有对象的原型中，包括 <code>JavaScript</code>内置对象。因此，可能会影响到其他代码库的行为，并且存在潜在的命名冲突和安全风险。</p>
<p><strong>本文内容来自</strong> : ChatGPT</p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em><a href="https://code.newban.cn/">乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</a></em></p>
]]></content>
      <tags>
        <tag>Web开发</tag>
      </tags>
  </entry>
  <entry>
    <title>如何使用git统计项目代码量</title>
    <url>/424.html</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>有时候公司可能会需要开发者统计项目总代码量和个人提交代码量</p>
<p>此时 我们可以通过<code>Git</code>工具获取到项目的代码行数</p>
<h3 id="查看项目总代码量"><a href="#查看项目总代码量" class="headerlink" title="查看项目总代码量"></a>查看项目总代码量</h3><p>在工程目录下,输入以下指令查看:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git log  --pretty=tformat: --numstat | awk '&#123; add += $1; subs += $2; loc += $1 - $2 &#125; END &#123; printf "added lines: %s, removed lines: %s, total lines: %s\n", add, subs, loc &#125;'</span><br></pre></td></tr></table></figure>

<p>打印如下内容:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">added lines: 105628, removed lines: 21640, total lines: 83988</span><br></pre></td></tr></table></figure>

<h3 id="查看某个人的代码量"><a href="#查看某个人的代码量" class="headerlink" title="查看某个人的代码量"></a>查看某个人的代码量</h3><p>添加<code>--author</code>参数即可:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git log  --author="你的用户名" --pretty=tformat: --numstat | awk '&#123; add += $1; subs += $2; loc += $1 - $2 &#125; END &#123; printf "added lines: %s, removed lines: %s, total lines: %s\n", add, subs, loc &#125;'</span><br></pre></td></tr></table></figure>

<h3 id="查看某个时间段的代码量"><a href="#查看某个时间段的代码量" class="headerlink" title="查看某个时间段的代码量"></a>查看某个时间段的代码量</h3><p>添加<code>--since</code>和<code>--before</code>参数:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git log --since="2018-03-01" --before="2019-01-09" --author="username" --pretty=tformat: --numstat | awk '&#123; add += $1; subs += $2; loc += $1 - $2 &#125; END &#123; printf "added lines: %s, removed lines: %s, total lines: %s\n", add, subs, loc &#125;'</span><br></pre></td></tr></table></figure>

<p><strong>本文为作者原创转载时请注明出处 谢谢</strong></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em><a href="https://code.newban.cn/">乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</a></em></p>
]]></content>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>向谷歌搜索引擎主动推送网页的教程 Google Indexing API 接口实现</title>
    <url>/43.html</url>
    <content><![CDATA[<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/jHXAmlIOfwsvtep-20200908110823361.jpg" alt></p>
<p>谷歌搜索引擎作为全球第一的搜索引擎早就支持了站长主动推送的功能，只不过不是面向普通用户的可视化界面，而是通过编程API接口实现的，有很多站长并不是专业的开发者，但由于谷歌需要验证网站所有权，所以我不能直接做一个可视化界面让站长自己填写自己的秘钥，所以只能对谷歌的接口进行二次封装，以降低使用的难度。</p>
<p>源码项目地址：<a href="https://github.com/NeilRen/GoogleIndexing" target="_blank" rel="noopener">https://github.com/NeilRen/GoogleIndexing</a></p>
<h2 id="环境要求"><a href="#环境要求" class="headerlink" title="环境要求"></a>环境要求</h2><p>首先，我是以Java为平台进行的封装，JDK版本为1.8，其他程序可能需要中间层才能打通，还不如自己实现，其他编程语言的同学我也没有办法，这个世界上编程语言太多了。</p>
<p>其次，谷歌的Google Indexing API接口在中国大陆无法访问，所以程序需要运行在可以访问谷歌的网络环境中。</p>
<h2 id="前提条件"><a href="#前提条件" class="headerlink" title="前提条件"></a>前提条件</h2><p>首先，你需要一个谷歌账号。你的项目是Java的，并且JDK为1.8以上。</p>
<h2 id="创建-Google-API-项目"><a href="#创建-Google-API-项目" class="headerlink" title="创建 Google API 项目"></a>创建 Google API 项目</h2><p>然后在向 Indexing API 发送请求之前，您需要告知 Google 您的客户端并激活对 Indexing API 的访问权限。谷歌为我们提供了一个<a href="https://console.developers.google.com/start/api?id=indexing.googleapis.com&credential=client_key" target="_blank" rel="noopener">设置向导</a>，设置向导会引导您在 Google API 控制台中创建项目、启用 Indexing API 以及创建凭据。</p>
<p>首先先跟着向导创建一个项目</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/M2ptE4nOaW6Z3qg.png" alt="Google Indexing API 设置向导"></p>
<p>然后转到凭据，添加凭据</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/20200310210556-20200908110850707.png" alt="Google Indexing API 添加凭证"></p>
<p>添加的凭据选择Indexing API、网页服务器(例如 node.js、Tomecat)，选择应用数据，点击“我需要哪些凭据？”到下一页</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/20200310210605-20200908110904033.png" alt="Google Indexing API 为项目添加凭证"></p>
<p>创建一个服务账号，名称可以自己起一个名字，秘钥类型选择JSON，点击继续</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/20200310210613-20200908110918941.png" alt="Google Indexing API 创建服务账号"></p>
<p>选择创建无角色账号即可</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/20200310210621-20200908110933400.png" alt="Google Indexing API 创建无角色账号"></p>
<p>这时就会自动下载一个json文件，这个就是我们的私钥，要保存好</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/20200310210628-20200908110944503.png" alt="Google Indexing API 秘钥"></p>
<h2 id="在-Search-Console-中验证网站所有权"><a href="#在-Search-Console-中验证网站所有权" class="headerlink" title="在 Search Console 中验证网站所有权"></a>在 Search Console 中验证网站所有权</h2><p>我们还需要到 <a href="https://www.google.com/webmasters/tools/home" target="_blank" rel="noopener">Search Console</a> 添加我们的网站，验证所有权，验证成功以后，注意我们要去<a href="https://www.google.com/webmasters/verification/home?pli=1" target="_blank" rel="noopener">旧版的控制台</a>，不要去新版的控制台！然后添加所有者</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/20200310210643-20200908110957641.png" alt="Google 旧版控制台">]</p>
<p>所有者的邮箱填写我们上一步获得的私钥JSON文件中的邮箱地址。</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/20200310210636-20200908111008115.png" alt="Google Indexing API 秘钥JSON"><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/20200310210654-20200908111018700.png" alt="Google 添加网站所有者"></p>
<h2 id="在自己的项目中安装依赖"><a href="#在自己的项目中安装依赖" class="headerlink" title="在自己的项目中安装依赖"></a>在自己的项目中安装依赖</h2><p>如果您使用Apache Maven来管理Java项目，只需在项目的<code>pom.xml</code>文件加入相应的依赖项即可。您只需在<code>pom.xml</code>中声明以下依赖：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;net.renfei&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;googleindexing&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.0.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p>编写代码调用服务，在实例化GoogleIndexing的时候，需要传一个String参数，这个参数是私钥JSON文件所在的文件地址：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import com.alibaba.fastjson.JSON;</span><br><span class="line">import com.google.api.services.indexing.v3.model.UrlNotificationMetadata;</span><br><span class="line">import net.renfei.googleindexing.GoogleIndexing;</span><br><span class="line">import net.renfei.googleindexing.entity.UrlNotification;</span><br><span class="line">import net.renfei.googleindexing.entity.UrlNotificationType;</span><br><span class="line"></span><br><span class="line">public class Demo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            GoogleIndexing googleIndexing = new GoogleIndexing(&quot;/Users/renfei/Google/Ren-Fei-5a8df7c2b912.json&quot;);</span><br><span class="line">            UrlNotification urlNotification = new UrlNotification();</span><br><span class="line">            urlNotification.setUrl(&quot;https://www.renfei.net&quot;);</span><br><span class="line">            urlNotification.setType(UrlNotificationType.URL_UPDATED);</span><br><span class="line">            UrlNotificationMetadata urlNotificationMetadata = googleIndexing.publish(urlNotification);</span><br><span class="line">            System.out.printf(JSON.toJSONString(urlNotificationMetadata));</span><br><span class="line">        &#125; catch (Exception ex) &#123;</span><br><span class="line">            ex.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>本文为作者原创 转载时请注明出处 谢谢</strong></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em>乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</em></p>
]]></content>
      <tags>
        <tag>seo</tag>
      </tags>
  </entry>
  <entry>
    <title>Android使用TextView加载Html实现点击图片放大</title>
    <url>/433.html</url>
    <content><![CDATA[<h2 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h2><p>在 <code>Android</code>的 <code>TextView</code> 中加载<code>HTML</code>标记时，我们可以使用 <code>&lt;img&gt;</code> 标记来显示图片，然后通过重写 <code>onTouchEvent</code> 方法来实现图片的放大效果。下面是一个示例代码，该代码在点击图片时会弹出一个对话框显示原图，用户可以选择是否放大图片。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTextView</span> <span class="keyword">extends</span> <span class="title">AppCompatTextView</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> LONG_CLICK_TIME_THRESHOLD = <span class="number">400</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> mStartClickTime = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyTextView</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyTextView</span><span class="params">(Context context, AttributeSet attrs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context, attrs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyTextView</span><span class="params">(Context context, AttributeSet attrs, <span class="keyword">int</span> defStyleAttr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context, attrs, defStyleAttr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</span><br><span class="line">        CharSequence text = getText();</span><br><span class="line">        <span class="keyword">if</span> (text <span class="keyword">instanceof</span> Spanned) &#123;</span><br><span class="line">            Spanned spanned = (Spanned) text;</span><br><span class="line">            <span class="keyword">int</span> action = event.getAction();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (action == MotionEvent.ACTION_DOWN) &#123;</span><br><span class="line">                mStartClickTime = System.currentTimeMillis();</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (action == MotionEvent.ACTION_UP) &#123;</span><br><span class="line">                <span class="keyword">long</span> clickDuration = System.currentTimeMillis() - mStartClickTime;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (clickDuration &lt; LONG_CLICK_TIME_THRESHOLD) &#123;</span><br><span class="line">                    <span class="keyword">int</span> x = (<span class="keyword">int</span>) event.getX();</span><br><span class="line">                    <span class="keyword">int</span> y = (<span class="keyword">int</span>) event.getY();</span><br><span class="line">                    x -= getTotalPaddingLeft();</span><br><span class="line">                    y -= getTotalPaddingTop();</span><br><span class="line">                    x += getScrollX();</span><br><span class="line">                    y += getScrollY();</span><br><span class="line">                    Layout layout = getLayout();</span><br><span class="line">                    <span class="keyword">int</span> line = layout.getLineForVertical(y);</span><br><span class="line">                    <span class="keyword">int</span> offset = layout.getOffsetForHorizontal(line, x);</span><br><span class="line"></span><br><span class="line">                    ClickableSpan[] link = spanned.getSpans(offset, offset, ClickableSpan.class);</span><br><span class="line">                    ImageSpan[] images = spanned.getSpans(offset, offset, ImageSpan.class);</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (link.length != <span class="number">0</span>) &#123;</span><br><span class="line">                        link[<span class="number">0</span>].onClick(<span class="keyword">this</span>);</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (images.length != <span class="number">0</span>) &#123;</span><br><span class="line">                        Drawable drawable = images[<span class="number">0</span>].getDrawable();</span><br><span class="line">                        Bitmap bitmap = <span class="keyword">null</span>;</span><br><span class="line">                        <span class="keyword">if</span> (drawable <span class="keyword">instanceof</span> BitmapDrawable) &#123;</span><br><span class="line">                            bitmap = ((BitmapDrawable) drawable).getBitmap();</span><br><span class="line">                        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (drawable <span class="keyword">instanceof</span> GifDrawable) &#123;</span><br><span class="line">                            bitmap = ((GifDrawable) drawable).getFirstFrame();</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (bitmap != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            AlertDialog.Builder builder = <span class="keyword">new</span> AlertDialog.Builder(getContext());</span><br><span class="line">                            builder.setTitle(<span class="string">"图片预览"</span>);</span><br><span class="line">                            View view = LayoutInflater.from(getContext()).inflate(R.layout.dialog_image_preview, <span class="keyword">null</span>);</span><br><span class="line">                            ImageView imageView = view.findViewById(R.id.image_view);</span><br><span class="line">                            imageView.setImageBitmap(bitmap);</span><br><span class="line">                            builder.setView(view);</span><br><span class="line">                            builder.setPositiveButton(<span class="string">"放大"</span>, <span class="keyword">new</span> DialogInterface.OnClickListener() &#123;</span><br><span class="line">                                <span class="meta">@Override</span></span><br><span class="line">                                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(DialogInterface dialog, <span class="keyword">int</span> which)</span> </span>&#123;</span><br><span class="line">                                    <span class="comment">// 进行图片放大操作</span></span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;);</span><br><span class="line">                            builder.setNegativeButton(<span class="string">"关闭"</span>, <span class="keyword">new</span> DialogInterface.OnClickListener() &#123;</span><br><span class="line">                                <span class="meta">@Override</span></span><br><span class="line">                                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(DialogInterface dialog, <span class="keyword">int</span> which)</span> </span>&#123;</span><br><span class="line">                                    dialog.dismiss();</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;);</span><br><span class="line">                            builder.show();</span><br><span class="line">                            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.onTouchEvent(event);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用方式</span></span><br><span class="line">String html = <span class="string">"这是一张图片： &lt;img src='file:///android_asset/sample.png'&gt;"</span>;</span><br><span class="line"></span><br><span class="line">MyTextView textView = findViewById(R.id.text_view);</span><br><span class="line">textView.setText(Html.fromHtml(html, <span class="keyword">new</span> Html.ImageGetter() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Drawable <span class="title">getDrawable</span><span class="params">(String source)</span> </span>&#123;</span><br><span class="line">        Drawable drawable = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            InputStream inputStream = getAssets().open(source);</span><br><span class="line">            drawable = Drawable.createFromStream(inputStream, <span class="keyword">null</span>);</span><br><span class="line">            drawable.setBounds(<span class="number">0</span>, <span class="number">0</span>, drawable.getIntrinsicWidth(), drawable.getIntrinsicHeight());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> drawable;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, <span class="keyword">null</span>));</span><br><span class="line">textView.setMovementMethod( LinkMovementMethod.getInstance());</span><br></pre></td></tr></table></figure>

<p>在这个示例代码中，我们继承了 <code>AppCompatTextView</code> 并重写了 <code>onTouchEvent</code> 方法。在该方法中，我们使用类似于之前的方式获取点击位置，并查找到该位置对应的 ImageSpan 对象。然后我们根据该对象的 <code>Drawable</code> 对象生成一个 Bitmap 对象，并将其显示在一个自定义的对话框中。在对话框中，用户可以选择放大图片，也可以直接关闭对话框。</p>
<p>需要注意的是，当我们使用 <code>&lt;img&gt;</code> 标记来显示图片时，我们需要在第二个参数中传入一个 <code>ImageGetter</code> 对象，该对象用于将图片加载到 <code>Drawable</code> 中并返回。在本例中，我们通过从 <code>Assets</code> 中读取文件的方式来生成 Drawable 对象，并将其绑定到相应的 <code>ImageSpan</code>中。那么在触发点击事件时，我们只需要找到该位置的 <code>ImageSpan</code> 并获取其 <code>Drawable</code> 对象就能够得到原始的 <code>Bitmap</code> 对象了。</p>
<p><strong>本文内容来自</strong> : ChatGPT</p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em><a href="https://code.newban.cn/">乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</a></em></p>
]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>关于在vue3和原生Html中使用Tailwind CSS</title>
    <url>/430.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><code>Tailwind CSS</code>封装了一套可用于多框架高复用性<code>CSS</code>样式, 能大大简化网页<code>css</code>编写, 具体可参考官网:</p>
<p>官网: <a href="https://tailwindcss.com/" target="_blank" rel="noopener">点击进入</a></p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20230428175340392.png" alt="image-20230428175340392"></p>
<h2 id="在Vue3中使用Tailwind-CSS"><a href="#在Vue3中使用Tailwind-CSS" class="headerlink" title="在Vue3中使用Tailwind CSS"></a>在Vue3中使用Tailwind CSS</h2><p>要在<code>Vue 3</code>中使用<code>Tailwind CSS</code>，需要执行以下步骤：</p>
<ol>
<li>安装<code>Tailwind CSS</code>和其它必要的库</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install tailwindcss postcss autoprefixer</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>创建并配置 <code>postcss.config.js</code> 文件以使用 Tailwind 和 Autoprefixer。将以下内容添加到该文件中：</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="built_in">require</span>(<span class="string">'tailwindcss'</span>),</span><br><span class="line">    <span class="built_in">require</span>(<span class="string">'autoprefixer'</span>)</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>在 <code>src/assets/css</code> 目录下创建一个新文件 <code>tailwind.css</code>, 并添加以下代码：</li>
</ol>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">@<span class="keyword">tailwind</span> base;</span><br><span class="line">@<span class="keyword">tailwind</span> components;</span><br><span class="line">@<span class="keyword">tailwind</span> utilities;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>将 <code>tailwind.css</code> 导入到 Vue 组件中, 比如在 App.vue 中：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    ...</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import &apos;@/assets/css/tailwind.css&apos;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  name: &apos;App&apos;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>确保在项目的 <code>main.js</code> 文件中引入全局样式：</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'@/assets/css/main.css'</span></span><br></pre></td></tr></table></figure>

<ol start="6">
<li>配置 <code>vue.config.js</code> 文件以启用 PostCSS。如果还没有该文件，则创建一个新的，并添加以下内容：</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  css: &#123;</span><br><span class="line">    loaderOptions: &#123;</span><br><span class="line">      postcss: &#123;</span><br><span class="line">        config: &#123;</span><br><span class="line">          path: <span class="string">'./postcss.config.js'</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="7">
<li>运行 <code>npm run serve</code> 后，在浏览器中查看应用程序，Tailwind CSS 应该已经生效了。</li>
</ol>
<p>例如，您可以在组件中使用以下代码来应用 Tailwind CSS 类：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;flex justify-center items-center h-screen bg-gray-100&quot;&gt;</span><br><span class="line">    &lt;h1 class=&quot;text-4xl font-bold text-indigo-600&quot;&gt;Hello, World!&lt;/h1&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure>

<p>这将显示一个居中对齐的灰色背景的页面，其中包含一条带有粗体和蓝色文本的标题。</p>
<h2 id="在原生Html中使用Tailwind-CSS"><a href="#在原生Html中使用Tailwind-CSS" class="headerlink" title="在原生Html中使用Tailwind CSS"></a>在原生Html中使用Tailwind CSS</h2><p>要在原生 <code>HTML</code> 中使用 <code>Tailwind CSS</code>，需要遵循以下步骤：</p>
<ol>
<li>在 HTML 文件中添加 Tailwind 的 CDN 链接。可以通过将以下代码放入 HTML 文件的 <code>&lt;head&gt;</code> 标签内来实现：</li>
</ol>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">"https://cdn.jsdelivr.net/npm/tailwindcss@2.2.15/dist/tailwind.min.css"</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>现在可以在 HTML 文件中使用 Tailwind 的类名称了。例如，要将一个元素的文本颜色设置为红色，可以添加以下代码：</li>
</ol>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"text-red-500"</span>&gt;</span>这是一段红色的文本。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>可以在 Tailwind 的官方文档中找到更多的类和用法示例。</li>
</ol>
<p>注意：在使用 Tailwind 时，请确保您已经了解其工作原理并能够正确地使用它的类名称。如果您不熟悉 Tailwind，请先阅读其文档，以免出现不必要的错误。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>如果需要在<code>vue</code>中全局使用<code>Tailwind CSS</code>, 可以考虑使用安装插件的方式, 一旦使用 那么其他自定义的style将会失效</p>
<p>如果是指某个模块使用, 建议使用原始的<code>css</code>文件导入的方式</p>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>在<code>vue</code>中使用时报错:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Syntax Error: Error: PostCSS plugin tailwindcss requires PostCSS 8.</span><br><span class="line">Migration guide for end-users:</span><br><span class="line">https://github.com/postcss/postcss/wiki/PostCSS-8-for-end-users</span><br></pre></td></tr></table></figure>

<p>解决方案:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">//卸载之前版本</span><br><span class="line">npm uninstall tailwindcss postcss autoprefixer</span><br><span class="line"> </span><br><span class="line">//安装指定兼容版本</span><br><span class="line">npm install tailwindcss@npm:@tailwindcss/postcss7-compat postcss@^7 autoprefixer@^9</span><br></pre></td></tr></table></figure>

<p><strong>本文为作者原创转载时请注明出处 谢谢</strong></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em><a href="https://code.newban.cn/">乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</a></em></p>
]]></content>
      <tags>
        <tag>Web开发</tag>
      </tags>
  </entry>
  <entry>
    <title>查看js对象原型的几种方法</title>
    <url>/429.html</url>
    <content><![CDATA[<h2 id="具体方法"><a href="#具体方法" class="headerlink" title="具体方法"></a>具体方法</h2><p>查看 JavaScript 对象的原型有多种方法，以下是其中的几种：</p>
<ol>
<li><p>使用 <code>Object.getPrototypeOf()</code> 方法获取对象的原型。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;&#125;;</span><br><span class="line"><span class="keyword">const</span> proto = <span class="built_in">Object</span>.getPrototypeOf(obj);</span><br><span class="line"><span class="built_in">console</span>.log(proto);</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用 <code>Object.prototype</code> 属性获取对象的原型。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;&#125;;</span><br><span class="line"><span class="keyword">const</span> proto = obj.__proto__;</span><br><span class="line"><span class="built_in">console</span>.log(proto);</span><br></pre></td></tr></table></figure>
</li>
<li><p>在控制台中使用 <code>console.dir()</code> 方法查看对象的属性和方法，它也会显示对象的原型。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;&#125;;</span><br><span class="line"><span class="built_in">console</span>.dir(obj);</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用 <code>instanceof</code> 运算符检查一个对象是否是另一个对象的实例，这个过程中会涉及到原型链。如果返回值为 <code>true</code> 则说明该对象的原型链中包含了这个构造函数的原型。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">const</span> person = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="built_in">console</span>.log(person <span class="keyword">instanceof</span> Person); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>无论你选择哪种方法，它们都可以帮助你优雅地查看 JavaScript 对象的原型。</p>
<p><strong>本文内容来自</strong> : ChatGPT</p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em><a href="https://code.newban.cn/">乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</a></em></p>
]]></content>
      <tags>
        <tag>Web开发</tag>
      </tags>
  </entry>
  <entry>
    <title>vue3中如何优雅地读取yaml配置文件中的数据</title>
    <url>/428.html</url>
    <content><![CDATA[<h2 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h2><p>要在<code>Vue3</code>中优雅地读取<code>YAML</code>配置文件的数据，可以使用<code>js-yaml</code>库将<code>YAML</code>文件解析成<code>JavaScript</code>对象。然后，您可以将该对象传递给<code>Vue</code>组件或存储在<code>Vuex store</code>中，以便在应用程序中使用。</p>
<p>以下是一个基本示例：</p>
<ol>
<li><p>安装<code>js-yaml</code>库：<code>npm install js-yaml --save</code></p>
</li>
<li><p>创建一个<code>config.yml</code>文件并添加以下内容：</p>
</li>
</ol>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">api:</span></span><br><span class="line"><span class="attr">  url:</span> <span class="attr">https://example.com/api</span></span><br><span class="line"><span class="attr">  timeout:</span> <span class="number">5000</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>在<code>Vue</code>组件中导入<code>js-yaml</code>和<code>config.yml</code>文件：</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> yaml <span class="keyword">from</span> <span class="string">'js-yaml'</span>;</span><br><span class="line"><span class="keyword">import</span> config <span class="keyword">from</span> <span class="string">'./config.yml'</span>;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>使用<code>js-yaml</code>将<code>config.yml</code>解析为<code>JavaScript</code>对象：</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> configObj = yaml.load(config);</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>现在，您可以在组件中使用<code>configObj</code>中的数据：</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      apiUrl: configObj.api.url,</span><br><span class="line">      apiTimeout: configObj.api.timeout</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这样，您就可以在<code>Vue3</code>应用程序中优雅地读取<code>YAML</code>配置文件的数据了。</p>
<p><strong>本文内容来自</strong> : ChatGPT</p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em><a href="https://code.newban.cn/">乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</a></em></p>
]]></content>
      <tags>
        <tag>Web开发</tag>
      </tags>
  </entry>
  <entry>
    <title>如何使用npm卸载旧版本依赖库</title>
    <url>/431.html</url>
    <content><![CDATA[<h2 id="具体如下"><a href="#具体如下" class="headerlink" title="具体如下"></a>具体如下</h2><p>要卸载旧版本的npm库，可以按照以下步骤进行：</p>
<ol>
<li><p>确认要卸载的包名和版本号</p>
<p>在命令行中输入 <code>npm ls &lt;package-name&gt;</code> 命令可以查看当前安装的指定包以及其所有版本的信息。例如，如果要卸载 lodash 库的旧版本，可以运行以下命令来列出所有已安装的 lodash 版本：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm ls lodash</span><br></pre></td></tr></table></figure>

<p>从输出中找到要卸载的版本号，记下来备用。</p>
</li>
<li><p>卸载指定版本的包</p>
<p>在命令行中输入以下命令来卸载指定版本的包：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm uninstall &lt;package-name&gt;@&lt;version&gt;</span><br></pre></td></tr></table></figure>

<p>其中，<code>&lt;package-name&gt;</code> 是要卸载的包名，<code>&lt;version&gt;</code> 是要卸载的具体版本号。例如，如果要卸载 lodash 库的 3.10.1 版本，可以运行以下命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm uninstall lodash@3.10.1</span><br></pre></td></tr></table></figure>

<p>如果要卸载多个版本，需要分别执行多次卸载命令。</p>
</li>
<li><p>（可选）清理不需要的依赖关系</p>
<p>如果卸载某个包后发现其它包不再需要它作为依赖关系，可以使用以下命令来清理不需要的依赖关系：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm prune</span><br></pre></td></tr></table></figure>

<p>这会删除所有没有被任何包所依赖的包和版本，从而减少磁盘空间占用。</p>
</li>
</ol>
<p>注意事项：</p>
<ul>
<li>卸载某个版本的包不会影响已安装的其它版本。</li>
<li>如果要卸载的包是一个依赖项，可能需要更新其它包的依赖关系。可以使用 <code>npm dedupe</code> 命令来重复依赖项并优化依赖关系树。</li>
<li>在卸载包之前，最好备份相关代码和数据以防数据丢失。</li>
</ul>
<p><strong>本文内容来自</strong> : ChatGPT</p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em><a href="https://code.newban.cn/">乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</a></em></p>
]]></content>
      <tags>
        <tag>Web开发</tag>
      </tags>
  </entry>
  <entry>
    <title>Android使用TextView加载Html都支持哪些标签和样式</title>
    <url>/432.html</url>
    <content><![CDATA[<h2 id="支持的标签"><a href="#支持的标签" class="headerlink" title="支持的标签"></a>支持的标签</h2><p><code>Android</code> 原生的 <code>TextView</code> 控件通过 <code>Html.fromHtml()</code> 方法可以加载 <code>HTML</code> 内容，并自动将其转换为<code>Spannable</code> 对象以支持富文本样式和链接等功能。在加载 <code>HTML</code> 内容时，<code>TextView</code>支持的 <code>HTML</code> 标签和样式主要有以下几种：</p>
<h3 id="标题标签"><a href="#标题标签" class="headerlink" title="标题标签"></a>标题标签</h3><p><code>TextView</code> 可以解析 <code>HTML</code> 中的标题标签，包括 <code>&lt;h1&gt;</code>、<code>&lt;h2&gt;</code>、<code>&lt;h3&gt;</code>、<code>&lt;h4&gt;</code>、<code>&lt;h5&gt;</code>、<code>&lt;h6&gt;</code>，并自动转换为对应的样式。</p>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">myTextView.setText(Html.fromHtml(<span class="string">"&lt;h1&gt;这是一级标题&lt;/h1&gt;&lt;h2&gt;这是二级标题&lt;/h2&gt;"</span>));</span><br></pre></td></tr></table></figure>

<h3 id="文本格式标签"><a href="#文本格式标签" class="headerlink" title="文本格式标签"></a>文本格式标签</h3><p><code>TextView</code> 支持的文本格式标签有 <code>&lt;b&gt;</code>（加粗）、<code>&lt;i&gt;</code>（斜体）、<code>&lt;u&gt;</code>（下划线）和 <code>&lt;strike&gt;</code>（删除线）等。在加载<code>HTML</code> 时，这些标签会自动被转换为相应的 Spannable 对象，并应用到对应的文字上。</p>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">myTextView.setText(Html.fromHtml(<span class="string">"&lt;b&gt;这段文字加粗&lt;/b&gt;，&lt;i&gt;这段文字斜体&lt;/i&gt;，&lt;u&gt;这段文字加下划线&lt;/u&gt;，&lt;strike&gt;这段文字带删除线&lt;/strike&gt;"</span>));</span><br></pre></td></tr></table></figure>

<h3 id="列表标签"><a href="#列表标签" class="headerlink" title="列表标签"></a>列表标签</h3><p><code>TextView</code> 支持的列表标签有无序列表 <code>&lt;ul&gt;</code> 和有序列表 <code>&lt;ol&gt;</code>，并会自动转换为相应的 <code>Spannable</code> 对象。</p>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">myTextView.setText(Html.fromHtml(<span class="string">"&lt;ul&gt;&lt;li&gt;这是无序列表的第一项&lt;/li&gt;&lt;li&gt;这是无序列表的第二项&lt;/li&gt;&lt;/ul&gt;&lt;ol&gt;&lt;li&gt;这是有序列表的第一项&lt;/li&gt;&lt;li&gt;这是有序列表的第二项&lt;/li&gt;&lt;/ol&gt;"</span>));</span><br></pre></td></tr></table></figure>

<h3 id="链接标签"><a href="#链接标签" class="headerlink" title="链接标签"></a>链接标签</h3><p><code>TextView</code> 支持的链接标签有 <code>&lt;a&gt;</code>，在加载 <code>HTML</code>时会自动将其转换为 <code>LinkSpan</code> 对象，并允许用户点击跳转到对应的<code>URL</code> 地址。同时，在跳转时，也支持使用自定义的 <code>Callback</code>回调函数进行处理。</p>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">myTextView.setText(Html.fromHtml(<span class="string">"请点击这个 &lt;a href=\"http://www.baidu.com\"&gt;链接&lt;/a&gt;"</span>));</span><br><span class="line">myTextView.setMovementMethod(LinkMovementMethod.getInstance());</span><br></pre></td></tr></table></figure>

<p>除了默认的点击行为之外，我们还可以使用自定义的 <code>URLSpan</code> 和 <code>ClickableSpan</code> 类来处理连接的点击事件，例如弹出一个对话框或者打开一个新的 Activity 等。</p>
<p>示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyLinkMovementMethod</span> <span class="keyword">extends</span> <span class="title">LinkMovementMethod</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTouchEvent</span><span class="params">(TextView widget, Spannable buffer, MotionEvent event)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> action = event.getAction();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (action == MotionEvent.ACTION_UP) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = (<span class="keyword">int</span>) event.getX();</span><br><span class="line">            <span class="keyword">int</span> y = (<span class="keyword">int</span>) event.getY();</span><br><span class="line"></span><br><span class="line">            x -= widget.getTotalPaddingLeft();</span><br><span class="line">            y -= widget.getTotalPaddingTop();</span><br><span class="line"></span><br><span class="line">            x += widget.getScrollX();</span><br><span class="line">            y += widget.getScrollY();</span><br><span class="line"></span><br><span class="line">            Layout layout = widget.getLayout();</span><br><span class="line">            <span class="keyword">int</span> line = layout.getLineForVertical(y);</span><br><span class="line">            <span class="keyword">int</span> off = layout.getOffsetForHorizontal(line, x);</span><br><span class="line"></span><br><span class="line">            URLSpan[] urls = buffer.getSpans(off, off, URLSpan.class);</span><br><span class="line">            ClickableSpan[] cs = buffer.getSpans(off, off, ClickableSpan.class);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (urls.length != <span class="number">0</span>) &#123;</span><br><span class="line">                urls[<span class="number">0</span>].onClick(widget);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cs.length != <span class="number">0</span>) &#123;</span><br><span class="line">                cs[<span class="number">0</span>].onClick(widget);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.onTouchEvent(widget, buffer, event);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码继承了 <code>LinkMovementMethod</code> 类，并重写了 <code>onTouchEvent</code> 方法，用于处理链接的点击事件。具体来说，当用户点击链接时，首先会判断该链接是否是一个 <code>URLSpan</code> 或者 <code>ClickableSpan</code> 对象，如果是，则调用其相应的 <code>onClick()</code> 方法实现自定义的行为。否则，将返回 <code>false</code> 继续使用默认的点击行为。</p>
<p>使用自定义的 <code>MyLinkMovementMethod</code> 可以通过以下方式设置给 TextView：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">myTextView.setMovementMethod(<span class="keyword">new</span> MyLinkMovementMethod());</span><br></pre></td></tr></table></figure>

<p>这样，就可以在用户点击链接时实现自定义的行为了。需要注意的是，实现过程中需要根据具体的需求自己进行相应的代码编写，例如在 <code>onClick()</code> 方法中弹出对话框或启动新的<code>Activity</code> 等。</p>
<p>除此之外还可以使用自定义的 <code>ClickableSpan</code> 对象来实现不同链接的事件处理:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClickableSpan</span> <span class="keyword">extends</span> <span class="title">ClickableSpan</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String mHref;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyClickableSpan</span><span class="params">(String href)</span> </span>&#123;</span><br><span class="line">        mHref = href;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View widget)</span> </span>&#123;</span><br><span class="line">        Context context = widget.getContext();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mHref.startsWith(<span class="string">"myapp://activity_a"</span>)) &#123;</span><br><span class="line">            Intent intent = <span class="keyword">new</span> Intent(context, ActivityA.class);</span><br><span class="line">            context.startActivity(intent);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mHref.startsWith(<span class="string">"myapp://activity_b"</span>)) &#123;</span><br><span class="line">            Intent intent = <span class="keyword">new</span> Intent(context, ActivityB.class);</span><br><span class="line">            context.startActivity(intent);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用方式</span></span><br><span class="line">String html = <span class="string">"&lt;a href=\"myapp://activity_a\"&gt;Activity A&lt;/a&gt;"</span> +</span><br><span class="line">              <span class="string">"&lt;a href=\"myapp://activity_b\"&gt;Activity B&lt;/a&gt;"</span>;</span><br><span class="line"></span><br><span class="line">TextView textView = findViewById(R.id.text_view);</span><br><span class="line">textView.setText(Html.fromHtml(html));</span><br><span class="line">textView.setMovementMethod(LinkMovementMethod.getInstance());</span><br><span class="line">SpannableString text = (SpannableString) textView.getText();</span><br><span class="line">MyClickableSpan[] links = text.getSpans(<span class="number">0</span>, text.length(), MyClickableSpan.class);</span><br><span class="line"><span class="keyword">for</span> (MyClickableSpan span : links) &#123;</span><br><span class="line">    <span class="keyword">int</span> start = text.getSpanStart(span);</span><br><span class="line">    <span class="keyword">int</span> end = text.getSpanEnd(span);</span><br><span class="line">    text.setSpan(span, start, end, Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="图片标签"><a href="#图片标签" class="headerlink" title="图片标签"></a>图片标签</h3><p><code>TextView</code> 支持的图片标签有 <code>&lt;img&gt;</code>，在加载 <code>HTML</code> 时会自动将其转换为 ImageSpan 对象，并将图片显示在对应的位置上。</p>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">myTextView.setText(Html.fromHtml(<span class="string">"&lt;img src=\"https://www.google.com/images/branding/googlelogo/1x/googlelogo_color_272x92dp.png\"/&gt;"</span>));</span><br></pre></td></tr></table></figure>

<p>上面所列举的标签和样式只是 <code>TextView</code>支持的一部分，实际上还有很多其它的标签和样式可以通过 <code>Html.fromHtml()</code> 方法解析并显示出来。但需要注意的是，由于安全性考虑，<code>Android</code> 在解析 <code>HTML</code> 内容时禁止加载 JavaScript、CSS 等内容，因此在使用时需要注意避免加载不安全的 <code>HTML</code> 内容。</p>
<h2 id="支持的样式"><a href="#支持的样式" class="headerlink" title="支持的样式"></a>支持的样式</h2><p>在<code>Android</code>原生<code>TextView</code> 中，通过 <code>Html.fromHtml()</code> 方法加载 <code>HTML</code>标记时，是可以支持部分 <code>CSS</code>样式的。下面是一些常见的 <code>CSS</code> 样式以及它们在 <code>Android</code>原生 <code>TextView</code> 中的表现效果：</p>
<ol>
<li><p>字体大小：<code>font-size</code></p>
<p>可以使用 <code>font-size</code> 属性来设置字体大小，例如：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">style</span>=<span class="string">"font-size: 20px;"</span>&gt;</span>这是一个字体大小为 20px 的段落。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>颜色：<code>color</code></p>
<p>可以使用 <code>color</code> 属性来设置字体颜色，例如：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">style</span>=<span class="string">"color: red;"</span>&gt;</span>这是一个红色的段落。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>字体粗细：<code>font-weight</code></p>
<p>可以使用 <code>font-weight</code> 属性来设置字体粗细，例如：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">style</span>=<span class="string">"font-weight: bold;"</span>&gt;</span>这是一个粗体的段落。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>文本对齐：<code>text-align</code></p>
<p>可以使用 <code>text-align</code> 属性来设置文本对齐方式，例如：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">style</span>=<span class="string">"text-align: center;"</span>&gt;</span>这是一个居中对齐的段落。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>背景颜色：<code>background-color</code></p>
<p>可以使用 <code>background-color</code> 属性来设置背景颜色，例如：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">style</span>=<span class="string">"background-color: yellow;"</span>&gt;</span>这是一个黄色背景的段落。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>下划线：<code>text-decoration</code></p>
<p>可以使用 <code>text-decoration</code> 属性来设置下划线，例如：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">style</span>=<span class="string">"text-decoration: underline;"</span>&gt;</span>这是一个带下划线的段落。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>需要注意的是，并不是所有的 <code>CSS</code> 样式都会被 <code>Android</code> 原生 <code>TextView</code> 支持。同时，在 HTML 标记中使用样式时，需要使用行内样式属性（如上面的示例代码所示），而不能使用外部样式表。如果需要添加进一步的样式，可以考虑使用 <code>SpannableString</code> 或自定义<code>View</code>来进行实现。</p>
<p><strong>本文内容来自</strong> : ChatGPT</p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em><a href="https://code.newban.cn/">乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</a></em></p>
]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>一款免费开源且跨平台的去中心化文件同步工具</title>
    <url>/435.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>今天无意之中发现一个很不错的文件同步工具, 它既不是类似于坚果云那种需要服务器中转的同步工具, 也不是类似于<code>FreeFileSync</code>那种电脑和U盘之间的同步工具, 它其实更像<code>Windows</code>系统中的网上邻居文件共享</p>
<p>但和网上邻居不同的是, 它支持非局域网的远程设备文件实时共享</p>
<p>特别适合多台电脑之间进行远程协作, 唯一缺点就是电脑必须开启才能共享, 在特定场景下还是非常好用的 </p>
<p><strong>该工具特点:</strong></p>
<ul>
<li>跨平台: 支持<code>Windows, Mac, Linux, BSD, Android,群晖</code></li>
<li>免费开源</li>
<li>私密安全: 去中心化的分享方式, 避免第三方服务器中转</li>
</ul>
<p>软件安装后直接在浏览器即可看到当前共享状态:</p>
<p><img src="https://gitee.com/songjianzaina/site_img/raw/master/img/image-20230717151201535.png" alt="image-20230717151201535"></p>
<h2 id="软件下载"><a href="#软件下载" class="headerlink" title="软件下载"></a>软件下载</h2><p>官网: <a href="https://syncthing.net/downloads/" target="_blank" rel="noopener">点击进入</a></p>
<p>Github: <a href="https://github.com/syncthing/syncthing" target="_blank" rel="noopener">点击进入</a></p>
<h2 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤"></a>使用步骤</h2><ol>
<li><p>在需要进行数据共享的设备上都安装<code>syncthing</code>工具</p>
</li>
<li><p>启动并运行该工具(<code>Windows</code>平台运行<code>syncthing.exe</code>文件)</p>
</li>
<li><p>浏览器地址栏输入<code>http://localhost:8384</code>打开控制面板</p>
</li>
<li><p>相互添加远程设备</p>
<p><img src="https://gitee.com/songjianzaina/site_img/raw/master/img/image-20230827145215469.png" alt="image-20230827145215469"></p>
</li>
<li><p>相互添加需要共享的文件夹 并共享给对方的设备</p>
<p><img src="https://gitee.com/songjianzaina/site_img/raw/master/img/image-20230827143031588.png" alt="image-20230827143031588"></p>
<p><img src="https://gitee.com/songjianzaina/site_img/raw/master/img/image-20230827142934567.png" alt="image-20230827142934567"></p>
<p>注: 这里需要注意的是,设备之间的文件夹ID需要填写相同的名称</p>
</li>
<li><p>修改最低空闲磁盘空间(可选)</p>
<p>如果你的磁盘空间不是太充裕, 那么需要在页面右上角设置菜单中修改最低空闲磁盘空间, 否则无法共享, 这里我设置为0.1%</p>
<p><img src="https://gitee.com/songjianzaina/site_img/raw/master/img/image-20230827142416049.png" alt="image-20230827142416049"></p>
<p>同时 文件夹设置中也需要进行更改:</p>
<p><img src="https://gitee.com/songjianzaina/site_img/raw/master/img/image-20230827144501846.png" alt="image-20230827144501846"></p>
</li>
<li><p>开始共享</p>
<p>任意设备在共享文件夹中添加或者删除文件 其他设备都会同步更新</p>
</li>
</ol>
<h2 id="相关资料"><a href="#相关资料" class="headerlink" title="相关资料"></a>相关资料</h2><p>官网: <a href="https://syncthing.net/" target="_blank" rel="noopener">点击进入</a></p>
<p>官方论坛: <a href="https://forum.syncthing.net/" target="_blank" rel="noopener">点击进入</a></p>
<p>工具使用案例: 《<a href="https://www.aaroncendan.me/side-projects/reaper-sync" target="_blank" rel="noopener">Synchronizing REAPER Installs Across Computers</a>》</p>
<p><strong>本文为作者原创转载时请注明出处 谢谢</strong></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em><a href="https://code.newban.cn/">乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</a></em></p>
]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>关于Android使用TextView加载Html实现图片居中显示</title>
    <url>/434.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在 <code>Android</code>原生 <code>TextView</code> 中加载 <code>HTML</code> 图片时，默认情况下图片会按照其原来的大小显示，并且会与文字共存，而不会像网页中一样默认居中显示。如果需要在 <code>TextView</code> 中将图片居中显示, 可以使用以下几种方式</p>
<h2 id="实现方案"><a href="#实现方案" class="headerlink" title="实现方案"></a>实现方案</h2><h3 id="第一种-使用自定义-ImageGetter"><a href="#第一种-使用自定义-ImageGetter" class="headerlink" title="第一种 使用自定义 ImageGetter"></a>第一种 使用自定义 <code>ImageGetter</code></h3><p>可以通过自定义<code>ImageGetter</code> 来实现图片居中显示。<code>ImageGetter</code>接口定义了获取 <code>Drawable</code>的方法，我们可以在这个方法中对图片进行处理，使其能够居中显示。以下是一个示例代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CenteredImageSpan</span> <span class="keyword">implements</span> <span class="title">LineHeightSpan</span>, <span class="title">Html</span>.<span class="title">ImageGetter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Context mContext;</span><br><span class="line">    <span class="keyword">private</span> Drawable mDrawable;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CenteredImageSpan</span><span class="params">(Context context, Drawable drawable)</span> </span>&#123;</span><br><span class="line">        mContext = context;</span><br><span class="line">        mDrawable = drawable;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getLeadingMargin</span><span class="params">(<span class="keyword">boolean</span> first)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mDrawable.getIntrinsicWidth() / <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">(Canvas canvas, CharSequence text, <span class="keyword">int</span> start, <span class="keyword">int</span> end, <span class="keyword">float</span> x, <span class="keyword">int</span> top, <span class="keyword">int</span> y, <span class="keyword">int</span> bottom, Paint paint)</span> </span>&#123;</span><br><span class="line">        canvas.save();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> transY = bottom - mDrawable.getBounds().bottom;</span><br><span class="line"></span><br><span class="line">        canvas.translate(x + getLeadingMargin(<span class="keyword">true</span>), transY / <span class="number">2</span>);</span><br><span class="line">        mDrawable.draw(canvas);</span><br><span class="line"></span><br><span class="line">        canvas.restore();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Drawable <span class="title">getDrawable</span><span class="params">(String source)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (mDrawable == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 获取图片</span></span><br><span class="line">            Bitmap bitmap = BitmapFactory.decodeFile(source);</span><br><span class="line">            mDrawable = <span class="keyword">new</span> BitmapDrawable(mContext.getResources(), bitmap);</span><br><span class="line">            mDrawable.setBounds(<span class="number">0</span>, <span class="number">0</span>, mDrawable.getIntrinsicWidth(), mDrawable.getIntrinsicHeight());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> mDrawable;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该示例代码主要通过实现 <code>ImageGetter</code> 接口和 <code>LineHeightSpan</code> 接口来实现图片的居中显示。通过实现 <code>Drawable</code>的 <code>getDrawable()</code>方法，我们可以在这里获取图片，并在 <code>draw()</code>方法中实现图片的绘制。而由于图片的高度是不确定的，我们需要通过实现 <code>LineHeightSpan</code> 接口来控制行间距，以使得图片垂直居中。</p>
<p>使用上述代码，可以在 <code>HTML</code> 代码中添加以下标签，来调用自定义的 <code>CenteredImageSpan</code> 类：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"file:///android_asset/1.jpg"</span> <span class="attr">width</span>=<span class="string">"200"</span> <span class="attr">align</span>=<span class="string">"middle"</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="第二种-使用-Html-TagHandler-和-CSS-样式"><a href="#第二种-使用-Html-TagHandler-和-CSS-样式" class="headerlink" title="第二种 使用 Html.TagHandler 和 CSS 样式"></a>第二种 使用 <code>Html.TagHandler</code> 和 <code>CSS</code> 样式</h3><p>可以通过自定义<code>Html.TagHandler</code> 和 <code>CSS</code> 样式来实现图片居中显示。以下是一个示例代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CenterImageTagHandler</span> <span class="keyword">implements</span> <span class="title">Html</span>.<span class="title">TagHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> TextView mTextView;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CenterImageTagHandler</span><span class="params">(TextView textView)</span> </span>&#123;</span><br><span class="line">        mTextView = textView;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleTag</span><span class="params">(<span class="keyword">boolean</span> opening, String tag, Editable output, XMLReader xmlReader)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (tag.equalsIgnoreCase(<span class="string">"img"</span>)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (opening) &#123;</span><br><span class="line">                <span class="comment">// 处理图片标签</span></span><br><span class="line">                ImageSpanCenter span = <span class="keyword">new</span> ImageSpanCenter(mTextView.getContext(), <span class="keyword">null</span>);</span><br><span class="line">                output.setSpan(span, output.length(), output.length(), Spannable.SPAN_MARK_MARK);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 处理结束标签</span></span><br><span class="line">                Object[] obj = output.getSpans(<span class="number">0</span>, output.length(), Object.class);</span><br><span class="line">                <span class="keyword">if</span> (obj != <span class="keyword">null</span> &amp;&amp; obj.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    Object span = obj[obj.length - <span class="number">1</span>];</span><br><span class="line">                    <span class="keyword">int</span> start = output.getSpanStart(span);</span><br><span class="line">                    <span class="keyword">int</span> end = output.length();</span><br><span class="line">                    output.removeSpan(span);</span><br><span class="line">                    <span class="keyword">if</span> (start != end) &#123;</span><br><span class="line">                        <span class="comment">// 设置图片的对齐方式为居中</span></span><br><span class="line">                        span = <span class="keyword">new</span> ImageSpanCenter(mTextView.getContext(), ((ImageSpan) span).getDrawable());</span><br><span class="line">                        output.setSpan(span, start, end, Spannable.SPAN_EXCLUSIVE_EXCLUSIVE);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ImageSpanCenter</span> <span class="keyword">extends</span> <span class="title">ImageSpan</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        ImageSpanCenter(Context context, Drawable drawable) &#123;</span><br><span class="line">            <span class="keyword">super</span>(drawable);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">(Canvas canvas, CharSequence text, <span class="keyword">int</span> start, <span class="keyword">int</span> end, <span class="keyword">float</span> x, <span class="keyword">int</span> top, <span class="keyword">int</span> y, <span class="keyword">int</span> bottom, Paint paint)</span> </span>&#123;</span><br><span class="line">            Drawable drawable = getDrawable();</span><br><span class="line"></span><br><span class="line">            canvas.save();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取 TextView 的宽度</span></span><br><span class="line">            <span class="keyword">float</span> textWidth = paint.measureText(text, start, end);</span><br><span class="line">            Layout layout = ((TextView) ((Spanned) text).getSpans(<span class="number">0</span>, ((Spanned) text).length(), Object.class)[<span class="number">0</span>]).getLayout();</span><br><span class="line">            <span class="keyword">float</span> viewWidth = layout.getWidth();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">float</span> transX = (viewWidth - textWidth) / <span class="number">2</span> - drawable.getIntrinsicWidth() / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">            canvas.translate(x + transX, (top + bottom) / <span class="number">2</span> - drawable.getIntrinsicHeight() / <span class="number">2</span>);</span><br><span class="line">            drawable.draw(canvas);</span><br><span class="line"></span><br><span class="line">            canvas.restore();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该示例代码主要通过实现 <code>Html.TagHandler</code>接口和自定义 <code>ImageSpan</code> 类来实现图片的居中显示。通过实现 <code>TagHandler</code> 的 <code>handleTag()</code> 方法，我们可以在这里处理 <code>img</code> 标签，并在对应的位置插入一个<code>ImageSpan</code> 对象。而<code>ImageSpan</code> 可以通过重写 <code>draw()</code> 方法来实现图片的绘制。通过测量 <code>TextView</code>和文本的宽度，并使用 <code>translate()</code>方法来实现图片的水平居中和垂直居中。</p>
<p>使用上述代码，可以在 <code>HTML</code> 代码中添加以下标签和样式，来调用自定义的 <code>CenterImageTagHandler</code> 类：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"file:///android_asset/1.jpg"</span> <span class="attr">width</span>=<span class="string">"200"</span> <span class="attr">style</span>=<span class="string">"display:block;margin:0 auto;"</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="第三种-给img标签包一层div然后添加居中样式"><a href="#第三种-给img标签包一层div然后添加居中样式" class="headerlink" title="第三种 给img标签包一层div然后添加居中样式"></a>第三种 给img标签包一层div然后添加居中样式</h3><p>这种方式最为简单, 具体<code>html</code>代码如下:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"text-align:center"</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"图片地址"</span> /&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>以上几种方式都可以实现图片居中显示，只是实现方法不同，选择哪种方式主要是根据实际情况灵活选择。</p>
<p><strong>本文内容来自</strong> : ChatGPT</p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em><a href="https://code.newban.cn/">乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</a></em></p>
]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>如何对网页进行防调试配置</title>
    <url>/436.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>有时候我们需要对网页进行反爬虫和防浏览器调试抓包</p>
<p>只需在网页源代码尾部添加一段代码即可实现</p>
<h2 id="具体代码"><a href="#具体代码" class="headerlink" title="具体代码"></a>具体代码</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 禁开发者工具调试 --&gt;</span><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">    <span class="comment">//如果用户在工具栏调起开发者工具，那么判断浏览器的可视高度和可视宽度是否有改变，如有改变则关闭本页面 </span></span></span><br><span class="line"><span class="actionscript">    <span class="comment">// var debuggerH = window.innerHeight, debuggerW = window.innerWidth;</span></span></span><br><span class="line"><span class="actionscript">    <span class="comment">// window.onresize = function () &#123;</span></span></span><br><span class="line"><span class="actionscript">    <span class="comment">//     if (debuggerH != window.innerHeight || debuggerW != window.innerWidth) &#123;</span></span></span><br><span class="line"><span class="actionscript">    <span class="comment">//         window.close();</span></span></span><br><span class="line"><span class="actionscript">    <span class="comment">//         window.location = "about:blank";</span></span></span><br><span class="line"><span class="actionscript">    <span class="comment">//     &#125;</span></span></span><br><span class="line"><span class="actionscript">    <span class="comment">// &#125;</span></span></span><br><span class="line"></span><br><span class="line"><span class="actionscript"> <span class="comment">// 无限的 debugger 兼容性好</span></span></span><br><span class="line"><span class="actionscript">    setInterval(<span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span></span><br><span class="line">        debuggerCheck();</span><br><span class="line">      &#125;, 2000);</span><br><span class="line"><span class="actionscript">      <span class="keyword">var</span> debuggerCheck = <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">        <span class="function"><span class="keyword">function</span> <span class="title">doCheck</span><span class="params">(a)</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">          <span class="keyword">if</span> ((<span class="string">''</span> + a / a)[<span class="string">'length'</span>] !== <span class="number">1</span> || a % <span class="number">20</span> === <span class="number">0</span>) &#123;</span></span><br><span class="line"><span class="actionscript">            (<span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;&#125;[<span class="string">'constructor'</span>](<span class="string">'debugger'</span>)());</span></span><br><span class="line"><span class="actionscript">          &#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="actionscript">            (<span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;&#125;[<span class="string">'constructor'</span>](<span class="string">'debugger'</span>)());</span></span><br><span class="line">          &#125;</span><br><span class="line">          doCheck(++a);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="actionscript">        <span class="keyword">try</span> &#123;</span></span><br><span class="line">          doCheck(0);</span><br><span class="line"><span class="actionscript">        &#125; <span class="keyword">catch</span> (err) &#123;&#125;</span></span><br><span class="line">      &#125;;</span><br><span class="line">      debuggerCheck();</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="突破封锁"><a href="#突破封锁" class="headerlink" title="突破封锁"></a>突破封锁</h2><p>作为用户来说, 这种防调试手段的确很烦人, 有时候我们可能需要抓取网页当中的视频流, 比如抓取网页中的M3U8地址</p>
<p>此时我们可以通过安装浏览器插件的方式来解决, 以谷歌浏览器为例, 这里给大家介绍一款好用的网页媒体嗅探插件, 名叫<strong>猫爪</strong>:</p>
<p><img src="https://gitee.com/songjianzaina/site_img/raw/master/img/image-20230924141300072.png" alt="image-20230924141300072"></p>
<p>这个插件不仅可以嗅探视频链接, 还能直接播放和下载, 很是强大:</p>
<p><img src="https://gitee.com/songjianzaina/site_img/raw/master/img/image-20230924141940042.png" alt="image-20230924141940042"></p>
<p><img src="https://gitee.com/songjianzaina/site_img/raw/master/img/image-20230924142213584.png" alt="image-20230924142213584"></p>
<p><strong>本文为作者原创转载时请注明出处 谢谢</strong></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em><a href="https://code.newban.cn/">乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</a></em></p>
]]></content>
      <tags>
        <tag>实用技巧</tag>
      </tags>
  </entry>
  <entry>
    <title>Android studio解决依赖冲突的三种有效方法</title>
    <url>/44.html</url>
    <content><![CDATA[<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/20150819072344805.jpg" alt></p>
<h3 id="第一种："><a href="#第一种：" class="headerlink" title="第一种："></a>第一种：</h3><p>排除依赖中的指定包</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">compile (&apos;com.mcxiaoke.viewpagerindicator:library:2.4.1&apos;) &#123;</span><br><span class="line">  exclude group: &apos;com.android.support&apos;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h3 id="第二种："><a href="#第二种：" class="headerlink" title="第二种："></a>第二种：</h3><p>force强制设置某个模块的版本</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">configurations.all &#123;</span><br><span class="line"> resolutionStrategy &#123;</span><br><span class="line">      force &apos;com.android.support:support-v4:24.1.0&apos;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h3 id="第二种：-1"><a href="#第二种：-1" class="headerlink" title="第二种："></a>第二种：</h3><p>force强制设置整个工程的的版本 在根目录的gradle.build文件中设置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">allprojects &#123;</span><br><span class="line">   </span><br><span class="line">    configurations.all &#123;</span><br><span class="line">        resolutionStrategy.eachDependency &#123; DependencyResolveDetails details -&gt;</span><br><span class="line">            def requested = details.requested</span><br><span class="line">            if (requested.group == &apos;com.android.support&apos;) &#123;</span><br><span class="line">                if (requested.name.startsWith(&quot;support-fragment&quot;)) &#123;</span><br><span class="line">                    details.useVersion &apos;28.0.0&apos;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>本文为作者原创 转载时请注明出处 谢谢</strong></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em>乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</em></p>
]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>移动设备下，我都用什么app来管理我的NAS</title>
    <url>/438.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>大多数人使用nas都是在pc端，不管你是通过web界面也好，还是通过映射管理你nas上的文件也好，pc端永远都是nas的主要操作环境。而今天我介绍的便是我自己移动端下的一些app或者小程序等服务，通过这一系列服务，实现移动端操作nas某一部分特定的功能。</p>
<p><img src="https://gitee.com/songjianzaina/site_img/raw/master/img/63ba3083896ce8875.png_e1080.jpg" alt="app"></p>
<h2 id="app"><a href="#app" class="headerlink" title="app"></a>app</h2><h3 id="「ds-file」"><a href="#「ds-file」" class="headerlink" title="「ds file」"></a>「ds file」</h3><p>由群晖科技官方推出的一款文件远程管理手机软件，用户可以非常轻松的进行图片、视频、txt文件的浏览。也可以直接在移动设备端通过ds file直接上传下载文件或进行基本的编辑。</p>
<p><img src="https://gitee.com/songjianzaina/site_img/raw/master/img/63ba3083834897112.png_e1080.jpg" alt="文件夹"></p>
<p>但是！以上功能我一个都用不上，之所以手机会有ds file，全是为了同步相册罢了，moments移动端的同步功能太难用了，而且如果使用群晖的相册同步也就意味着你的照片在传到nas后会被打乱，它会通过生成一个一个文件夹来存放你的同步，这点我接受不了。而通过ds file同步，它只会同步你想要同步的文件夹，不会胡乱的打乱你的照片存放。</p>
<p><img src="https://gitee.com/songjianzaina/site_img/raw/master/img/63ba308389f466840.png_e1080.jpg" alt="同步相册"></p>
<h3 id="「群晖助手」"><a href="#「群晖助手」" class="headerlink" title="「群晖助手」"></a>「群晖助手」</h3><p>由民间大神开发的一款开源的群晖管理应用。可以管理nas各个文件夹的内容，支持系统状况、存储、资源监控、目前连接用户、计划任务、最新日志、缓存状态，查看系统消息，查看套件信息。总之它的功能太多了，基本可以实现大部分nas的操作了，而且作者还一直在更新，只不过最近加了开屏广告，不过也能理解。</p>
<p><img src="https://gitee.com/songjianzaina/site_img/raw/master/img/63ba308387a655010.png_e1080.jpg" alt="控制台"></p>
<p>用过群晖助手后再对比一下群晖官方的软件，真的就一坨答辩O.o，而且明明很多功能是可以集成的，非要搞一堆app出来，真的逆天。我的建议是群晖直接花重金买软件版权，emmm不对，按照群晖的尿性，买了后估计是不会继续更新了，建议直接聘用作者。</p>
<p><img src="https://gitee.com/songjianzaina/site_img/raw/master/img/63ba308384ebd7660.png_e1080.jpg" alt="更新公告"></p>
<h3 id="「EMBY」"><a href="#「EMBY」" class="headerlink" title="「EMBY」"></a>「EMBY」</h3><p>emby我觉得不需要过多的介绍了。app端的emby体验上相对于网页端基本没有什么差别，web能操作的app上基本都是同样可以操作的，包括控制台这一类。</p>
<p><img src="https://gitee.com/songjianzaina/site_img/raw/master/img/63ba308419d066441.png_e1080.jpg" alt="控制台"></p>
<p>对于折腾好的东西我一向是不想折腾第二遍的，所以除了emby我也没使用过其他的媒体套件了，当然群晖自带的还是用过。在众多的媒体管理套件中，大家觉得拿一个好用呢？我可以去尝试一下。</p>
<p><img src="https://gitee.com/songjianzaina/site_img/raw/master/img/63ba308425eb69535.png_e1080.jpg" alt="媒体库"></p>
<h3 id="「moents」"><a href="#「moents」" class="headerlink" title="「moents」"></a>「moents」</h3><p>moments支持自动扫描识别相似的照片，可以将像素较低的照片删除节省手机空间，可以按照关键字来查找和预览照片，还可以将手机里的照片备份到moments里面。当然同步功能我是用不上，毕竟我已经使用ds file同步了，所以moments的同步我一直都是关闭状态。</p>
<p><img src="https://gitee.com/songjianzaina/site_img/raw/master/img/63ba30842e0f04071.png_e1080.jpg" alt="主题"></p>
<p>我的mometns主要作用还是查看和下载照片，有时候和爱人或者朋友在一起，翻翻之前的照片聊聊以前的事情，这种氛围还蛮不错的。我几乎所有照片都存在nas，这导致我moments大概有接近3000找照片，手机上从来都是不存照片的。（谁知道moments的智能助手能关吗？）</p>
<h3 id="「mix文件管理」"><a href="#「mix文件管理」" class="headerlink" title="「mix文件管理」"></a>「mix文件管理」</h3><p>这并不是一个用于群晖的app，为什么要介绍它？因为它拥有webdav、smb以及众多网盘等功能，这让我可以直接使用手机通过webdav或者smb链接群晖。群晖官方的app太烂了，而群晖助手自带的一些播放器或者编辑器兼容性太差，而mix能够实现几乎所有文档的编辑与查看功能，同时还能作为手机自带文件管理器的替代品。</p>
<p><img src="https://gitee.com/songjianzaina/site_img/raw/master/img/63ba30842f5139187.png_e1080.jpg" alt="界面"></p>
<h3 id="「drive」"><a href="#「drive」" class="headerlink" title="「drive」"></a>「drive」</h3><p>支持在手机上将各种文档文件进行安全备份处理，不仅可以备份音乐、视频、图片、文件等，还可以直接备份应用以及数据。作为群晖官方的同步工具，我实际使用几乎为0，下这个软件的原因是为了同步工作日程表，后面发现mix一样可以做到，就再也没用过了。</p>
<p><img src="https://gitee.com/songjianzaina/site_img/raw/master/img/63ba30842db868991.png_e1080.jpg" alt="drive"></p>
<p>以上便是我目前手机所有app类的群晖相关应用，当然除了以上这些还有很多适用于群晖的app，例如群晖ds cam摄像头监控软件、ds audio软件、ds finder远程唤醒app以及note station笔记软件等等。这些就不一一介绍了，使用方法都很简单，功能也很明了。</p>
<h2 id="小程序"><a href="#小程序" class="headerlink" title="小程序"></a>小程序</h2><h3 id="「随身PT」"><a href="#「随身PT」" class="headerlink" title="「随身PT」"></a>「随身PT」</h3><p>顾名思义，一款能监控PT下器的小程序，可以添加多个服务器，也能通过链接或者本地上传添加种子，还能显示pt对应的标签。</p>
<p><img src="https://gitee.com/songjianzaina/site_img/raw/master/img/63ba30844061e5380.png_e1080.jpg" alt="种子界面"></p>
<p>整体作为一个监控pt的工具还是不错，不过不能链接pt站点，也不能使用服务器预设的下载路径很不方便，如果想要下载，还需要手动去更改路径。</p>
<h3 id="「PT管理宝」"><a href="#「PT管理宝」" class="headerlink" title="「PT管理宝」"></a>「PT管理宝」</h3><p><img src="https://gitee.com/songjianzaina/site_img/raw/master/img/63ba3084aedcc6040.jpg_e1080.jpg" alt="统计信息"></p>
<p>我一直在使用的工具，相对于上一款，它既能限时服务器统计信息，也能通过服务器预设分类直接按照分类路径下载，最重要的是它存在docker容器，在群晖端设置好docker容器后，便可以直接通过小程序链接各类“知名”PT站点，并且支持搜索和直接下载。</p>
<p><img src="https://gitee.com/songjianzaina/site_img/raw/master/img/63ba3084c325d641.jpg_e1080.jpg" alt="下载"></p>
<p>由于“知名”PT站点的内容不好截图，我这里就不展示了。有兴趣的小伙伴可以自行研究或评论区讨论。</p>
<h2 id="后述"><a href="#后述" class="headerlink" title="后述"></a>后述</h2><p>以上便是我手机端的所有关于nas的应用以及小程序了，针对适应手机的web界面没什么可介绍的，所以在这里就不讲了。手机作为每天使用最多的工具，能够使用手机更好的操控nas，那么我一定会选择手机，毕竟有时候下班回到家压根不想打开电脑。</p>
<p><strong>本文转载自</strong>:<a href="https://post.smzdm.com/p/a5oxe4ox/" target="_blank" rel="noopener">什么值得买</a></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em><a href="https://code.newban.cn/">乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</a></em></p>
]]></content>
      <tags>
        <tag>NAS</tag>
      </tags>
  </entry>
  <entry>
    <title>M3U8在线播放和下载工具</title>
    <url>/437.html</url>
    <content><![CDATA[<h2 id="在线播放"><a href="#在线播放" class="headerlink" title="在线播放"></a>在线播放</h2><p><a href="https://m3u8-player.com/" target="_blank" rel="noopener">点击进入</a></p>
<h2 id="在线下载提取"><a href="#在线下载提取" class="headerlink" title="在线下载提取"></a>在线下载提取</h2><p><a href="http://blog.luckly-mjw.cn/tool-show/m3u8-downloader/index.html" target="_blank" rel="noopener">点击进入</a></p>
<p><img src="https://gitee.com/songjianzaina/site_img/raw/master/img/image-20230924145356260.png" alt="image-20230924145356260"></p>
<h2 id="网页M3U8嗅探播放和下载"><a href="#网页M3U8嗅探播放和下载" class="headerlink" title="网页M3U8嗅探播放和下载"></a>网页M3U8嗅探播放和下载</h2><p>需要安装一个<code>Chorme</code>插件, 名叫<strong>猫抓</strong>:</p>
<p><img src="https://gitee.com/songjianzaina/site_img/raw/master/img/image-20230924141300072.png" alt="image-20230924141300072"></p>
<p>这个插件不仅可以嗅探视频链接, 还能直接播放和下载, 并且支持任意m3u8地址的解析, 很是强大:</p>
<p><img src="https://gitee.com/songjianzaina/site_img/raw/master/img/image-20230924141940042.png" alt="image-20230924141940042"></p>
<p><img src="https://gitee.com/songjianzaina/site_img/raw/master/img/image-20230924142213584.png" alt="image-20230924142213584"></p>
<p><img src="https://gitee.com/songjianzaina/site_img/raw/master/img/image-20230924144328549.png" alt="image-20230924144328549"></p>
<p>此插件已经开源:<a href="https://github.com/xifangczy/cat-catch" target="_blank" rel="noopener">GitHub</a></p>
<p><strong>本文为作者原创转载时请注明出处 谢谢</strong></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em><a href="https://code.newban.cn/">乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</a></em></p>
]]></content>
      <tags>
        <tag>实用技巧</tag>
      </tags>
  </entry>
  <entry>
    <title>一款好用的网盘管理工具Alist</title>
    <url>/439.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近在折腾<code>NAS</code>,发现一款比较好用的跨平台网盘管理工具,名为<code>Alist</code></p>
<p><img src="https://gitee.com/songjianzaina/site_img/raw/master/img/image-20231223120448624.png" alt="image-20231223120448624"></p>
<p>这款工具不仅支持群晖系统和<code>docker</code>容器, 还支持主流的桌面系统,如下图:</p>
<p><img src="https://gitee.com/songjianzaina/site_img/raw/master/img/image-20231223120250775.png" alt="image-20231223120250775"></p>
<p>它不仅可以管理多个网盘,还可以将其挂载到电脑本地使用, 可谓是网盘党的福音</p>
<h2 id="支持的网盘厂商"><a href="#支持的网盘厂商" class="headerlink" title="支持的网盘厂商"></a>支持的网盘厂商</h2><p>支持市面上主流的网盘,包括但不限于百度网盘,阿里云盘,谷歌网盘等等</p>
<p><img src="https://gitee.com/songjianzaina/site_img/raw/master/img/image-20231223121137429.png" alt="image-20231223121137429"></p>
<h2 id="使用说明"><a href="#使用说明" class="headerlink" title="使用说明"></a>使用说明</h2><p>Alist功能很强大, 具体的使用说明详见官方文档:</p>
<p>Alist官方文档: <a href="https://alist.nn.ci/zh/" target="_blank" rel="noopener">点击进入</a></p>
<h2 id="Alist下载"><a href="#Alist下载" class="headerlink" title="Alist下载"></a>Alist下载</h2><p>GitHub: <a href="https://github.com/alist-org/desktop-release" target="_blank" rel="noopener">点击进入</a></p>
<p>Alist官网: <a href="https://ad.nn.ci/zh" target="_blank" rel="noopener">点击进入</a></p>
<p><strong>本文为作者原创转载时请注明出处 谢谢</strong></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em><a href="https://code.newban.cn/">乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</a></em></p>
]]></content>
      <tags>
        <tag>NAS</tag>
      </tags>
  </entry>
  <entry>
    <title>ubuntu系统部署Frps实现内网穿透</title>
    <url>/443.html</url>
    <content><![CDATA[<h2 id="部署环境"><a href="#部署环境" class="headerlink" title="部署环境"></a>部署环境</h2><ul>
<li>阿里云<code>ubuntu</code>64位系统</li>
</ul>
<h2 id="部署Frps"><a href="#部署Frps" class="headerlink" title="部署Frps"></a>部署Frps</h2><ol>
<li><p>下载<code>frps</code>工具</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget https://github.com/fatedier/frp/releases/download/v0.53.2/frp_0.53.2_linux_amd64.tar.gz</span><br></pre></td></tr></table></figure>

<p>这里使用当前最新的<code>0.53.2</code>版本,可前往<a href="https://github.com/fatedier/frp/releases" target="_blank" rel="noopener">GitHub</a>指定具体版本下载</p>
</li>
<li><p>解压文件</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">tar -zxvf frp_0.53.2_linux_amd64.tar.gz</span><br></pre></td></tr></table></figure>
</li>
<li><p>在<code>frps.toml</code>配置文件中填写配置信息</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="section">[common]</span></span><br><span class="line"><span class="comment"># 内网穿透端口配置</span></span><br><span class="line"><span class="attr">bind_addr</span> = <span class="number">0.0</span>.<span class="number">0.0</span></span><br><span class="line"><span class="attr">bind_port</span> = <span class="number">7000</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># WEB控制面板相关配置</span></span><br><span class="line"><span class="attr">dashboard_addr</span> = <span class="number">0.0</span>.<span class="number">0.0</span></span><br><span class="line"><span class="attr">dashboard_port</span> = <span class="number">7500</span></span><br><span class="line"><span class="attr">dashboard_user</span> = admin</span><br><span class="line"><span class="attr">dashboard_pwd</span> = admin</span><br><span class="line"></span><br><span class="line"><span class="comment"># 日志相关配置</span></span><br><span class="line"><span class="attr">log_file</span> = ./frps.log</span><br><span class="line"><span class="attr">log_level</span> = info</span><br><span class="line"><span class="attr">log_max_days</span> = <span class="number">3</span></span><br><span class="line"><span class="attr">disable_log_color</span> = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># auth token</span></span><br><span class="line"><span class="attr">token</span> = <span class="number">12345678</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 子域名配置</span></span><br><span class="line"><span class="attr">subdomain_host</span> = frps.com</span><br><span class="line"></span><br><span class="line"><span class="attr">allow_ports</span> = <span class="number">2000</span>-<span class="number">3000</span>,<span class="number">3001</span>,<span class="number">3003</span>,<span class="number">4000</span>-<span class="number">50000</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="attr">max_pool_count</span> = <span class="number">5</span></span><br><span class="line"><span class="attr">max_ports_per_client</span> = <span class="number">0</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>运行<code>frps</code>程序</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./frps -c frps.toml</span><br></pre></td></tr></table></figure>
</li>
<li><p>验证程序是否可用</p>
<p>首先在阿里云后台安全组开放<code>7000</code>和<code>7500</code>端口方便外网访问</p>
<p>配置好后在浏览器中输入<code>http://服务器ip:7500</code>,看控制面板界面是否能正常打开</p>
<p>打开后界面如下:</p>
<p><img src="https://gitee.com/songjianzaina/site_img/raw/master/img/image-20240104163746870.png" alt="image-20240104163746870"></p>
</li>
<li><p>将<code>frps</code>设置后台运行</p>
<ol>
<li><p><code>进入systemctl</code>目录，创建<code>frps.service</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /etc/systemd/system/</span><br><span class="line">vim frps.service</span><br><span class="line"><span class="comment"># 或者直接</span></span><br><span class="line">vim /etc/systemd/system/frps.service</span><br></pre></td></tr></table></figure>
</li>
<li><p>复制下面的代码到文件<code>frps.service</code>中</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[Unit]</span><br><span class="line"><span class="comment"># 服务名称，可自定义</span></span><br><span class="line">Description = frp server</span><br><span class="line">After = network.target syslog.target</span><br><span class="line">Wants = network.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type = simple</span><br><span class="line"><span class="comment"># 启动frps的命令，需修改为您的frps的安装路径</span></span><br><span class="line">ExecStart = /root/frp_0.53.2_linux_amd64/frps -c /root/frp_0.53.2_linux_amd64/frps.toml</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy = multi-user.target</span><br></pre></td></tr></table></figure>
</li>
<li><p>启动该后台服务</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl start frps</span><br></pre></td></tr></table></figure>

<p>可通过<code>systemctl status frps</code>指令查看服务运行日志</p>
</li>
</ol>
</li>
<li><p>将<code>frps</code>设置开机自启动</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl <span class="built_in">enable</span> frps</span><br></pre></td></tr></table></figure>
</li>
<li><p>至此, <code>frps</code>安装完毕</p>
<p>接下来,可在需要进行内网穿透的电脑上安装<code>frpc</code>来实现内网穿透,具体详见之前的文章:《<a href="https://code.newban.cn/372.html">使用frp进行内网穿透实现外网访问局域网中的服务器</a>》</p>
</li>
</ol>
<p><strong>本文为作者原创 转载时请注明出处 谢谢</strong></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em><a href="https://code.newban.cn/">乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</a></em></p>
]]></content>
      <tags>
        <tag>frp</tag>
      </tags>
  </entry>
  <entry>
    <title>推荐几款好用的跨平台磁力or种子下载工具</title>
    <url>/440.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>老司机必备,且往下看</p>
<h2 id="Motrix"><a href="#Motrix" class="headerlink" title="Motrix"></a>Motrix</h2><p>支持各种协议并且免费开源跨平台的下载工具 不仅可以下载文件 还可以下载视频流</p>
<p><img src="https://gitee.com/songjianzaina/site_img/raw/master/img/image-20231229114333177.png" alt="image-20231229114333177"></p>
<p>支持平台: Windows、MacOs、Linux</p>
<p>官网: <a href="https://motrix.app/zh-CN/" target="_blank" rel="noopener">点击进入</a></p>
<p>GitHub: <a href="https://github.com/agalwood/Motrix" target="_blank" rel="noopener">点击进入</a></p>
<h2 id="Transmission"><a href="#Transmission" class="headerlink" title="Transmission"></a>Transmission</h2><p><img src="https://gitee.com/songjianzaina/site_img/raw/master/img/image-20231229114557365.png" alt="image-20231229114557365"></p>
<p>该工具提速快, 基本上能秒杀市面上大部分BT下载器</p>
<p>支持平台: Windows、MacOs、Linux</p>
<p>官网: <a href="https://transmissionbt.com/" target="_blank" rel="noopener">点击进入</a></p>
<p><strong>本文为作者原创转载时请注明出处 谢谢</strong></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em><a href="https://code.newban.cn/">乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</a></em></p>
]]></content>
      <tags>
        <tag>下载工具</tag>
      </tags>
  </entry>
  <entry>
    <title>使用docker部署Frps实现内网穿透</title>
    <url>/442.html</url>
    <content><![CDATA[<h2 id="部署环境"><a href="#部署环境" class="headerlink" title="部署环境"></a>部署环境</h2><ul>
<li>阿里云<code>ubuntu</code>系统</li>
</ul>
<h2 id="部署Frps"><a href="#部署Frps" class="headerlink" title="部署Frps"></a>部署Frps</h2><ol>
<li><p>搜索<code>frps</code>镜像</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker search frp</span><br></pre></td></tr></table></figure>
</li>
<li><p>拉取<code>frp</code>镜像</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker pull snowdreamtech/frps</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建<code>frps</code>目录以及<code>frps.toml</code>配置文件</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">mkdir frps</span><br><span class="line"><span class="built_in">cd</span> frps</span><br><span class="line">touch frps.toml</span><br></pre></td></tr></table></figure>
</li>
<li><p>在<code>frps.toml</code>配置文件中填写配置信息</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="section">[common]</span></span><br><span class="line"><span class="comment"># 内网穿透端口配置</span></span><br><span class="line"><span class="attr">bind_addr</span> = <span class="number">0.0</span>.<span class="number">0.0</span></span><br><span class="line"><span class="attr">bind_port</span> = <span class="number">7000</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># WEB控制面板相关配置</span></span><br><span class="line"><span class="attr">dashboard_addr</span> = <span class="number">0.0</span>.<span class="number">0.0</span></span><br><span class="line"><span class="attr">dashboard_port</span> = <span class="number">7500</span></span><br><span class="line"><span class="attr">dashboard_user</span> = admin</span><br><span class="line"><span class="attr">dashboard_pwd</span> = admin</span><br><span class="line"></span><br><span class="line"><span class="comment"># 日志相关配置</span></span><br><span class="line"><span class="attr">log_file</span> = ./frps.log</span><br><span class="line"><span class="attr">log_level</span> = info</span><br><span class="line"><span class="attr">log_max_days</span> = <span class="number">3</span></span><br><span class="line"><span class="attr">disable_log_color</span> = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># auth token</span></span><br><span class="line"><span class="attr">token</span> = <span class="number">12345678</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 子域名配置</span></span><br><span class="line"><span class="attr">subdomain_host</span> = frps.com</span><br><span class="line"></span><br><span class="line"><span class="attr">allow_ports</span> = <span class="number">2000</span>-<span class="number">3000</span>,<span class="number">3001</span>,<span class="number">3003</span>,<span class="number">4000</span>-<span class="number">50000</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="attr">max_pool_count</span> = <span class="number">5</span></span><br><span class="line"><span class="attr">max_ports_per_client</span> = <span class="number">0</span></span><br></pre></td></tr></table></figure>


</li>
</ol>
<ol start="5">
<li><p>创建并运行容器</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -id \</span><br><span class="line">--name=c_frps \</span><br><span class="line">--restart=always \</span><br><span class="line">--network c_bridge \</span><br><span class="line">-p 6010:6000 \</span><br><span class="line">-p 7010:7000 \</span><br><span class="line">-p 7510:7500 \</span><br><span class="line">-v /root/songjian/frp/frps/frps.toml:/etc/frp/frps.toml \</span><br><span class="line">-h c_frps \</span><br><span class="line">snowdreamtech/frps:latest</span><br></pre></td></tr></table></figure>
</li>
<li><p>验证程序是否可用</p>
<p>在浏览器中输入<code>http://localhost:7510</code>,看控制面板界面是否能正常打开</p>
<p>界面如下:</p>
<p><img src="https://gitee.com/songjianzaina/site_img/raw/master/img/image-20240104163746870.png" alt="image-20240104163746870"></p>
</li>
<li><p>至此, <code>frps</code>安装完毕</p>
<p>接下来,可在需要进行内网穿透的电脑上安装<code>frpc</code>来实现内网穿透,具体详见之前的文章:《<a href="https://code.newban.cn/372.html">使用frp进行内网穿透实现外网访问局域网中的服务器</a>》</p>
</li>
</ol>
<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ol>
<li><p>如果需要进入容器,可执行以下指令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -it c_frps /bin/sh</span><br></pre></td></tr></table></figure>

<p>   注意:这里需要使用<code>/bin/sh</code>,不能使用<code>bash</code>或者<code>/bin/bash</code>,否则会报错</p>
</li>
</ol>
<p><strong>本文为作者原创 转载时请注明出处 谢谢</strong></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em><a href="https://code.newban.cn/">乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</a></em></p>
]]></content>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>使用外部域名访问黑群晖的方法</title>
    <url>/441.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>使用外部域名访问群晖，大约有下面3种方法：</p>
<ol>
<li>一种方法是使用DDNS服务，这个服务可以让你把一个域名绑定到你的动态IP地址上，这样你就可以通过域名来访问群晖。你需要在群晖的控制面板中开启外部访问功能，然后选择一个DDNS服务商，比如群晖自带的或者其他的，然后输入你的域名和账号信息。</li>
<li>另一种方法是使用内网穿透服务，这个服务可以让你在没有公网IP的情况下，通过一个中转服务器来访问群晖。你需要在群晖上安装一个内网穿透的应用，比如花生壳、QuickConnect等，然后注册一个账号和域名，然后在电脑或手机上安装相应的客户端，就可以通过域名来访问群晖。</li>
<li>还有一种方法是使用IPv4协议，这个协议可以让你的每个设备都有一个独立的公网地址，外网可以直接通过这个地址来访问群晖。你需要在群晖上安装Docker，并运行一个DDNS-GO的容器，然后在阿里云或其他服务商上注册一个域名，并设置好API密钥，然后在DDNS-GO的设置页面中输入你的域名和密钥，就可以通过域名来访问群晖。</li>
</ol>
<p>今天咱们就用重点用第3种方法来实现。</p>
<h2 id="第一步：登录注册阿里云"><a href="#第一步：登录注册阿里云" class="headerlink" title="第一步：登录注册阿里云"></a>第一步：登录注册阿里云</h2><p><img src="https://gitee.com/songjianzaina/site_img/raw/master/img/20231231215807.png" alt></p>
<p>首先打开阿里云官网注册账号并完成实名认证。</p>
<p><img src="https://gitee.com/songjianzaina/site_img/raw/master/img/20231231215828.png" alt></p>
<p>完成之后在【账号中心】&gt;【基本信息】中就可以看到“个人实名认证”的信息，就说明我们这个账号创建成功了，然后我们进行下一步操作。</p>
<h2 id="第二步：注册域名"><a href="#第二步：注册域名" class="headerlink" title="第二步：注册域名"></a>第二步：注册域名</h2><p>在搜索框输入自己想要的域名名字，任何名字都可以，最好想一个适合自己专属的名字，这里以“bihu”为例说明，输入好以后点击后面的“查询域名”按钮。</p>
<p><img src="https://gitee.com/songjianzaina/site_img/raw/master/img/20231231215849.png" alt></p>
<p>看见自己喜欢的直接点击后面的“加入清单”按钮（不要只看首购便宜，你得看续费的价格）。然后下单付款。</p>
<p>然后打开“域名服务—域名列表”，就能看到你刚刚购买的那个域名了。</p>
<p><img src="https://gitee.com/songjianzaina/site_img/raw/master/img/20231231215903.png" alt></p>
<p>阿里云域名控制台直达：<a href="https://link.zhihu.com/?target=http%3A//dc.console.aliyun.com/" target="_blank" rel="noopener">http://dc.console.aliyun.com/</a></p>
<h2 id="第三步：创建DDNS"><a href="#第三步：创建DDNS" class="headerlink" title="第三步：创建DDNS"></a>第三步：创建DDNS</h2><p><img src="https://gitee.com/songjianzaina/site_img/raw/master/img/20231231215923.png" alt></p>
<p>在“域名列表”中，点击你刚才注册的域名后面的【解析】按钮。</p>
<p><img src="https://gitee.com/songjianzaina/site_img/raw/master/img/20231231215935.png" alt></p>
<p>需要添加一条主机记录为 nas，记录值为 0.0.0.0 的记录，其它保持默认即可，完成之后点击右下角的“确认”按钮。（主机记录，你可以写www或者nas都可以，我这里以nas为例）</p>
<p><img src="https://gitee.com/songjianzaina/site_img/raw/master/img/20231231215948.png" alt></p>
<p>继续点击页面右上角的图像点击“AccessKey管理”进入下一个页面。</p>
<p><img src="https://gitee.com/songjianzaina/site_img/raw/master/img/20231231220001.png" alt></p>
<p>点击<code>创建AccessKey</code>，然后就会出现<code>AccessKey ID</code>和<code>AccessKey Secret</code>两个数值，请一定妥善保管好这两个数值，等下需要用到的。（记不住也没有关系，任何时候都可以点击后面的<code>查看Secret</code>随时查看。）</p>
<h2 id="第四步：群晖NAS里启用DDNS"><a href="#第四步：群晖NAS里启用DDNS" class="headerlink" title="第四步：群晖NAS里启用DDNS"></a>第四步：群晖NAS里启用DDNS</h2><p>接下来需要到群晖上操作了。需要说明的是，目前群晖自带的DDNS设置并没有阿里云的服务供应商。所以我们需要借助一个工具套件，叫做【DDNS-GO】（它同时也有Docker容器插件可以安装）。</p>
<p>PS：【DDNS-GO】顾名思义就是用来做DDNS的，支持国内的阿里云、腾讯云、华为云和百度云这四大域名商，以及支持国外大名鼎鼎的Cloudflare，同时支持IPv4和IPv6的解析，非常强大。</p>
<p><img src="https://gitee.com/songjianzaina/site_img/raw/master/img/20231231220014.png" alt></p>
<p>群晖套间里搜索【DDNS-GO】，然后安装（安装插件就不需要教程了吧）。</p>
<p><img src="https://gitee.com/songjianzaina/site_img/raw/master/img/20231231220056.png" alt></p>
<p>安装好【DDNS-GO】后，直接打开。如上图：</p>
<p><strong>DNS服务商：</strong>这里很明显是选择“阿里云”</p>
<p><strong>AccessKey ID：</strong>上面获取的阿里云AccessKey ID</p>
<p><strong>AccessKey Secret：</strong>上面获取的阿里云AccessKey Secret</p>
<p><strong>Domains：</strong>需要解析的域名，也就是上面你申请的那个阿里域名</p>
<p><img src="https://gitee.com/songjianzaina/site_img/raw/master/img/20231231220109.png" alt></p>
<p>设置好对应的参数后，点“Save”保存，稍等几秒就会看到右边的日志显示运行情况。出现更新域名解析成功，并出现你的公网IP，就说明我们【DDNS-GO】设置好了。</p>
<p><img src="https://gitee.com/songjianzaina/site_img/raw/master/img/20231231220121.png" alt></p>
<p>最后返回阿里云后台的解析设置那里，可以看到我们设置为0.0.0.0的记录值，已经自动变成我们的公网IP地址。至此我们的DDNS设置部分全部搞定！</p>
<p>第五步：路由器端口路转发</p>
<p><img src="https://gitee.com/songjianzaina/site_img/raw/master/img/20231231220132.png" alt></p>
<p>首先是在路由器拨号的情况下，打开路由器的<a href="https://www.zhihu.com/search?q=upnp&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={" sourcetype"%3a"answer"%2c"sourceid"%3a2989427439}" target="_blank" rel="noopener">upnp</a>，然后直接找到路由器的<a href="https://www.zhihu.com/search?q=端口转发&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={" sourcetype"%3a"answer"%2c"sourceid"%3a2989427439}" target="_blank" rel="noopener">端口转发</a>开始创建即可。创建方法按上图设置就可以了，基本没有什么难度。</p>
<p>PS：端口映射不同的路由器叫法不一样，有的叫做“端口映射”，还有的叫做“虚拟服务器”。每个人使用的路由器品牌和网络环境不一样，设置也会有所不同，请根据实际情况进行设置，本文不再赘述。</p>
<h2 id="第六步：验证登录"><a href="#第六步：验证登录" class="headerlink" title="第六步：验证登录"></a>第六步：验证登录</h2><p><img src="https://gitee.com/songjianzaina/site_img/raw/master/img/20231231220149.png" alt></p>
<p>直接用浏览器登录你的域名，加上你路由器映射的端口号，能直接访问群晖NAS，就说明此次设置成功！</p>
<p><strong>本文转载自</strong>:<a href="https://www.zhihu.com/question/28904728/answer/2989427439" target="_blank" rel="noopener">知乎</a></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em><a href="https://code.newban.cn/">乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</a></em></p>
]]></content>
      <tags>
        <tag>Nas</tag>
      </tags>
  </entry>
  <entry>
    <title>谷歌Adsense大陆地区如何填写收款信息</title>
    <url>/445.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>自 2020年起<code>Google AdSense</code>暂停西联汇款，采用电汇方式付款。经过很多网友推荐，目前招商银行一卡通比较好用：没有手续费，收款稳定，一般也不要求提供证明文件，手机APP即可完成结汇。</p>
<p>本文一起来看看，谷歌adsense后台付款方式，招行银行一卡通信息如何填写</p>
<h2 id="添加AdSense付款方式"><a href="#添加AdSense付款方式" class="headerlink" title="添加AdSense付款方式"></a>添加AdSense付款方式</h2><p>前提当然是你要先申请一张招商银行一卡通。</p>
<blockquote>
<p><strong>注意：</strong><br>银行卡必须为一类账户，二类及以下账户没有收款外币权限。<br>开通网银和手机银行。</p>
</blockquote>
<p>登陆<code>Google AdSense</code>管理后台点击付款→付款信息→管理付款方式，添加付款方式。</p>
<p><img src="https://gitee.com/songjianzaina/site_img/raw/master/img/image-20240405212739394.png" alt="image-20240405212739394"></p>
<p><img src="https://gitee.com/songjianzaina/site_img/raw/master/img/%E8%B0%B7%E6%AD%8CAdsense%E6%B7%BB%E5%8A%A0%E4%BB%98%E6%AC%BE%E6%96%B9%E5%BC%8F%EF%BC%8C%E6%8B%9B%E5%95%86%E9%93%B6%E8%A1%8C%E4%BF%A1%E6%81%AF%E5%A6%82%E4%BD%95%E5%A1%AB%E5%86%99%EF%BC%9F01.jpg" alt="Adsense添加付款方式，招商银行信息如何填写？01"></p>
<ul>
<li><strong>付款人 ID（可选）：</strong>不用填</li>
<li><strong>银行账户上的姓名：</strong>XING MINGMING（姓名拼音，大写，姓和名之间空格）</li>
<li><strong>银行名称</strong>：China Merchants Bank, H.O. Shenzhen, China（招行总行，不管哪个地方办理的卡都一样）</li>
<li><strong>SWIFT BIC：</strong>CMBCCNBS</li>
<li><strong>账号：</strong>招商银行一卡通卡号</li>
<li><strong>重新输入账号：</strong>招商银行一卡通卡号</li>
<li><strong>中转银行</strong>：不填</li>
<li><strong>最终汇入方或最终收款人</strong>：不用填</li>
<li>勾选设为主要付款方式</li>
</ul>
<p>填写完成后，点击保存即可！</p>
<p><img src="https://gitee.com/songjianzaina/site_img/raw/master/img/image-20240405211906512.png" alt="image-20240405211906512"></p>
<h2 id="AdSense付款"><a href="#AdSense付款" class="headerlink" title="AdSense付款"></a>AdSense付款</h2><p>当谷歌<code>AdSense</code>账号余额达到<code>$100</code>，谷歌<code>AdSense</code>固定在每个月21日（中国时间22日）发起付款，1-3工作日可收到汇款。</p>
<h2 id="招行APP结汇"><a href="#招行APP结汇" class="headerlink" title="招行APP结汇"></a>招行APP结汇</h2><p>下载安装登陆招商银行一卡通APP，找到【外汇结汇】，点开后点击【去结汇】<br>在【结汇委托】界面：</p>
<ul>
<li><strong>卖出货币：</strong>选择美元现汇</li>
<li><strong>结汇资金来源：</strong>选择【其他经常转移】或【职工报酬和赡家款】</li>
<li><strong>结汇金额：</strong>输入要结汇的金额</li>
</ul>
<p><img src="https://gitee.com/songjianzaina/site_img/raw/master/img/%E8%B0%B7%E6%AD%8CAdsense%E6%B7%BB%E5%8A%A0%E4%BB%98%E6%AC%BE%E6%96%B9%E5%BC%8F%EF%BC%8C%E6%8B%9B%E5%95%86%E9%93%B6%E8%A1%8C%E4%BF%A1%E6%81%AF%E5%A6%82%E4%BD%95%E5%A1%AB%E5%86%99%EF%BC%9F04.jpg" alt="Adsense添加付款方式，招商银行信息如何填写？04"></p>
<p>最后点击确定，输入密码即可成功结汇，结汇后的人民币就自动打入银行卡。</p>
<blockquote>
<p><strong>注意：</strong><br>每个人年度结汇总额度（$50000），如果超出可到银行柜台申请额度。<br>结汇业务办理时间是 8:30-22:00。</p>
</blockquote>
<p><strong>本文转载自</strong> : <a href="https://zyc420.com/6343.html" target="_blank" rel="noopener">自由超</a></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em><a href="https://code.newban.cn/">乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</a></em></p>
]]></content>
      <tags>
        <tag>adsense</tag>
      </tags>
  </entry>
  <entry>
    <title>Paypal绑定收款银行账户的注意事项</title>
    <url>/446.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>目前国外的大部分平台都支持<code>Paypal</code>收付款 如果你在某些平台赚取了一些美元需要通过<code>Paypal</code>提现到国内账户 那么就需要关联银行账户</p>
<p><img src="https://gitee.com/songjianzaina/site_img/raw/master/img/image-20240406124429746.png" alt="image-20240406124429746"></p>
<p><img src="https://gitee.com/songjianzaina/site_img/raw/master/img/image-20240406124626479.png" alt="image-20240406124626479"></p>
<p>目前<code>Paypal</code>是以电汇的形式进行打款 这里国内招行银行为例 给大家介绍如何填写 以及相关注意事项</p>
<h2 id="填写账户信息"><a href="#填写账户信息" class="headerlink" title="填写账户信息"></a>填写账户信息</h2><p><img src="https://gitee.com/songjianzaina/site_img/raw/master/img/image-20240406125038367.png" alt="image-20240406125038367"></p>
<ul>
<li><strong>银行名称</strong>：China Merchants Bank（填写英文名称 输入一部分英文网页会自动搜索 然后我们只需要进行选择即可)</li>
<li><strong>SWIFT 代码：</strong>CMBCCNBS (选择好银行对应名称后 该代码会自动补全 当然我们也可以手动填写)</li>
<li><strong>分行地址:</strong> 这个只需要填写一个空格即可 注意是英文空格 需要将输入法切换至英文输入状态</li>
<li><strong>账号：</strong>招商银行一卡通卡号</li>
</ul>
<p><strong>本文为作者原创 转载时请注明出处 谢谢</strong></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em><a href="https://code.newban.cn/">乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</a></em></p>
]]></content>
      <tags>
        <tag>Paypal</tag>
      </tags>
  </entry>
  <entry>
    <title>谷歌Adsense的PIN码接收问题</title>
    <url>/447.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>当<code>Google Adsense</code>账户收益达到10美元时 会触发<code>PIN</code>码验证 为六位数字验证码 该码以国际挂号信的方式按照<code>Adsense</code>上填写的联系地址进行邮寄 国内大概一个月左右就能收到</p>
<h2 id="提高PIN码收取成功率"><a href="#提高PIN码收取成功率" class="headerlink" title="提高PIN码收取成功率"></a>提高PIN码收取成功率</h2><p>由于国际挂号信没有电话信息的 <code>Adsense</code>也未提供联系电话输入栏  这种形式的邮寄很容易造成收不到件  尤其是国内非一线城市</p>
<p>我之前收<code>PIN</code>码 就是没有填写联系电话  然后隔三差五往邮局跑 有些费劲  还好最后总算收到了</p>
<p>为了避免像我这样折腾 建议大家在地址栏补上自己的联系电话 这一招是很多网友测试过可行的 格式如下图:</p>
<p><img src="https://gitee.com/songjianzaina/site_img/raw/master/img/image-20240406132833839.png" alt="image-20240406132833839"></p>
<ol>
<li>地址填写中文</li>
<li>地址填写办公楼地址更容易收到Pin码</li>
<li>地址栏加上姓名及联系电话，备注“到件联系1xxxxxxxx88 xx女士/先生”</li>
<li>邮编一定填写精确</li>
</ol>
<h2 id="仍然收不到PIN码怎么办"><a href="#仍然收不到PIN码怎么办" class="headerlink" title="仍然收不到PIN码怎么办"></a>仍然收不到PIN码怎么办</h2><p>如果连续四次申请PIN码都未能收到 那么<code>Google Adense</code> 平台会提供一个人工验证通道</p>
<p><a href="https://support.google.com/adsense/contact/id_verification" target="_blank" rel="noopener">点击进入验证通道</a></p>
<p>人工验证需要填写姓名、电子邮件、发布商 ID、上传身份证照片 另外需要将身份证上的地址和 <code>Google Adsense</code> 账户的地址保持一致</p>
<p>待 <code>Google</code>审核通过后 谷歌就会发邮件告诉你已经通过验证</p>
<p><strong>本文为作者原创 转载时请注明出处 谢谢</strong></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em><a href="https://code.newban.cn/">乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</a></em></p>
]]></content>
      <tags>
        <tag>adsense</tag>
      </tags>
  </entry>
  <entry>
    <title>Git根据commit信息过滤并提取相应文件</title>
    <url>/448.html</url>
    <content><![CDATA[<h2 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h2><p>最近发现<code>GitHub</code>图床仓库容量过大 已经严重影响到使用了 于是我准备将这个仓库按照不同的<code>commit</code>拆分多个独立的小仓库 方便后期的维护和管理</p>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><ol>
<li><p>首先创建一个无内容的空分支</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git checkout --orphan new_branch_name</span><br></pre></td></tr></table></figure>
</li>
<li><p>清除目录下所有的文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git rm -rf .</span><br></pre></td></tr></table></figure>
</li>
<li><p>将指定某个或者某些个<code>commit</code>提取到新分支上</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git cherry-pick 12345abc def678 98765fed</span><br></pre></td></tr></table></figure>

<p>如果是一系列连续的<code>commits</code>，可以使用范围操作符：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git cherry-pick commit1^..commit2</span><br></pre></td></tr></table></figure>

<p>如果你想要按照某种模式过滤<code>commits</code>，可以使用<code>git log</code>和<code>grep</code>结合<code>cherry-pick</code>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">log</span> master --oneline | grep <span class="string">'pattern'</span> | awk <span class="string">'&#123;print $1&#125;'</span> | xargs git cherry-pick</span><br></pre></td></tr></table></figure>

<p>这里需要将<code>pattern</code>替换为你想要匹配的文本，例如一个作者名或者某个关键词</p>
<ul>
<li><code>git log master</code>: 由于是空分支 无任何<code>log</code>记录 这里我要获取<code>master</code>分支上的<code>commit</code>信息</li>
<li><code>grep &#39;pattern&#39;</code>: 对<code>commit</code>信息进行匹配过滤</li>
<li><code>--oneline</code> : 匹配到的<code>commitid</code>在一行显示</li>
<li><code>awk &#39;{print $1}&#39;| xargs git cherry-pick</code>: 将匹配到的<code>commit</code>打印出来 并作为<code>git cherry-pick</code>的参数</li>
</ul>
</li>
<li><p>最后 将目录下提取出的文件迁移至新仓库中即可</p>
</li>
</ol>
<p><strong>本文为作者原创 转载时请注明出处 谢谢</strong></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em><a href="https://code.newban.cn/">乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</a></em></p>
]]></content>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>谷歌Adsense新加坡税务信息如何填写</title>
    <url>/444.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>2023年10月起，谷歌<code>adsense</code>中国区、香港区等亚太地区账号后台都会提示：</p>
<blockquote>
<p>需要添加新加坡税务信息，为了避免收款延迟，并确保预扣税款准确无误，请务必尽快提供您的新加坡税务信息！</p>
</blockquote>
<p>这篇文章将给大家分享如何填写新加坡税务信息以及如何申请《中国税收居民身份证明》</p>
<h2 id="为什么要提交新加坡税务信息"><a href="#为什么要提交新加坡税务信息" class="headerlink" title="为什么要提交新加坡税务信息"></a>为什么要提交新加坡税务信息</h2><p>我们虽然提供过美国税务信息，但是<code>adsense</code>的广告费用，并不是直接从美国谷歌汇出。谷歌在全球各地有不同分公司，负责不同的区域。中国区账号所在的亚太地区广告费都是从谷歌新加坡分公司汇出的，所以需要提供新加坡税务信息。</p>
<blockquote>
<p>参考谷歌官方说明：<a href="https://support.google.com/product-documentation/answer/13401799#zippy=" target="_blank" rel="noopener">https://support.google.com/product-documentation/answer/13401799#zippy=</a></p>
</blockquote>
<p><img src="https://gitee.com/songjianzaina/site_img/raw/master/img/%E8%B0%B7%E6%AD%8Cadsense%E6%96%B0%E5%8A%A0%E5%9D%A1%E7%A8%8E%E5%8A%A1%E4%BF%A1%E6%81%AF%E5%A6%82%E4%BD%95%E5%A1%AB%E5%86%99%EF%BC%9F%E5%A6%82%E4%BD%95%E7%94%B3%E8%AF%B7%E4%B8%AD%E5%9B%BD%E7%A8%8E%E6%94%B6%E5%B1%85%E6%B0%91%E8%BA%AB%E4%BB%BD%E8%AF%81%E6%98%8E%EF%BC%9F01.png" alt="谷歌adsense新加坡税务信息如何填写？如何申请中国税收居民身份证明？01"></p>
<h2 id="新加坡税务信息填写"><a href="#新加坡税务信息填写" class="headerlink" title="新加坡税务信息填写"></a>新加坡税务信息填写</h2><p>点击【添加税务信息】，点击【开始填表】</p>
<p><img src="https://gitee.com/songjianzaina/site_img/raw/master/img/%E8%B0%B7%E6%AD%8Cadsense%E6%96%B0%E5%8A%A0%E5%9D%A1%E7%A8%8E%E5%8A%A1%E4%BF%A1%E6%81%AF%E5%A6%82%E4%BD%95%E5%A1%AB%E5%86%99%EF%BC%9F%E5%A6%82%E4%BD%95%E7%94%B3%E8%AF%B7%E4%B8%AD%E5%9B%BD%E7%A8%8E%E6%94%B6%E5%B1%85%E6%B0%91%E8%BA%AB%E4%BB%BD%E8%AF%81%E6%98%8E%EF%BC%9F02.jpg" alt="谷歌adsense新加坡税务信息如何填写？如何申请中国税收居民身份证明？02"></p>
<p><img src="https://gitee.com/songjianzaina/site_img/raw/master/img/%E8%B0%B7%E6%AD%8Cadsense%E6%96%B0%E5%8A%A0%E5%9D%A1%E7%A8%8E%E5%8A%A1%E4%BF%A1%E6%81%AF%E5%A6%82%E4%BD%95%E5%A1%AB%E5%86%99%EF%BC%9F%E5%A6%82%E4%BD%95%E7%94%B3%E8%AF%B7%E4%B8%AD%E5%9B%BD%E7%A8%8E%E6%94%B6%E5%B1%85%E6%B0%91%E8%BA%AB%E4%BB%BD%E8%AF%81%E6%98%8E%EF%BC%9F03.jpg" alt="谷歌adsense新加坡税务信息如何填写？如何申请中国税收居民身份证明？03"></p>
<p><img src="https://gitee.com/songjianzaina/site_img/raw/master/img/%E8%B0%B7%E6%AD%8Cadsense%E6%96%B0%E5%8A%A0%E5%9D%A1%E7%A8%8E%E5%8A%A1%E4%BF%A1%E6%81%AF%E5%A6%82%E4%BD%95%E5%A1%AB%E5%86%99%EF%BC%9F%E5%A6%82%E4%BD%95%E7%94%B3%E8%AF%B7%E4%B8%AD%E5%9B%BD%E7%A8%8E%E6%94%B6%E5%B1%85%E6%B0%91%E8%BA%AB%E4%BB%BD%E8%AF%81%E6%98%8E%EF%BC%9F04.jpg" alt="谷歌adsense新加坡税务信息如何填写？如何申请中国税收居民身份证明？04"></p>
<p><strong>公司信息填写：</strong>选择【个人/独资经营者】，下面常设机构、注册服务税都选【否】</p>
<p><img src="https://gitee.com/songjianzaina/site_img/raw/master/img/%E8%B0%B7%E6%AD%8Cadsense%E6%96%B0%E5%8A%A0%E5%9D%A1%E7%A8%8E%E5%8A%A1%E4%BF%A1%E6%81%AF%E5%A6%82%E4%BD%95%E5%A1%AB%E5%86%99%EF%BC%9F%E5%A6%82%E4%BD%95%E7%94%B3%E8%AF%B7%E4%B8%AD%E5%9B%BD%E7%A8%8E%E6%94%B6%E5%B1%85%E6%B0%91%E8%BA%AB%E4%BB%BD%E8%AF%81%E6%98%8E%EF%BC%9F05.jpg" alt="谷歌adsense新加坡税务信息如何填写？如何申请中国税收居民身份证明？05"></p>
<p><strong>免税：</strong>您是否有资格申请免税待遇，当然选【是】</p>
<p><img src="https://gitee.com/songjianzaina/site_img/raw/master/img/%E8%B0%B7%E6%AD%8Cadsense%E6%96%B0%E5%8A%A0%E5%9D%A1%E7%A8%8E%E5%8A%A1%E4%BF%A1%E6%81%AF%E5%A6%82%E4%BD%95%E5%A1%AB%E5%86%99%EF%BC%9F%E5%A6%82%E4%BD%95%E7%94%B3%E8%AF%B7%E4%B8%AD%E5%9B%BD%E7%A8%8E%E6%94%B6%E5%B1%85%E6%B0%91%E8%BA%AB%E4%BB%BD%E8%AF%81%E6%98%8E%EF%BC%9F06.jpg" alt="谷歌adsense新加坡税务信息如何填写？如何申请中国税收居民身份证明？06"></p>
<p><strong>税务居住地：</strong>上面选了【是】之后，就会跳出税务居住地。国家地区我们选择【中国】，税务居住地证明，我们选择【税务居住地证明】。新加坡谷歌只认可政府签发的居住地证明, 其他证件如身份证, 护照, 水费电费发票是没用的。这个地方就是要提交《中国税收居民身份证明》，下面我们来看看如何申请这个证明。</p>
<p><img src="https://gitee.com/songjianzaina/site_img/raw/master/img/%E8%B0%B7%E6%AD%8Cadsense%E6%96%B0%E5%8A%A0%E5%9D%A1%E7%A8%8E%E5%8A%A1%E4%BF%A1%E6%81%AF%E5%A6%82%E4%BD%95%E5%A1%AB%E5%86%99%EF%BC%9F%E5%A6%82%E4%BD%95%E7%94%B3%E8%AF%B7%E4%B8%AD%E5%9B%BD%E7%A8%8E%E6%94%B6%E5%B1%85%E6%B0%91%E8%BA%AB%E4%BB%BD%E8%AF%81%E6%98%8E%EF%BC%9F07.jpg" alt="谷歌adsense新加坡税务信息如何填写？如何申请中国税收居民身份证明？07"></p>
<h2 id="申请《中国税收居民身份证明》"><a href="#申请《中国税收居民身份证明》" class="headerlink" title="申请《中国税收居民身份证明》"></a>申请《中国税收居民身份证明》</h2><h3 id="什么是《中国税收居民身份证明》？"><a href="#什么是《中国税收居民身份证明》？" class="headerlink" title="什么是《中国税收居民身份证明》？"></a>什么是《中国税收居民身份证明》？</h3><p>《中国税收居民身份证明》是依据我国对外签署的避免双重征税协定，为帮助中国居民企业和个人享受在境外取得所得时的协定优惠待遇，由税务部门开具的证明企业或个人的中国税收居民身份的一种制式证明。</p>
<h3 id="《中国税收居民身份证明》有什么作用？"><a href="#《中国税收居民身份证明》有什么作用？" class="headerlink" title="《中国税收居民身份证明》有什么作用？"></a>《中国税收居民身份证明》有什么作用？</h3><p>中国居民企业和个人开展对外投资、经营和提供劳务活动时,如果取得相应的收入，且在投资东道国负有纳税义务（主要是企业所得税和个人所得税），为适用我国与东道国签署的税收协定以减轻在东道国的税收负担，就需要向当地税务部门提交《中国税收居民身份证明》。简而言之，<strong>就是可以用来减轻税负。</strong></p>
<h3 id="《中国税收居民身份证明》怎么申请？"><a href="#《中国税收居民身份证明》怎么申请？" class="headerlink" title="《中国税收居民身份证明》怎么申请？"></a>《中国税收居民身份证明》怎么申请？</h3><p>线上线下都能办。建议线上办理，更简单高效。每个省市税务申请的界面不一样，要填写或提交的材料不一样，像江苏税务必须要提交一个合同，不然无法申请。实际上全国税务都可以申请，我们以深圳税务为例，实测申请也更简单。</p>
<p><strong>可按以下步骤申请：</strong><br>网页打开深圳税务电子税务局</p>
<p><a href="https://12366.chinatax.gov.cn/bsfw/onlinetaxation/main" target="_blank" rel="noopener">网上办税 (chinatax.gov.cn)</a></p>
<p><img src="https://gitee.com/songjianzaina/site_img/raw/master/img/%E8%B0%B7%E6%AD%8Cadsense%E6%96%B0%E5%8A%A0%E5%9D%A1%E7%A8%8E%E5%8A%A1%E4%BF%A1%E6%81%AF%E5%A6%82%E4%BD%95%E5%A1%AB%E5%86%99%EF%BC%9F%E5%A6%82%E4%BD%95%E7%94%B3%E8%AF%B7%E4%B8%AD%E5%9B%BD%E7%A8%8E%E6%94%B6%E5%B1%85%E6%B0%91%E8%BA%AB%E4%BB%BD%E8%AF%81%E6%98%8E%EF%BC%9F08.jpg" alt="谷歌adsense新加坡税务信息如何填写？如何申请中国税收居民身份证明？08"></p>
<p>点击【我要办税】</p>
<p><img src="https://gitee.com/songjianzaina/site_img/raw/master/img/%E8%B0%B7%E6%AD%8Cadsense%E6%96%B0%E5%8A%A0%E5%9D%A1%E7%A8%8E%E5%8A%A1%E4%BF%A1%E6%81%AF%E5%A6%82%E4%BD%95%E5%A1%AB%E5%86%99%EF%BC%9F%E5%A6%82%E4%BD%95%E7%94%B3%E8%AF%B7%E4%B8%AD%E5%9B%BD%E7%A8%8E%E6%94%B6%E5%B1%85%E6%B0%91%E8%BA%AB%E4%BB%BD%E8%AF%81%E6%98%8E%EF%BC%9F21.jpg" alt="谷歌adsense新加坡税务信息如何填写？如何申请中国税收居民身份证明？21"></p>
<p>登陆界面我们使用【个人所得税APP】扫码登陆，个人所得税APP应该大家都有。如果深圳税务APP和个人所得税APP之前都没有注册，要单独注册下。</p>
<p><img src="https://gitee.com/songjianzaina/site_img/raw/master/img/%E8%B0%B7%E6%AD%8Cadsense%E6%96%B0%E5%8A%A0%E5%9D%A1%E7%A8%8E%E5%8A%A1%E4%BF%A1%E6%81%AF%E5%A6%82%E4%BD%95%E5%A1%AB%E5%86%99%EF%BC%9F%E5%A6%82%E4%BD%95%E7%94%B3%E8%AF%B7%E4%B8%AD%E5%9B%BD%E7%A8%8E%E6%94%B6%E5%B1%85%E6%B0%91%E8%BA%AB%E4%BB%BD%E8%AF%81%E6%98%8E%EF%BC%9F09.jpg" alt="谷歌adsense新加坡税务信息如何填写？如何申请中国税收居民身份证明？09"></p>
<p>登陆之后，点击【我要办税】，再点击【证明开具】</p>
<p><img src="https://gitee.com/songjianzaina/site_img/raw/master/img/%E8%B0%B7%E6%AD%8Cadsense%E6%96%B0%E5%8A%A0%E5%9D%A1%E7%A8%8E%E5%8A%A1%E4%BF%A1%E6%81%AF%E5%A6%82%E4%BD%95%E5%A1%AB%E5%86%99%EF%BC%9F%E5%A6%82%E4%BD%95%E7%94%B3%E8%AF%B7%E4%B8%AD%E5%9B%BD%E7%A8%8E%E6%94%B6%E5%B1%85%E6%B0%91%E8%BA%AB%E4%BB%BD%E8%AF%81%E6%98%8E%EF%BC%9F10.jpg" alt="谷歌adsense新加坡税务信息如何填写？如何申请中国税收居民身份证明？10"></p>
<p>再点击【中国税收居民身份证明开具】</p>
<p><img src="https://gitee.com/songjianzaina/site_img/raw/master/img/%E8%B0%B7%E6%AD%8Cadsense%E6%96%B0%E5%8A%A0%E5%9D%A1%E7%A8%8E%E5%8A%A1%E4%BF%A1%E6%81%AF%E5%A6%82%E4%BD%95%E5%A1%AB%E5%86%99%EF%BC%9F%E5%A6%82%E4%BD%95%E7%94%B3%E8%AF%B7%E4%B8%AD%E5%9B%BD%E7%A8%8E%E6%94%B6%E5%B1%85%E6%B0%91%E8%BA%AB%E4%BB%BD%E8%AF%81%E6%98%8E%EF%BC%9F11.jpg" alt="谷歌adsense新加坡税务信息如何填写？如何申请中国税收居民身份证明？11"></p>
<p>再点击【中国税收居民身份证明开具】</p>
<p><img src="https://gitee.com/songjianzaina/site_img/raw/master/img/%E8%B0%B7%E6%AD%8Cadsense%E6%96%B0%E5%8A%A0%E5%9D%A1%E7%A8%8E%E5%8A%A1%E4%BF%A1%E6%81%AF%E5%A6%82%E4%BD%95%E5%A1%AB%E5%86%99%EF%BC%9F%E5%A6%82%E4%BD%95%E7%94%B3%E8%AF%B7%E4%B8%AD%E5%9B%BD%E7%A8%8E%E6%94%B6%E5%B1%85%E6%B0%91%E8%BA%AB%E4%BB%BD%E8%AF%81%E6%98%8E%EF%BC%9F12.jpg" alt="谷歌adsense新加坡税务信息如何填写？如何申请中国税收居民身份证明？12"></p>
<p>跳出申请页面，点击最下面的【申请】</p>
<p><img src="https://gitee.com/songjianzaina/site_img/raw/master/img/%E8%B0%B7%E6%AD%8Cadsense%E6%96%B0%E5%8A%A0%E5%9D%A1%E7%A8%8E%E5%8A%A1%E4%BF%A1%E6%81%AF%E5%A6%82%E4%BD%95%E5%A1%AB%E5%86%99%EF%BC%9F%E5%A6%82%E4%BD%95%E7%94%B3%E8%AF%B7%E4%B8%AD%E5%9B%BD%E7%A8%8E%E6%94%B6%E5%B1%85%E6%B0%91%E8%BA%AB%E4%BB%BD%E8%AF%81%E6%98%8E%EF%BC%9F13.jpg" alt="谷歌adsense新加坡税务信息如何填写？如何申请中国税收居民身份证明？13"></p>
<p>申请页面填写信息，标红星的框都是必填项：</p>
<ul>
<li><strong>英文名称：</strong>拼音名在前，姓在后   建议使用大写</li>
<li><strong>职业：</strong>可任意填写，和实际接近最好</li>
<li><strong>享受待遇所得类型：</strong>独立个人劳务</li>
<li><strong>享受待遇金额：</strong>任意填</li>
<li><strong>通讯地址、境内住所地址、现居住地址：</strong>建议都填写真实地址</li>
<li><strong>联系电话：</strong>填写自己的手机号</li>
<li><strong>申请年度：</strong>可以写2024</li>
<li><strong>合伙企业信息：</strong>不用填，斜杠</li>
</ul>
<p><img src="https://gitee.com/songjianzaina/site_img/raw/master/img/%E8%B0%B7%E6%AD%8Cadsense%E6%96%B0%E5%8A%A0%E5%9D%A1%E7%A8%8E%E5%8A%A1%E4%BF%A1%E6%81%AF%E5%A6%82%E4%BD%95%E5%A1%AB%E5%86%99%EF%BC%9F%E5%A6%82%E4%BD%95%E7%94%B3%E8%AF%B7%E4%B8%AD%E5%9B%BD%E7%A8%8E%E6%94%B6%E5%B1%85%E6%B0%91%E8%BA%AB%E4%BB%BD%E8%AF%81%E6%98%8E%EF%BC%9F14.jpg" alt="谷歌adsense新加坡税务信息如何填写？如何申请中国税收居民身份证明？14"></p>
<ul>
<li><strong>缔约对方国家（地区）：</strong>选择新加坡共和国</li>
<li><strong>对方纳税人识别号：</strong>200817984R</li>
<li><strong>对方纳税人名称（英文）：</strong>Google Asia Pacific Pte. Ltd.</li>
<li><strong>对方纳税人名称（英文）：</strong>谷歌亚太私人有限公司</li>
<li><strong>拟享受协定名称：</strong>谷歌adsense广告费</li>
<li><strong>拟享受协议条款：</strong>可以不填</li>
<li><strong>拟享受协定收入金额：</strong>可以写50000，没有硬性要求</li>
<li><strong>预计减免税金额：</strong>可以写50000，没有硬性要求</li>
<li><strong>申请人或代理人：</strong>填写自己的中文姓名</li>
<li><strong>税务机关：</strong>任意选择</li>
</ul>
<p><img src="https://gitee.com/songjianzaina/site_img/raw/master/img/%E8%B0%B7%E6%AD%8Cadsense%E6%96%B0%E5%8A%A0%E5%9D%A1%E7%A8%8E%E5%8A%A1%E4%BF%A1%E6%81%AF%E5%A6%82%E4%BD%95%E5%A1%AB%E5%86%99%EF%BC%9F%E5%A6%82%E4%BD%95%E7%94%B3%E8%AF%B7%E4%B8%AD%E5%9B%BD%E7%A8%8E%E6%94%B6%E5%B1%85%E6%B0%91%E8%BA%AB%E4%BB%BD%E8%AF%81%E6%98%8E%EF%BC%9F15.jpg" alt="谷歌adsense新加坡税务信息如何填写？如何申请中国税收居民身份证明？15"></p>
<p>申请信息填写完毕后，点击【保存】，即完成申请。</p>
<p>返回申请页面，点击【查询】，里面可以马上看到刚刚申请好的证明，效率是真的高！勾选后点击【打印】。</p>
<p><img src="https://gitee.com/songjianzaina/site_img/raw/master/img/%E8%B0%B7%E6%AD%8Cadsense%E6%96%B0%E5%8A%A0%E5%9D%A1%E7%A8%8E%E5%8A%A1%E4%BF%A1%E6%81%AF%E5%A6%82%E4%BD%95%E5%A1%AB%E5%86%99%EF%BC%9F%E5%A6%82%E4%BD%95%E7%94%B3%E8%AF%B7%E4%B8%AD%E5%9B%BD%E7%A8%8E%E6%94%B6%E5%B1%85%E6%B0%91%E8%BA%AB%E4%BB%BD%E8%AF%81%E6%98%8E%EF%BC%9F16.jpg" alt="谷歌adsense新加坡税务信息如何填写？如何申请中国税收居民身份证明？16"></p>
<p>会自动跳出PDF版的《中国税收居民身份证明》，我们保存下来。</p>
<p><img src="https://gitee.com/songjianzaina/site_img/raw/master/img/%E8%B0%B7%E6%AD%8Cadsense%E6%96%B0%E5%8A%A0%E5%9D%A1%E7%A8%8E%E5%8A%A1%E4%BF%A1%E6%81%AF%E5%A6%82%E4%BD%95%E5%A1%AB%E5%86%99%EF%BC%9F%E5%A6%82%E4%BD%95%E7%94%B3%E8%AF%B7%E4%B8%AD%E5%9B%BD%E7%A8%8E%E6%94%B6%E5%B1%85%E6%B0%91%E8%BA%AB%E4%BB%BD%E8%AF%81%E6%98%8E%EF%BC%9F17.jpg" alt="谷歌adsense新加坡税务信息如何填写？如何申请中国税收居民身份证明？17"></p>
<h2 id="上传《中国税收居民身份证明》"><a href="#上传《中国税收居民身份证明》" class="headerlink" title="上传《中国税收居民身份证明》"></a>上传《中国税收居民身份证明》</h2><p>回到之前新加坡税务信息提交的页面。我们把上面申请到的《中国税收居民身份证明》上传上去。</p>
<p><img src="https://gitee.com/songjianzaina/site_img/raw/master/img/%E8%B0%B7%E6%AD%8Cadsense%E6%96%B0%E5%8A%A0%E5%9D%A1%E7%A8%8E%E5%8A%A1%E4%BF%A1%E6%81%AF%E5%A6%82%E4%BD%95%E5%A1%AB%E5%86%99%EF%BC%9F%E5%A6%82%E4%BD%95%E7%94%B3%E8%AF%B7%E4%B8%AD%E5%9B%BD%E7%A8%8E%E6%94%B6%E5%B1%85%E6%B0%91%E8%BA%AB%E4%BB%BD%E8%AF%81%E6%98%8E%EF%BC%9F18.jpg" alt="谷歌adsense新加坡税务信息如何填写？如何申请中国税收居民身份证明？18"></p>
<p>上传成功后，我们点击【提交】，就完成了新加坡税务信息的填写和提交，后面就等待谷歌adsense审核。</p>
<p><img src="https://gitee.com/songjianzaina/site_img/raw/master/img/%E8%B0%B7%E6%AD%8Cadsense%E6%96%B0%E5%8A%A0%E5%9D%A1%E7%A8%8E%E5%8A%A1%E4%BF%A1%E6%81%AF%E5%A6%82%E4%BD%95%E5%A1%AB%E5%86%99%EF%BC%9F%E5%A6%82%E4%BD%95%E7%94%B3%E8%AF%B7%E4%B8%AD%E5%9B%BD%E7%A8%8E%E6%94%B6%E5%B1%85%E6%B0%91%E8%BA%AB%E4%BB%BD%E8%AF%81%E6%98%8E%EF%BC%9F19.jpg" alt="谷歌adsense新加坡税务信息如何填写？如何申请中国税收居民身份证明？19"></p>
<p><img src="https://gitee.com/songjianzaina/site_img/raw/master/img/%E8%B0%B7%E6%AD%8Cadsense%E6%96%B0%E5%8A%A0%E5%9D%A1%E7%A8%8E%E5%8A%A1%E4%BF%A1%E6%81%AF%E5%A6%82%E4%BD%95%E5%A1%AB%E5%86%99%EF%BC%9F%E5%A6%82%E4%BD%95%E7%94%B3%E8%AF%B7%E4%B8%AD%E5%9B%BD%E7%A8%8E%E6%94%B6%E5%B1%85%E6%B0%91%E8%BA%AB%E4%BB%BD%E8%AF%81%E6%98%8E%EF%BC%9F20.jpg" alt="谷歌adsense新加坡税务信息如何填写？如何申请中国税收居民身份证明？20"></p>
<h2 id="审批结果"><a href="#审批结果" class="headerlink" title="审批结果"></a>审批结果</h2><p>提交之后，几乎每天都会关注下审核结果。实际1/19提交，通过审核是在1/30。中间真的是经过了7个工作日，一天不多一天不少。看了下有效期是到12/31</p>
<p><img src="https://gitee.com/songjianzaina/site_img/raw/master/img/%E8%B0%B7%E6%AD%8Cadsense%E6%96%B0%E5%8A%A0%E5%9D%A1%E7%A8%8E%E5%8A%A1%E4%BF%A1%E6%81%AF%E5%A6%82%E4%BD%95%E5%A1%AB%E5%86%99%EF%BC%9F%E5%A6%82%E4%BD%95%E7%94%B3%E8%AF%B7%E4%B8%AD%E5%9B%BD%E7%A8%8E%E6%94%B6%E5%B1%85%E6%B0%91%E8%BA%AB%E4%BB%BD%E8%AF%81%E6%98%8E%EF%BC%9F22.jpg" alt="谷歌adsense新加坡税务信息如何填写？如何申请中国税收居民身份证明？22"></p>
<p><img src="https://gitee.com/songjianzaina/site_img/raw/master/img/%E8%B0%B7%E6%AD%8Cadsense%E6%96%B0%E5%8A%A0%E5%9D%A1%E7%A8%8E%E5%8A%A1%E4%BF%A1%E6%81%AF%E5%A6%82%E4%BD%95%E5%A1%AB%E5%86%99%EF%BC%9F%E5%A6%82%E4%BD%95%E7%94%B3%E8%AF%B7%E4%B8%AD%E5%9B%BD%E7%A8%8E%E6%94%B6%E5%B1%85%E6%B0%91%E8%BA%AB%E4%BB%BD%E8%AF%81%E6%98%8E%EF%BC%9F23.jpg" alt="谷歌adsense新加坡税务信息如何填写？如何申请中国税收居民身份证明？23"></p>
<p><img src="https://gitee.com/songjianzaina/site_img/raw/master/img/%E8%B0%B7%E6%AD%8Cadsense%E6%96%B0%E5%8A%A0%E5%9D%A1%E7%A8%8E%E5%8A%A1%E4%BF%A1%E6%81%AF%E5%A6%82%E4%BD%95%E5%A1%AB%E5%86%99%EF%BC%9F%E5%A6%82%E4%BD%95%E7%94%B3%E8%AF%B7%E4%B8%AD%E5%9B%BD%E7%A8%8E%E6%94%B6%E5%B1%85%E6%B0%91%E8%BA%AB%E4%BB%BD%E8%AF%81%E6%98%8E%EF%BC%9F24.jpg" alt="谷歌adsense新加坡税务信息如何填写？如何申请中国税收居民身份证明？24"></p>
<p><a href="https://youtu.be/D1kfzpSvfVM" target="_blank" rel="noopener">YouTube视频版</a></p>
<p><strong>本文转载自</strong> : <a href="https://zyc420.com/6280.html" target="_blank" rel="noopener">自由超</a></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em><a href="https://code.newban.cn/">乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</a></em></p>
]]></content>
      <tags>
        <tag>adsense</tag>
      </tags>
  </entry>
  <entry>
    <title>Smali语言从入门到精通视频教程-胖薯出品</title>
    <url>/449.html</url>
    <content><![CDATA[<h2 id="适用人群"><a href="#适用人群" class="headerlink" title="适用人群"></a>适用人群</h2><ul>
<li>对<code>Smali</code>语言以及逆向反编译有兴趣的同学</li>
<li>安卓逆向从业者</li>
</ul>
<h2 id="课程要求"><a href="#课程要求" class="headerlink" title="课程要求"></a>课程要求</h2><p>有任意一门编程语言的同学均可学习, 有Java或者安卓基础最佳</p>
<h2 id="课程概述"><a href="#课程概述" class="headerlink" title="课程概述"></a>课程概述</h2><p>安卓逆向必备基础知识 学完后快速掌握<code>smali</code>语法</p>
<h3 id="课程特色"><a href="#课程特色" class="headerlink" title="课程特色"></a>课程特色</h3><p>23课时 帮你快速入门Smali语言 </p>
<h3 id="课程亮点"><a href="#课程亮点" class="headerlink" title="课程亮点"></a>课程亮点</h3><ul>
<li><p>从0到1快速入门 基础语法开始 循序渐进</p>
</li>
<li><p>内容清晰流畅 不废话不拖沓 </p>
</li>
<li><p>配套工具 快速上手 一边学习一边实战</p>
</li>
</ul>
<h3 id="课程大纲"><a href="#课程大纲" class="headerlink" title="课程大纲"></a>课程大纲</h3><ul>
<li><p>第一部分: Smali语言和Java语言的对比分析</p>
</li>
<li><p>第二部分: 类和各种方法以及属性的定义</p>
</li>
<li><p>第三部分: 寄存器的声明和定义</p>
</li>
<li><p>第四部分: 手写Smali代码打印输出</p>
</li>
</ul>
<h2 id="课程观看"><a href="#课程观看" class="headerlink" title="课程观看"></a>课程观看</h2><ul>
<li><a href="https://study.163.com/course/introduction/1211378813.htm" target="_blank" rel="noopener">网易云课堂</a></li>
<li><a href="https://edu.51cto.com/course/36057.html" target="_blank" rel="noopener">51CTO课堂</a></li>
<li><a href="https://mbd.pub/o/bread/ZZ6UmZtt" target="_blank" rel="noopener">面包多付费观看</a></li>
<li>Udemy课堂</li>
<li><a href="https://www.bilibili.com/video/BV1Vf4y1q7gh/" target="_blank" rel="noopener">B站免费观看</a></li>
<li><a href="https://youtu.be/KbB5B2iJEsk" target="_blank" rel="noopener">YouTube观看</a></li>
<li>淘宝/拼多多赞助观看</li>
</ul>
<p><img src="https://gitee.com/songjianzaina/site_img/raw/master/img/image-20240409102103326.png" alt="image-20240409102103326"></p>
<p><strong>本文为作者原创 转载时请注明出处 谢谢</strong></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em><a href="https://code.newban.cn/">乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</a></em></p>
]]></content>
      <tags>
        <tag>Smali</tag>
      </tags>
  </entry>
  <entry>
    <title>Android Studio下JNI开发的基本步骤</title>
    <url>/45.html</url>
    <content><![CDATA[<ul>
<li>第一步 设置ndk路径 配置相应的开发环境</li>
</ul>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/1570498988042.png" alt></p>
<ul>
<li>第二步 配置快捷键 Settings -&gt; External tools中配置javah,javap,ndk-build快捷方式，(这一步主要是为了简化命令行输入，使用原生命令行也是可以的)</li>
</ul>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/1570499176459.png" alt></p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/1570525244895.png" alt></p>
<p><em>javah参数配置(直接拷贝)：</em><br><strong>Program:</strong> $JDKPath$\bin\javah.exe<br><strong>Parameters:</strong> -classpath . -jni -o $ModuleFileDir$/src/main/jni/$Prompt$ $FileClass$<br><strong>Working directory:</strong> $ModuleFileDir$\src\main\Java<br><strong>Parameters的另外一种写法</strong>: -classpath . -jni -d $ModuleFileDir$/src/main/jni $FileClass$</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/1570499347400.png" alt></p>
<p>javap参数配置(直接拷贝)：*<br><strong>Program:</strong> $JDKPath$\bin\javap<br><strong>Parameters:</strong> -s -p $FileClass$<br><strong>Working directory:</strong> $ModuleFileDir$\build\intermediates\classes\debug</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/1570499347400.png" alt></p>
<p><em>ndk-build参数配置(直接拷贝)：</em></p>
<p><strong>Program:</strong> D:\Android_NDK\android-ndk-r11b\ndk-build.cmd </p>
<p><strong>Working directory:</strong> $ModuleFileDir$\src\main</p>
<ul>
<li>第三步 创建java类 引用即将创建的链接库,以及创建所需要的本地方法</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static &#123;</span><br><span class="line">    System.loadLibrary(&quot;MyJni&quot;);//导入指定的so库文件名称 </span><br><span class="line">&#125;</span><br><span class="line">public native String getStringFromNative();//本地方法</span><br><span class="line">public native String getString_From_c();</span><br></pre></td></tr></table></figure>

<ul>
<li>第四步 使用之前配置的javah快捷键快速生成.h头文件</li>
</ul>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/909970-20161115184349967-1329241072.png" alt></p>
<p><strong>此时 会自动创建jni目录并生成头文件</strong></p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/909970-20161115184350373-820716990.png" alt></p>
<ul>
<li>第五步 参考头文件 在jni目录下开始编写C/C++代码<img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/909970-20161115184350685-607675028.png" alt></li>
</ul>
<p><strong>注：</strong></p>
<p>项目结构切换成 Android状态时，jni文件夹显示成 cpp名字！ </p>
<p>当切换成project时就显示成jni文件夹！！</p>
<p>如下图：</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/909970-20161115184350998-1201697394.png" alt> <img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/909970-20161115184351263-1458780704.png" alt></p>
<p>添加如下代码：</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/909970-20161115184351560-1855950848.png" alt></p>
<ul>
<li>第六步 配置gradle </li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> ndk&#123;</span><br><span class="line">        moduleName &quot;MyJni&quot;//编译后so库的名字</span><br><span class="line">        ldLibs &quot;log&quot;//连接的库，可以有多个</span><br><span class="line">        abiFilters &quot;armeabi&quot;,&quot;armeabi-v7a&quot;,&quot;x86&quot;//指定so库运行的cpu架构，有armeabi armeabi-v7a arm64-v8a x86 x86_64 mips mips64这些，常用的是armeabi和armeabi-v7a</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>点击Androidstudio 菜单栏 Build -&gt;ReBuildProject 后自动生成Android.mk文件 </p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/909970-20161115184352513-848045712.png" alt></p>
<p>把Android.mk文件拷贝到 main/jni文件夹下 然后右键—&gt;External Tools –&gt;ndk-build  生成 .so文件！！</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/1570500786572.png" alt></p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/1570500816087.png" alt></p>
<p>其次 在项目的gradle.properties 文件中添加</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">android.useDeprecatedNdk=true</span><br></pre></td></tr></table></figure>

<ul>
<li>第七步 运行java代码 调取c库</li>
</ul>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/909970-20161115184354279-1935016921.png" alt></p>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul>
<li><p>加载生成的动态库指定的文件名（ System.loadLibrary(“MyJni”);）和生成.so时指定的名字（build.gradle中的ndk{moduleName “MyJni” }），还有Android.mk中LOCAL_MODULE := MyJni三者名称需要保持一致；</p>
</li>
<li><p>异常提示不支持c++</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Error: Flag android.useDeprecatedNdk is no longer supported and will be removed in the next version of Android Studio.  Please switch to a supported build system.</span><br><span class="line">  Consider using CMake or ndk-build integration. For more information, go to:</span><br><span class="line">   https://d.android.com/r/studio-ui/add-native-code.html#ndkCompile</span><br><span class="line">   To get started, you can use the sample ndk-build script the Android</span><br><span class="line">   plugin generated for you at:</span><br><span class="line">   E:\IT\youban\module_c++\build\intermediates\ndk\release\Android.mk</span><br><span class="line">  Alternatively, you can use the experimental plugin:</span><br><span class="line">   https://developer.android.com/r/tools/experimental-plugin.html</span><br><span class="line">  To continue using the deprecated NDK compile for another 60 days, set </span><br><span class="line">  android.deprecatedNdkCompileLease=1570504380180 in gradle.properties</span><br></pre></td></tr></table></figure>

<p>解决方案:在build.gradle中添加如下配置即可:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">android&#123;</span><br><span class="line"></span><br><span class="line">//增加之后如下信息之后，右键项目的时候Link C++ Project with Gradle选项不再显示;</span><br><span class="line">//    externalNativeBuild &#123;</span><br><span class="line">//        ndkBuild &#123;</span><br><span class="line">//            path file(&apos;src/main/jni/Android.mk&apos;)</span><br><span class="line">//        &#125;</span><br><span class="line">//    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="附-C调java代码"><a href="#附-C调java代码" class="headerlink" title="附:C调java代码"></a>附:C调java代码</h3><h5 id="Java中代码如下"><a href="#Java中代码如下" class="headerlink" title="Java中代码如下:"></a>Java中代码如下:</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static &#123;</span><br><span class="line">    </span><br><span class="line">    System.loadLibrary(&quot;MyJni&quot;);//导入指定的so库文件</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void show()&#123;</span><br><span class="line">    System.out.println(&quot;hahaha  C++调了我&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="C中代码如下"><a href="#C中代码如下" class="headerlink" title="C中代码如下:"></a>C中代码如下:</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//在c代码里面调用java代码里面的方法</span><br><span class="line"></span><br><span class="line">//1 . 找到java代码的 class文件</span><br><span class="line">jclass dpclazz = (*env)-&gt;FindClass(env, &quot;com/insworks/module_ccc/CCCTestActivity&quot;);</span><br><span class="line">if (dpclazz == 0) &#123;</span><br><span class="line">    return (*(*env)).NewStringUTF(env, &quot;NDK 没有找到指定的类&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//2 寻找class里面的方法</span><br><span class="line">jmethodID method1 = (*env)-&gt;GetMethodID(env, dpclazz, &quot;show&quot;, &quot;()V&quot;);</span><br><span class="line">if (method1 == 0) &#123;</span><br><span class="line">    return (*(*env)).NewStringUTF(env, &quot;NDK 没有找到方法&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//3.实例化类</span><br><span class="line">jobject jobject1 = (*env)-&gt;AllocObject(env, dpclazz);</span><br><span class="line"></span><br><span class="line">//4 .调用这个方法</span><br><span class="line">(*env)-&gt;CallVoidMethod(env, jobject1, method1);</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/20131221142524640.png" alt></p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/20131221140115156.png" alt></p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/20131221142910828.png" alt></p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/20131221142742906.png" alt></p>
<h3 id="注意事项-1"><a href="#注意事项-1" class="headerlink" title="注意事项:"></a>注意事项:</h3><ol>
<li><strong>原生方法在C和C++的调用方式不同，例如：</strong></li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/* C */</span><br><span class="line">return (*env)-&gt;NewStringUTF(env, &quot;Hello World&quot;);</span><br><span class="line">/* C++ */</span><br><span class="line">return env-&gt;NewStringUTF(&quot;Hello World&quot;);</span><br></pre></td></tr></table></figure>

<p>​    在C语言中，JNIEnv是指向JNINativeInterface结构的指针，使用它必须要解引用。而第一个参数还是env，学过C和C++语言都知道，C语言是面向过程语言，NewStringUTF只是一个函数指针，调用该方法还不清楚调用者，所以要传递env，而C++就不用，因为C++是面向对象语言，这个就不解释咯</p>
<p>2.<strong>关于C++调用C函数或者变量</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//在C++中引用C语言中的函数和变量，在包含C语言头文件时(假设为cExample.h)，需进行以下处理：</span><br><span class="line">//  extern &quot;C&quot;</span><br><span class="line">//  &#123;</span><br><span class="line">//    #include &quot;cExample.h&quot;;</span><br><span class="line">//  &#125;</span><br></pre></td></tr></table></figure>

<p>3.<strong>关于so文件的名称问题</strong></p>
<p>Android.mk文件中的LOCAL_MODULE 决定了so文件的名称,LOCAL_MODULE 的名称可以手动修改也可以在build.gradle中配置:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">       ndk &#123;</span><br><span class="line">//            moduleName &quot;native_datahelp&quot;//编译后so库的名称</span><br><span class="line"></span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>4.<strong>关于System.loadLibrary();</strong></p>
<p>为什么loadLibrary中填入的名称不一致,却能依然运行成功不报错?</p>
<p>目前自测发现 build文件中出现很多编译后的so库 有可能是旧so库未及时清除的原因,可以过研究研究build文件夹,里面藏着非常多的秘密</p>
<p>5.<strong>ndk-build不执行照样运行成功</strong></p>
<p>C/C++源码文件改动后自动调用ndk-build编译生成新的so库存放在build文件夹中,可以拷贝直接使用,ndk-build生成正式的so库,这跟apk打包是同样的道理 Android.mk文件是必须存在的,否则无法编译生成so库,也无法编译识别源文件</p>
<p><strong>本文为作者原创 转载时请注明出处 谢谢</strong></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em>乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</em></p>
]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>Android进阶之逆向安全反编译视频教程-胖薯出品</title>
    <url>/450.html</url>
    <content><![CDATA[<h2 id="适用人群"><a href="#适用人群" class="headerlink" title="适用人群"></a>适用人群</h2><ul>
<li>对安卓逆向反编译有兴趣的同学</li>
<li>安卓逆向从业者</li>
</ul>
<h2 id="课程要求"><a href="#课程要求" class="headerlink" title="课程要求"></a>课程要求</h2><p>适用于有安卓开发基础的同学</p>
<h2 id="课程概述"><a href="#课程概述" class="headerlink" title="课程概述"></a>课程概述</h2><p>学完本课程后可以实现对App进行逆向破解操作, 其中包括:</p>
<ol>
<li><code>app</code>内容篡改</li>
<li><code>app</code>运行流程篡改</li>
<li><code>app</code>数据拦截和替换</li>
<li><code>https</code>数据拦截以及<code>xposed hook</code>操作</li>
</ol>
<h3 id="课程特色"><a href="#课程特色" class="headerlink" title="课程特色"></a>课程特色</h3><p>15课时 帮你快速入门安卓逆向反编译</p>
<h3 id="课程亮点"><a href="#课程亮点" class="headerlink" title="课程亮点"></a>课程亮点</h3><ul>
<li><p>适合新手入门 只要有一定的安卓开发基础就能快速掌握</p>
</li>
<li><p>内容清晰循序渐进 不拖沓 全程干货</p>
</li>
<li><p>配套工具 快速上手 一边学习一边实战</p>
</li>
</ul>
<h3 id="课程大纲"><a href="#课程大纲" class="headerlink" title="课程大纲"></a>课程大纲</h3><ul>
<li><p>第一部分: 反编译工具的基本介绍和使用</p>
</li>
<li><p>第二部分: <code>App</code>启动入口替换</p>
</li>
<li><p>第三部分: <code>Https</code>请求抓包</p>
</li>
<li><p>第四部分: <code>JNI</code>数据分析</p>
</li>
</ul>
<h2 id="课程观看"><a href="#课程观看" class="headerlink" title="课程观看"></a>课程观看</h2><ul>
<li><a href="https://study.163.com/course/introduction/1211381812.htm" target="_blank" rel="noopener">网易云课堂</a></li>
<li><a href="https://edu.51cto.com/course/36058.html" target="_blank" rel="noopener">51CTO课堂</a></li>
<li><a href="https://mbd.pub/o/bread/ZZ6UmZxs" target="_blank" rel="noopener">面包多付费观看</a></li>
<li>Udemy课堂</li>
<li><a href="https://www.bilibili.com/video/BV1QZ4y1V7zy/" target="_blank" rel="noopener">B站免费观看</a></li>
<li><a href="https://youtu.be/RiD3bmHr3Jg" target="_blank" rel="noopener">YouTube观看</a></li>
<li>淘宝/拼多多赞助观看</li>
</ul>
<p><img src="https://gitee.com/songjianzaina/site_img/raw/master/img/1b954d951bca464294b5761a77fae70d.webp" alt="1b954d951bca464294b5761a77fae70d"></p>
<p><strong>本文为作者原创 转载时请注明出处 谢谢</strong></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em><a href="https://code.newban.cn/">乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</a></em></p>
]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>程序员进阶之三大架构汇编语言入门视频教程-胖薯出品</title>
    <url>/451.html</url>
    <content><![CDATA[<h2 id="适用人群"><a href="#适用人群" class="headerlink" title="适用人群"></a>适用人群</h2><ul>
<li>计算机爱好者</li>
<li>程序员</li>
<li>硬件开发者</li>
</ul>
<h2 id="课程要求"><a href="#课程要求" class="headerlink" title="课程要求"></a>课程要求</h2><p>需要掌握一定的计算机基础知识 懂任意一门编程语言最佳</p>
<h2 id="课程概述"><a href="#课程概述" class="headerlink" title="课程概述"></a>课程概述</h2><p>涵盖x86 ARM MIPS三大主流架构汇编语言入门知识</p>
<h3 id="课程特色"><a href="#课程特色" class="headerlink" title="课程特色"></a>课程特色</h3><p>68课时 帮你快速入门汇编语言技能</p>
<h3 id="课程亮点"><a href="#课程亮点" class="headerlink" title="课程亮点"></a>课程亮点</h3><ul>
<li><p>内容全面 涵盖市面上主流x86 ARM MIPS三大架构汇编语言</p>
</li>
<li><p>讲解通俗易懂 适合零基础的同学快速入门学习</p>
</li>
<li><p>实战结合 将语法知识拆分成若干个小细节 分别进行相应的实战操作 帮助大家快速理解并上手</p>
</li>
</ul>
<h3 id="课程大纲"><a href="#课程大纲" class="headerlink" title="课程大纲"></a>课程大纲</h3><ul>
<li><p>第一部分: 三大汇编语言基础精讲</p>
</li>
<li><p>第二部分: <code>8086</code>汇编语言讲解</p>
</li>
<li><p>第三部分: <code>MIPS</code>汇编语言讲解</p>
</li>
<li><p>第四部分: <code>ARM</code>汇编语言讲解</p>
</li>
</ul>
<h2 id="课程观看"><a href="#课程观看" class="headerlink" title="课程观看"></a>课程观看</h2><ul>
<li><a href="https://study.163.com/course/introduction/1211547802.htm" target="_blank" rel="noopener">网易云课堂</a></li>
<li>51CTO课堂</li>
<li><a href="https://mbd.pub/o/bread/ZZ6UmZ1p" target="_blank" rel="noopener">面包多付费观看</a></li>
<li><a href="https://edu.51cto.com/course/36080.html" target="_blank" rel="noopener">Udemy课堂</a></li>
<li><a href="https://www.bilibili.com/video/BV1CK411u76E/" target="_blank" rel="noopener">B站免费观看</a></li>
<li><a href="https://youtu.be/LnjTzPfJArw" target="_blank" rel="noopener">YouTube观看</a></li>
<li>淘宝/拼多多赞助观看</li>
</ul>
<p><img src="https://gitee.com/songjianzaina/site_img/raw/master/img/455b581f5038499b9ad03f6dcbb7c3e6.webp" alt="455b581f5038499b9ad03f6dcbb7c3e6"></p>
<p><strong>本文为作者原创 转载时请注明出处 谢谢</strong></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em><a href="https://code.newban.cn/">乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</a></em></p>
]]></content>
      <tags>
        <tag>汇编</tag>
      </tags>
  </entry>
  <entry>
    <title>Chrome浏览器中如何下载SVG图片</title>
    <url>/454.html</url>
    <content><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>当我们通过浏览器以图片链接的形式访问SVG图片时 我们会发现无法通过鼠标右键复制该图片</p>
<p>如果不考虑图片清晰度 那么可以用截图的方式简单粗暴地将图片拷贝下来</p>
<p>我们都知道SVG是矢量图 是一种基于XML语法的图像格式 这中格式图片可以实现无限缩放而不失真 所以我们必须将原图代码给拷贝下来才行</p>
<p>既然是代码 那就只能在开发者工具页面找</p>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><ol>
<li><p>点击图片鼠标右键选择检查 进入开发者页面</p>
<p><img src="https://gitee.com/songjianzaina/site_img/raw/master/img/image-20240409112448266.png" alt="image-20240409112448266"></p>
</li>
<li><p>找到<code>svg</code>标签 鼠标右键<code>Copy</code>→<code>Copy Element</code></p>
<p><img src="https://gitee.com/songjianzaina/site_img/raw/master/img/image-20240409112542590.png" alt="image-20240409112542590"></p>
</li>
<li><p>将拷贝到的源代码粘贴到文本文档中 并将文件后缀改成<code>svg</code>即可</p>
</li>
</ol>
<h2 id="SVG相关工具"><a href="#SVG相关工具" class="headerlink" title="SVG相关工具"></a>SVG相关工具</h2><ul>
<li><a href="https://convertio.co/zh/png-svg/" target="_blank" rel="noopener">SVG在线转PNG</a></li>
<li><a href="https://www.youcompress.com/zh-cn/svg/" target="_blank" rel="noopener">SVG图片在线压缩</a></li>
<li><a href="https://onlineconvertfree.com/zh/convert-format/pdf-to-svg" target="_blank" rel="noopener">PDF转SVG</a></li>
</ul>
<p><strong>本文为作者原创 转载时请注明出处 谢谢</strong></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em><a href="https://code.newban.cn/">乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</a></em></p>
]]></content>
      <tags>
        <tag>SVG</tag>
      </tags>
  </entry>
  <entry>
    <title>Github Token的获取+PicGo图床配置</title>
    <url>/452.html</url>
    <content><![CDATA[<h2 id="Github获取token"><a href="#Github获取token" class="headerlink" title="Github获取token"></a>Github获取token</h2><p>在<code>GitHub</code>上获取个人访问令牌（<code>Personal Access Token, PAT</code>）的步骤如下：</p>
<ol>
<li>登录到你的<code>GitHub</code>账户。</li>
<li>点击右上角的用户头像，选择<code>Settings（设置</code></li>
<li>在侧边栏中点击<code>Developer settings（开发者设置）</code></li>
<li>点击<code>Personal access tokens（个人访问令牌）</code></li>
<li>点击<code>Generate new token（生成新令牌）</code></li>
<li>填写必要的信息，例如令牌的描述和选择所需的权限</li>
<li>完成后，点击<code>Generate token（生成令牌）</code></li>
<li>复制生成的令牌并保存，因为生成后不会再显示</li>
</ol>
<h2 id="PicGo图床配置"><a href="#PicGo图床配置" class="headerlink" title="PicGo图床配置"></a>PicGo图床配置</h2><h3 id="GitHub图床"><a href="#GitHub图床" class="headerlink" title="GitHub图床"></a>GitHub图床</h3><ul>
<li>仓库名 :<code>用户名/仓库名</code></li>
<li>分支名 :<code>master</code></li>
<li>该仓库<code>token</code>  : <code>xxxxxxxxxx</code></li>
<li>指定存储路径 :<code>img/</code></li>
<li>自定义域名访问(CDN) : <code>https://cdn.jsdelivr.net/gh/用户名/仓库名</code></li>
</ul>
<p>截图如下:</p>
<p><img src="https://cdn.jsdelivr.net/gh/songjianzaina/SavePicGoPic/img/20191115175451.png" alt></p>
<p>示例图如下:</p>
<p><img src="https://cdn.jsdelivr.net/gh/songjianzaina/SavePicGoPic/img/icon_game.jpg" alt></p>
<p><strong>本文为作者原创 转载时请注明出处 谢谢</strong></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em><a href="https://code.newban.cn/">乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</a></em></p>
]]></content>
      <tags>
        <tag>图床</tag>
      </tags>
  </entry>
  <entry>
    <title>常见静态网站托管平台使用及多节点部署方案</title>
    <url>/453.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>对于 Hexo 来说，我们使用它来部署博客是因为无后端运维和高速渲染页面等优点。选择一个合适的托管平台对于博客来说十分重要，可以免费使用且稳定高速的平台是不存在的，我们总是需要做出妥协。我使用了 Github Pages、Coding Pages、Gitee Pages、Netlify 和 Vercel 来部署博客，以下为我的使用报告。</p>
<h2 id="常见托管平台"><a href="#常见托管平台" class="headerlink" title="常见托管平台"></a>常见托管平台</h2><p><img src="https://gitee.com/songjianzaina/site_img/raw/master/img/11.svg" alt="11"></p>
<h3 id="Github-Pages"><a href="#Github-Pages" class="headerlink" title="Github Pages"></a>Github Pages</h3><p>免费扩展性强无限制性</p>
<p>使用体验：可以与仓库无缝对接，高效部署，但是没用设置国内节点，在国内访问速度较慢，作为一个海外节点还是非常不错的。相对而言，使用 jsdelivr 来加速网站相关文件可以满足基本使用。查看 Github Status，Pages 服务会出现偶尔挂掉的情况，但多数仓库文档、演示等都选择了 Github Pages 服务。</p>
<p>使用及扩展：提供二级域名，支持域名绑定及免费 SSL 证书。网站内容与仓库保存一致，自动推送。通过使用 Github Actions 具有较强扩展性。</p>
<h3 id="Netlify"><a href="#Netlify" class="headerlink" title="Netlify"></a>Netlify</h3><p>免费扩展性强无限制性</p>
<p>使用体验：Netlify 的节点设置在海外，但 Netlify 的服务速度尚可，国内部分地区可以到达高速服务。在使用 CDN 的情况下，把网站部署在 Netlify 是可以比较好的选择。Vuejs 和 Hexo 的官网都部署在 Netlify 上，其稳定性可想而知。Netlify 虽然拥有付费功能，但是基本上我们需要使用到的服务都免费。</p>
<p>使用及扩展：提供二级域名，支持域名绑定及免费 SSL 证书。Netlify 支持 Github 或者 Gitlab 等账号登录，如果仓库已经是静态网站文件，每次 Push 到仓库 Netlify 都会自动部署。支持 Build Command，源文件也可以通过提供的环境自动编译或渲染，类似于一款 CI，与 Github Pages 功能相近。</p>
<h3 id="Vercel"><a href="#Vercel" class="headerlink" title="Vercel"></a>Vercel</h3><p>免费扩展性强无限制性</p>
<p>使用体验：Vercel 的体验情况总体和 Netlify 相近，节点设置在海外，访问速度尚可。前身是 now.sh，作为一个高质量的静态托管平台，Vercel的使用体验非常好，是一个可选的优秀平台。</p>
<p>使用及扩展：提供二级域名，支持域名绑定及免费 SSL 证书。支持 Github 或者 Gitlab 等账号登录，如果仓库已经是静态网站文件，每次 Push 到仓库都会自动部署。Vercel 打出了 free forever 的口号，也就是说在非商用的情况下，个人可以永久免费使用。支持设置环境并执行相关命令，自动部署不在话下。</p>
<h3 id="Coding"><a href="#Coding" class="headerlink" title="Coding"></a>Coding</h3><p>免费一般扩展性限制性</p>
<p>使用体验：Coding 是腾讯系的一个国内托管平台，对于人数较少的团体实行免费制度。服务器节点部署在国内，在国内使用访问速度较快。也是国内开放程度比较高的一个代码托管平台了，静态网站功能 Coding 最近改版了一下，相对于之前来说更稳定了一些。</p>
<p>使用及扩展：提供二级域名，支持域名绑定及免费 SSL 证书。基于 Kubernetes 的持续部署，可以人我们体验到与 DevOps 体系紧密结合的持续部署能力。持续中提供静态网站托管，但是静态网站托管需要实名和绑定手机号。</p>
<h3 id="Gitee"><a href="#Gitee" class="headerlink" title="Gitee"></a>Gitee</h3><p>免费（国内限制）扩展性较低限制性强</p>
<p>使用体验：Gitee 是一个国内托管平台，对比 coding 来说较为封闭。静态托管功能上拥有较大限制，且无法自动部署，功能残缺。</p>
<p>使用及扩展：提供二级域名，非付费版不支持自动部署、域名绑定及免费 SSL 证书。如果强制使用 https，可能会造成样式文件失效等问题。</p>
<h3 id="TCB"><a href="#TCB" class="headerlink" title="TCB"></a>TCB</h3><p>付费扩展性高一般限制性</p>
<p>使用体验：TCB(Tencent CloudBase）采用 serverless 架构，提供静态托管服务。我的主站就是使用 TCB，相对而言因为付费了，所以效果较好，在全国各地有 CDN 节点，目前使用是因为腾讯的赞助计划，如果赞助计划失效了，价格过高可能会考虑切换平台。空间较大，流量较多，已经充当 CDN 使用了。</p>
<p>使用及扩展：提供二级域名，支持自动部署及 免费SSL 证书，但是 SSL 证书申请可能需要备案。扩展性较强，可以使用 CLI 工具或者 Tencent CloudBase Github Action 来部署。</p>
<h2 id="多节点部署方案"><a href="#多节点部署方案" class="headerlink" title="多节点部署方案"></a>多节点部署方案</h2><p><img src="https://gitee.com/songjianzaina/site_img/raw/master/img/20240409105357.png" alt></p>
<h3 id="几个仓库"><a href="#几个仓库" class="headerlink" title="几个仓库"></a>几个仓库</h3><h4 id="Hexo-源码仓库"><a href="#Hexo-源码仓库" class="headerlink" title="Hexo 源码仓库"></a>Hexo 源码仓库</h4><p>从图中可以看到使用了 <code>Blog-Source</code> 这个仓库为 Hexo 源码仓库，这个仓库有一个使用了两个 Github Actions，一个用来渲染博客文件并推送到 TCB 静态托管平台，一个用来渲染博客文件推送到各个 Git 仓库，理论上一个 Action 也可以完成这些任务，但是便于管理我选择了两个 Action。</p>
<p>推送至各个 Git 仓库</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">Deploy</span> <span class="string">to</span> <span class="string">Repo(Github,</span> <span class="string">Coding,</span> <span class="string">Gitee)</span></span><br><span class="line"><span class="attr">on:</span> <span class="string">[push]</span></span><br><span class="line"><span class="attr">jobs:</span></span><br><span class="line"><span class="attr">  build:</span></span><br><span class="line"><span class="attr">    runs-on:</span> <span class="string">ubuntu-latest</span></span><br><span class="line"><span class="attr">    env:</span> </span><br><span class="line"><span class="attr">      hTZ:</span> <span class="string">Asia/Shanghai</span></span><br><span class="line"><span class="attr">    steps:</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">Checkout</span></span><br><span class="line"><span class="attr">      uses:</span> <span class="string">actions/checkout@v2</span></span><br><span class="line"><span class="attr">      with:</span></span><br><span class="line"><span class="attr">        ref:</span> <span class="string">master</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">Update</span> <span class="string">Submodule</span></span><br><span class="line"><span class="attr">      run:</span> <span class="string">|</span></span><br><span class="line"><span class="string">        git submodule init</span></span><br><span class="line"><span class="string">        git submodule update --remote</span></span><br><span class="line"><span class="string"></span><span class="attr">    - name:</span> <span class="string">Setup</span> <span class="string">Node</span></span><br><span class="line"><span class="attr">      uses:</span> <span class="string">actions/setup-node@v1</span></span><br><span class="line"><span class="attr">      with:</span></span><br><span class="line"><span class="attr">        node-version:</span> <span class="string">"10.x"</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">Hexo</span> <span class="string">Generate</span></span><br><span class="line"><span class="attr">      run:</span> <span class="string">|</span></span><br><span class="line"><span class="string">        rm -f .yarnclean</span></span><br><span class="line"><span class="string">        yarn --frozen-lockfile --ignore-engines --ignore-optional --non-interactive --silent --ignore-scripts --production=false</span></span><br><span class="line"><span class="string">        rm -rf ./public</span></span><br><span class="line"><span class="string">        yarn run hexo clean</span></span><br><span class="line"><span class="string">        yarn run hexo generate</span></span><br><span class="line"><span class="string"></span><span class="attr">    - name:</span> <span class="string">Hexo</span> <span class="string">Deploy</span></span><br><span class="line"><span class="attr">      env:</span></span><br><span class="line"><span class="attr">        SSH_PRIVATE:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.SSH_PRIVATE</span> <span class="string">&#125;&#125;</span></span><br><span class="line"><span class="attr">        GIT_NAME:</span> <span class="string">vinceying</span></span><br><span class="line"><span class="attr">        GIT_EMAIL:</span> <span class="string">admin@vicne.pub</span></span><br><span class="line"><span class="attr">      run:</span> <span class="string">|</span></span><br><span class="line"><span class="string">        mkdir -p ~/.ssh/</span></span><br><span class="line"><span class="string">        echo "$SSH_PRIVATE" | tr -d '\r' &gt; ~/.ssh/id_rsa</span></span><br><span class="line"><span class="string">        chmod 600 ~/.ssh/id_rsa</span></span><br><span class="line"><span class="string">        ssh-keyscan e.coding.net &gt;&gt; ~/.ssh/known_hosts</span></span><br><span class="line"><span class="string">        ssh-keyscan github.com &gt;&gt; ~/.ssh/known_hosts</span></span><br><span class="line"><span class="string">        ssh-keyscan gitee.com &gt;&gt; ~/.ssh/known_hosts</span></span><br><span class="line"><span class="string">        git config --global user.name "$GIT_NAME"</span></span><br><span class="line"><span class="string">        git config --global user.email "$GIT_EMAIL"</span></span><br><span class="line"><span class="string">        yarn run hexo deploy</span></span><br></pre></td></tr></table></figure>

<p>推送至 TCB</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">Deploy</span> <span class="string">to</span> <span class="string">Tencent</span> <span class="string">CloudBase</span></span><br><span class="line"><span class="attr">on:</span> <span class="string">push</span></span><br><span class="line"><span class="attr">jobs:</span></span><br><span class="line"><span class="attr">  build:</span></span><br><span class="line"><span class="attr">    runs-on:</span> <span class="string">ubuntu-latest</span></span><br><span class="line"><span class="attr">    env:</span></span><br><span class="line"><span class="attr">      TZ:</span> <span class="string">Asia/Shanghai</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">Deploy</span> <span class="string">Hexo</span> <span class="string">Souce</span> <span class="string">Repo</span> <span class="string">to</span> <span class="string">Tencent</span> <span class="string">CloudBase</span></span><br><span class="line"><span class="attr">    steps:</span></span><br><span class="line"><span class="attr">      - name:</span> <span class="string">Checkout</span></span><br><span class="line"><span class="attr">        uses:</span> <span class="string">actions/checkout@v2</span></span><br><span class="line"><span class="attr">      - name:</span> <span class="string">Setup</span> <span class="string">Node</span></span><br><span class="line"><span class="attr">        uses:</span> <span class="string">actions/setup-node@v1</span></span><br><span class="line"><span class="attr">        with:</span></span><br><span class="line"><span class="attr">          node-version:</span> <span class="string">'10.x'</span></span><br><span class="line">      <span class="comment"># NPM 环境及 Hexo 部署</span></span><br><span class="line"><span class="attr">      - name:</span> <span class="string">NPM</span></span><br><span class="line"><span class="attr">        run:</span> <span class="string">npm</span> <span class="string">install</span></span><br><span class="line"><span class="attr">      - name:</span> <span class="string">Clean</span></span><br><span class="line"><span class="attr">        run:</span> <span class="string">./node_modules/.bin/hexo</span> <span class="string">clean</span></span><br><span class="line"><span class="attr">      - name:</span> <span class="string">Generate</span></span><br><span class="line"><span class="attr">        run:</span> <span class="string">./node_modules/.bin/hexo</span> <span class="string">generate</span></span><br><span class="line">      <span class="comment"># Deploy static to Tencent CloudBase</span></span><br><span class="line"><span class="attr">      - name:</span> <span class="string">Deploy</span> <span class="string">static</span> <span class="string">to</span> <span class="string">Tencent</span> <span class="string">CloudBase</span></span><br><span class="line"><span class="attr">        id:</span> <span class="string">deployStatic</span></span><br><span class="line"><span class="attr">        uses:</span> <span class="string">TencentCloudBase/cloudbase-action@v1.1.1</span></span><br><span class="line"><span class="attr">        with:</span></span><br><span class="line"><span class="attr">          secretId:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.SECRET_ID</span> <span class="string">&#125;&#125;</span></span><br><span class="line"><span class="attr">          secretKey:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.SECRET_KEY</span> <span class="string">&#125;&#125;</span></span><br><span class="line"><span class="attr">          envId:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.ENV_ID</span> <span class="string">&#125;&#125;</span></span><br><span class="line"><span class="attr">          staticSrcPath:</span> <span class="string">public</span></span><br></pre></td></tr></table></figure>

<h4 id="Github-博客页面仓库"><a href="#Github-博客页面仓库" class="headerlink" title="Github 博客页面仓库"></a>Github 博客页面仓库</h4><p>这个作为使用 Github Pages 服务的仓库，同时在 Netlify 和 Vercel 的选择为源仓库，在每次推送至本仓库时，Netlify 和 Vercel 都会自动部署新文件。</p>
<h4 id="CDN-文件仓库"><a href="#CDN-文件仓库" class="headerlink" title="CDN 文件仓库"></a>CDN 文件仓库</h4><p>这个仓库作为管理和存放一些需要推送到 CDN 的文件，比如 css 文件、图片和视频等，首先是为了便于管理及通过 Github Actions推送 到 TCB，其次是为了使用 Jsdelivr CDN 服务作为备用 CDN。</p>
<h3 id="方案优点"><a href="#方案优点" class="headerlink" title="方案优点"></a>方案优点</h3><ul>
<li>高效自动化，利用 Github Actions,每次只要 Push 到 <code>Blog-Souce</code>和<code>Blog-file</code>仓库就可以全仓库和全节点同步。</li>
<li>便于管理文件，当主 CDN 失效后，直接替换 CDN 地址链接即可完成启用备用 CDN，且备份了文件。</li>
<li>多设备管理，当切换设备后，直接在不安装环境的情况下直接 Clone 即可管理博客，但调试方面还是需要安装环境。特别是在 Github 的云端 IDE-Codespace 正式发布后，可以完全通过仓库管理博客。</li>
</ul>
<p><strong>本文转载自:</strong> <a href="https://i.vince.pub/p/hexo-static/" target="_blank" rel="noopener">HexoThemeFluid</a></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em><a href="https://code.newban.cn/">乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</a></em></p>
]]></content>
      <tags>
        <tag>网站托管</tag>
      </tags>
  </entry>
  <entry>
    <title>android逆向反编译工具包下载</title>
    <url>/455.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>该压缩包为《<a href="https://code.newban.cn/450.html">Android进阶之逆向安全反编译视频教程-胖薯出品</a>》的配套工具包</p>
<h2 id="工具包"><a href="#工具包" class="headerlink" title="工具包"></a>工具包</h2><p>该压缩包包含以下工具:</p>
<h3 id="命令行工具"><a href="#命令行工具" class="headerlink" title="命令行工具"></a>命令行工具</h3><ul>
<li>apktool2.4</li>
<li>dex2jar2.0</li>
</ul>
<h3 id="集成工具"><a href="#集成工具" class="headerlink" title="集成工具"></a>集成工具</h3><ul>
<li>jadx0.9</li>
<li>jd-gui.exe</li>
<li>apkIDE</li>
<li>安卓逆向助手2.0</li>
</ul>
<h2 id="工具下载"><a href="#工具下载" class="headerlink" title="工具下载"></a>工具下载</h2><p><a href="https://545c.com/file/21042697-468848041" target="_blank" rel="noopener">点击进入</a></p>
<p><strong>本文为作者原创 转载时请注明出处 谢谢</strong></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em><a href="https://code.newban.cn/">乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</a></em></p>
]]></content>
      <tags>
        <tag>android逆向</tag>
      </tags>
  </entry>
  <entry>
    <title>各大音乐平台的api汇总</title>
    <url>/456.html</url>
    <content><![CDATA[<h2 id="网易云音乐"><a href="#网易云音乐" class="headerlink" title="网易云音乐"></a>网易云音乐</h2><h3 id="歌曲搜索"><a href="#歌曲搜索" class="headerlink" title="歌曲搜索"></a>歌曲搜索</h3><h4 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h4><p>请求方式 : POST</p>
<p>请求地址 : </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https://music.163.com/api/search/get/web?csrf_token=hlpretag=&amp;hlposttag=&amp;s=歌名&amp;type=1&amp;offset=0&amp;total=true&amp;limit=1</span><br></pre></td></tr></table></figure>

<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https://music.163.com/api/search/get/web?csrf_token=hlpretag=&amp;hlposttag=&amp;s=阳光正好-十二越&amp;type=1&amp;offset=0&amp;total=true&amp;limit=1</span><br></pre></td></tr></table></figure>

<h4 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h4><p>请求结果如下:</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	<span class="attr">"result"</span>: &#123;</span><br><span class="line">		<span class="attr">"songs"</span>: [</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="attr">"id"</span>: <span class="number">1335942808</span>,</span><br><span class="line">				<span class="attr">"name"</span>: <span class="string">"阳光正好"</span>,</span><br><span class="line">				<span class="attr">"artists"</span>: [</span><br><span class="line">					&#123;</span><br><span class="line">						<span class="attr">"id"</span>: <span class="number">31021271</span>,</span><br><span class="line">						<span class="attr">"name"</span>: <span class="string">"十二越"</span>,</span><br><span class="line">						<span class="attr">"picUrl"</span>: <span class="literal">null</span>,</span><br><span class="line">						<span class="attr">"alias"</span>: [],</span><br><span class="line">						<span class="attr">"albumSize"</span>: <span class="number">0</span>,</span><br><span class="line">						<span class="attr">"picId"</span>: <span class="number">0</span>,</span><br><span class="line">						<span class="attr">"fansGroup"</span>: <span class="literal">null</span>,</span><br><span class="line">						<span class="attr">"img1v1Url"</span>: <span class="string">"https://p2.music.126.net/6y-UleORITEDbvrOLV0Q8A==/5639395138885805.jpg"</span>,</span><br><span class="line">						<span class="attr">"img1v1"</span>: <span class="number">0</span>,</span><br><span class="line">						<span class="attr">"trans"</span>: <span class="literal">null</span></span><br><span class="line">					&#125;</span><br><span class="line">				],</span><br><span class="line">				<span class="attr">"album"</span>: &#123;</span><br><span class="line">					<span class="attr">"id"</span>: <span class="number">74994476</span>,</span><br><span class="line">					<span class="attr">"name"</span>: <span class="string">"阳光正好"</span>,</span><br><span class="line">					<span class="attr">"artist"</span>: &#123;</span><br><span class="line">						<span class="attr">"id"</span>: <span class="number">0</span>,</span><br><span class="line">						<span class="attr">"name"</span>: <span class="string">""</span>,</span><br><span class="line">						<span class="attr">"picUrl"</span>: <span class="literal">null</span>,</span><br><span class="line">						<span class="attr">"alias"</span>: [],</span><br><span class="line">						<span class="attr">"albumSize"</span>: <span class="number">0</span>,</span><br><span class="line">						<span class="attr">"picId"</span>: <span class="number">0</span>,</span><br><span class="line">						<span class="attr">"fansGroup"</span>: <span class="literal">null</span>,</span><br><span class="line">						<span class="attr">"img1v1Url"</span>: <span class="string">"https://p1.music.126.net/6y-UleORITEDbvrOLV0Q8A==/5639395138885805.jpg"</span>,</span><br><span class="line">						<span class="attr">"img1v1"</span>: <span class="number">0</span>,</span><br><span class="line">						<span class="attr">"trans"</span>: <span class="literal">null</span></span><br><span class="line">					&#125;,</span><br><span class="line">					<span class="attr">"publishTime"</span>: <span class="number">1545753600000</span>,</span><br><span class="line">					<span class="attr">"size"</span>: <span class="number">1</span>,</span><br><span class="line">					<span class="attr">"copyrightId"</span>: <span class="number">558010</span>,</span><br><span class="line">					<span class="attr">"status"</span>: <span class="number">0</span>,</span><br><span class="line">					<span class="attr">"picId"</span>: <span class="number">109951163752920822</span>,</span><br><span class="line">					<span class="attr">"mark"</span>: <span class="number">0</span></span><br><span class="line">				&#125;,</span><br><span class="line">				<span class="attr">"duration"</span>: <span class="number">304111</span>,</span><br><span class="line">				<span class="attr">"copyrightId"</span>: <span class="number">558010</span>,</span><br><span class="line">				<span class="attr">"status"</span>: <span class="number">0</span>,</span><br><span class="line">				<span class="attr">"alias"</span>: [],</span><br><span class="line">				<span class="attr">"rtype"</span>: <span class="number">0</span>,</span><br><span class="line">				<span class="attr">"ftype"</span>: <span class="number">0</span>,</span><br><span class="line">				<span class="attr">"mvid"</span>: <span class="number">0</span>,</span><br><span class="line">				<span class="attr">"fee"</span>: <span class="number">8</span>,</span><br><span class="line">				<span class="attr">"rUrl"</span>: <span class="literal">null</span>,</span><br><span class="line">				<span class="attr">"mark"</span>: <span class="number">8192</span></span><br><span class="line">			&#125;</span><br><span class="line">		],</span><br><span class="line">		<span class="attr">"songCount"</span>: <span class="number">1</span></span><br><span class="line">	&#125;,</span><br><span class="line">	<span class="attr">"code"</span>: <span class="number">200</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="获取歌曲播放直链地址"><a href="#获取歌曲播放直链地址" class="headerlink" title="获取歌曲播放直链地址"></a>获取歌曲播放直链地址</h3><h4 id="格式-1"><a href="#格式-1" class="headerlink" title="格式"></a>格式</h4><p>请求方式 :<code>GET</code></p>
<p>请求地址 : </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https://music.163.com/song/media/outer/url?id=歌曲ID.mp3</span><br></pre></td></tr></table></figure>

<h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h4><p>歌曲ID我们可以通过浏览器地址获取 比如 <code>http://music.163.com/#/m/song?id=1901359372</code></p>
<p>那么该首歌的直链地址为:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https://music.163.com/song/media/outer/url?id=1901359372.mp3</span><br></pre></td></tr></table></figure>

<p>我们可以将该地址其嵌入到 HTML中 使用<code>audio</code>标签:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">audio</span> <span class="attr">controls</span>=<span class="string">"controls"</span> <span class="attr">title</span>=<span class="string">"歌名"</span> <span class="attr">src</span>=<span class="string">"直链地址"</span>&gt;</span><span class="tag">&lt;/<span class="name">audio</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="效果-1"><a href="#效果-1" class="headerlink" title="效果"></a>效果</h4><p><audio controls="controls" title="歌名" src="https://music.163.com/song/media/outer/url?id=1901359372.mp3"></audio></p>
<p>注意: 这种方式只能获取到免费歌曲的直链 如果是VIP收费歌曲 则获取不到 </p>
<h3 id="获取歌曲歌词"><a href="#获取歌曲歌词" class="headerlink" title="获取歌曲歌词"></a>获取歌曲歌词</h3><h4 id="格式-2"><a href="#格式-2" class="headerlink" title="格式"></a>格式</h4><p>请求方式 : <code>GET</code></p>
<p>请求地址:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http://music.163.com/api/song/lyric?os=pc&amp;id=歌曲ID&amp;lv=-1&amp;kv=-1&amp;tv=-1</span><br></pre></td></tr></table></figure>

<p>请求参数含义:</p>
<ul>
<li><code>&amp;tv=-1</code> : 表示获取歌词译文</li>
<li><code>&amp;lv=-1</code> : 表示获取歌词原文</li>
<li><code>&amp;kv=-1</code> : 表示获取歌词状态信息</li>
</ul>
<h4 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http://music.163.com/api/song/lyric?os=pc&amp;id=1901359372&amp;lv=-1&amp;kv=-1&amp;tv=-1</span><br></pre></td></tr></table></figure>

<h4 id="效果-2"><a href="#效果-2" class="headerlink" title="效果"></a>效果</h4><p>请求结果如下:</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	<span class="attr">"sgc"</span>: <span class="literal">false</span>,</span><br><span class="line">	<span class="attr">"sfy"</span>: <span class="literal">false</span>,</span><br><span class="line">	<span class="attr">"qfy"</span>: <span class="literal">false</span>,</span><br><span class="line">	<span class="attr">"lrc"</span>: &#123;</span><br><span class="line">		<span class="attr">"version"</span>: <span class="number">3</span>,</span><br><span class="line">		<span class="attr">"lyric"</span>: <span class="string">"[00:00.00] 作词 : 十二越\n[00:01.00] 作曲 : 十二越\n[00:02.00] 编曲 : 十二越\n[00:16.28]\n[00:31.53] 你在哪里\n[00:37.87] 回忆闪烁不停\n[00:45.05] 我在这里\n[00:50.81] 一直等你\n[00:53.24] 在原地\n[00:57.71]\n[00:58.54] 时间一点一点过去\n[01:03.65] 真假不明\n[01:07.00] 沉醉在我们记忆\n[01:11.04]\n[01:12.05] 世界开始变得忧郁\n[01:17.14] 昏暗不明\n[01:20.49] 只为了你\n[01:25.39]\n[01:25.62] 你说 你说你还爱我\n[01:30.63] 是唯一的承诺\n[01:33.92] 却只剩承诺 没有了结果\n[01:36.43]\n[01:38.86] 你说 你说你会等我\n[01:44.12] 是绝对的承诺\n[01:47.55] 却没了联络 只剩下沉默\n[01:49.28]\n[01:50.62]\n[01:52.65] 你在哪里\n[01:59.01] 回忆闪烁不停\n[02:06.15] 我在这里\n[02:11.62] 一直等你\n[02:14.56] 在原地\n[02:18.24]\n[02:19.68] 时间一点一点过去\n[02:24.75] 真假不明\n[02:28.15] 沉醉在我们记忆\n[02:29.63]\n[02:33.14] 世界开始变得忧郁\n[02:38.23] 昏暗不明\n[02:41.61] 只为了你\n[02:43.30]\n[02:46.70] 你说 你说你还爱我\n[02:51.73] 是唯一的承诺\n[02:55.12] 却只剩承诺 没有了结果\n[02:59.38]\n[03:00.18] 你说 你说你会等我\n[03:05.32] 是绝对的承诺\n[03:08.69] 却没了联络 只剩下沉默\n[03:10.41]\n[03:13.82] 你说 你说你还爱我\n[03:19.69] 最后的承诺变成了软弱\n[03:25.19] 你说 你说 你说....\n[03:28.86]\n[03:40.89] 你说 你说你还爱我\n[03:45.89] 是唯一的承诺\n[03:49.26] 却只剩承诺 没有了结果\n[03:51.51]\n[03:54.36] 你说 你说你还爱我\n[04:00.33] 最后的承诺变成了软弱\n[04:10.02] 你说\n[04:12.56]\n[04:29.25] 混音 : 十二越\n"</span></span><br><span class="line">	&#125;,</span><br><span class="line">	<span class="attr">"klyric"</span>: &#123;</span><br><span class="line">		<span class="attr">"version"</span>: <span class="number">0</span>,</span><br><span class="line">		<span class="attr">"lyric"</span>: <span class="string">""</span></span><br><span class="line">	&#125;,</span><br><span class="line">	<span class="attr">"tlyric"</span>: &#123;</span><br><span class="line">		<span class="attr">"version"</span>: <span class="number">0</span>,</span><br><span class="line">		<span class="attr">"lyric"</span>: <span class="string">""</span></span><br><span class="line">	&#125;,</span><br><span class="line">	<span class="attr">"code"</span>: <span class="number">200</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="获取歌曲的详细信息"><a href="#获取歌曲的详细信息" class="headerlink" title="获取歌曲的详细信息"></a>获取歌曲的详细信息</h3><h4 id="格式-3"><a href="#格式-3" class="headerlink" title="格式"></a>格式</h4><p>请求方法: <code>GET</code></p>
<p>请求地址 :</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http://music.163.com/api/song/detail/?id=歌曲id&amp;ids=[歌曲id]</span><br></pre></td></tr></table></figure>

<h4 id="示例-3"><a href="#示例-3" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http://music.163.com/api/song/detail/?id=1901359372&amp;ids=[1901359372]</span><br></pre></td></tr></table></figure>

<h4 id="效果-3"><a href="#效果-3" class="headerlink" title="效果"></a>效果</h4><p>请求结果如下:</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	<span class="attr">"songs"</span>: [</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="attr">"name"</span>: <span class="string">"你说你还爱我"</span>,</span><br><span class="line">			<span class="attr">"id"</span>: <span class="number">1901359372</span>,</span><br><span class="line">			<span class="attr">"position"</span>: <span class="number">0</span>,</span><br><span class="line">			<span class="attr">"alias"</span>: [],</span><br><span class="line">			<span class="attr">"status"</span>: <span class="number">0</span>,</span><br><span class="line">			<span class="attr">"fee"</span>: <span class="number">8</span>,</span><br><span class="line">			<span class="attr">"copyrightId"</span>: <span class="number">2708773</span>,</span><br><span class="line">			<span class="attr">"disc"</span>: <span class="string">"01"</span>,</span><br><span class="line">			<span class="attr">"no"</span>: <span class="number">4</span>,</span><br><span class="line">			<span class="attr">"artists"</span>: [</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="attr">"name"</span>: <span class="string">"十二越"</span>,</span><br><span class="line">					<span class="attr">"id"</span>: <span class="number">31021271</span>,</span><br><span class="line">					<span class="attr">"picId"</span>: <span class="number">0</span>,</span><br><span class="line">					<span class="attr">"img1v1Id"</span>: <span class="number">0</span>,</span><br><span class="line">					<span class="attr">"briefDesc"</span>: <span class="string">""</span>,</span><br><span class="line">					<span class="attr">"picUrl"</span>: <span class="string">"http://p2.music.126.net/6y-UleORITEDbvrOLV0Q8A==/5639395138885805.jpg"</span>,</span><br><span class="line">					<span class="attr">"img1v1Url"</span>: <span class="string">"http://p2.music.126.net/6y-UleORITEDbvrOLV0Q8A==/5639395138885805.jpg"</span>,</span><br><span class="line">					<span class="attr">"albumSize"</span>: <span class="number">0</span>,</span><br><span class="line">					<span class="attr">"alias"</span>: [],</span><br><span class="line">					<span class="attr">"trans"</span>: <span class="string">""</span>,</span><br><span class="line">					<span class="attr">"musicSize"</span>: <span class="number">0</span>,</span><br><span class="line">					<span class="attr">"topicPerson"</span>: <span class="number">0</span></span><br><span class="line">				&#125;</span><br><span class="line">			],</span><br><span class="line">			<span class="attr">"album"</span>: &#123;</span><br><span class="line">				<span class="attr">"name"</span>: <span class="string">"茶余饭后"</span>,</span><br><span class="line">				<span class="attr">"id"</span>: <span class="number">137142351</span>,</span><br><span class="line">				<span class="attr">"type"</span>: <span class="string">"EP"</span>,</span><br><span class="line">				<span class="attr">"size"</span>: <span class="number">5</span>,</span><br><span class="line">				<span class="attr">"picId"</span>: <span class="number">109951166702919266</span>,</span><br><span class="line">				<span class="attr">"blurPicUrl"</span>: <span class="string">"http://p2.music.126.net/3474m94J-3GI3LIfdRTBmA==/109951166702919266.jpg"</span>,</span><br><span class="line">				<span class="attr">"companyId"</span>: <span class="number">0</span>,</span><br><span class="line">				<span class="attr">"pic"</span>: <span class="number">109951166702919266</span>,</span><br><span class="line">				<span class="attr">"picUrl"</span>: <span class="string">"http://p2.music.126.net/3474m94J-3GI3LIfdRTBmA==/109951166702919266.jpg"</span>,</span><br><span class="line">				<span class="attr">"publishTime"</span>: <span class="number">1638892800000</span>,</span><br><span class="line">				<span class="attr">"description"</span>: <span class="string">""</span>,</span><br><span class="line">				<span class="attr">"tags"</span>: <span class="string">""</span>,</span><br><span class="line">				<span class="attr">"company"</span>: <span class="string">"HIFIVE智能经纪人"</span>,</span><br><span class="line">				<span class="attr">"briefDesc"</span>: <span class="string">""</span>,</span><br><span class="line">				<span class="attr">"artist"</span>: &#123;</span><br><span class="line">					<span class="attr">"name"</span>: <span class="string">""</span>,</span><br><span class="line">					<span class="attr">"id"</span>: <span class="number">0</span>,</span><br><span class="line">					<span class="attr">"picId"</span>: <span class="number">0</span>,</span><br><span class="line">					<span class="attr">"img1v1Id"</span>: <span class="number">0</span>,</span><br><span class="line">					<span class="attr">"briefDesc"</span>: <span class="string">""</span>,</span><br><span class="line">					<span class="attr">"picUrl"</span>: <span class="string">"http://p2.music.126.net/6y-UleORITEDbvrOLV0Q8A==/5639395138885805.jpg"</span>,</span><br><span class="line">					<span class="attr">"img1v1Url"</span>: <span class="string">"http://p2.music.126.net/6y-UleORITEDbvrOLV0Q8A==/5639395138885805.jpg"</span>,</span><br><span class="line">					<span class="attr">"albumSize"</span>: <span class="number">0</span>,</span><br><span class="line">					<span class="attr">"alias"</span>: [],</span><br><span class="line">					<span class="attr">"trans"</span>: <span class="string">""</span>,</span><br><span class="line">					<span class="attr">"musicSize"</span>: <span class="number">0</span>,</span><br><span class="line">					<span class="attr">"topicPerson"</span>: <span class="number">0</span></span><br><span class="line">				&#125;,</span><br><span class="line">				<span class="attr">"songs"</span>: [],</span><br><span class="line">				<span class="attr">"alias"</span>: [],</span><br><span class="line">				<span class="attr">"status"</span>: <span class="number">0</span>,</span><br><span class="line">				<span class="attr">"copyrightId"</span>: <span class="number">2708773</span>,</span><br><span class="line">				<span class="attr">"commentThreadId"</span>: <span class="string">"R_AL_3_137142351"</span>,</span><br><span class="line">				<span class="attr">"artists"</span>: [</span><br><span class="line">					&#123;</span><br><span class="line">						<span class="attr">"name"</span>: <span class="string">"十二越"</span>,</span><br><span class="line">						<span class="attr">"id"</span>: <span class="number">31021271</span>,</span><br><span class="line">						<span class="attr">"picId"</span>: <span class="number">0</span>,</span><br><span class="line">						<span class="attr">"img1v1Id"</span>: <span class="number">0</span>,</span><br><span class="line">						<span class="attr">"briefDesc"</span>: <span class="string">""</span>,</span><br><span class="line">						<span class="attr">"picUrl"</span>: <span class="string">"http://p2.music.126.net/6y-UleORITEDbvrOLV0Q8A==/5639395138885805.jpg"</span>,</span><br><span class="line">						<span class="attr">"img1v1Url"</span>: <span class="string">"http://p2.music.126.net/6y-UleORITEDbvrOLV0Q8A==/5639395138885805.jpg"</span>,</span><br><span class="line">						<span class="attr">"albumSize"</span>: <span class="number">0</span>,</span><br><span class="line">						<span class="attr">"alias"</span>: [],</span><br><span class="line">						<span class="attr">"trans"</span>: <span class="string">""</span>,</span><br><span class="line">						<span class="attr">"musicSize"</span>: <span class="number">0</span>,</span><br><span class="line">						<span class="attr">"topicPerson"</span>: <span class="number">0</span></span><br><span class="line">					&#125;</span><br><span class="line">				],</span><br><span class="line">				<span class="attr">"subType"</span>: <span class="string">"录音室版"</span>,</span><br><span class="line">				<span class="attr">"transName"</span>: <span class="literal">null</span>,</span><br><span class="line">				<span class="attr">"onSale"</span>: <span class="literal">false</span>,</span><br><span class="line">				<span class="attr">"mark"</span>: <span class="number">0</span>,</span><br><span class="line">				<span class="attr">"gapless"</span>: <span class="number">0</span>,</span><br><span class="line">				<span class="attr">"dolbyMark"</span>: <span class="number">0</span>,</span><br><span class="line">				<span class="attr">"picId_str"</span>: <span class="string">"109951166702919266"</span></span><br><span class="line">			&#125;,</span><br><span class="line">			<span class="attr">"starred"</span>: <span class="literal">false</span>,</span><br><span class="line">			<span class="attr">"popularity"</span>: <span class="number">5</span>,</span><br><span class="line">			<span class="attr">"score"</span>: <span class="number">5</span>,</span><br><span class="line">			<span class="attr">"starredNum"</span>: <span class="number">0</span>,</span><br><span class="line">			<span class="attr">"duration"</span>: <span class="number">269258</span>,</span><br><span class="line">			<span class="attr">"playedNum"</span>: <span class="number">0</span>,</span><br><span class="line">			<span class="attr">"dayPlays"</span>: <span class="number">0</span>,</span><br><span class="line">			<span class="attr">"hearTime"</span>: <span class="number">0</span>,</span><br><span class="line">			<span class="attr">"sqMusic"</span>: &#123;</span><br><span class="line">				<span class="attr">"name"</span>: <span class="literal">null</span>,</span><br><span class="line">				<span class="attr">"id"</span>: <span class="number">6988110024</span>,</span><br><span class="line">				<span class="attr">"size"</span>: <span class="number">28403471</span>,</span><br><span class="line">				<span class="attr">"extension"</span>: <span class="string">"flac"</span>,</span><br><span class="line">				<span class="attr">"sr"</span>: <span class="number">44100</span>,</span><br><span class="line">				<span class="attr">"dfsId"</span>: <span class="number">0</span>,</span><br><span class="line">				<span class="attr">"bitrate"</span>: <span class="number">843901</span>,</span><br><span class="line">				<span class="attr">"playTime"</span>: <span class="number">269258</span>,</span><br><span class="line">				<span class="attr">"volumeDelta"</span>: <span class="number">-37808</span></span><br><span class="line">			&#125;,</span><br><span class="line">			<span class="attr">"hrMusic"</span>: <span class="literal">null</span>,</span><br><span class="line">			<span class="attr">"ringtone"</span>: <span class="string">""</span>,</span><br><span class="line">			<span class="attr">"crbt"</span>: <span class="literal">null</span>,</span><br><span class="line">			<span class="attr">"audition"</span>: <span class="literal">null</span>,</span><br><span class="line">			<span class="attr">"copyFrom"</span>: <span class="string">""</span>,</span><br><span class="line">			<span class="attr">"commentThreadId"</span>: <span class="string">"R_SO_4_1901359372"</span>,</span><br><span class="line">			<span class="attr">"rtUrl"</span>: <span class="literal">null</span>,</span><br><span class="line">			<span class="attr">"ftype"</span>: <span class="number">0</span>,</span><br><span class="line">			<span class="attr">"rtUrls"</span>: [],</span><br><span class="line">			<span class="attr">"copyright"</span>: <span class="number">0</span>,</span><br><span class="line">			<span class="attr">"transName"</span>: <span class="literal">null</span>,</span><br><span class="line">			<span class="attr">"sign"</span>: <span class="literal">null</span>,</span><br><span class="line">			<span class="attr">"mark"</span>: <span class="number">0</span>,</span><br><span class="line">			<span class="attr">"originCoverType"</span>: <span class="number">0</span>,</span><br><span class="line">			<span class="attr">"originSongSimpleData"</span>: <span class="literal">null</span>,</span><br><span class="line">			<span class="attr">"single"</span>: <span class="number">0</span>,</span><br><span class="line">			<span class="attr">"noCopyrightRcmd"</span>: <span class="literal">null</span>,</span><br><span class="line">			<span class="attr">"hMusic"</span>: &#123;</span><br><span class="line">				<span class="attr">"name"</span>: <span class="literal">null</span>,</span><br><span class="line">				<span class="attr">"id"</span>: <span class="number">6988110025</span>,</span><br><span class="line">				<span class="attr">"size"</span>: <span class="number">10772942</span>,</span><br><span class="line">				<span class="attr">"extension"</span>: <span class="string">"mp3"</span>,</span><br><span class="line">				<span class="attr">"sr"</span>: <span class="number">44100</span>,</span><br><span class="line">				<span class="attr">"dfsId"</span>: <span class="number">0</span>,</span><br><span class="line">				<span class="attr">"bitrate"</span>: <span class="number">320000</span>,</span><br><span class="line">				<span class="attr">"playTime"</span>: <span class="number">269258</span>,</span><br><span class="line">				<span class="attr">"volumeDelta"</span>: <span class="number">-37825</span></span><br><span class="line">			&#125;,</span><br><span class="line">			<span class="attr">"mMusic"</span>: &#123;</span><br><span class="line">				<span class="attr">"name"</span>: <span class="literal">null</span>,</span><br><span class="line">				<span class="attr">"id"</span>: <span class="number">6988110027</span>,</span><br><span class="line">				<span class="attr">"size"</span>: <span class="number">6463782</span>,</span><br><span class="line">				<span class="attr">"extension"</span>: <span class="string">"mp3"</span>,</span><br><span class="line">				<span class="attr">"sr"</span>: <span class="number">44100</span>,</span><br><span class="line">				<span class="attr">"dfsId"</span>: <span class="number">0</span>,</span><br><span class="line">				<span class="attr">"bitrate"</span>: <span class="number">192000</span>,</span><br><span class="line">				<span class="attr">"playTime"</span>: <span class="number">269258</span>,</span><br><span class="line">				<span class="attr">"volumeDelta"</span>: <span class="number">-35358</span></span><br><span class="line">			&#125;,</span><br><span class="line">			<span class="attr">"lMusic"</span>: &#123;</span><br><span class="line">				<span class="attr">"name"</span>: <span class="literal">null</span>,</span><br><span class="line">				<span class="attr">"id"</span>: <span class="number">6988110029</span>,</span><br><span class="line">				<span class="attr">"size"</span>: <span class="number">4309203</span>,</span><br><span class="line">				<span class="attr">"extension"</span>: <span class="string">"mp3"</span>,</span><br><span class="line">				<span class="attr">"sr"</span>: <span class="number">44100</span>,</span><br><span class="line">				<span class="attr">"dfsId"</span>: <span class="number">0</span>,</span><br><span class="line">				<span class="attr">"bitrate"</span>: <span class="number">128000</span>,</span><br><span class="line">				<span class="attr">"playTime"</span>: <span class="number">269258</span>,</span><br><span class="line">				<span class="attr">"volumeDelta"</span>: <span class="number">-33920</span></span><br><span class="line">			&#125;,</span><br><span class="line">			<span class="attr">"bMusic"</span>: &#123;</span><br><span class="line">				<span class="attr">"name"</span>: <span class="literal">null</span>,</span><br><span class="line">				<span class="attr">"id"</span>: <span class="number">6988110029</span>,</span><br><span class="line">				<span class="attr">"size"</span>: <span class="number">4309203</span>,</span><br><span class="line">				<span class="attr">"extension"</span>: <span class="string">"mp3"</span>,</span><br><span class="line">				<span class="attr">"sr"</span>: <span class="number">44100</span>,</span><br><span class="line">				<span class="attr">"dfsId"</span>: <span class="number">0</span>,</span><br><span class="line">				<span class="attr">"bitrate"</span>: <span class="number">128000</span>,</span><br><span class="line">				<span class="attr">"playTime"</span>: <span class="number">269258</span>,</span><br><span class="line">				<span class="attr">"volumeDelta"</span>: <span class="number">-33920</span></span><br><span class="line">			&#125;,</span><br><span class="line">			<span class="attr">"mvid"</span>: <span class="number">0</span>,</span><br><span class="line">			<span class="attr">"mp3Url"</span>: <span class="literal">null</span>,</span><br><span class="line">			<span class="attr">"rtype"</span>: <span class="number">0</span>,</span><br><span class="line">			<span class="attr">"rurl"</span>: <span class="literal">null</span></span><br><span class="line">		&#125;</span><br><span class="line">	],</span><br><span class="line">	<span class="attr">"equalizers"</span>: &#123;&#125;,</span><br><span class="line">	<span class="attr">"code"</span>: <span class="number">200</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="QQ音乐"><a href="#QQ音乐" class="headerlink" title="QQ音乐"></a>QQ音乐</h2><p><strong>本文为作者原创 转载时请注明出处 谢谢</strong></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em><a href="https://code.newban.cn/">乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</a></em></p>
]]></content>
      <tags>
        <tag>音乐api</tag>
      </tags>
  </entry>
  <entry>
    <title>关于群晖NAS使用DownloadStation下载直播流的问题以及缓存目录挂载</title>
    <url>/459.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近有群晖NSA下载直播流的需求 在使用<code>DownloadStation</code>套件的时候遇到一些坑 在这里做个记录</p>
<h2 id="关于流的下载"><a href="#关于流的下载" class="headerlink" title="关于流的下载"></a>关于流的下载</h2><p>首先 我需要下载的流地址的格式为:<code>http://xxxx.flv</code></p>
<p>如果我使用常规添加链接地址的方式进行下载 就容易出现处于一直读取保存状态:</p>
<p><img src="https://gitee.com/songjianzaina/site_img/raw/master/img/image-20240412083406987.png" alt="image-20240412083406987"></p>
<p>这种状态下我们无法关闭应用 只能在套件中心停用该应用才能解决 否则后台会持续地从网络拉取数据:</p>
<p><img src="https://gitee.com/songjianzaina/site_img/raw/master/img/image-20240412084021153.png" alt="image-20240412084021153"></p>
<p>问题出在于 该地址输入框更适合填入种子的下载链接而不是视频或者流本身的 虽然这样也能变相地下载视频 但是极度不推荐 很多新手在使用的时候一不注意就掉了坑 我就是其中一个😂</p>
<p>正确的使用方式是将视频或者流地址填入搜索框然后回车:</p>
<p><img src="https://gitee.com/songjianzaina/site_img/raw/master/img/image-20240412085002263.png" alt="image-20240412085002263"></p>
<p><img src="https://gitee.com/songjianzaina/site_img/raw/master/img/image-20240412085055724.png" alt="image-20240412085055724"></p>
<p>此时视频就能正常下载了</p>
<p>可接下来新的问题又出现了 下载过程中无法在下载目录看到当前下载的文件 只有当视频下载完成或者手动终止该下载任务后才能看到 </p>
<p>很明显<code>Download Station</code>有个下载缓存目录 但是这个缓存目录我们在<code>File Station</code>中看不到 只能通过<code>ssh</code>在终端查看</p>
<p>由于我下载的是直播流视频 为了保证视频的完整性 我不能中断视频的下载 在这种情况下 如果要实时查看并当前下载的内容  方便随时播放  那么我需要将隐藏的缓存目录给显示到<code>File Station</code>中</p>
<p>这里 我们需要使用目录的挂载功能</p>
<h2 id="缓存目录的挂载"><a href="#缓存目录的挂载" class="headerlink" title="缓存目录的挂载"></a>缓存目录的挂载</h2><p><code>Download Station</code>默认的缓存目录是<code>/volume/@download</code> 如果我们要将其挂载到指定的目录比如<code>homes/download_cache</code> 那么需要先在<code>File Station</code>中手动创建该文件夹 </p>
<p>注意: 这里不建议使用终端命令进行创建 因为很容易创建隐藏文件</p>
<p>接下来 按照以下步骤进行缓存目录的挂载</p>
<ol>
<li><p>首先在电脑上打开我们的终端窗口 使用<code>ssh</code>连接我们的群晖<code>NAS</code>:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh 你的群晖登录用户名@群晖ip -p22</span><br></pre></td></tr></table></figure>

<p>回车输入登录密码 即可进入到我们的<code>NAS</code></p>
</li>
<li><p>然后使用<code>mount</code>指令将隐藏的缓存目录<code>@download</code>挂载到<code>download_cache</code> 如下:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo mount --<span class="built_in">bind</span> /volume/@download /volume/home/download_cache</span><br></pre></td></tr></table></figure>
</li>
<li><p>挂载完毕后 我们会在<code>File Station</code>中找到该目录 并查看到当前正在下载的视频</p>
<p><img src="https://gitee.com/songjianzaina/site_img/raw/master/img/image-20240412094619148.png" alt="image-20240412094619148"></p>
<p><img src="https://gitee.com/songjianzaina/site_img/raw/master/img/image-20240412094719618.png" alt="image-20240412094719618"></p>
</li>
</ol>
<h2 id="种子缓存目录"><a href="#种子缓存目录" class="headerlink" title="种子缓存目录"></a>种子缓存目录</h2><p>上面我们提到 在种子链接输入框填入视频或流的下载地址 也可下载视频 但是这种方式是不推荐的  </p>
<p>如果你不小心误操作了 或者也想体验一把 那么坑定也想知道这种方式下载的视频缓存目录在到底在哪个位置</p>
<p>这里 我已经给大家提前探查明白了 这个种子的缓存目录就在<code>volume/@tmp</code>下的<code>btdl</code>文件夹中</p>
<p>如果你想查看这里面存放的数据首先需要修改以下目录权限:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo chomd 777 volume/@tmp/btdl</span><br></pre></td></tr></table></figure>

<p>然后我们进入该目录会发现一个<code>upload</code>开头的文件 这个文件就是视频或种子文件:</p>
<p><img src="https://gitee.com/songjianzaina/site_img/raw/master/img/image-20240412103745114.png" alt="image-20240412103745114"></p>
<p>如果是视频文件  那么我们只需要将其拷贝出来修改一下文件后缀名就行</p>
<p>同样的 为了方便在<code>File Station</code>中查看并编辑该文件 我将这个种子缓存目录挂载到<code>home</code>中</p>
<p>操作步骤和上面的大同小异:</p>
<ol>
<li><p>在<code>Flie Station</code>中手动创建一个目录 用于种子缓存目录的映射 我这里将其命名为<code>temp</code> </p>
</li>
<li><p>使用<code>mount</code>指令将目录进行挂载</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo mount --<span class="built_in">bind</span> /volume/@tmp /volume/home/temp</span><br></pre></td></tr></table></figure>
</li>
<li><p>挂载完后 我们就能在<code>File Station</code>中找到该目录以及对应的文件</p>
<p><img src="https://gitee.com/songjianzaina/site_img/raw/master/img/image-20240412103447862.png" alt="image-20240412103447862"></p>
<p>由于我个文件是个<code>flv</code>的视频 所以我将其后缀改为<code>.flv</code></p>
</li>
</ol>
<p><strong>需要注意的是:</strong> </p>
<p>假如你的群晖NAS设有多个存储空间 你若把<code>Download Station</code>套件安装到了<code>volume1</code>中 但是下载目录却指定在了<code>volume2</code>下 </p>
<p>那么 种子缓存目录需要在套件安装磁盘中也就是<code>volume1</code>里面找  <code>@tmp</code> 目录跟随的是套件</p>
<p>而下载缓存目录则是和下载目录同一个磁盘也就是<code>volume2</code>里面找 <code>@download</code>跟随的是下载目录</p>
<h2 id="关于Download-Station使用感受"><a href="#关于Download-Station使用感受" class="headerlink" title="关于Download Station使用感受"></a>关于Download Station使用感受</h2><p>总体还是比较满意的 下载的稳定性不错</p>
<p>大部分下载软件都不支持流的断点续传 然而<code>Download Station</code>却能做到这一点 值得一赞</p>
<p><strong>本文为作者原创 转载时请注明出处 谢谢</strong></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em><a href="https://code.newban.cn/">乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</a></em></p>
]]></content>
      <tags>
        <tag>NAS</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Wireshark对网络进行抓包</title>
    <url>/458.html</url>
    <content><![CDATA[<h2 id="软件介绍"><a href="#软件介绍" class="headerlink" title="软件介绍"></a>软件介绍</h2><p><code>Wireshark</code>是一款非常强大的跨平台抓包工具 支持<code>Mac</code>和<code>Windows</code>平台</p>
<p><img src="https://gitee.com/songjianzaina/site_img/raw/master/img/image-20240411201058820.png" alt="image-20240411201058820"></p>
<p><img src="https://gitee.com/songjianzaina/site_img/raw/master/img/image-20240411201029770.png" alt="image-20240411201029770"></p>
<h2 id="软件下载"><a href="#软件下载" class="headerlink" title="软件下载"></a>软件下载</h2><p><a href="https://www.wireshark.org/" target="_blank" rel="noopener">点击进入官网</a></p>
<h2 id="软件配置"><a href="#软件配置" class="headerlink" title="软件配置"></a>软件配置</h2><p>这里以<code>Mac</code>平台结合谷歌浏览器为例进行配置</p>
<ol>
<li><p>进入谷歌浏览器设置页 选择启动时打开新的标签页</p>
<p><img src="https://gitee.com/songjianzaina/site_img/raw/master/img/image-20240411184036016.png" alt="image-20240411184036016"></p>
</li>
<li><p>创建<code>keylog.txt</code>用于存储<code>ssl</code>密钥 方便<code>https</code>抓包</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /Users/xxx</span><br><span class="line">touch keylog.txt</span><br></pre></td></tr></table></figure>

<p>注意:<code>keylog.txt</code>的存放位置由你自己决定  这里我存放到<code>Users</code>目录下</p>
</li>
<li><p>执行以下指令启动谷歌浏览器</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo /Applications/Google\ Chrome.app/Contents/MacOS/Google\ Chrome --ssl-key-log-file=/Users/xxx/keylog.txt</span><br></pre></td></tr></table></figure>

<p><code>--ssl-key-log-file</code> : 表示将<code>ssl</code>密钥输出到指定文件中</p>
<p>注意: </p>
<ol>
<li><p>由于我将<code>keylog.txt</code>文件放在了用户目录下 所以指令执行必须加<code>sudo</code>表示以管理者的身份运行</p>
</li>
<li><p>如果你的谷歌浏览器并未安装在<code>Applications</code>目录下 可以利用以下指令来获取Chrome应用的路径</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo find / -iname <span class="string">"Google Chrome"</span></span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/songjianzaina/site_img/raw/master/img/image-20240411185614773.png" alt="image-20240411185614773"></p>
</li>
</ol>
</li>
<li><p>在新打开的浏览器中输入你需要进行<code>https</code>抓包的网址 并回车</p>
<p>这里我以百度官网<code>https://baidu.com</code>为例</p>
</li>
<li><p>此时我们会发现<code>keylog.txt</code>文件中已经有了相应的日志信息</p>
<p><img src="https://gitee.com/songjianzaina/site_img/raw/master/img/image-20240411185017352.png" alt="image-20240411185017352"></p>
</li>
<li><p>启动<code>Wireshark</code> 选择需要监控的网卡</p>
<p><img src="https://gitee.com/songjianzaina/site_img/raw/master/img/image-20240411200537770.png" alt="image-20240411200537770"></p>
</li>
<li><p>并配置TLS 关联<code>keylog</code>文件</p>
<p><img src="https://gitee.com/songjianzaina/site_img/raw/master/img/image-20240411185810657.png" alt="image-20240411185810657"></p>
<p><img src="https://gitee.com/songjianzaina/site_img/raw/master/img/image-20240411185830566.png" alt="image-20240411185830566"></p>
<p><img src="https://gitee.com/songjianzaina/site_img/raw/master/img/image-20240411190033618.png" alt="image-20240411190033618"></p>
</li>
</ol>
<p>至此 软件配置完毕 接下来开始抓包测试</p>
<h2 id="抓包测试"><a href="#抓包测试" class="headerlink" title="抓包测试"></a>抓包测试</h2><ol>
<li><p>打开百度网页 然后按<code>F12</code>进入<code>Chrome</code>开发者工具 获取百度的实际<code>ip</code>地址 用于过滤使用</p>
<p><img src="https://gitee.com/songjianzaina/site_img/raw/master/img/image-20240411190618555.png" alt="image-20240411190618555"></p>
</li>
<li><p>在<code>Wireshark</code> 过滤栏中输入<code>ip.dst==36.155.132.76 and http</code>对该<code>ip</code>进行过滤</p>
</li>
</ol>
<h2 id="软件详细使用"><a href="#软件详细使用" class="headerlink" title="软件详细使用"></a>软件详细使用</h2><h3 id="利用好过滤"><a href="#利用好过滤" class="headerlink" title="利用好过滤"></a>利用好过滤</h3><p><code>Wireshark</code>的快速上手的技巧那就是<strong>使用过滤</strong></p>
<p>想要在大量的数据中获取到自己想要的数据 那就必须利用好过滤关键字</p>
<p>我们进行网络抓包时大部分都是抓取<code>http/https</code>请求 因此我们只需在过滤栏中输入<code>http</code>关键字:</p>
<p><img src="https://gitee.com/songjianzaina/site_img/raw/master/img/image-20240411195505450.png" alt="image-20240411195505450"></p>
<p>当我们在过滤栏进行输入时<code>Wireshark</code>会有自动补全提示 当过滤栏背景为绿色表示软件能识别并根据该关键字进行数据过滤 如果背景色为红色 那表明无法根据该关键字进行过滤:</p>
<p><img src="https://gitee.com/songjianzaina/site_img/raw/master/img/image-20240411195710102.png" alt="image-20240411195710102"></p>
<h3 id="过滤json数据"><a href="#过滤json数据" class="headerlink" title="过滤json数据"></a>过滤json数据</h3><p>通常我们可能会抓取一下应用的<code>api</code> 返回的数据基本都是<code>json</code>格式 此时我们可以在过滤栏输入<code>http and json</code>关键字 </p>
<p><img src="https://gitee.com/songjianzaina/site_img/raw/master/img/image-20240411195944621.png" alt="image-20240411195944621"></p>
<h3 id="过滤图片"><a href="#过滤图片" class="headerlink" title="过滤图片"></a>过滤图片</h3><p>如果要过滤图片 可以使用<code>http.content_type</code> 比如:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http.content_type ==&quot;image/png&quot;</span><br></pre></td></tr></table></figure>

<p>不过为了更好地过滤出数据 我推荐大家使用<code>contains</code>的形式而不是<code>==</code> 这样容错率能大幅提升</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http.content_type contains &quot;image&quot;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/songjianzaina/site_img/raw/master/img/image-20240411224905514.png" alt="image-20240411224905514"></p>
<h3 id="过滤音视频"><a href="#过滤音视频" class="headerlink" title="过滤音视频"></a>过滤音视频</h3><p>如果是<code>amr</code>格式的音频可以在过滤栏输入<code>http and amr</code>关键字</p>
<p>如果是<code>MP4</code>格式视频可以在过滤栏输入<code>http and mp4</code>关键字</p>
<p>如果是直播流 可以尝试输入<code>rtp</code>关键字</p>
<p>当然我们还可以通过模糊过滤的方式 比如:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http.content_type contains &quot;video&quot;</span><br></pre></td></tr></table></figure>

<p>和</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http.content_type contains &quot;audio&quot;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/songjianzaina/site_img/raw/master/img/image-20240411225240083.png" alt="image-20240411225240083"></p>
<h3 id="根据ip地址过滤"><a href="#根据ip地址过滤" class="headerlink" title="根据ip地址过滤"></a>根据ip地址过滤</h3><p>这里需要注意的是 一个完整的数据交互是包括请求和响应两部分的</p>
<p>如果我们需要抓请求的部分 那么使用<code>dst</code>关键字:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ip.dst==服务器ip地址</span><br></pre></td></tr></table></figure>

<p>如果我们需要抓响应的的部分 那么使用<code>src</code>关键字 也就是来源于对方 向我们发送数据:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ip.src==服务器ip地址</span><br></pre></td></tr></table></figure>

<p>如果请求和响应两个部分都想抓取 那就用<code>addr</code>关键字:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ip.addr==服务器ip地址</span><br></pre></td></tr></table></figure>

<p>也就是说无论是<code>Suorce</code>还是<code>Destination</code>只要包含该<code>ip</code>的都会过滤出来</p>
<h3 id="根据请求方法过滤"><a href="#根据请求方法过滤" class="headerlink" title="根据请求方法过滤"></a>根据请求方法过滤</h3><p>如果我们要指定过滤<code>GET</code>或者<code>POST</code>方法 那么可以使用以下关键字:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http.request.method==GET</span><br></pre></td></tr></table></figure>

<h3 id="根据请求路径进行过滤"><a href="#根据请求路径进行过滤" class="headerlink" title="根据请求路径进行过滤"></a>根据请求路径进行过滤</h3><p>有时候同一个应用会使用不同的<code>ip</code>地址 尤其是某些直播应用 虽然每个视频ip可能会不同 但是地址路径是一样的 比如以<code>live/xxx.flv</code>结尾 那么我们就可以根据这个进行匹配过滤 如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http.request.uri contains &quot;live&quot;</span><br></pre></td></tr></table></figure>

<h3 id="根据排除法进行过滤"><a href="#根据排除法进行过滤" class="headerlink" title="根据排除法进行过滤"></a>根据排除法进行过滤</h3><p>如果我们要排除某个ip的数据, 我们可以在关键字前面加上<code>not</code>或者<code>!</code> 如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">!(ip.addr == 192.168.0.1)</span><br></pre></td></tr></table></figure>

<h3 id="根据内容长度进行过滤"><a href="#根据内容长度进行过滤" class="headerlink" title="根据内容长度进行过滤"></a>根据内容长度进行过滤</h3><p>如果我们要根据请求的内容进行过滤可以使用<code>http.content_length</code> 关键字 如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http.content_length &lt;=30</span><br></pre></td></tr></table></figure>

<h3 id="根据正则进行匹配过滤"><a href="#根据正则进行匹配过滤" class="headerlink" title="根据正则进行匹配过滤"></a>根据正则进行匹配过滤</h3><p>如果我们要使用正则匹配 可以使用<code>matches</code>关键字 如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http.request.uri matches &quot;user&quot;</span><br></pre></td></tr></table></figure>

<p>注意: <code>matches</code>匹配不区分大小写</p>
<h3 id="根据域名进行过滤"><a href="#根据域名进行过滤" class="headerlink" title="根据域名进行过滤"></a>根据域名进行过滤</h3><p>如果需要根据域名进行过滤 可以使用<code>http.host</code>关键字 如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http.host==baidu.com</span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http.host contains &quot;baidu&quot;</span><br></pre></td></tr></table></figure>

<p>如果要按照源地址和目标地址过滤 可以使用<code>src www.baidu.com</code>和<code>dst  www.baidu.com</code></p>
<h3 id="根据cookie进行过滤"><a href="#根据cookie进行过滤" class="headerlink" title="根据cookie进行过滤"></a>根据cookie进行过滤</h3><p>使用<code>http.cookie</code>关键字 如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http.cookie contains &quot;userid&quot;</span><br></pre></td></tr></table></figure>

<h3 id="根据端口号过滤"><a href="#根据端口号过滤" class="headerlink" title="根据端口号过滤"></a>根据端口号过滤</h3><p>使用<code>http.port</code>关键字 如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http.port==80</span><br></pre></td></tr></table></figure>

<h3 id="根据http响应状态码过滤"><a href="#根据http响应状态码过滤" class="headerlink" title="根据http响应状态码过滤"></a>根据http响应状态码过滤</h3><p>可以使用http.response.code关键字 如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http.response.code==200</span><br></pre></td></tr></table></figure>

<h3 id="结合使用"><a href="#结合使用" class="headerlink" title="结合使用"></a>结合使用</h3><p>以上所有的关键字 都可以使用与或非运算符进行结合使用 比如我想过滤一个<code>http</code>请求且请求响应为<code>403</code>的数据 过滤方式如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http and (http.response.code==403)</span><br></pre></td></tr></table></figure>

<h3 id="关于清除界面数据"><a href="#关于清除界面数据" class="headerlink" title="关于清除界面数据"></a>关于清除界面数据</h3><p>当我们感觉数据过多 需要清理界面数据时 需要停止抓包 然后再点击开始抓包 这个时候软件会给予提示 是否需要将数据包进行保存到本地 我们只需要点不保存即可:</p>
<p><img src="https://gitee.com/songjianzaina/site_img/raw/master/img/image-20240411200226017.png" alt="image-20240411200226017"></p>
<p>或者直接点击重新抓包一步到位:</p>
<p><img src="https://gitee.com/songjianzaina/site_img/raw/master/img/image-20240411212025725.png" alt="image-20240411212025725"></p>
<h2 id="Wireshark-的优势"><a href="#Wireshark-的优势" class="headerlink" title="Wireshark 的优势"></a><code>Wireshark</code> 的优势</h2><ul>
<li><p>能抓取物理层到应用层七大层数据 这是其他诸如<code>Charles、Fiddler</code>抓包软件所不具备的</p>
<p><img src="https://gitee.com/songjianzaina/site_img/raw/master/img/20240411200816.png" alt></p>
</li>
<li><p>监控网卡 所有数据无所遁形</p>
</li>
<li><p>有些<code>App</code>禁止代理状态下使用 或者内部走的非代理流量 那么这种问题<code>Wireshark</code>可以轻松解决</p>
</li>
</ul>
<p>总之 <code>Wireshark</code>和其它抓包软件结合使用 基本上能解决我们的抓包需求</p>
<p><strong>本文为作者原创 转载时请注明出处 谢谢</strong></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em><a href="https://code.newban.cn/">乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</a></em></p>
]]></content>
      <tags>
        <tag>抓包</tag>
      </tags>
  </entry>
  <entry>
    <title>Android Studio 自定义Gradle插件</title>
    <url>/46.html</url>
    <content><![CDATA[<p>本文内容包括:</p>
<ul>
<li>利用AndroidStudio,编写自定义Gradle plugin</li>
<li>MavenDeployer 发布plugin</li>
<li>使用Gradle plugin</li>
</ul>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>之前写了一个Android中的AOP框架Cooker.<br>这里总结一下里面用到的两块小知识:</p>
<p>1)自定义 Gradle plugin<br>2)发布自己的jar到 maven仓库</p>
<p>项目中引入自定义Gradle plugin一般有三种方法:</p>
<blockquote>
<ol>
<li>直接写在 build.gradle中.</li>
<li>plugin源码放到rootProjectDir/buildSrc/src/main/groovy目录下</li>
<li>plugin打包成jar, 发布到maven仓库, 然后项目通过Build Script依赖jar的形式引入</li>
</ol>
</blockquote>
<p>下面介绍的是第3种方式.</p>
<h2 id="一-用AndroidStudio中写plugin"><a href="#一-用AndroidStudio中写plugin" class="headerlink" title="一. 用AndroidStudio中写plugin"></a>一. 用AndroidStudio中写plugin</h2><h3 id="1-新建一个Android工程"><a href="#1-新建一个Android工程" class="headerlink" title="1.新建一个Android工程"></a>1.新建一个Android工程</h3><h3 id="2-在这个工程里面-新建一个Android-Library"><a href="#2-在这个工程里面-新建一个Android-Library" class="headerlink" title="2.在这个工程里面,新建一个Android Library"></a>2.在这个工程里面,新建一个Android Library</h3><p>先起名叫cooker-plugin吧, 我们将会用这个library写Gradle plugin</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/4048192-c46c28de5172cdd9.webp" alt></p>
<h3 id="3-建立plugin的目录结构"><a href="#3-建立plugin的目录结构" class="headerlink" title="3.建立plugin的目录结构"></a>3.建立plugin的目录结构</h3><p>把这个cooker-plugin中默认产生的文件都删除, 然后按照下面结构新建文件</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/4048192-debed4cf882cc124.webp" alt></p>
<h4 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h4><p>1.因为我们用Groovy写的插件, 插件代码放在 src/main/groovy下</p>
<p>2.在src/main/resources/META-INF/gradle-plugins 里声明plugin信息<br>比如:新建<code>cooker-plugin.properties</code>文件,内容如下</p>
<blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&gt; </span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>implementation-class=com.helen.plugin.CookerPlugin</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">&gt; 这里:  </span><br><span class="line">&gt; <span class="string">"cooker-plugin"</span> 是插件名称;    </span><br><span class="line">&gt; <span class="string">"com.helen.plugin.CookerPlugin"</span> 是对应的插件实现类  </span><br><span class="line"></span><br><span class="line"><span class="number">3.b</span>uild.gradle 声明用groovy开发      </span><br><span class="line"></span><br><span class="line">```java   </span><br><span class="line">apply plugin: <span class="string">'groovy'</span></span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">    <span class="function">compile <span class="title">gradleApi</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    compile <span class="title">localGroovy</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">&#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">repositories</span> &#123;</span><br><span class="line">    mavenCentral()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-实现插件"><a href="#4-实现插件" class="headerlink" title="4.实现插件"></a>4.实现插件</h3><p>实现plugin,其实就是需要继承实现Plugin<project> 的接口</project></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.helen.plugin</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.gradle.api.Plugin</span><br><span class="line"><span class="keyword">import</span> org.gradle.api.Project</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CookerPlugin</span> <span class="keyword">implements</span> <span class="title">Plugin</span>&lt;<span class="title">Project</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">apply</span><span class="params">(Project project)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//这里实现plugin的逻辑</span></span><br><span class="line">        <span class="comment">//巴拉巴拉巴拉</span></span><br><span class="line">        println <span class="string">"hello, this is cooker plugin!"</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//cooker-plugin</span></span><br><span class="line">        <span class="comment">//比如这里加一个简单的task</span></span><br><span class="line">        project.task(<span class="string">'cooker-test-task'</span>) &lt;&lt; &#123;</span><br><span class="line">            println <span class="string">"hello, this is cooker test task!"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-一个简单的plugin就写好了"><a href="#5-一个简单的plugin就写好了" class="headerlink" title="5.一个简单的plugin就写好了"></a>5.一个简单的plugin就写好了</h3><p>在cooker-plugin项目中, build一下.<br>就能在build/libs下生成对应的plugin插件了</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/4048192-177dc91cce18091e.webp" alt></p>
<p>这个插件就能使用了. 可以发布在本地仓库或者Maven仓库.</p>
<h2 id="二-mavenDeployer发布插件"><a href="#二-mavenDeployer发布插件" class="headerlink" title="二. mavenDeployer发布插件"></a>二. mavenDeployer发布插件</h2><p>下面介绍一下利用mavenDeployer发布在本地仓库.</p>
<h3 id="1-引入-mavenDeplayer插件"><a href="#1-引入-mavenDeplayer插件" class="headerlink" title="1. 引入 mavenDeplayer插件"></a>1. 引入 mavenDeplayer插件</h3><p>修改cooker-plugin的build.gradle, 修改后如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">apply plugin: <span class="string">'groovy'</span></span><br><span class="line"><span class="comment">//添加maven plugin, 用于发布我们的jar</span></span><br><span class="line">apply plugin: <span class="string">'maven'</span></span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">    <span class="function">compile <span class="title">gradleApi</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    compile <span class="title">localGroovy</span><span class="params">()</span></span></span><br><span class="line"><span class="function">&#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">repositories </span>&#123;</span><br><span class="line">    mavenCentral()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置maven deployer</span></span><br><span class="line">uploadArchives &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        mavenDeployer &#123;</span><br><span class="line">            <span class="comment">//设置插件的GAV参数</span></span><br><span class="line">            pom.groupId = <span class="string">'com.helen.plugin'</span></span><br><span class="line">            pom.artifactId = <span class="string">'cooker-plugin'</span></span><br><span class="line">            pom.version = <span class="number">1.0</span> </span><br><span class="line">            <span class="comment">//文件发布到下面目录</span></span><br><span class="line">            repository(url: uri(<span class="string">'../release'</span>))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-用uploadArchices发布"><a href="#2-用uploadArchices发布" class="headerlink" title="2.用uploadArchices发布"></a>2.用uploadArchices发布</h3><p>运行uploadArchives. 就能在设置的仓库路径中生成 cooker-plugin了</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/4048192-200e613468863e3a.webp" alt></p>
<h2 id="三-使用gradle-plugin"><a href="#三-使用gradle-plugin" class="headerlink" title="三. 使用gradle plugin"></a>三. 使用gradle plugin</h2><h3 id="1-在build-gradle引入-cooker-plugin"><a href="#1-在build-gradle引入-cooker-plugin" class="headerlink" title="1.在build.gradle引入 cooker-plugin"></a>1.在build.gradle引入 cooker-plugin</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">apply plugin: <span class="string">'com.android.application'</span></span><br><span class="line"><span class="comment">//使用cooker-plugin</span></span><br><span class="line">apply plugin: <span class="string">'cooker-plugin'</span></span><br><span class="line"></span><br><span class="line">buildscript &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        maven &#123;</span><br><span class="line">            <span class="comment">//cooker-plugin 所在的仓库</span></span><br><span class="line">            <span class="comment">//这里是发布在本地文件夹了</span></span><br><span class="line">            <span class="function">url <span class="title">uri</span><span class="params">(<span class="string">'../release'</span>)</span></span></span><br><span class="line"><span class="function">        &#125;</span></span><br><span class="line"><span class="function">    &#125;</span></span><br><span class="line"><span class="function">    dependencies </span>&#123;</span><br><span class="line">        <span class="comment">//引入cooker-plugin</span></span><br><span class="line">        classpath <span class="string">'com.helen.plugin:cooker-plugin:1.0'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-我们编译App的时候-cooker-plugin就会介入了"><a href="#2-我们编译App的时候-cooker-plugin就会介入了" class="headerlink" title="2. 我们编译App的时候,cooker-plugin就会介入了"></a>2. 我们编译App的时候,cooker-plugin就会介入了</h3><p>每次clean/build时, 在Gradle Console可以看到我们的log<br><code>hello, this is cooker plugin!</code></p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">Configuration <span class="keyword">on</span> demand <span class="keyword">is</span> an incubating feature.</span><br><span class="line">hello, <span class="keyword">this</span> <span class="keyword">is</span> cooker plugin!</span><br><span class="line">Incremental java compilation <span class="keyword">is</span> an incubating feature.</span><br><span class="line">:app:preBuild UP-TO-DATE</span><br></pre></td></tr></table></figure>

<h3 id="3-使用cooker-plugin中定义的task"><a href="#3-使用cooker-plugin中定义的task" class="headerlink" title="3.使用cooker-plugin中定义的task"></a>3.使用cooker-plugin中定义的task</h3><p>前面demo中, 我们新建了一个task: <code>cooker-test-task</code>, 他简单输出一句log.下面测试运行一下这个task.<br>在控制台输入 <code>gradle cooker-test-task</code> 运行结果如下</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/4048192-0e73dc69b9dad25f.webp" alt></p>
<h2 id="四-总结"><a href="#四-总结" class="headerlink" title="四. 总结"></a>四. 总结</h2><p><a href="https://link.jianshu.com/?t=https://github.com/helen-x/gradle-plugin-demo" target="_blank" rel="noopener">Demo地址-Github</a><br>到此为止, 自定义Gradle plugin就介绍完了.<br>结合AndroidStudio, 自定义Gradle plugin可以完成很多功能.</p>
<p>比如cooker的plugin完成了:<br>1)添加编译依赖<br>2)进行Aspecj编译<br>3)自动生成混淆配置</p>
<h1 id="五-开发只针对当前项目的Gradle插件-附"><a href="#五-开发只针对当前项目的Gradle插件-附" class="headerlink" title="五. 开发只针对当前项目的Gradle插件(附)"></a>五. 开发只针对当前项目的Gradle插件(附)</h1><p>前面我们讲了如何自定义gradle插件并且打包出去，可能步骤比较多。有时候，你可能并不需要打包出去，只是在这一个项目中使用而已，那么你无需打包这个过程。</p>
<p>只是针对当前项目开发的Gradle插件相对较简单。步骤之前所提到的很类似，只是有几点需要注意：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.新建的Module名称必须为BuildSrc</span><br><span class="line">2.无需resources目录</span><br></pre></td></tr></table></figure>

<p>目录结构如下所示：</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/20160702135323958" alt></p>
<p>其中，build.gradle内容为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apply plugin: &apos;groovy&apos;</span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">    compile gradleApi()//gradle sdk</span><br><span class="line">    compile localGroovy()//groovy sdk</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">repositories &#123;</span><br><span class="line">    jcenter()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>SecondPlugin.groovy内容为：</strong></p>
<p>SecondPlugin.groovy内容为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package  com.hc.second</span><br><span class="line"></span><br><span class="line">import org.gradle.api.Plugin</span><br><span class="line">import org.gradle.api.Project</span><br><span class="line"></span><br><span class="line">public class SecondPlugin implements Plugin&lt;Project&gt; &#123;</span><br><span class="line"></span><br><span class="line">void apply(Project project) &#123;</span><br><span class="line">    System.out.println(&quot;========================&quot;);</span><br><span class="line">    System.out.println(&quot;这是第二个插件!&quot;);</span><br><span class="line">    System.out.println(&quot;========================&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>在app这个Module中如何使用呢</strong>？直接在app的build.gradle下加入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apply plugin: com.hc.second.SecondPlugin</span><br></pre></td></tr></table></figure>

<p>clean一下，再make project，messages窗口信息如下<br><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/20160702135750329" alt></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em>乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</em></p>
]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Proxyman抓取android应用数据请求</title>
    <url>/457.html</url>
    <content><![CDATA[<h2 id="软件介绍"><a href="#软件介绍" class="headerlink" title="软件介绍"></a>软件介绍</h2><p><code>Proxyman</code>是一款跨平台的<code>HTTP/HTTPS</code>网络抓包工具 目前支持<code>Windows</code>、<code>Linux</code>、<code>MacOS</code>、<code>IOS</code>四大平台 </p>
<p><img src="https://gitee.com/songjianzaina/site_img/raw/master/img/image-20240411171337537.png" alt="image-20240411171337537"></p>
<p>软件主界面如下:</p>
<p><img src="https://gitee.com/songjianzaina/site_img/raw/master/img/image-20240411175955421.png" alt="image-20240411175955421"></p>
<h2 id="软件下载"><a href="#软件下载" class="headerlink" title="软件下载"></a>软件下载</h2><p><a href="https://proxyman.io/" target="_blank" rel="noopener">点击进入官网</a></p>
<h2 id="Android抓包"><a href="#Android抓包" class="headerlink" title="Android抓包"></a>Android抓包</h2><p>这里以网易的<code>MUMU</code>模拟器为例 给大介绍如果使用<code>Proxyman</code>抓取手机上的<code>HTTP/HTTPS</code>请求</p>
<h3 id="第一步-打开proxyman获取代理服务地址和端口号"><a href="#第一步-打开proxyman获取代理服务地址和端口号" class="headerlink" title="第一步 打开proxyman获取代理服务地址和端口号"></a>第一步 打开proxyman获取代理服务地址和端口号</h3><p>点击菜单栏<code>Certificate--&gt;Install Certificate on Android--&gt;Physical Devices</code> </p>
<p><img src="https://gitee.com/songjianzaina/site_img/raw/master/img/image-20240411172928040.png" alt="image-20240411172928040"></p>
<p><img src="https://gitee.com/songjianzaina/site_img/raw/master/img/image-20240411173138799.png" alt="image-20240411173138799"></p>
<h3 id="第二步-在模拟器上配置网络代理"><a href="#第二步-在模拟器上配置网络代理" class="headerlink" title="第二步 在模拟器上配置网络代理"></a>第二步 在模拟器上配置网络代理</h3><p>进入<code>设置--&gt;WLAN</code>长按网络名称弹出对话框 这里我们点击修改网络:</p>
<p><img src="https://gitee.com/songjianzaina/site_img/raw/master/img/image-20240411173440435.png" alt="image-20240411173440435"></p>
<p>然后将服务地址和端口号填入并点击保存:</p>
<p><img src="https://gitee.com/songjianzaina/site_img/raw/master/img/image-20240411173512415.png" alt="image-20240411173512415"></p>
<h3 id="第三步-下载SSL证书"><a href="#第三步-下载SSL证书" class="headerlink" title="第三步 下载SSL证书"></a>第三步 下载SSL证书</h3><p>证书用于抓取<code>HTTPS</code>请求</p>
<p>打开模拟器中的浏览器 输入地址<code>http://proxy.man/ssl</code>下载证书并安装</p>
<p><img src="https://gitee.com/songjianzaina/site_img/raw/master/img/image-20240411174336396.png" alt="image-20240411174336396"></p>
<h3 id="第四步-测试能否正常抓包"><a href="#第四步-测试能否正常抓包" class="headerlink" title="第四步 测试能否正常抓包"></a>第四步 测试能否正常抓包</h3><p>在手机浏览器上输入一个返回<code>json</code>串测试地址进行配置验证 测试地址如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http://music.163.com/api/search/get/web?csrf_token=hlpretag=&amp;hlposttag=&amp;s=阳光正好-十二越&amp;type=1&amp;offset=0&amp;total=true&amp;limit=1</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/songjianzaina/site_img/raw/master/img/image-20240411174633446.png" alt="image-20240411174633446"></p>
<p>如果我们能在<code>proxman</code>中能找到对应的测试地址和请求响应 则表示配置成功:</p>
<p><img src="https://gitee.com/songjianzaina/site_img/raw/master/img/image-20240411174809359.png" alt="image-20240411174809359"></p>
<p>不管是<code>http</code>还是<code>https</code>请求都能正常拦截:</p>
<p><img src="https://gitee.com/songjianzaina/site_img/raw/master/img/image-20240411175000111.png" alt="image-20240411175000111"></p>
<p>配置完毕!</p>
<p><strong>本文为作者原创 转载时请注明出处 谢谢</strong></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em><a href="https://code.newban.cn/">乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</a></em></p>
]]></content>
      <tags>
        <tag>抓包</tag>
      </tags>
  </entry>
  <entry>
    <title>Mac平台如何下载ffmpeg并对m3u8视频进行下载转换成MP4</title>
    <url>/460.html</url>
    <content><![CDATA[<h2 id="ffmpeg安装"><a href="#ffmpeg安装" class="headerlink" title="ffmpeg安装"></a>ffmpeg安装</h2><p>在Mac平台上 本人多次使用<code>brew</code>工具进行<code>ffmpeg</code>安装都未成功</p>
<p>于是决定直接去<code>ffmpeg</code>官网下载执行包</p>
<p><a href="http://www.ffmpeg.org/download.html" target="_blank" rel="noopener">点击进入官网</a></p>
<p>由于是国外的网站 下载速度会相对较慢 文末已经给大家准备了网盘下载链接</p>
<p>这里我们选择<code>Mac</code> :</p>
<p><img src="https://gitee.com/songjianzaina/site_img/raw/master/img/image-20240413173518406.png" alt="image-20240413173518406"></p>
<p><img src="https://gitee.com/songjianzaina/site_img/raw/master/img/image-20240413173539785.png" alt="image-20240413173539785"></p>
<p><img src="https://gitee.com/songjianzaina/site_img/raw/master/img/image-20240413173602675.png" alt="image-20240413173602675"></p>
<p>将执行压缩包解压后得到一个独立的<code>ffmpeg</code>执行文件:</p>
<p><img src="https://gitee.com/songjianzaina/site_img/raw/master/img/image-20240413173929604.png" alt="image-20240413173929604"></p>
<p>为了方便我们接下来的使用 需要对其进行环境变量的配置:</p>
<ol>
<li><p>在终端中输入以下命令 打开环境变量配置文件：</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim ~/.bash_profile</span><br></pre></td></tr></table></figure>
</li>
<li><p>在该文件中加入以下内容</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> PATH=<span class="string">"/path/to/ffmpeg:<span class="variable">$PATH</span>"</span></span><br></pre></td></tr></table></figure>

<p> 注意: 这里需要将 <code>/path/to/ffmpeg</code> 替换为你的<code>ffmpeg</code>所在路径</p>
</li>
</ol>
<ol start="3">
<li><p>使用<code>source</code>命令使新的环境变量生效</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">source</span> ~/.bash_profile</span><br></pre></td></tr></table></figure>
</li>
<li><p>验证是否配置成功</p>
<p>在任意一个非ffmpeg所在目录执行以下命令, 如果正常打印内容 则代表配置成功:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ffmpeg -version</span><br></pre></td></tr></table></figure>



</li>
</ol>
<h2 id="下载m3u8视频并转换成mp4"><a href="#下载m3u8视频并转换成mp4" class="headerlink" title="下载m3u8视频并转换成mp4"></a>下载m3u8视频并转换成mp4</h2><p><code>ffmpeg</code>支持直接访问<code>m3u8</code>链接并将其内容转成mp4格式, 执行命令如下:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ffmpeg -i &#123;m3u8链接&#125; -c copy -bsf:a aac_adtstoasc &#123;文件名&#125;.mp4</span><br></pre></td></tr></table></figure>

<p>同样的该<code>ffmpeg</code>指令也适用于直播流的下载和转换 比如<code>http://xxx.flv</code>:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ffmpeg -i &#123;直播链接&#125; -c copy -bsf:a aac_adtstoasc &#123;文件名&#125;.mp4</span><br></pre></td></tr></table></figure>

<h2 id="ffmpeg国内下载"><a href="#ffmpeg国内下载" class="headerlink" title="ffmpeg国内下载"></a>ffmpeg国内下载</h2><p><a href="https://url97.ctfile.com/d/21042697-59243365-19e46d?p=312306" target="_blank" rel="noopener">网盘下载</a> (访问密码: 312306)</p>
<p><strong>本文为作者原创 转载时请注明出处 谢谢</strong></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em><a href="https://code.newban.cn/">乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</a></em></p>
]]></content>
      <tags>
        <tag>m3u8</tag>
      </tags>
  </entry>
  <entry>
    <title>编写一个hexo插件 实现给文章中的外部超链接增加一个中间跳转询问页面</title>
    <url>/464.html</url>
    <content><![CDATA[<h2 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h2><p>我本来想让AI给我写一个<code>hexo</code>插件 如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">请写一个hexo插件 要求功能如下:</span><br><span class="line"></span><br><span class="line">1. 在执行hexo -g指令时自动将文章中的非本站合法超链接提取替换出来 为每个合法的链接生成独立的跳转页面  独立页面的地址和链接形成固定的对应关系  不会因为新增文章而发生对应链接改变的问题</span><br><span class="line">2. 当用户浏览博客时点击超链接会跳转到一个单独的网页 在这个网页中显示文字和该链接地址并询问用户是否需要跳转到该链接  当用户点击文字下方的跳转按钮则自动跳转到该链接  </span><br><span class="line">3. 文章中的链接应该替换成对应已经生成的跳转页面的链接 </span><br><span class="line">4. 要求能在`config`文件中自定义需要进行排除的域名 不对排除的域名下的所有链接进行跳转页面的生成 保留原始的直接跳转即可 </span><br><span class="line">5. 在`config`文件中增加插件的开启开关 </span><br><span class="line">6. 需要过滤掉非合法的超链接 非合法的链接不做处理</span><br><span class="line">7. 跳转页面的UI希望能美观一些 内容居中显示 </span><br><span class="line"></span><br><span class="line">请给出插件的完整代码</span><br></pre></td></tr></table></figure>

<p>然后<code>AI</code>给我的答案是:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">以下是一个满足您需求的Hexo插件的完整代码：</span><br><span class="line"></span><br><span class="line">const fs = require(&apos;fs&apos;);</span><br><span class="line">const path = require(&apos;path&apos;);</span><br><span class="line">const &#123; promisify &#125; = require(&apos;util&apos;);</span><br><span class="line">const &#123; URL &#125; = require(&apos;url&apos;);</span><br><span class="line"></span><br><span class="line">const readFile = promisify(fs.readFile);</span><br><span class="line">const writeFile = promisify(fs.writeFile);</span><br><span class="line"></span><br><span class="line">const config = hexo.config.external_link_redirect || &#123;&#125;;</span><br><span class="line">const excludedDomains = config.excluded_domains || [];</span><br><span class="line">const redirectPageDir = path.join(hexo.public_dir, &apos;redirect_pages&apos;);</span><br><span class="line">const redirectPageTemplate = `</span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;</span><br><span class="line">  &lt;title&gt;Redirect Page&lt;/title&gt;</span><br><span class="line">  &lt;style&gt;</span><br><span class="line">    body &#123;</span><br><span class="line">      font-family: Arial, sans-serif;</span><br><span class="line">      text-align: center;</span><br><span class="line">    &#125;</span><br><span class="line">    .container &#123;</span><br><span class="line">      margin-top: 100px;</span><br><span class="line">    &#125;</span><br><span class="line">    .link &#123;</span><br><span class="line">      font-size: 18px;</span><br><span class="line">      font-weight: bold;</span><br><span class="line">    &#125;</span><br><span class="line">    .button &#123;</span><br><span class="line">      padding: 10px 20px;</span><br><span class="line">      background-color: #007bff;</span><br><span class="line">      color: #fff;</span><br><span class="line">      border: none;</span><br><span class="line">      border-radius: 5px;</span><br><span class="line">      cursor: pointer;</span><br><span class="line">      text-decoration: none;</span><br><span class="line">    &#125;</span><br><span class="line">  &lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;div class=&quot;container&quot;&gt;</span><br><span class="line">    &lt;p class=&quot;link&quot;&gt;%LINK%&lt;/p&gt;</span><br><span class="line">    &lt;button class=&quot;button&quot; onclick=&quot;redirectToLink()&quot;&gt;Go to Link&lt;/button&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">  &lt;script&gt;</span><br><span class="line">    function redirectToLink() &#123;</span><br><span class="line">      window.location.href = &apos;%URL%&apos;;</span><br><span class="line">    &#125;</span><br><span class="line">  &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line">`;</span><br><span class="line"></span><br><span class="line">hexo.extend.filter.register(&apos;before_generate&apos;, async function () &#123;</span><br><span class="line">  if (!config.enable) &#123;</span><br><span class="line">    console.log(&apos;External link redirect plugin is disabled.&apos;);</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  await createRedirectPages();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">async function createRedirectPages() &#123;</span><br><span class="line">  const posts = hexo.locals.get(&apos;posts&apos;);</span><br><span class="line">  if (!posts || !posts.length) &#123;</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  for (const post of posts.data) &#123;</span><br><span class="line">    const content = post.content;</span><br><span class="line">    const updatedContent = await processContent(content);</span><br><span class="line">    post.content = updatedContent;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">async function processContent(content) &#123;</span><br><span class="line">  const updatedContent = content.replace(/&lt;a href=&quot;([^&quot;]+)&quot;[^&gt;]*&gt;(.*?)&lt;\/a&gt;/gi, async (match, url, text) =&gt; &#123;</span><br><span class="line">    if (!isLinkValid(url)) &#123;</span><br><span class="line">      return match; // Skip invalid links</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    const redirectPagePath = await generateRedirectPage(url);</span><br><span class="line">    const redirectLink = `&lt;a href=&quot;$&#123;redirectPagePath&#125;&quot;&gt;$&#123;text&#125;&lt;/a&gt;`;</span><br><span class="line">    return redirectLink;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  return updatedContent;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function isLinkValid(url) &#123;</span><br><span class="line">  if (!url || typeof url !== &apos;string&apos;) &#123;</span><br><span class="line">    return false;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  const parsedUrl = new URL(url);</span><br><span class="line">  const domain = parsedUrl.hostname.replace(&apos;www.&apos;, &apos;&apos;);</span><br><span class="line">  return !excludedDomains.includes(domain);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">async function generateRedirectPage(url) &#123;</span><br><span class="line">  const redirectUrl = new URL(url);</span><br><span class="line">  const domain = redirectUrl.hostname.replace(&apos;www.&apos;, &apos;&apos;);</span><br><span class="line">  const redirectPagePath = path.join(redirectPageDir, `$&#123;domain&#125;_$&#123;Date.now()&#125;.html`);</span><br><span class="line">  const pageContent = redirectPageTemplate.replace(&apos;%LINK%&apos;, url).replace(&apos;%URL%&apos;, url);</span><br><span class="line"></span><br><span class="line">  await writeFile(redirectPagePath, pageContent);</span><br><span class="line">  return redirectPagePath.replace(hexo.public_dir, &apos;&apos;);</span><br><span class="line">&#125;</span><br><span class="line">在这个插件中，我们做了以下几件事情：</span><br><span class="line"></span><br><span class="line">在执行hexo -g指令之前，通过before_generate过滤器来自动生成跳转页面。</span><br><span class="line">通过正则表达式遍历文章内容，找到所有超链接，并检查链接是否有效。</span><br><span class="line">对于有效的链接，创建一个跳转页面，并将原始链接替换为跳转页面的链接。</span><br><span class="line">生成的跳转页面是一个HTML文件，包含跳转链接和一个按钮，点击按钮可以跳转到原始链接。</span><br><span class="line">用户可以在Hexo配置文件中设置插件的开启状态、需要排除的域名以及跳转页面模板。</span><br><span class="line">最终生成的跳转页面保存在public/redirect_pages目录下，每个页面都有固定的对应关系，不会因为新增文章而改变链接。</span><br></pre></td></tr></table></figure>

<p>看了一下AI给我写的代码, 可以说是秀的我头疼, 代码可读性实在太差了, 难道是我问的方式不对?🤔</p>
<p>由于<code>ChatGPT</code>免费次数有限 我也懒得去搜寻免费的<code>AIChat</code>,  干脆就自己手动写一个吧</p>
<p>最后调试完成后的插件代码如下:</p>
<h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="meta">'use strict'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">const</span> cheerio = <span class="built_in">require</span>(<span class="string">'cheerio'</span>);</span><br><span class="line"><span class="keyword">const</span> crypto = <span class="built_in">require</span>(<span class="string">'crypto'</span>);</span><br><span class="line"><span class="keyword">const</span> &#123; log &#125; = <span class="built_in">require</span>(<span class="string">'console'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> DEFAULT_EXCLUDE_DOMAINS = [<span class="string">'example.com'</span>]; <span class="comment">// 默认排除的域名列表</span></span><br><span class="line"></span><br><span class="line">hexo.extend.filter.register(<span class="string">'before_generate'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> config = hexo.config.external_links || &#123;&#125;;</span><br><span class="line">    <span class="keyword">const</span> excludeDomains = config.exclude_domains || DEFAULT_EXCLUDE_DOMAINS;</span><br><span class="line">    <span class="keyword">if</span> (!config.enable) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'关闭external_links插件'</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    hexo.extend.generator.register(<span class="string">'external_links'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">locals</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> posts = locals.posts;</span><br><span class="line">        <span class="keyword">const</span> author = hexo.config.author;</span><br><span class="line">        <span class="keyword">const</span> outputDir = hexo.config.external_links_output || <span class="string">'external_links'</span>;</span><br><span class="line">        <span class="keyword">const</span> linkMap = <span class="keyword">new</span> <span class="built_in">Map</span>(); <span class="comment">// 存储链接和其对应的哈希值的映射</span></span><br><span class="line"></span><br><span class="line">        posts.forEach(<span class="function"><span class="params">post</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> $ = cheerio.load(post.content);</span><br><span class="line">            $(<span class="string">'a'</span>).each(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="keyword">const</span> href = filterUrl($(<span class="keyword">this</span>).attr(<span class="string">'href'</span>));</span><br><span class="line">                <span class="keyword">const</span> hostname = getHostname(href);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (hostname!=<span class="string">""</span>&amp;&amp;!excludeDomains.includes(hostname)) &#123;</span><br><span class="line">                    <span class="keyword">const</span> hash = generateHash(href);</span><br><span class="line">                    linkMap.set(href, hash); <span class="comment">// 存储链接和哈希值的映射关系</span></span><br><span class="line"></span><br><span class="line">                    <span class="comment">//替换文章中的原始链接</span></span><br><span class="line">                    <span class="keyword">const</span> newHref = <span class="string">`/<span class="subst">$&#123;outputDir&#125;</span>/<span class="subst">$&#123;hash&#125;</span>.html`</span>;</span><br><span class="line">                    $(<span class="keyword">this</span>).attr(<span class="string">'href'</span>, newHref);</span><br><span class="line">                    $(<span class="keyword">this</span>).attr(<span class="string">'target'</span>, <span class="string">"blank"</span>);<span class="comment">//在新标签页中打开超链接</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            post.content = $.html();</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> outputPath = path.join(hexo.public_dir, outputDir);</span><br><span class="line">        <span class="keyword">if</span> (!fs.existsSync(outputPath)) &#123;</span><br><span class="line">            fs.mkdirSync(outputPath);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 生成每个链接对应的页面</span></span><br><span class="line">        linkMap.forEach(<span class="function">(<span class="params">hash, href</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> htmlContent = generateLinkPage(href, hash,author);</span><br><span class="line">            <span class="keyword">const</span> outputFile = path.join(outputPath, <span class="string">`<span class="subst">$&#123;hash&#125;</span>.html`</span>);</span><br><span class="line">            fs.writeFileSync(outputFile, htmlContent);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">generateLinkPage</span>(<span class="params">href, hash,author</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> html = <span class="string">`</span></span><br><span class="line"><span class="string">        &lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="string">        &lt;html lang="en"&gt;</span></span><br><span class="line"><span class="string">        &lt;head&gt;</span></span><br><span class="line"><span class="string">            &lt;meta charset="UTF-8"&gt;</span></span><br><span class="line"><span class="string">            &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;</span></span><br><span class="line"><span class="string">            &lt;title&gt;访问外部网站-&#123;author&#125;&lt;/title&gt;</span></span><br><span class="line"><span class="string">            &lt;style&gt;</span></span><br><span class="line"><span class="string">                body &#123;</span></span><br><span class="line"><span class="string">                    margin: 20px;</span></span><br><span class="line"><span class="string">                    padding-top: 100px;</span></span><br><span class="line"><span class="string">                    color: #222;</span></span><br><span class="line"><span class="string">                    font-size: 13px;</span></span><br><span class="line"><span class="string">                    font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif;</span></span><br><span class="line"><span class="string">                    line-height: 1.5;</span></span><br><span class="line"><span class="string">                    -webkit-tap-highlight-color: rgba(0, 0, 0, 0);</span></span><br><span class="line"><span class="string">                &#125;</span></span><br><span class="line"><span class="string">                .wrapper &#123;</span></span><br><span class="line"><span class="string">                    margin: auto;</span></span><br><span class="line"><span class="string">                    padding-left: 30px;</span></span><br><span class="line"><span class="string">                    padding-right: 30px;</span></span><br><span class="line"><span class="string">                    max-width: 540px;</span></span><br><span class="line"><span class="string"> 									  padding-top: 25px;</span></span><br><span class="line"><span class="string">                    padding-bottom: 25px;</span></span><br><span class="line"><span class="string">                    background-color: #f7f7f7;</span></span><br><span class="line"><span class="string">                    border: 1px solid #babbbc;</span></span><br><span class="line"><span class="string">                    border-radius: 5px;</span></span><br><span class="line"><span class="string">                &#125;</span></span><br><span class="line"><span class="string">             </span></span><br><span class="line"><span class="string">              </span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">                .button &#123;</span></span><br><span class="line"><span class="string">                    padding: 0;</span></span><br><span class="line"><span class="string">                    font-family: inherit;</span></span><br><span class="line"><span class="string">                    background: none;</span></span><br><span class="line"><span class="string">                    border: none;</span></span><br><span class="line"><span class="string">                    outline: none;</span></span><br><span class="line"><span class="string">                    cursor: pointer;</span></span><br><span class="line"><span class="string">                &#125;</span></span><br><span class="line"><span class="string">                .button:hover &#123;</span></span><br><span class="line"><span class="string">                    background-color: #0070cd;</span></span><br><span class="line"><span class="string">                &#125;</span></span><br><span class="line"><span class="string">                a&#123;</span></span><br><span class="line"><span class="string">                    text-decoration: none</span></span><br><span class="line"><span class="string">                &#125;</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">                .button:active &#123;</span></span><br><span class="line"><span class="string">                    background-color: #0077d9;</span></span><br><span class="line"><span class="string">                &#125;</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">          </span></span><br><span class="line"><span class="string">                .link &#123;</span></span><br><span class="line"><span class="string">                    margin-bottom: 10px;</span></span><br><span class="line"><span class="string">                &#125;</span></span><br><span class="line"><span class="string">              </span></span><br><span class="line"><span class="string">                .button &#123;</span></span><br><span class="line"><span class="string">                    display: inline-block;</span></span><br><span class="line"><span class="string">                    padding: 10px 16px;</span></span><br><span class="line"><span class="string">                    color: #fff;</span></span><br><span class="line"><span class="string">                    font-size: 14px;</span></span><br><span class="line"><span class="string">                    line-height: 1;</span></span><br><span class="line"><span class="string">                    background-color: #0077d9;</span></span><br><span class="line"><span class="string">                    border-radius: 3px;</span></span><br><span class="line"><span class="string">                &#125;</span></span><br><span class="line"><span class="string">                .actions &#123;</span></span><br><span class="line"><span class="string">                    margin-top: 15px;</span></span><br><span class="line"><span class="string">                    padding-top: 30px;</span></span><br><span class="line"><span class="string">                    text-align: right;</span></span><br><span class="line"><span class="string">                    border-top: 1px solid #d8d8d8;</span></span><br><span class="line"><span class="string">                &#125;</span></span><br><span class="line"><span class="string">            &lt;/style&gt;</span></span><br><span class="line"><span class="string">        &lt;/head&gt;</span></span><br><span class="line"><span class="string">        &lt;body&gt;</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">            &lt;div class="wrapper"&gt;</span></span><br><span class="line"><span class="string">                &lt;div class="content"&gt;</span></span><br><span class="line"><span class="string">                    &lt;h1&gt;即将离开<span class="subst">$&#123;author&#125;</span>&lt;/h1&gt;</span></span><br><span class="line"><span class="string">                    &lt;p class="info"&gt;您即将离开<span class="subst">$&#123;author&#125;</span>，前往外部网站。&lt;/p&gt;</span></span><br><span class="line"><span class="string">                    &lt;p class="link"&gt;<span class="subst">$&#123;href&#125;</span>&lt;/p&gt;</span></span><br><span class="line"><span class="string">                &lt;/div&gt;</span></span><br><span class="line"><span class="string">                &lt;div class="actions"&gt;</span></span><br><span class="line"><span class="string">                    &lt;a class="button" href="<span class="subst">$&#123;href&#125;</span>" one-link-mark="yes"&gt;继续访问&lt;/a&gt;</span></span><br><span class="line"><span class="string">                &lt;/div&gt;</span></span><br><span class="line"><span class="string">            &lt;/div&gt;</span></span><br><span class="line"><span class="string">        &lt;/body&gt;</span></span><br><span class="line"><span class="string">        &lt;/html&gt;</span></span><br><span class="line"><span class="string">    `</span>;</span><br><span class="line">    <span class="keyword">return</span> html;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getHostname</span>(<span class="params">url</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> URL(url).hostname;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">''</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">filterUrl</span>(<span class="params">url</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> urlRegex = <span class="regexp">/http[s]?:\/\/[\u4e00-\u9fa5\w.-\/:]+[\u4e00-\u9fa5\w.?&amp;\/=-]+/g</span>;</span><br><span class="line">    <span class="keyword">const</span> match = urlRegex.exec(url);</span><br><span class="line">    <span class="keyword">return</span> match ? match[<span class="number">0</span>] : <span class="string">''</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">generateHash</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> crypto.createHash(<span class="string">'md5'</span>).update(data).digest(<span class="string">'hex'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>使用方法:</strong></p>
<p>在<code>script</code>目录下新建一个<code>js</code>文件,  注意名称不要使用<code>index.js</code>, 将上面代码粘贴过去, 然后在<code>config</code>配置文件中指定输出的目录以及需要过滤的域名 如下:</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#需要排除的域名 以及是否开启该插件</span></span><br><span class="line"><span class="attr">external_links:</span></span><br><span class="line"><span class="attr">  exclude_domains:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">'acg.newban.cn'</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">'newban.cn'</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">'code.newban.cn'</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">'audio.newban.cn'</span></span><br><span class="line"><span class="attr">  enable:</span> <span class="literal">true</span></span><br><span class="line"><span class="comment">#输出目录</span></span><br><span class="line"><span class="attr">external_links_output:</span> <span class="string">external_links</span></span><br></pre></td></tr></table></figure>

<h2 id="效果展示"><a href="#效果展示" class="headerlink" title="效果展示"></a>效果展示</h2><p>模仿的知乎效果:</p>
<p><img src="https://gitee.com/songjianzaina/site_img/raw/master/img/image-20240416141911249.png" alt="image-20240416141911249"></p>
<p><strong>本文为作者原创 转载时请注明出处 谢谢</strong></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em><a href="https://code.newban.cn/">乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</a></em></p>
]]></content>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>使用ffmpeg将本地的flv视频压制转换成小体积的MP4</title>
    <url>/461.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>关于<code>ffmpeg</code>的下载, 可查阅上一篇文章《<a href="https://code.newban.cn/460.html">Mac平台如何下载ffmpeg并对m3u8视频进行下载转换成MP4</a>》</p>
<p>本文将给大家介绍如何使用<code>ffmpeg</code>将本地的<code>flv</code>视频压制转换成小体积的<code>MP4</code></p>
<h2 id="格式转换"><a href="#格式转换" class="headerlink" title="格式转换"></a>格式转换</h2><p>如果只是单纯的进行格式转换 可以直接使用以下指令来实现:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ffmpeg -i input.flv -vcodec copy -acodec copy output.mp4</span><br></pre></td></tr></table></figure>

<p>这种方式通常体积不会有太大的改变 </p>
<h2 id="转换格式并压缩视频体积"><a href="#转换格式并压缩视频体积" class="headerlink" title="转换格式并压缩视频体积"></a>转换格式并压缩视频体积</h2><p>如果需要将视频进行压缩 以减少空间的占用 可以参考以下指令:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ffmpeg -i input.flv -c:v libx264 -crf 26 -c:a aac -strict experimental -b:a 128k output.mp4</span><br></pre></td></tr></table></figure>

<p><strong>解释各选项含义：</strong></p>
<ul>
<li><code>-i input.flv</code>：指定输入文件名为<code>input.flv</code>。</li>
<li><code>-c:v libx264</code>：使用<code>H.264</code>编码来压缩视频。</li>
<li><code>-crf 28</code>：设置<code>CRF</code>（常量速率因子）的值为23。低值表示更好的质量，但文件会更大；高值会降低质量。范围是从0（无损）到51（最糟），通常使用18到28, <code>27</code>通常是用于<code>MP4</code>格式的视频质量很好的平衡</li>
<li><code>-c:a aac</code>：使用<code>AAC</code>编码来压缩音频。</li>
<li><code>-strict experimental</code>：允许使用实验性的编码器。</li>
<li><code>-b:a 128k</code>：设置音频比特率为128k。根据需求可以调整大小。</li>
</ul>
<p>我们需要找到一个合适的参数平衡点 确保视频画面的质量的同时尽可能地压缩视频体积</p>
<p>如果我们想要快速压制 减少等待时间 还可以指定编码器预设 如下:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ffmpeg -i input.flv -c:v libx264 -preset veryfast -crf 24 -c:a aac -b:a 128k output.mp4</span><br></pre></td></tr></table></figure>

<p><strong>解释选项含义：</strong></p>
<ul>
<li><code>-preset veryfast</code>：指定编码器预设，<code>veryfast</code>提供快速但质量较低的编码, 除此之外 还有<code>fast</code>、<code>HQ</code>、 <code>SuperHQ</code>等预设。</li>
</ul>
<h2 id="ffmpeg-截取视频"><a href="#ffmpeg-截取视频" class="headerlink" title="ffmpeg 截取视频"></a>ffmpeg 截取视频</h2><p>要使用<code>FFmpeg</code>截取视频 可以使用以下指令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ffmpeg -i input.mp4 -ss 00:00:10 -t 00:00:30 -c copy output.mp4</span><br></pre></td></tr></table></figure>

<p><strong>解释各选项含义：</strong></p>
<ul>
<li><code>-i input.mp4</code> 指定输入视频文件。</li>
<li><code>-ss 00:00:10</code> 表示从视频的指定时间点开始截取，这里是从10秒处开始。</li>
<li><code>-t 00:00:30</code> 表示截取的时长，这里是30秒。</li>
<li><code>-c copy</code> 表示复制编码器，即不重新编码，直接复制视频流和音频流。</li>
<li><code>output.mp4</code> 是输出文件的名称。</li>
</ul>
<p>请根据实际需求调整时间参数。如果需要不同的起始时间或时长，只需修改<code>-ss</code>和<code>-t</code>参数即可。如果需要对视频进行重编码，可以去掉<code>-c copy</code>参数或指定其他编码器选项。</p>
<p><strong>本文为作者原创 转载时请注明出处 谢谢</strong></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em><a href="https://code.newban.cn/">乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</a></em></p>
]]></content>
      <tags>
        <tag>m3u8</tag>
      </tags>
  </entry>
  <entry>
    <title>内容多平台分发工具汇总</title>
    <url>/467.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>文章撰写一次 到处分发 无需繁琐的复制粘贴 节省大量的重复机械劳动力 追求极致的自动化 一键分发工具 无疑是解决了很多创作者的痛点</p>
<p>接下来给大家汇总几个可一键分发的网站</p>
<h2 id="一键分发平台"><a href="#一键分发平台" class="headerlink" title="一键分发平台"></a>一键分发平台</h2><ul>
<li><p><a href="https://mdnice.com/?platform=2" target="_blank" rel="noopener">mdnice</a></p>
<p><img src="https://gitee.com/songjianzaina/site_img/raw/master/img/image-20240418194825613.png" alt="image-20240418194825613"></p>
</li>
<li><p><a href="https://openwrite.cn/" target="_blank" rel="noopener">openwrite</a></p>
<p><img src="https://gitee.com/songjianzaina/site_img/raw/master/img/image-20240417225346730.png" alt="image-20240417225346730"></p>
</li>
</ul>
<p><strong>本文为作者原创 转载时请注明出处 谢谢</strong></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em><a href="https://code.newban.cn/">乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</a></em></p>
]]></content>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>使用python3将wordpress博客数据迁移到hexo</title>
    <url>/465.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>为了追求网站访问的稳定性 准备将<code>wordpress</code>博客迁移到<code>hexo</code>上 考虑到数据量比较多 我直接将数据库导出成压缩包 然后下载到本地电脑 然后使用<code>python</code>批量将里面的文章转成<code>markdown</code>格式的文档</p>
<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><ol>
<li><p>导出数据库</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysqldump -u用户名 -p密码 数据库名 | gzip &gt; 数据库名.sql.gz</span><br></pre></td></tr></table></figure>
</li>
<li><p>将导出的数据库文件下载到本地 然后双击解压该数据库</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">scp -r root@服务器IP:刚导出的数据库所在路径 本地目录</span><br></pre></td></tr></table></figure>
</li>
<li><p>数据库导入进本地<code>mysql</code>中 方便<code>python</code>连接</p>
<p>首先创建新数据库:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysql&gt;create database 数据库名;</span><br></pre></td></tr></table></figure>

<p>然后将<code>sql</code>文件导入到该库中:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysql -u用户名 -p密码 数据库名 &lt; 数据库名.sql</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="Python批量转换"><a href="#Python批量转换" class="headerlink" title="Python批量转换"></a>Python批量转换</h2><p><code>python</code>代码如下:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># coding:utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="comment">##########################</span></span><br><span class="line"><span class="comment">#  </span></span><br><span class="line"><span class="comment">#  链接本地mysql数据库将wordpress中的文章提取出来并转成hexo博客格式</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">##########################</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">from</span> markdownify <span class="keyword">import</span> markdownify <span class="keyword">as</span> md</span><br><span class="line"><span class="keyword">import</span> pymysql.cursors</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">sys.setrecursionlimit(<span class="number">1000000</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 连接数据库</span></span><br><span class="line">conn = pymysql.Connect(</span><br><span class="line">    host=<span class="string">'127.0.0.1'</span>,</span><br><span class="line">    port=<span class="number">3306</span>,</span><br><span class="line">    user=<span class="string">'数据库用户名'</span>,</span><br><span class="line">    passwd=<span class="string">'数据库密码'</span>,</span><br><span class="line">    db=<span class="string">'wordpress_it'</span>,</span><br><span class="line">    charset=<span class="string">'utf8mb4'</span></span><br><span class="line">)</span><br><span class="line"><span class="comment"># 获取游标</span></span><br><span class="line">cursor = conn.cursor()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取所有文章</span></span><br><span class="line">cursor.execute(<span class="string">"SELECT post_title, post_content, post_date FROM wp_posts WHERE post_type='post'"</span>)</span><br><span class="line">posts = cursor.fetchall()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 确保输出目录存在</span></span><br><span class="line">output_dir = <span class="string">'hexo_posts'</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(output_dir):</span><br><span class="line">    os.makedirs(output_dir)</span><br><span class="line"></span><br><span class="line">tags=[<span class="string">"Android"</span>,<span class="string">"IOS"</span>,<span class="string">"服务器"</span>,<span class="string">"Docker"</span>,<span class="string">"Mysql"</span>,<span class="string">"Flutter"</span>,<span class="string">"Java"</span>,<span class="string">"Hexo"</span>]</span><br><span class="line">postTag=<span class="string">"技术文章"</span> <span class="comment">#默认分类为</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 遍历每篇文章</span></span><br><span class="line"><span class="keyword">for</span> idx, post <span class="keyword">in</span> enumerate(posts):</span><br><span class="line">    title, content,date = post</span><br><span class="line">    <span class="keyword">for</span> tag <span class="keyword">in</span> tags:</span><br><span class="line">        <span class="keyword">if</span> tag <span class="keyword">in</span> title:</span><br><span class="line">            postTag=tag</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="comment"># 将HTML内容转换为Markdown</span></span><br><span class="line">    markdown_content = md(content)</span><br><span class="line">    <span class="comment"># 写入Hexo格式的Markdown文件</span></span><br><span class="line">    <span class="keyword">with</span> open(os.path.join(output_dir, <span class="string">f"<span class="subst">&#123;idx+<span class="number">1</span>&#125;</span>.md"</span>), <span class="string">'w'</span>, encoding=<span class="string">'utf-8'</span>) <span class="keyword">as</span> f:</span><br><span class="line">        f.write(<span class="string">"---\n"</span>)</span><br><span class="line">        f.write(<span class="string">f"title: <span class="subst">&#123;title&#125;</span>\n"</span>) <span class="comment"># 如果要嵌入变量 需要加f</span></span><br><span class="line">        f.write(<span class="string">f"date: <span class="subst">&#123;date&#125;</span>\n"</span>)  <span class="comment"># 请将日期替换为实际发布日期</span></span><br><span class="line">        f.write(<span class="string">f"tags: <span class="subst">&#123;postTag&#125;</span>\n"</span>)</span><br><span class="line">        f.write(<span class="string">"---\n"</span>)</span><br><span class="line">        f.write(<span class="string">"\n"</span>)</span><br><span class="line">        f.write(markdown_content)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 关闭游标和连接</span></span><br><span class="line">cursor.close()</span><br><span class="line">conn.close()</span><br></pre></td></tr></table></figure>

<p>想要正常运行该代码 需要安装<code>pymysql</code>和<code>markdownify</code>两个库:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip3 install markdownify</span><br><span class="line">pip3 install pymysql</span><br></pre></td></tr></table></figure>

<p><strong>本文为作者原创 转载时请注明出处 谢谢</strong></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em><a href="https://code.newban.cn/">乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</a></em></p>
]]></content>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>博客文章自动同步微信公众号实践</title>
    <url>/468.html</url>
    <content><![CDATA[<p>本文来自 zhiyi 的个人博客实践，可以通过开放能力将其他平台的文章同步到微信公众号上，对刚学前端的同学（有自己的博客就更好了）来说，是对后台接口链路的一个不错的探索。</p>
<h3 id="整体思路"><a href="#整体思路" class="headerlink" title="整体思路"></a>整体思路</h3><p>微信官方提供了素材管理的 API，通过 API 可以很方便地进行同步。在使用 API 之前需要进行鉴权，所以需要先获取 access token。微信公众号中不允许出现外域图片，因此需要把文章里的图片全部使用微信的图片上传接口处理后替换。此外，微信公众号支持 HTML 标签但是只支持内联样式，所以必须把外联样式全部转换为内联样式。</p>
<p>所以，同步到微信公众号的操作，需要按照以下步骤：</p>
<ol>
<li>使用公众号的 appid 和 secret 换取 access token。</li>
<li>把文章中的所有图片用微信图片上传接口上传，并替换文章里的 URL。这一步需要使用 access token 鉴权。</li>
<li>将文章中的所有外联 css 转为内联样式。</li>
<li>调用微信素材管理接口，同步文章。这里需要使用 access token 鉴权。</li>
</ol>
<h3 id="获取-access-token"><a href="#获取-access-token" class="headerlink" title="获取 access token"></a>获取 access token</h3><p>获取 access token 本身没什么难度，使用微信公众号的 appid 和 secret 就可以从接口获取到。需要注意的是，这个接口有调用频率限制，短时间内调用次数不能过多。</p>
<p>所以我们从微信的接口获取 access token 之后应该将它缓存，之后直接从缓存中获取，缓存失效了再重新从接口获取。这里的缓存机制使用了 Redis，因为 Redis 提供的过期失效机制正好满足我们的需求。</p>
<p>首先我们在 Koa 的全局变量里注册 Redis，以便在各种场景调用。这里，我们把它写成 Koa 中间件的形式，并把几个 Redis 常用操作 Promise 化。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = <span class="function">(<span class="params">redisConfig</span>) =&gt;</span><span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> client = redis.createClient(redisConfig.port, redisConfig.host);</span><br><span class="line">  client.auth(redisConfig.password);</span><br><span class="line">  ctx.redis = &#123;</span><br><span class="line">    <span class="keyword">get</span>: (key) =&gt; new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">      client.get(key, (err, result) =&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (err) &#123;</span><br><span class="line">          reject(err);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          resolve(result);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="keyword">set</span>: (key, value) =&gt; new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">      client.set(key, value, (err, result) =&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (err) &#123;</span><br><span class="line">          reject(err);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          resolve(result);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;),</span><br><span class="line">    expire: <span class="function">(<span class="params">key, expire</span>) =&gt;</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      client.expire(key, expire, (err, result) =&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (err) &#123;</span><br><span class="line">          reject(err);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          resolve(result);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;),</span><br><span class="line">    del: <span class="function">(<span class="params">key</span>) =&gt;</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      client.del(key, (err, result) =&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (err) &#123;</span><br><span class="line">          reject(err);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          resolve(result);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;),</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">await</span> next();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>之后，在获取<code>access token</code> 时，先尝试从<code>Redis</code>中取。如果获取到了，就直接返回结果；如果没取到，就向微信接口请求并写入 Redis。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = <span class="keyword">async</span> (ctx) =&gt; &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> accessToken = <span class="keyword">await</span> ctx.redis.get(<span class="string">'wechatAccessToken'</span>);</span><br><span class="line">    <span class="keyword">if</span> (!accessToken) &#123;</span><br><span class="line">      <span class="keyword">const</span> res = <span class="keyword">await</span> axios.get(<span class="string">`https://api.weixin.qq.com/cgi-bin/token?grant_type=client_credential&amp;appid=<span class="subst">$&#123;wechatConfig.appid&#125;</span>&amp;secret=<span class="subst">$&#123;wechatConfig.secret&#125;</span>`</span>);</span><br><span class="line">      <span class="keyword">if</span> (res?.status !== <span class="number">200</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'get access token error'</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      accessToken = res?.data?.access_token;</span><br><span class="line">      <span class="keyword">const</span> expiresIn = res?.data?.expires_in;</span><br><span class="line">      <span class="keyword">if</span> (!accessToken) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'get access token error'</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">await</span> ctx.redis.set(<span class="string">'wechatAccessToken'</span>, accessToken);</span><br><span class="line">        <span class="keyword">await</span> ctx.redis.expire(<span class="string">'wechatAccessToken'</span>, expiresIn);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(accessToken);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(err);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这样，我们就实现了获取并缓存<code>access token</code>。</p>
<h3 id="上传并替换图片"><a href="#上传并替换图片" class="headerlink" title="上传并替换图片"></a>上传并替换图片</h3><p>我的文章内容是一段 HTML 代码字符串，这是由前端传入的。不管前端使用什么编辑器，这一步都需要先转为 HTML 字符串再操作。</p>
<p>首先需要把文章内容中的图片全部找出来，这里直接用正则即可：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> images = parsedContent.match(<span class="regexp">/&lt;img.*?(?:&gt;|\/&gt;)/gi</span>);</span><br><span class="line"><span class="keyword">if</span> (images) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> image <span class="keyword">of</span> images) &#123;</span><br><span class="line">    <span class="keyword">const</span> src = image.match(<span class="regexp">/src=['"]?([^'"]*)['"]?/i</span>);</span><br><span class="line">    <span class="keyword">const</span> url = src?.[<span class="number">1</span>];</span><br><span class="line">    <span class="comment">// 对取出的 URL 做处理</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先匹配所有的 <code>&lt;img /&gt;</code> 标签，之后针对每个标签再做一次匹配，取到其中的 src 值（也就是图片的 URL）。</p>
<p>对匹配到的图片 URL 依次下载为 stream 并上传到微信公众号图片上传接口，之后使用返回的微信域内 URL 替换原文中的 URL。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (url) &#123;</span><br><span class="line">  <span class="keyword">const</span> imageStream = (<span class="keyword">await</span> axios.get(url, &#123; <span class="attr">responseType</span>: <span class="string">'stream'</span> &#125;)).data;</span><br><span class="line">  <span class="keyword">const</span> formData = &#123; <span class="attr">media</span>: imageStream &#125;;</span><br><span class="line">  <span class="keyword">const</span> res = <span class="keyword">await</span> request(&#123;</span><br><span class="line">    url: <span class="string">`https://api.weixin.qq.com/cgi-bin/media/uploadimg?access_token=<span class="subst">$&#123;accessToken&#125;</span>`</span>,</span><br><span class="line">    method: <span class="string">'POST'</span>,</span><br><span class="line">    formData,</span><br><span class="line">  &#125;);</span><br><span class="line">  parsedContent = parsedContent.replace(url, <span class="built_in">JSON</span>.parse(res).url);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上传图片的接口当然需要鉴权，这里的 access token 是直接使用上一步封装好的方法获取的。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> accessToken = <span class="keyword">await</span> getWechatAccessToken(ctx);</span><br></pre></td></tr></table></figure>

<p>需要注意的是，上传到微信公众号必须使用 request 或者基于 request 的 request-promise。因为 node 环境的 axios 对 form-data 格式发送文件的 POST 并不能很好地支持。</p>
<p>不要忘记了对封面图也做一样的处理，因为使用 API 编辑公众号图文必须添加封面图，封面图也必须是微信域内的。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> coverImageStream = (<span class="keyword">await</span> axios.get(coverImage, &#123; <span class="attr">responseType</span>: <span class="string">'stream'</span> &#125;)).data;</span><br><span class="line"><span class="keyword">const</span> coverImageRes = <span class="keyword">await</span> request(&#123;</span><br><span class="line">  url: <span class="string">`https://api.weixin.qq.com/cgi-bin/material/add_material?access_token=<span class="subst">$&#123;accessToken&#125;</span>&amp;type=image`</span>,</span><br><span class="line">  method: <span class="string">'POST'</span>,</span><br><span class="line">  formData: &#123; <span class="attr">media</span>: coverImageStream &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">const</span> coverImageId = <span class="built_in">JSON</span>.parse(coverImageRes).media_id;</span><br></pre></td></tr></table></figure>

<p>这里需要注意的是，上传封面图的接口和上传图片的接口是不一样的，要注意区分。最后我们拿到的是封面图的素材 id，这个 id 我们后面创建图文素材时会用到。</p>
<p>把封面图和文章中的图片都替换一遍后，我们就完成了这一步。</p>
<h3 id="外联-CSS-转为内联"><a href="#外联-CSS-转为内联" class="headerlink" title="外联 CSS 转为内联"></a>外联 CSS 转为内联</h3><p>这一步我本来以为会很麻烦，但是幸运的是，在 node 上（前端浏览器等环境不可以用这个包，会报错）有一个名为 <a href="https://mp.weixin.qq.com/s/mZeuVB6lpXQ1yKNULeG5tw" target="_blank" rel="noopener">juice</a> 的 npm 包可以帮我们一行代码完成任务：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">parsedContent = juice(<span class="string">`</span></span><br><span class="line"><span class="string">  &lt;style&gt;</span></span><br><span class="line"><span class="string">    <span class="subst">$&#123;cssString&#125;</span></span></span><br><span class="line"><span class="string">  &lt;/style&gt;</span></span><br><span class="line"><span class="string">  &lt;div&gt;</span></span><br><span class="line"><span class="string">    <span class="subst">$&#123;parsedContent&#125;</span></span></span><br><span class="line"><span class="string">  &lt;/div&gt;</span></span><br><span class="line"><span class="string">`</span>);</span><br></pre></td></tr></table></figure>

<p>这里的 <code>cssString</code> 是定义好的字符串，事先把需要应用的 CSS 代码定义好一个字符串变量即可；第一个参数则是需要处理的 HTML 代码，也就是上一步替换图片 URL 的结果。</p>
<h3 id="调用接口创建素材"><a href="#调用接口创建素材" class="headerlink" title="调用接口创建素材"></a>调用接口创建素材</h3><p>到这一步已经没什么问题了，按照微信开发文档调用接口即可。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">await</span> axios.post(<span class="string">`https://api.weixin.qq.com/cgi-bin/draft/add?access_token=<span class="subst">$&#123;accessToken&#125;</span>`</span>, &#123;</span><br><span class="line">  articles: [&#123;</span><br><span class="line">    title: <span class="string">'你的文章标题'</span>,</span><br><span class="line">    thumb_media_id: coverImageId, <span class="comment">// 刚才取到的封面图素材 id</span></span><br><span class="line">    author: <span class="string">'文章作者'</span>,</span><br><span class="line">    digest: <span class="string">'文章摘要'</span>,</span><br><span class="line">    content: parsedContent, <span class="comment">// 刚才处理好的文章</span></span><br><span class="line">    content_source_url: <span class="string">'原文链接'</span>, <span class="comment">// 非必填，这里我写的是我博客这篇文章的 URL</span></span><br><span class="line">    need_open_comment: <span class="number">1</span>, <span class="comment">// 是否打开留言功能</span></span><br><span class="line">    show_cover_pic: <span class="number">0</span>, <span class="comment">// 是否把封面图添加到文章开头</span></span><br><span class="line">  &#125;],</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>这样就可以成功把文章同步到微信公众号后台的素材库中。最后在微信公众号官方客户端 “订阅号助手” 操作一下，就可以成功把文章发布出去了。当然，最后的发布操作也可以调用 API 解决，不过官方客户端本身就有这个功能，而且官方客户端的 “预览” 功能可以让我提前看到效果，所以我就不必多此一举了。</p>
<h3 id="尚未解决的小问题"><a href="#尚未解决的小问题" class="headerlink" title="尚未解决的小问题"></a>尚未解决的小问题</h3><p>虽然同步到微信公众号这个功能帮我打通了在手机上创作到发布的整个链路，但是还是有两个小问题暂时没法解决：</p>
<ol>
<li>微信公众号未提供声明原创的接口，官方客户端也没有这个功能，因此想要声明原创文章还是必须在电脑上操作。</li>
<li>微信公众号网页版管理后台支持对封面图进行自定义裁剪，而通过 API 指定封面图则只能使用图片中间部分。</li>
</ol>
<h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p><a href="https://developers.weixin.qq.com/doc/offiaccount/Getting_Started/Overview.html" target="_blank" rel="noopener">微信公众号开发文档</a></p>
<p><strong>本文转载自:</strong> <a href="https://mp.weixin.qq.com/s/mZeuVB6lpXQ1yKNULeG5tw" target="_blank" rel="noopener">微信公众号</a></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em><a href="https://code.newban.cn/">乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</a></em></p>
]]></content>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>2024年关于新浪图床失效的解决方法</title>
    <url>/466.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>很多早期的站长基本使用新浪的图床, 新浪图床免费又稳定, 受到很多人的青睐, 我本人不怎么用新浪图床, 但是手上有一批素材, 引用的是新浪服务器中的图片, 目前这些图片无论是在浏览器还是在<code>Markdown</code>编辑器中都无法显示</p>
<p><img src="https://gitee.com/songjianzaina/site_img/raw/master/img/image-20240417181012252.png" alt="image-20240417181012252"></p>
<p><img src="https://gitee.com/songjianzaina/site_img/raw/master/img/image-20240417181029759.png" alt="image-20240417181029759"></p>
<p>这已经不是简单的防盗链了 应该是新浪服务器做了某种屏蔽处理</p>
<h2 id="检测服务器和链接是否正常"><a href="#检测服务器和链接是否正常" class="headerlink" title="检测服务器和链接是否正常"></a>检测服务器和链接是否正常</h2><p>首先我们要确保新浪服务器中有该图片文件,  可以通过以下几种方式检测:</p>
<ol>
<li><p>用<code>VScode</code>编辑器中打开文档 然后鼠标停留在图片链接上, 如果能显示图片, 说明该链接有效</p>
<p> <img src="https://gitee.com/songjianzaina/site_img/raw/master/img/2024-04-17%2018-02-18.2024-04-17%2018_02_58.gif" alt="2024-04-17 18-02-18.2024-04-17 18_02_58"></p>
</li>
<li><p>用<code>PostMan</code>或者<code>ApiPost</code>进行请求访问<br> <img src="https://gitee.com/songjianzaina/site_img/raw/master/img/image-20240417181652619.png" alt="image-20240417181652619"></p>
</li>
<li><p>使用下载工具进行下载</p>
<p> <img src="https://gitee.com/songjianzaina/site_img/raw/master/img/image-20240417181820927.png" alt="image-20240417181820927"></p>
</li>
</ol>
<p>值得庆幸的是 新浪服务器还没有挂 我们还有足够的时间来对图片进行转移和备份</p>
<h2 id="防盗链临时解决方法"><a href="#防盗链临时解决方法" class="headerlink" title="防盗链临时解决方法"></a>防盗链临时解决方法</h2><p>为了使图片迅速恢复访问, 我们可以使用第三方缓存服务来解决防盗链问题, 有以下四种方式可行:</p>
<ol>
<li><p><strong>WordPress</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https://i0.wp.com/图片地址（图片地址要掉 https://）</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>Weserv.nl</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https://images.weserv.nl/?url=图片地址</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>百度 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https://image.baidu.com/search/down?url=图片地址</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>百度 2</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https://gimg2.baidu.com/image_search/&amp;app=2020&amp;src=图片地址（图片地址要去掉 https://）</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>使用百度的速度相对快一些</p>
<h2 id="Wordpress批量替换"><a href="#Wordpress批量替换" class="headerlink" title="Wordpress批量替换"></a>Wordpress批量替换</h2><p>如果你的<code>wordpress</code>博客大量的图片都在新浪中, 那么可以通过以下两种方式进行批量替换:</p>
<ol>
<li><p><strong>静态替换 修改数据库</strong></p>
<p>修改数据库之前记得先备份数据库 以防止误操作无法还原</p>
<p><code>sql</code>命令如下:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> wp_posts <span class="keyword">SET</span> post_content = <span class="keyword">REPLACE</span>( post_content,  <span class="string">'https://tvax1.sinaimg.cn/'</span>,  <span class="string">'https://image.baidu.com/search/down?url=https://tvax1.sinaimg.cn/'</span> )</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>动态替换 修改主题代码</strong></p>
<p>进入<code>wordpress</code>主题编辑器:</p>
<p><img src="https://gitee.com/songjianzaina/site_img/raw/master/img/image-20240417185327043.png" alt="image-20240417185327043"></p>
<p>将以下代码添加到主题页脚<code>foot.php</code>中:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"> <span class="keyword">let</span> context = <span class="built_in">Array</span>.prototype.map.call(<span class="built_in">document</span>.images, (event) =&gt; &#123;</span></span><br><span class="line"><span class="actionscript">           event.src = event.src.replace(<span class="string">"tvax1.sinaimg.cn/"</span>, <span class="string">"image.baidu.com/search/down?url=https://tvax1.sinaimg.cn/"</span>)</span></span><br><span class="line">          </span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/songjianzaina/site_img/raw/master/img/image-20240417185632599.png" alt="image-20240417185632599"></p>
</li>
</ol>
<p>推荐使用动态的方式自动批量替换, 能将降低数据库操作风险, 又方便后期再次更改, 动态的方式唯一不足之处就是图片加载有延迟</p>
<p>如果你追求加载速度和用户体验, 那么建议采用静态替换的方式</p>
<h2 id="图片批量备份"><a href="#图片批量备份" class="headerlink" title="图片批量备份"></a>图片批量备份</h2><p>上面这种临时替换方式始终不是长久之计, 我们需要尽快对图片进行备份和迁移  防止新浪图床哪天不再提供服务了</p>
<p>我个人的做法是通过<code>python</code>批量将图片下载到本地 然后进行图床更换, 核心代码如下:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">from</span> pyquery <span class="keyword">import</span> PyQuery <span class="keyword">as</span> pq</span><br><span class="line"><span class="keyword">import</span> urllib</span><br><span class="line"><span class="comment"># 当前文件路径</span></span><br><span class="line">current_path = os.path.abspath(__file__)</span><br><span class="line"><span class="comment"># 父目录</span></span><br><span class="line">father_path = os.path.abspath(os.path.dirname(current_path) + os.path.sep + <span class="string">"."</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#----- 用于图片下载------</span></span><br><span class="line">opener=urllib.request.build_opener()</span><br><span class="line">opener.addheaders=[(<span class="string">'User-Agent'</span>,<span class="string">'Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/36.0.1941.0 Safari/537.36'</span>),(<span class="string">'Accept'</span>			, <span class="string">'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8'</span>),(</span><br><span class="line">        <span class="string">'Accept-Encoding'</span>	, <span class="string">'gzip,deflate,sdch'</span>),</span><br><span class="line">        (<span class="string">'Accept-Language'</span>	, <span class="string">'zh-CN,zh;q=0.8'</span>)]</span><br><span class="line">req=urllib.request</span><br><span class="line">req.install_opener(opener)</span><br><span class="line"><span class="comment">#----- 用于图片下载------</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 图片输出目录</span></span><br><span class="line">pic_dir = <span class="string">'img'</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(pic_dir):</span><br><span class="line">    os.makedirs(pic_dir)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#将网络图片下载到本地</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">download_img</span><span class="params">(url,dir,image_name)</span>:</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        req.urlretrieve(url, dir+image_name)</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        <span class="keyword">raise</span> e</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#采用原图片地址的名称</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_pic_name_by_url</span><span class="params">(url)</span>:</span></span><br><span class="line">     <span class="comment"># 我只需要末尾xxx部分 使用正则替换</span></span><br><span class="line">    image_name = url.split(<span class="string">'/'</span>)[<span class="number">-1</span>]</span><br><span class="line">    <span class="keyword">return</span> image_name</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">img2url</span><span class="params">(url)</span>:</span></span><br><span class="line">    		 fir=<span class="string">"https://cdn.jsdelivr.net/gh/xxx/xxx/img/"</span></span><br><span class="line">   </span><br><span class="line">    <span class="keyword">if</span> <span class="string">"sinaimg.cn"</span> <span class="keyword">in</span> url:</span><br><span class="line">        url=<span class="string">"https://image.baidu.com/search/down?url="</span>+url</span><br><span class="line">    new_name=get_pic_name_by_url(url)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        download_img(url,<span class="string">"&#123;parent&#125;/img/"</span>.format(parent=father_path),new_name)</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        print(<span class="string">f"图片下载异常: <span class="subst">&#123;e&#125;</span>"</span>)</span><br><span class="line">        <span class="keyword">return</span> url</span><br><span class="line">    <span class="keyword">return</span> fir+new_name</span><br><span class="line"></span><br><span class="line"><span class="comment"># 遍历每篇文章</span></span><br><span class="line"><span class="keyword">for</span> idx, post <span class="keyword">in</span> enumerate(posts):</span><br><span class="line">    content, lastmodifytime = post</span><br><span class="line"></span><br><span class="line">    d=pq(content)</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> d(<span class="string">"img"</span>).items():</span><br><span class="line">        old_url=item.attr(<span class="string">"src"</span>)</span><br><span class="line">        <span class="comment"># 将图片下载到本地</span></span><br><span class="line">        new_url=img2url(old_url)</span><br><span class="line">        print(new_url)</span><br><span class="line">        <span class="comment">#替换图片地址</span></span><br><span class="line">        item.attr(<span class="string">"src"</span>,new_url)</span><br></pre></td></tr></table></figure>

<p><strong>本文为作者原创 转载时请注明出处 谢谢</strong></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em><a href="https://code.newban.cn/">乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</a></em></p>
]]></content>
      <tags>
        <tag>图床</tag>
      </tags>
  </entry>
  <entry>
    <title>编写一个hexo插件 实现将博客中的原创文章同步到微信公众号</title>
    <url>/469.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这个需求很早以前就有了 由于各种原因耽搁了  这次准备把这个功能搞定</p>
<p>我的大本营在博客上 微信公众号只是附带 不过考虑到微信搜索流量以及公众号的广告收益 所以 还等什么呢 自动化地搞起来 嘿嘿😜</p>
<h2 id="功能实现流程"><a href="#功能实现流程" class="headerlink" title="功能实现流程"></a>功能实现流程</h2><p>流程如下:</p>
<ol>
<li>在执行<code>hexo d</code>指令是 获取所有文章<code>html</code></li>
<li>将内容中带有<code>本文为作者原创</code>的文章过滤出来 并排除<code>wx_pushed.txt</code>中已经同步的文章</li>
<li>替换文章中的图片</li>
<li>增加封面图</li>
<li>替换内链样式</li>
<li>推送文章到公众号</li>
<li>推送成功后将文章文件名称记录到<code>wx_pushed.txt</code>中 防止后面重复推送</li>
</ol>
<h2 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h2><p>插件代码如下:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// hexo-wx-sync.js 自动将hexo博客中的原创文章同步到微信公众号</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> axios = <span class="built_in">require</span>(<span class="string">'axios'</span>);</span><br><span class="line"><span class="keyword">const</span> &#123; log &#125; = <span class="built_in">require</span>(<span class="string">'console'</span>);</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">const</span> cheerio = <span class="built_in">require</span>(<span class="string">'cheerio'</span>);</span><br><span class="line"><span class="keyword">var</span> req = <span class="built_in">require</span>(<span class="string">'request-promise'</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> PLUGIN_NAME = <span class="string">'hexo-wx-sync'</span>;</span><br><span class="line"><span class="keyword">const</span> PUSHED_ARTICLES_FILE = <span class="string">'wx_pushed.txt'</span>;</span><br><span class="line"><span class="keyword">const</span> config = hexo.config.wx_sync</span><br><span class="line"><span class="keyword">const</span> parentDir = path.dirname(__dirname);<span class="comment">//当前文件的父目录 也就是hexo</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在执行 hexo d 时触发</span></span><br><span class="line">hexo.extend.generator.register(<span class="string">'wechat'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">locals</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//获取微信公众号accesToken</span></span><br><span class="line">   accessToken=getAccessToken()</span><br><span class="line">  <span class="comment">// 获取所有文章</span></span><br><span class="line">  <span class="keyword">const</span> posts = locals.posts;</span><br><span class="line">  <span class="comment">// 遍历所有文章</span></span><br><span class="line">  posts.forEach(<span class="keyword">async</span> post =&gt; &#123;<span class="comment">//post.content 获取的是html格式内容</span></span><br><span class="line">    <span class="comment">// 获取文章路径</span></span><br><span class="line">    <span class="keyword">const</span> postPath = parentDir + <span class="string">"/source/"</span> + post.source;</span><br><span class="line">    <span class="comment">// 读取markdown文章内容</span></span><br><span class="line">    <span class="keyword">const</span> content = fs.readFileSync(postPath, <span class="string">'utf8'</span>);</span><br><span class="line">    <span class="comment">// 过滤符合条件的文章并替换内容</span></span><br><span class="line">    <span class="keyword">const</span> filteredContent = <span class="keyword">await</span> filterAndReplaceContent(post.content);</span><br><span class="line">    <span class="comment">// 增加封面图</span></span><br><span class="line">     <span class="keyword">const</span> coverImageId = <span class="keyword">await</span> addCoverImage(<span class="string">"https://source.unsplash.com/900x400/?book,library"</span>);</span><br><span class="line">  </span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"准备发布"</span> + content)</span><br><span class="line">    <span class="comment">// 调用微信接口发布文章</span></span><br><span class="line">    publishToWechat(content, post, coverImageId);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">filterAndReplaceContent</span>(<span class="params">content</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 使用 cheerio 解析 HTML 内容</span></span><br><span class="line">  <span class="keyword">const</span> $ = cheerio.load(<span class="string">`&lt;article&gt;<span class="subst">$&#123;content&#125;</span>&lt;/article&gt;`</span>);</span><br><span class="line">  <span class="comment">// 过滤带有'本文为作者原创'的文章 closest表示查找当前元素最近的祖元素</span></span><br><span class="line">  <span class="keyword">const</span> filteredContent = $(<span class="string">'p:contains("本文为作者原创")'</span>).closest(<span class="string">'article'</span>).html();</span><br><span class="line">  <span class="comment">// 替换文章中的图片和内链样式</span></span><br><span class="line">  <span class="comment">// 这里假设你已经实现了相应的函数，比如 replaceImages 和 replaceInternalLinks</span></span><br><span class="line">  <span class="keyword">const</span> replacedContent = <span class="keyword">await</span> replaceImages(filteredContent);</span><br><span class="line">  <span class="keyword">const</span> finalContent = <span class="keyword">await</span> replaceInternalLinks(replacedContent);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"文章过滤完成"</span>)</span><br><span class="line">  <span class="keyword">return</span> finalContent;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">publishToWechat</span>(<span class="params">parsedContent, metadata, coverImageId</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  axios.post(<span class="string">`https://api.weixin.qq.com/cgi-bin/draft/add?access_token=<span class="subst">$&#123;accessToken&#125;</span>`</span>, &#123;</span><br><span class="line">    articles: [&#123;</span><br><span class="line">      title: <span class="string">`<span class="subst">$&#123;metadata.title&#125;</span> `</span>,</span><br><span class="line">      thumb_media_id: coverImageId, <span class="comment">// 刚才取到的封面图素材 id</span></span><br><span class="line">      author: <span class="string">'乱码三千'</span>,</span><br><span class="line">      digest: metadata.title,</span><br><span class="line">      content: parsedContent, <span class="comment">// 刚才处理好的文章</span></span><br><span class="line">      content_source_url: <span class="string">`http://code.newban.cn/463.html`</span>, <span class="comment">// 非必填，这里我写的是我博客这篇文章的 URL</span></span><br><span class="line">      need_open_comment: <span class="number">1</span>, <span class="comment">// 是否打开留言功能</span></span><br><span class="line">      show_cover_pic: <span class="number">0</span>, <span class="comment">// 是否把封面图添加到文章开头</span></span><br><span class="line">    &#125;],</span><br><span class="line">  &#125;).then(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//推送成功会返回一个media_id </span></span><br><span class="line">    da = response.data</span><br><span class="line">    <span class="keyword">if</span> (<span class="string">'media_id'</span> <span class="keyword">in</span> da) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;metadata.title&#125;</span> successfully pushed to WeChat.`</span>);</span><br><span class="line">      <span class="comment">// 记录已推送的文章名称到 wx_pushed.txt 文件中</span></span><br><span class="line">      fs.appendFileSync(PUSHED_ARTICLES_FILE, <span class="string">`<span class="subst">$&#123;metadata.source.replace(<span class="string">"_post/"</span>, <span class="string">""</span>).replace(<span class="string">"md"</span>, <span class="string">"html"</span>)&#125;</span>\n`</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(da)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;).catch(<span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.error(<span class="string">`Failed to push <span class="subst">$&#123;metadata.title&#125;</span> to WeChat: <span class="subst">$&#123;error&#125;</span>`</span>);</span><br><span class="line">  &#125;);;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 替换文章中的图片</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">replaceImages</span>(<span class="params">content</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"开始替换图片"</span>)</span><br><span class="line">  <span class="keyword">const</span> $ = cheerio.load(content);</span><br><span class="line">  $(<span class="string">'img'</span>).each(<span class="keyword">async</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> newUrl = <span class="keyword">await</span> uploadImg($(<span class="keyword">this</span>).attr(<span class="string">'src'</span>));</span><br><span class="line">    $(<span class="keyword">this</span>).attr(<span class="string">'src'</span>, newUrl);</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"图片替换完成"</span>)</span><br><span class="line">  <span class="keyword">return</span> $.html();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">request</span>(<span class="params">option</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">await</span> req(option).then(<span class="function">(<span class="params">response</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"请求成功: "</span> + response);</span><br><span class="line">    <span class="keyword">return</span> response</span><br><span class="line">  &#125;).catch(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"请求错误: "</span> + err);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'&#123;"media_id":"fTLNXU-IBCWKkfWOlCRS17gXwNG5_75-7aBJQalLz1BBBE5UJ43cj3JfxCyYiTN-"&#125;'</span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 上传图片到素材库并获取新的图片地址</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">uploadImg</span>(<span class="params">url</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"需要上传的图片地址:"</span> + url)</span><br><span class="line">  <span class="keyword">const</span> imageStream = (<span class="keyword">await</span> axios.get(url, &#123; <span class="attr">responseType</span>: <span class="string">'stream'</span> &#125;)).data;</span><br><span class="line">  <span class="keyword">const</span> formData = &#123; <span class="attr">media</span>: imageStream &#125;;</span><br><span class="line">  <span class="keyword">const</span> res = <span class="keyword">await</span> request(&#123;</span><br><span class="line">    url: <span class="string">`https://api.weixin.qq.com/cgi-bin/media/uploadimg?access_token=<span class="subst">$&#123;accessToken&#125;</span>`</span>,</span><br><span class="line">    method: <span class="string">'POST'</span>,</span><br><span class="line">    formData,</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">JSON</span>.parse(res).url;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">addCoverImage</span>(<span class="params">coverImage</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 实现封面图增加逻辑</span></span><br><span class="line">  <span class="keyword">const</span> coverImageStream = (<span class="keyword">await</span> axios.get(coverImage, &#123; <span class="attr">responseType</span>: <span class="string">'stream'</span> &#125;)).data;</span><br><span class="line">  <span class="keyword">const</span> coverImageRes = <span class="keyword">await</span> request(&#123;</span><br><span class="line">    url: <span class="string">`https://api.weixin.qq.com/cgi-bin/material/add_material?access_token=<span class="subst">$&#123;accessToken&#125;</span>&amp;type=image`</span>,</span><br><span class="line">    method: <span class="string">'POST'</span>,</span><br><span class="line">    formData: &#123; <span class="attr">media</span>: coverImageStream &#125;,</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">const</span> coverImageId = <span class="built_in">JSON</span>.parse(coverImageRes).media_id;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"封面图id:"</span> + coverImageId)</span><br><span class="line">  <span class="keyword">return</span> coverImageId;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getAccessToken</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> axios.get(<span class="string">`https://api.weixin.qq.com/cgi-bin/token?grant_type=client_credential&amp;appid=<span class="subst">$&#123;config.appid&#125;</span>&amp;secret=<span class="subst">$&#123;config.secret&#125;</span>`</span>).then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (res.status !== <span class="number">200</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> res.data.access_token;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;).catch(<span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.error(<span class="string">`获取accesToken失败`</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>使用方法:</strong></p>
<p>在<code>script</code>目录下新建一个<code>自定义名称.js</code>文件,  注意名称不要使用<code>index.js</code>, 将上面代码粘贴过去, 然后在<code>config</code>配置文件中配置<code>AppID</code>和<code>AppSecret</code> 如下:</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 将文章同步到微信公众号</span></span><br><span class="line"><span class="attr">wx_sync:</span></span><br><span class="line"><span class="attr">    enable:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">    appid:</span> <span class="string">你的appid</span></span><br><span class="line"><span class="attr">    secret:</span> <span class="string">你的secret</span></span><br></pre></td></tr></table></figure>

<h2 id="关于AppID和AppSecret的获取"><a href="#关于AppID和AppSecret的获取" class="headerlink" title="关于AppID和AppSecret的获取"></a>关于AppID和AppSecret的获取</h2><p>开发者ID(<code>AppID</code>)和开发者密码(<code>AppSecret</code>)可以在公众号后台基本配置中获取:</p>
<p><img src="https://gitee.com/songjianzaina/site_img/raw/master/img/image-20240419133336814.png" alt="image-20240419133336814"></p>
<p><img src="https://gitee.com/songjianzaina/site_img/raw/master/img/image-20240419133636776.png" alt="image-20240419133636776"></p>
<p>为了确保接口能正常访问, 还需要设置接口请求所在地的ip地址, 如果你在阿里云服务器调用这些接口 则填入服务器的<code>ip</code> , 如果是本地电脑 则在百度搜索IP获取当前公网IP:</p>
<p><img src="https://gitee.com/songjianzaina/site_img/raw/master/img/image-20240419134212591.png" alt="image-20240419134212591"></p>
<p><img src="https://gitee.com/songjianzaina/site_img/raw/master/img/image-20240419133544001.png" alt="image-20240419133544001"></p>
<p>文章参考 : 《<a href="https://code.newban.cn/468.html">博客文章自动同步微信公众号实践</a>》</p>
<p><strong>本文为作者原创 转载时请注明出处 谢谢</strong></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em><a href="https://code.newban.cn/">乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</a></em></p>
]]></content>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Android 中使用WebViewJavaScriptBridge进行H5和原生的交互</title>
    <url>/47.html</url>
    <content><![CDATA[<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/fdfs.jpg" alt></p>
<h3 id="1-概述"><a href="#1-概述" class="headerlink" title="1.  概述"></a>1.  概述</h3><blockquote>
<p>当我们采用H5与Native原生结合开发，使用H5去开发一些功能的时候，肯定会涉及到Android与Js互相调用的问题，通常有两种实现方式，</p>
</blockquote>
<p><strong>第一种</strong> 使用原生的addJavascriptInterface()来解决</p>
<p><strong>第二种</strong> 使用第三方框架WebViewJavascriptBridge   这也是我今天要分享的部分</p>
<h3 id="2-为什么要使用WsebViewJavascriptBridge"><a href="#2-为什么要使用WsebViewJavascriptBridge" class="headerlink" title="2.为什么要使用WsebViewJavascriptBridge"></a>2.为什么要使用WsebViewJavascriptBridge</h3><p>对于安卓开发有一段时间的人来说，知道安卓4.4以前谷歌的webview存在安全漏洞，网站可以通过js注入就可以随便拿到客户端的重要信息，甚至轻而易举的调用本地代码进行流氓行为，谷歌后来发现有此漏洞后，增加了防御措施，如果要是js调用本地代码，开发者必须在代码中申明<code>JavascriptInterface</code>，</p>
<p> 列如在4.0之前我们要使得webView加载js只需如下代码：   </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mWebView.addJavascriptInterface(new JsToJava(), &quot;myjsfunction&quot;);</span><br></pre></td></tr></table></figure>

<p>4.4之后调用需要在调用方法加入加入@JavascriptInterface注解，如果代码无此申明，那么也就无法使得js生效，也就是说这样就可以避免恶意网页利用js对安卓客户端的窃取和攻击。</p>
<p>但是即使这样，我们很多时候需要在js记载本地代码的时候，要做一些判断和限制，或者有可能也会做些过滤和对用户友好提示，因此JavascriptInterface也就无法满足我们的需求了，特此有大神就写出了WebViewJavascriptBridge框架。</p>
<h3 id="3-开始使用"><a href="#3-开始使用" class="headerlink" title="3.开始使用"></a>3.开始使用</h3><h5 id="第一步-Android-Studio-导包"><a href="#第一步-Android-Studio-导包" class="headerlink" title="第一步.Android Studio 导包"></a>第一步.Android Studio 导包</h5><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">repositories &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    maven &#123; url <span class="string">"https://jitpack.io"</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">    compile <span class="string">'com.github.lzyzsd:jsbridge:1.0.4'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="第二步-在布局文件中添加"><a href="#第二步-在布局文件中添加" class="headerlink" title="第二步.在布局文件中添加"></a>第二步.在布局文件中添加</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;com.github.lzyzsd.jsbridge.BridgeWebView</span><br><span class="line">    android:id=&quot;@+id/wv_web_view&quot;</span><br><span class="line">    android:layout_width=&quot;match_parent&quot;</span><br><span class="line">    android:layout_height=&quot;match_parent&quot; /&gt;</span><br></pre></td></tr></table></figure>

<h5 id="第三步-代码中添加交互方法"><a href="#第三步-代码中添加交互方法" class="headerlink" title="第三步.代码中添加交互方法"></a>第三步.代码中添加交互方法</h5><p><strong>H5调android方法</strong></p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">//android端代码</span></span><br><span class="line">mWebView.registerHandler(<span class="string">"test"</span>, <span class="keyword">new</span> BridgeHandler() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public <span class="keyword">void</span> handler(<span class="built_in">String</span> data, CallBackFunction <span class="function"><span class="keyword">function</span>) </span>&#123;</span><br><span class="line">           <span class="function"><span class="keyword">function</span>.<span class="title">onCallBack</span>(<span class="params"><span class="string">"指定Handler收到Web发来的数据，回传数据给你"</span></span>);</span></span><br><span class="line"><span class="function">&#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">//<span class="title">H5</span>端代码</span></span><br><span class="line"><span class="function"><span class="title">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">           <span class="comment">//调用本地java方法</span></span><br><span class="line">           <span class="comment">//第一个参数是 调用java的函数名字 第二个参数是要传递的数据 第三个参数js在被回调后具体执行方法，responseData为java层回传数据</span></span><br><span class="line">           <span class="keyword">var</span> data=<span class="string">'发送消息给java代码指定接收'</span>;</span><br><span class="line">           <span class="built_in">window</span>.WebViewJavascriptBridge.callHandler(</span><br><span class="line">               <span class="string">'test'</span></span><br><span class="line">               ,data</span><br><span class="line">               , <span class="function"><span class="keyword">function</span>(<span class="params">responseData</span>) </span>&#123;</span><br><span class="line">                   bridgeLog(<span class="string">'来自Java的回传数据： '</span> + responseData);</span><br><span class="line">               &#125;</span><br><span class="line">           );</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">//android端代码 </span></span><br><span class="line">mWebView.setDefaultHandler(<span class="keyword">new</span> BridgeHandler() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public <span class="keyword">void</span> handler(<span class="built_in">String</span> data, CallBackFunction <span class="function"><span class="keyword">function</span>) </span>&#123;</span><br><span class="line">                <span class="function"><span class="keyword">function</span>.<span class="title">onCallBack</span>(<span class="params"><span class="string">"指定Handler收到Web发来的数据，回传数据给你"</span></span>);</span></span><br><span class="line"><span class="function">            &#125;</span></span><br><span class="line"><span class="function">        &#125;);</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">//<span class="title">H5</span>端代码</span></span><br><span class="line"><span class="function"><span class="title">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">           <span class="comment">//发送消息给java代码</span></span><br><span class="line">           <span class="keyword">var</span> data = <span class="string">'发送消息给java代码全局接收'</span>;</span><br><span class="line"></span><br><span class="line">           <span class="built_in">window</span>.WebViewJavascriptBridge.send(</span><br><span class="line">               data</span><br><span class="line">               , <span class="function"><span class="keyword">function</span>(<span class="params">responseData</span>) </span>&#123;</span><br><span class="line">                  bridgeLog(<span class="string">'来自Java的回传数据： '</span> +responseData);</span><br><span class="line">               &#125;</span><br><span class="line">           );</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>

<p>以上两种方式 一个是指定调具体协定好的方法,一个是全局调用</p>
<p><strong>android调H5</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//android端代码 </span></span><br><span class="line">mWebView.send(<span class="string">"发送数据给web默认接收"</span>,<span class="keyword">new</span> CallBackFunction()&#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCallBack</span><span class="params">(String data)</span> </span>&#123;</span><br><span class="line">                        Log.e(TAG, <span class="string">"来自web的回传数据："</span> + data);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//H5端代码 </span></span><br><span class="line"><span class="comment">//注册回调函数，第一次连接时调用 初始化函数</span></span><br><span class="line">connectWebViewJavascriptBridge(function(bridge) &#123;</span><br><span class="line">           bridge.init(function(message, responseCallback) &#123;</span><br><span class="line">               bridgeLog(<span class="string">'默认接收收到来自Java数据： '</span> + message);</span><br><span class="line">               <span class="keyword">var</span> responseData = <span class="string">'默认接收收到来自Java的数据，回传数据给你'</span>;</span><br><span class="line">               responseCallback(responseData);</span><br><span class="line">           &#125;);</span><br><span class="line"></span><br><span class="line">          </span><br><span class="line">       &#125;)</span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//android端代码 </span></span><br><span class="line">mWebView.callHandler(<span class="string">"test"</span>,<span class="string">"发送数据给web指定接收"</span>,<span class="keyword">new</span> CallBackFunction()&#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCallBack</span><span class="params">(String data)</span> </span>&#123;</span><br><span class="line">                        Log.e(TAG, <span class="string">"来自web的回传数据："</span> + data);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line"><span class="comment">//H5端代码 </span></span><br><span class="line">   connectWebViewJavascriptBridge(function(bridge) &#123;</span><br><span class="line">          bridge.registerHandler(<span class="string">"test"</span>, function(data, responseCallback) &#123;</span><br><span class="line">               bridgeLog(<span class="string">'指定接收收到来自Java数据： '</span> + data);</span><br><span class="line">               <span class="keyword">var</span> responseData = <span class="string">'指定接收收到来自Java的数据，回传数据给你'</span>;</span><br><span class="line">               responseCallback(responseData);</span><br><span class="line">           &#125;);</span><br><span class="line">       &#125;)</span><br></pre></td></tr></table></figure>

<p>同样 两种方式一个是不指定方法,另一个是指定具体方法</p>
<p> <strong>到此为止还无法交互,还需要配置setWebViewClient</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mWebView.setWebViewClient(new BridgeWebViewClient(mWebView));</span><br></pre></td></tr></table></figure>

<p>这步非常关键,如果不配置 测试点击压根就不响应,如果你需要自定义WebViewClient,必须实现对应构造方法,而且重写的方法必须调用父类方法,如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private class MyWebViewClient extends BridgeWebViewClient &#123;</span><br><span class="line">	//必须</span><br><span class="line">    public MyWebViewClient(BridgeWebView webView) &#123;</span><br><span class="line">        super(webView);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onReceivedError(WebView view, WebResourceRequest request, WebResourceError error) &#123;</span><br><span class="line">        super.onReceivedError(view, request, error);//这个不能省略</span><br><span class="line">        // 避免出现默认的错误界面</span><br><span class="line">        view.loadUrl(&quot;about:blank&quot;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>到此为止,配置完毕,H5和Android就可以互相调用了</p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em>乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</em></p>
]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库常用操作指令</title>
    <url>/463.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>数据库操作指令<em></em>涵盖了创建、查询、修改和删除数据库及表的过程，以及如何在这些数据库和表中进行数据操作。以下是一些常用的数据库操作指令：</p>
<h2 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h2><h3 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">database</span> 数据库名;</span><br></pre></td></tr></table></figure>

<h3 id="删除数据库"><a href="#删除数据库" class="headerlink" title="删除数据库"></a>删除数据库</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">database</span> 数据库名;</span><br></pre></td></tr></table></figure>

<h3 id="创建表"><a href="#创建表" class="headerlink" title="创建表"></a>创建表</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> 表名 (列名 数据类型);</span><br></pre></td></tr></table></figure>

<h3 id="删除表"><a href="#删除表" class="headerlink" title="删除表"></a>删除表</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> 表名;</span><br></pre></td></tr></table></figure>

<h3 id="显示所有数据库"><a href="#显示所有数据库" class="headerlink" title="显示所有数据库"></a>显示所有数据库</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">databases</span>;</span><br></pre></td></tr></table></figure>

<h3 id="进入数据库"><a href="#进入数据库" class="headerlink" title="进入数据库"></a>进入数据库</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> 数据库名;</span><br></pre></td></tr></table></figure>

<h3 id="显示所有表"><a href="#显示所有表" class="headerlink" title="显示所有表"></a>显示所有表</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">tables</span>;</span><br></pre></td></tr></table></figure>

<h3 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> 表名 <span class="keyword">values</span>(值<span class="number">1</span>,值<span class="number">2</span>,...);</span><br></pre></td></tr></table></figure>

<h3 id="修改数据"><a href="#修改数据" class="headerlink" title="修改数据"></a>修改数据</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">update</span> 表名 <span class="keyword">set</span> 字段=新值 <span class="keyword">where</span> 条件;</span><br></pre></td></tr></table></figure>

<h3 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> 表名 <span class="keyword">where</span> 条件;</span><br></pre></td></tr></table></figure>

<h3 id="修改表名"><a href="#修改表名" class="headerlink" title="修改表名"></a>修改表名</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 旧表名 <span class="keyword">rename</span> <span class="keyword">to</span> 新表名;</span><br></pre></td></tr></table></figure>

<h3 id="查看表所有的字段"><a href="#查看表所有的字段" class="headerlink" title="查看表所有的字段"></a>查看表所有的字段</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">describe</span> 表名</span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">columns</span> <span class="keyword">from</span> 表名</span><br></pre></td></tr></table></figure>

<h3 id="添加字段"><a href="#添加字段" class="headerlink" title="添加字段"></a>添加字段</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名 <span class="keyword">add</span> 字段名 数据类型;</span><br></pre></td></tr></table></figure>

<h3 id="修改字段"><a href="#修改字段" class="headerlink" title="修改字段"></a>修改字段</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> <span class="keyword">modify</span> 字段名 新数据类型;</span><br></pre></td></tr></table></figure>

<h3 id="删除字段"><a href="#删除字段" class="headerlink" title="删除字段"></a>删除字段</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名 <span class="keyword">drop</span> 字段名;</span><br></pre></td></tr></table></figure>

<p>这些指令提供了对数据库和表的基本操作，包括创建、修改、删除和查询数据 根据具体需求，可以组合使用这些指令来完成更复杂的数据库管理任务</p>
<p><strong>本文为作者原创 转载时请注明出处 谢谢</strong></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em><a href="https://code.newban.cn/">乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</a></em></p>
]]></content>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Google Admob移动广告快速集成步骤</title>
    <url>/48.html</url>
    <content><![CDATA[<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/20200515163037.png" alt></p>
<h3 id><a href="#" class="headerlink" title></a></h3><h5 id="第一步-引入依赖包"><a href="#第一步-引入依赖包" class="headerlink" title="第一步:引入依赖包"></a>第一步:引入依赖包</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//admob广告</span></span><br><span class="line">implementation <span class="string">'com.google.android.gms:play-services-ads:17.2.0'</span></span><br></pre></td></tr></table></figure>

<h5 id="第二步-在清单文件中设置appID"><a href="#第二步-在清单文件中设置appID" class="headerlink" title="第二步:在清单文件中设置appID"></a>第二步:在清单文件中设置appID</h5><figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;application</span><br><span class="line">&lt;!-- admob配置 --&gt;</span><br><span class="line">    &lt;meta-data</span><br><span class="line">        android:name=<span class="string">"com.google.android.gms.ads.APPLICATION_ID"</span></span><br><span class="line">        &lt;!-- 注意 这里设置应用id 而不是广告单元id 每个广告都有各自独立的id --&gt;</span><br><span class="line">        android:value=<span class="string">"ca-app-pub-xxxxxxxxxxxxxxxxxxxx"</span>/&gt;</span><br><span class="line">&lt;/application&gt;</span><br></pre></td></tr></table></figure>

<h5 id="第三步-在布局文件中设置广告显示的具体位置"><a href="#第三步-在布局文件中设置广告显示的具体位置" class="headerlink" title="第三步:在布局文件中设置广告显示的具体位置"></a>第三步:在布局文件中设置广告显示的具体位置</h5><figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;!-- 布局中可以设置广告单元id  这里考虑到防止反编译 改成在代码中设置--&gt;</span><br><span class="line">&lt;com.google.android.gms.ads.AdView xmlns:ads=<span class="string">"http://schemas.android.com/apk/res-auto"</span></span><br><span class="line">    android:id=<span class="string">"@+id/adView"</span></span><br><span class="line">    android:layout_width=<span class="string">"wrap_content"</span></span><br><span class="line">    android:layout_height=<span class="string">"wrap_content"</span></span><br><span class="line">    android:layout_alignParentBottom=<span class="string">"true"</span></span><br><span class="line">    android:layout_centerHorizontal=<span class="string">"true"</span></span><br><span class="line">    ads:adSize=<span class="string">"SMART_BANNER"</span></span><br><span class="line">    &gt;&lt;/com.google.android.gms.ads.AdView&gt;</span><br></pre></td></tr></table></figure>

<h5 id="第四步-初始化Admob"><a href="#第四步-初始化Admob" class="headerlink" title="第四步:初始化Admob"></a>第四步:初始化Admob</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 初始化Admob  这个地方填appid 注意</span></span><br><span class="line">MobileAds.initialize(<span class="keyword">this</span>, <span class="string">"ca-app-pub-xxxxxxxxxxxxxxxxxxxx"</span>);</span><br></pre></td></tr></table></figure>

<h5 id="第五步-在对应的Activity或Fragment中设置广告显示"><a href="#第五步-在对应的Activity或Fragment中设置广告显示" class="headerlink" title="第五步: 在对应的Activity或Fragment中设置广告显示"></a>第五步: 在对应的Activity或Fragment中设置广告显示</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String AD_UNIT_ID = <span class="string">"ca-app-pub-xxxxxxxxxxxxxxxxxxxx"</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initAdmob</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mAdView = findViewById(R.id.adView);</span><br><span class="line">    mAdView.setAdUnitId(AD_UNIT_ID);</span><br><span class="line">    AdRequest adRequest = <span class="keyword">new</span> AdRequest.Builder().build();</span><br><span class="line">    mAdView.loadAd(adRequest);</span><br><span class="line"></span><br><span class="line">    mAdView.setAdListener(<span class="keyword">new</span> AdListener() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAdLoaded</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// Code to be executed when an ad finishes loading.</span></span><br><span class="line">            <span class="comment">//广告加载完成后，系统会执行 onAdLoaded() 方法。</span></span><br><span class="line">            <span class="comment">// 如果您想延迟向 Activity 或 Fragment 中添加AdView的操作（例如，延迟到您确定广告会加载时），可以在此处进行。</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAdFailedToLoad</span><span class="params">(<span class="keyword">int</span> errorCode)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// Code to be executed when an ad request fails.</span></span><br><span class="line">            <span class="comment">//onAdFailedToLoad() 是唯一包含参数的方法。errorCode 参数会指明发生了何种类型的失败。系统将这些可能的类型值定义为AdRequest类中的如下常量：</span></span><br><span class="line">            <span class="comment">//ERROR_CODE_INTERNAL_ERROR - 内部出现问题；例如，收到广告服务器的无效响应。</span></span><br><span class="line">            <span class="comment">//ERROR_CODE_INVALID_REQUEST - 广告请求无效；例如，广告单元 ID 不正确。</span></span><br><span class="line">            <span class="comment">//ERROR_CODE_NETWORK_ERROR - 由于网络连接问题，广告请求失败。</span></span><br><span class="line">            <span class="comment">//ERROR_CODE_NO_FILL - 广告请求成功，但由于缺少广告资源，未返回广告。</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAdOpened</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// Code to be executed when an ad opens an overlay that</span></span><br><span class="line">            <span class="comment">// covers the screen.</span></span><br><span class="line">            <span class="comment">//此方法会在用户点按广告时调用。</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAdClicked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// Code to be executed when the user clicks on an ad.</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAdLeftApplication</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// Code to be executed when the user has left the app.</span></span><br><span class="line">            <span class="comment">//此方法会于 onAdOpened() 之后在用户点击打开其他应用（例如，Google Play）时调用，从而在后台运行当前应用。</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAdClosed</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// Code to be executed when the user is about to return</span></span><br><span class="line">            <span class="comment">// to the app after tapping on an ad.</span></span><br><span class="line">            <span class="comment">//在用户查看广告的目标网址后返回应用时，会调用此方法。应用可以使用此方法恢复暂停的活动，或执行任何其他必要的操作，以做好互动准备。</span></span><br><span class="line">            <span class="comment">// 有关 Android API Demo 应用中广告监听器方法的实现方式，请参阅 AdMob AdListener 示例。</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>本文为作者原创 转载时请注明出处 谢谢</strong></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em>乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</em></p>
]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>如何开发hexo插件</title>
    <url>/462.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Hexo 有强大的插件系统，使您能轻松扩展功能而不用修改核心模块的源码。在 Hexo 中有两种形式的插件：</p>
<h3 id="脚本（Scripts）"><a href="#脚本（Scripts）" class="headerlink" title="脚本（Scripts）"></a>脚本（Scripts）</h3><p>如果您的代码很简单，建议您编写脚本，您只需要把 JavaScript 文件放到 <code>scripts</code> 文件夹，在启动时就会自动加载。</p>
<h3 id="插件（Packages）"><a href="#插件（Packages）" class="headerlink" title="插件（Packages）"></a>插件（Packages）</h3><p>如果您的代码较复杂，或是您想要发布到 NPM 上，建议您编写插件。首先，在 <code>node_modules</code> 文件夹中建立文件夹，文件夹名称开头必须为 <code>hexo-</code>，如此一来 Hexo 才会在启动时加载；否则 Hexo 将会忽略它。</p>
<p>文件夹内至少要包含 2 个文件：一个是主程序，另一个是 <code>package.json</code>，描述插件的用途和所依赖的插件。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── index.js</span><br><span class="line">└── package.json</span><br></pre></td></tr></table></figure>

<p><code>package.json</code> 中至少要包含 <code>name</code>, <code>version</code>, <code>main</code> 属性，例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">package.json&#123;</span><br><span class="line">  <span class="string">"name"</span>: <span class="string">"hexo-my-plugin"</span>,</span><br><span class="line">  <span class="string">"version"</span>: <span class="string">"0.0.1"</span>,</span><br><span class="line">  <span class="string">"main"</span>: <span class="string">"index"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h3><p>您可以使用 Hexo 提供的官方工具插件来加速开发：</p>
<ul>
<li><a href="https://github.com/hexojs/hexo-fs" target="_blank" rel="noopener">hexo-fs</a>：文件 IO</li>
<li><a href="https://github.com/hexojs/hexo-util" target="_blank" rel="noopener">hexo-util</a>：工具程式</li>
<li><a href="https://github.com/hexojs/hexo-i18n" target="_blank" rel="noopener">hexo-i18n</a>：本地化（i18n）</li>
<li><a href="https://github.com/hexojs/hexo-pagination" target="_blank" rel="noopener">hexo-pagination</a>：生成分页数据</li>
</ul>
<h3 id="发布"><a href="#发布" class="headerlink" title="发布"></a>发布</h3><p>当您完成插件后，可以考虑将它发布到 <a href="https://hexo.io/plugins" target="_blank" rel="noopener">插件列表</a>，让更多人能够使用您的插件。发布插件的步骤和 <a href="https://hexo.io/zh-cn/docs/contributing.html#更新文档" target="_blank" rel="noopener">更新文档</a> 非常类似。</p>
<ol>
<li><p>Fork <a href="https://github.com/hexojs/site" target="_blank" rel="noopener">hexojs/site</a></p>
</li>
<li><p>把库（repository）复制到电脑上，并安装所依赖的插件。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> https://github.com/&lt;username&gt;/site.git</span><br><span class="line">$ <span class="built_in">cd</span> site</span><br><span class="line">$ npm install</span><br></pre></td></tr></table></figure>
</li>
<li><p>在 <code>source/_data/plugins/</code> 中创建一个新的 yaml 文件，使用您的插件名称作为文件名。</p>
</li>
<li><p>编辑 <code>source/_data/plugins/&lt;your-plugin-name&gt;.yml</code> 并添加您的插件。例如：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">description:</span> <span class="string">Server</span> <span class="string">module</span> <span class="string">for</span> <span class="string">Hexo.</span></span><br><span class="line"><span class="attr">link:</span> <span class="attr">https://github.com/hexojs/hexo-server</span></span><br><span class="line"><span class="attr">tags:</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">official</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">server</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">console</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>推送（push）分支。</p>
</li>
<li><p>建立一个新的合并申请（pull request）并描述改动。</p>
</li>
</ol>
<p><strong>本文转载自</strong> : <a href="https://hexo.io/zh-cn/docs/plugins" target="_blank" rel="noopener">Hexo中文网</a></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em><a href="https://code.newban.cn/">乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</a></em></p>
]]></content>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>H5通过scheme跳转指定Activity的几种方式</title>
    <url>/49.html</url>
    <content><![CDATA[<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/u=3857517106,2525057362&fm=26&gp=0.jpg" alt></p>
<h3 id="如果是App内部WebView点击跳转指定Activity"><a href="#如果是App内部WebView点击跳转指定Activity" class="headerlink" title="如果是App内部WebView点击跳转指定Activity"></a>如果是App内部WebView点击跳转指定Activity</h3><h4 id="第一种-在清单文件配置intent-filter"><a href="#第一种-在清单文件配置intent-filter" class="headerlink" title="第一种 在清单文件配置intent-filter"></a>第一种 在清单文件配置intent-filter</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;intent-filter&gt;</span><br><span class="line">    &lt;action android:name=&quot;android.intent.action.VIEW&quot; /&gt;</span><br><span class="line">    &lt;category android:name=&quot;android.intent.category.DEFAULT&quot; /&gt;</span><br><span class="line">    &lt;data</span><br><span class="line">        android:host=&quot;personal_page_info&quot;</span><br><span class="line">        android:scheme=&quot;$&#123;app_scheme&#125;&quot; /&gt;</span><br><span class="line">&lt;/intent-filter&gt;</span><br></pre></td></tr></table></figure>

<p><strong>WebView设置:</strong></p>
<pre><code>mWebView.setWebViewClient(new WebViewClient() {
@Override
public void onPageStarted(WebView view, String url, Bitmap favicon) {

}
@Override
public boolean shouldOverrideUrlLoading(WebView view, String httpurl) {
    if (httpurl.startsWith(&quot;app:&quot;)) {
        Intent intent = new Intent(Intent.ACTION_VIEW, Uri.parse(httpurl));
        startActivity(intent);
    }
    return false;
}
});</code></pre><p><strong>如果还需要传值的话, 在Activity中进行数据解析:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if (intent.dataString.orEmpty().isNotEmpty()) &#123;</span><br><span class="line">       mUserId = intent.dataString.orEmpty().parseValue(&quot;userid&quot;, 0)</span><br><span class="line">   &#125; else &#123;</span><br><span class="line">       ActivityLauncher.bind(this)</span><br><span class="line">   &#125;</span><br><span class="line">   if (mUserId == 0) finish()</span><br></pre></td></tr></table></figure>

<h4 id="第二种-不配置intent-filter的方式"><a href="#第二种-不配置intent-filter的方式" class="headerlink" title="第二种 不配置intent-filter的方式"></a>第二种 不配置intent-filter的方式</h4><p>只需在WebView的shouldOverrideUrlLoading方法中进行内链解析处理即可:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  @Override</span><br><span class="line">public boolean shouldOverrideUrlLoading(WebView view, String httpurl) &#123;</span><br><span class="line">    if (httpurl.startsWith(&quot;app://jump_activity&quot;)) &#123;</span><br><span class="line">        Intent intent = new Intent(context, XXXActivity.class));</span><br><span class="line">        startActivity(intent);</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="如果是外部浏览器页面点击跳转指定Activity"><a href="#如果是外部浏览器页面点击跳转指定Activity" class="headerlink" title="如果是外部浏览器页面点击跳转指定Activity"></a>如果是外部浏览器页面点击跳转指定Activity</h3><p>只需在清单文件中对指定Acticity做intent-filter配置即可</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;intent-filter&gt;</span><br><span class="line">    &lt;action android:name=&quot;android.intent.action.VIEW&quot; /&gt;</span><br><span class="line">    &lt;category android:name=&quot;android.intent.category.DEFAULT&quot; /&gt;</span><br><span class="line">    &lt;data</span><br><span class="line">        android:host=&quot;personal_page_info&quot;</span><br><span class="line">        android:scheme=&quot;$&#123;app_scheme&#125;&quot; /&gt;</span><br><span class="line">&lt;/intent-filter&gt;</span><br></pre></td></tr></table></figure>

<p><strong>本文为作者原创 转载时请注明出处 谢谢</strong></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em>乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</em></p>
]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo NexT 主题集成 utterance 评论系统</title>
    <url>/50.html</url>
    <content><![CDATA[<p>使用 Hexo 的 Next 主题搭建的博客内置了很多种评论系统，如：gitalk，changyan 等。</p>
<p>这里讲解集成另外一种评论系统：<code>utterance</code>（<a href="https://utteranc.es/）" target="_blank" rel="noopener">https://utteranc.es/）</a></p>
<p>其配置非常简单，支持 Github 账号登录后才能评论。原理就是使用了 Github 的 Issues 功能来保存评论。</p>
<h2 id="配置步骤"><a href="#配置步骤" class="headerlink" title="配置步骤"></a>配置步骤</h2><h3 id="创建-Github-仓库"><a href="#创建-Github-仓库" class="headerlink" title="创建 Github 仓库"></a>创建 Github 仓库</h3><p>上面提到，utterance 使用 Github 保存评论，那我们就需要创建一个 <code>repository</code> 专门保存评论。</p>
<p><code>repository</code>名称可以根据自己喜好取，这个后面会用到。</p>
<h3 id="授权"><a href="#授权" class="headerlink" title="授权"></a>授权</h3><p>用户在博客页面上输入评论，utterance 拿到这个评论后，自动的提交到上面刚创建仓库的 Issues 里。</p>
<p>所以我们需要授权 utterance 应用能访问仓库的 Issues。</p>
<p>点击链接： <a href="https://github.com/apps/utterances" target="_blank" rel="noopener">https://github.com/apps/utterances</a> ，如下图所示：</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/20200520123555.png" alt></p>
<h3 id="主题配置"><a href="#主题配置" class="headerlink" title="主题配置"></a>主题配置</h3><p>一，在主题的配置文件 <code>_config.yml</code> 文件中，加入如下配置：</p>
<p><em>位置可以放到其它评论配置的后面</em></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 整合 utterance 评论</span><br><span class="line">utterance:</span><br><span class="line">  enable: true</span><br><span class="line">  # 仓库名字，格式：你的用户 ID/ 仓库名称，如：zhangsan/utterance_repo</span><br><span class="line">  repo: </span><br><span class="line">  # 主题</span><br><span class="line">  theme: github-light</span><br><span class="line">  # 映射配置</span><br><span class="line">  issue_term: pathname</span><br></pre></td></tr></table></figure>

<p>二，在主题的 <code>layout\_third-party\comments</code> 文件夹下，创建 <code>utterance.swig</code> 文件，添加如下内容：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">    (function() &#123;</span><br><span class="line">        // 匿名函数，防止污染全局变量</span><br><span class="line">        var utterances = document.createElement(&apos;script&apos;);</span><br><span class="line">        utterances.type = &apos;text/javascript&apos;;</span><br><span class="line">        utterances.async = true;</span><br><span class="line">        utterances.setAttribute(&apos;issue-term&apos;,&apos;&#123;&#123; theme.utterance.issue_term &#125;&#125;&apos;)</span><br><span class="line">        utterances.setAttribute(&apos;theme&apos;,&apos;&#123;&#123; theme.utterance.theme &#125;&#125;&apos;)</span><br><span class="line">        utterances.setAttribute(&apos;repo&apos;,&apos;&#123;&#123; theme.utterance.repo &#125;&#125;&apos;)</span><br><span class="line">        utterances.crossorigin = &apos;anonymous&apos;;</span><br><span class="line">        utterances.src = &apos;https://utteranc.es/client.js&apos;;</span><br><span class="line">        // content 是要插入评论的地方</span><br><span class="line">        document.getElementById(&apos;gitment-container&apos;).appendChild(utterances);</span><br><span class="line">    &#125;)();</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>三，还是刚才那个文件夹，找到 <code>index.swig</code> 文件，加入如下配置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% elif theme.utterance.enable %&#125;</span><br><span class="line">  &#123;% include &apos;utterance.swig&apos; %&#125;</span><br></pre></td></tr></table></figure>

<p>注意加在 <code>endif</code> 后面，如：</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/20200520123610.png" alt></p>
<p>四，以上只是添加了脚本，还需添加 comment 样式。找到 <code>layout\_partials\comments.swig</code> 文件。在最后加入内容：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% elif theme.utterance.enable %&#125;</span><br><span class="line">  &lt;div class=&quot;comments&quot; id=&quot;comments&quot;&gt;</span><br><span class="line">      &lt;div id=&quot;gitment-container&quot;&gt;&lt;/div&gt;</span><br><span class="line">  &lt;/div&gt;</span><br></pre></td></tr></table></figure>

<p>如：</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/20200520123626.png" alt></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上就是整个集成 utterance 评论的流程，按照流程一步一步来应该是没问题的。</p>
<p><strong>本文转载自:</strong><a href="https://zhangzw.com/posts/20190720.html" target="_blank" rel="noopener">https://zhangzw.com/posts/20190720.html</a></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em>乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</em></p>
]]></content>
      <tags>
        <tag>hexo技巧</tag>
      </tags>
  </entry>
  <entry>
    <title>如何给你的博客集成Gittalk or Gitment 第三方评论插件</title>
    <url>/52.html</url>
    <content><![CDATA[<blockquote>
<p>Gittalk or Gitment都是基于的GitHub Issues作为评论系统 它们的配置方式基本差不多</p>
</blockquote>
<h2 id="开始配置"><a href="#开始配置" class="headerlink" title="开始配置"></a>开始配置</h2><h4 id="第一步-："><a href="#第一步-：" class="headerlink" title="第一步 ："></a>第一步 ：</h4><p>首先需要到GitHub上去新建一个仓库用于存放评论的内容：</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/20200519172005.png" alt></p>
<h4 id="第二步"><a href="#第二步" class="headerlink" title="第二步:"></a>第二步:</h4><p>在设置中打开isue功能, 默认是开启状态:</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/20200519172028.png" alt></p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/20200519171836.png" alt></p>
<h4 id="第三步"><a href="#第三步" class="headerlink" title="第三步:"></a>第三步:</h4><p>需要注册一个Github Application:</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/20200519170416.png" alt></p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/20200519170549.png" alt></p>
<p><strong>注意两个URL就是你网站的域名。应用名称和描述和之前仓库的保持一致就行, 方便以后归类查找。</strong></p>
<p>注册成功后接下来到了以下页面:</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/20200519170910.png" alt></p>
<p><strong>其中Client ID 和 Client Secret是我们需要的东西</strong></p>
<h4 id="第四步"><a href="#第四步" class="headerlink" title="第四步"></a>第四步</h4><p><strong>gitalk评论插件配置</strong></p>
<p>只需要将如下代码引入你想添加评论的 html 或者 jsp 页面中就可以使用了</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">&lt;-- 引入 --&gt;</span><br><span class="line">&lt;link rel=<span class="string">"stylesheet"</span> href=<span class="string">"https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css"</span>&gt;</span><br><span class="line">  &lt;script src=<span class="string">"https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"</span>&gt;&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;-- 添加一个容器--&gt;</span><br><span class="line">&lt;div id=<span class="string">"gitalk-container"</span>&gt;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;-- 生成 gitalk 插件--&gt;</span><br><span class="line"><span class="keyword">var</span> gitalk = <span class="keyword">new</span> Gitalk(&#123;</span><br><span class="line">  clientID: <span class="string">'56f73fbc5e79a466ea62'</span>, <span class="comment">//Client ID</span></span><br><span class="line"></span><br><span class="line">  clientSecret: <span class="string">'26d8eb4f3b0de9ce02382103ffc32ba34c4671f4'</span>, <span class="comment">//Client Secret</span></span><br><span class="line"></span><br><span class="line">  repo: <span class="string">'newban_comment'</span>,<span class="comment">//仓库名称</span></span><br><span class="line">  owner: <span class="string">'songjianzaina'</span>,<span class="comment">//仓库拥有者</span></span><br><span class="line">  admin: [<span class="string">'songjianzaina'</span>],</span><br><span class="line">  id: location.href,      <span class="comment">// Ensure uniqueness and length less than 50</span></span><br><span class="line">  distractionFreeMode: <span class="literal">false</span>  <span class="comment">// Facebook-like distraction free mode</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">gitalk.render(<span class="string">'gitalk-container'</span>)</span><br></pre></td></tr></table></figure>

<h4 id="如果你的博客使用的也是Next主题可以直接配置gitment评论插件"><a href="#如果你的博客使用的也是Next主题可以直接配置gitment评论插件" class="headerlink" title="如果你的博客使用的也是Next主题可以直接配置gitment评论插件"></a>如果你的博客使用的也是Next主题可以直接配置gitment评论插件</h4><p>找到自己主题文件下的配置文件<code>_config.yml</code>中配置gitment即可</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gitment:</span><br><span class="line">  enable: true</span><br><span class="line">  mint: true # RECOMMEND, A mint on Gitment, to support count, language and proxy_gateway</span><br><span class="line">  count: true # Show comments count in post meta area</span><br><span class="line">  lazy: false # Comments lazy loading with a button</span><br><span class="line">  cleanly: false # Hide &apos;Powered by ...&apos; on footer, and more</span><br><span class="line">  language: # Force language, or auto switch by theme</span><br><span class="line">  github_user: 自己账号的用户名 </span><br><span class="line">  github_repo: 刚刚创建仓库的名 </span><br><span class="line">  client_id: xxx 刚刚得到的值</span><br><span class="line">  client_secret:  xxx 刚刚得到的值</span><br><span class="line">  proxy_gateway: </span><br><span class="line">  redirect_protocol:</span><br></pre></td></tr></table></figure>

<h2 id="其他评论系统"><a href="#其他评论系统" class="headerlink" title="其他评论系统"></a>其他评论系统</h2><p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20220708110541293.png" alt="image-20220708110541293"></p>
<p>还有在线聊天系统</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20220708110639326.png" alt="image-20220708110639326"></p>
<p>详细介绍参见《<a href="https://butterfly.js.org/posts/ceeb73f/" target="_blank" rel="noopener">Butterfly 安装文档(四) 主题配置</a>》</p>
<p><strong>本文为作者原创 转载时请注明出处 谢谢</strong></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em>乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</em></p>
]]></content>
      <tags>
        <tag>hexo技巧</tag>
      </tags>
  </entry>
  <entry>
    <title>如何在markdown中插入js和css</title>
    <url>/53.html</url>
    <content><![CDATA[<blockquote>
<p>有时候我们可能需要改动markdown 的样式。由于markdown的呈现形式是html，可以直接把以下部分添加到markdown中，即可更改默认的样式</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&lt;style&gt;</span><br><span class="line">h1,</span><br><span class="line">h2,</span><br><span class="line">h3,</span><br><span class="line">h4,</span><br><span class="line">h5,</span><br><span class="line">h6,</span><br><span class="line">p,</span><br><span class="line">blockquote &#123;</span><br><span class="line">    margin: 0;</span><br><span class="line">    padding: 0;</span><br><span class="line">&#125;</span><br><span class="line">body &#123;</span><br><span class="line">    font-family: &quot;Helvetica Neue&quot;, Helvetica, &quot;Hiragino Sans GB&quot;, Arial, sans-serif;</span><br><span class="line">    font-size: 13px;</span><br><span class="line">    line-height: 18px;</span><br><span class="line">    color: #737373;</span><br><span class="line">    background-color: white;</span><br><span class="line">    margin: 10px 13px 10px 13px;</span><br><span class="line">&#125;</span><br><span class="line">table &#123;</span><br><span class="line">    margin: 10px 0 15px 0;</span><br><span class="line">    border-collapse: collapse;</span><br><span class="line">&#125;</span><br><span class="line">td,th &#123; </span><br><span class="line">    border: 1px solid #ddd;</span><br><span class="line">    padding: 3px 10px;</span><br><span class="line">&#125;</span><br><span class="line">th &#123;</span><br><span class="line">    padding: 5px 10px;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">a &#123;</span><br><span class="line">    color: #0069d6;</span><br><span class="line">&#125;</span><br><span class="line">a:hover &#123;</span><br><span class="line">    color: #0050a3;</span><br><span class="line">    text-decoration: none;</span><br><span class="line">&#125;</span><br><span class="line">a img &#123;</span><br><span class="line">    border: none;</span><br><span class="line">&#125;</span><br><span class="line">p &#123;</span><br><span class="line">    margin-bottom: 9px;</span><br><span class="line">&#125;</span><br><span class="line">h1,</span><br><span class="line">h2,</span><br><span class="line">h3,</span><br><span class="line">h4,</span><br><span class="line">h5,</span><br><span class="line">h6 &#123;</span><br><span class="line">    color: #404040;</span><br><span class="line">    line-height: 36px;</span><br><span class="line">&#125;</span><br><span class="line">h1 &#123;</span><br><span class="line">    margin-bottom: 18px;</span><br><span class="line">    font-size: 30px;</span><br><span class="line">&#125;</span><br><span class="line">h2 &#123;</span><br><span class="line">    font-size: 24px;</span><br><span class="line">&#125;</span><br><span class="line">h3 &#123;</span><br><span class="line">    font-size: 18px;</span><br><span class="line">&#125;</span><br><span class="line">h4 &#123;</span><br><span class="line">    font-size: 16px;</span><br><span class="line">&#125;</span><br><span class="line">h5 &#123;</span><br><span class="line">    font-size: 14px;</span><br><span class="line">&#125;</span><br><span class="line">h6 &#123;</span><br><span class="line">    font-size: 13px;</span><br><span class="line">&#125;</span><br><span class="line">hr &#123;</span><br><span class="line">    margin: 0 0 19px;</span><br><span class="line">    border: 0;</span><br><span class="line">    border-bottom: 1px solid #ccc;</span><br><span class="line">&#125;</span><br><span class="line">blockquote &#123;</span><br><span class="line">    padding: 13px 13px 21px 15px;</span><br><span class="line">    margin-bottom: 18px;</span><br><span class="line">    font-family:georgia,serif;</span><br><span class="line">    font-style: italic;</span><br><span class="line">&#125;</span><br><span class="line">blockquote:before &#123;</span><br><span class="line">    content:&quot;\201C&quot;;</span><br><span class="line">    font-size:40px;</span><br><span class="line">    margin-left:-10px;</span><br><span class="line">    font-family:georgia,serif;</span><br><span class="line">    color:#eee;</span><br><span class="line">&#125;</span><br><span class="line">blockquote p &#123;</span><br><span class="line">    font-size: 14px;</span><br><span class="line">    font-weight: 300;</span><br><span class="line">    line-height: 18px;</span><br><span class="line">    margin-bottom: 0;</span><br><span class="line">    font-style: italic;</span><br><span class="line">&#125;</span><br><span class="line">code, pre &#123;</span><br><span class="line">    font-family: Monaco, Andale Mono, Courier New, monospace;</span><br><span class="line">&#125;</span><br><span class="line">code &#123;</span><br><span class="line">    background-color: #fee9cc;</span><br><span class="line">    color: rgba(0, 0, 0, 0.75);</span><br><span class="line">    padding: 1px 3px;</span><br><span class="line">    font-size: 12px;</span><br><span class="line">    -webkit-border-radius: 3px;</span><br><span class="line">    -moz-border-radius: 3px;</span><br><span class="line">    border-radius: 3px;</span><br><span class="line">&#125;</span><br><span class="line">pre &#123;</span><br><span class="line">    display: block;</span><br><span class="line">    padding: 14px;</span><br><span class="line">    margin: 0 0 18px;</span><br><span class="line">    line-height: 16px;</span><br><span class="line">    font-size: 11px;</span><br><span class="line">    border: 1px solid #d9d9d9;</span><br><span class="line">    white-space: pre-wrap;</span><br><span class="line">    word-wrap: break-word;</span><br><span class="line">&#125;</span><br><span class="line">pre code &#123;</span><br><span class="line">    background-color: #fff;</span><br><span class="line">    color:#737373;</span><br><span class="line">    font-size: 11px;</span><br><span class="line">    padding: 0;</span><br><span class="line">&#125;</span><br><span class="line">sup &#123;</span><br><span class="line">    font-size: 0.83em;</span><br><span class="line">    vertical-align: super;</span><br><span class="line">    line-height: 0;</span><br><span class="line">&#125;</span><br><span class="line">*&#123;</span><br><span class="line">    -webkit-print-color-adjust: exact;</span><br><span class="line">&#125;</span><br><span class="line">@media screen and (min-width: 914px) &#123;</span><br><span class="line">    body &#123;</span><br><span class="line">        width: 854px;</span><br><span class="line">        margin:10px auto;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">@media print &#123;</span><br><span class="line">    body,code,pre code,h1,h2,h3,h4,h5,h6 &#123;</span><br><span class="line">        color: black;</span><br><span class="line">    &#125;</span><br><span class="line">    table, pre &#123;</span><br><span class="line">        page-break-inside: avoid;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>

<p>直接将以上代码插入文本的上方, 如下:</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20210831104548134.png" alt="image-20210831104548134"></p>
<p>生成html的结果为:</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20210831104446641.png" alt="image-20210831104446641"></p>
<h4 id="如何在Hexo发布博客的Md文件中引入JS代码"><a href="#如何在Hexo发布博客的Md文件中引入JS代码" class="headerlink" title="如何在Hexo发布博客的Md文件中引入JS代码"></a>如何在Hexo发布博客的Md文件中引入JS代码</h4><p>跟引入css样式一样 直接插入js代码即可 这里有两种方式:</p>
<p><strong>第一种 引用第三方js文件</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script type=&quot;text/javascript&quot; src=&quot;/js/src/echarts.min.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p><strong>第二种 常规写法</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line"></span><br><span class="line">var bmapChart=echarts.init(document.getElementById(&quot;map-wrap&quot;));</span><br><span class="line"></span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<h4 id="附加"><a href="#附加" class="headerlink" title="附加"></a>附加</h4><p>如果使用<code>hexo</code>编译<code>html</code> 如果要将<code>html</code>代码当做普通文本处理 可以添加以下<code>raw</code>标签, 如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% raw %&#125;</span><br><span class="line"></span><br><span class="line">这里是html代码区域, 表示失去html的功能</span><br><span class="line"></span><br><span class="line">&#123;% endraw %&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em>乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</em></p>
]]></content>
      <tags>
        <tag>小技巧</tag>
      </tags>
  </entry>
  <entry>
    <title>在Gradle中声明一个Java可使用的变量</title>
    <url>/56.html</url>
    <content><![CDATA[<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/a1ek1i9490023624619.jpg" alt></p>
<h2 id="生成Java常量"><a href="#生成Java常量" class="headerlink" title="生成Java常量"></a>生成Java常量</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">    buildTypes &#123;</span><br><span class="line">        debug &#123;</span><br><span class="line">            buildConfigField <span class="string">"int"</span>, <span class="string">"FOO"</span>, <span class="string">"42"</span></span><br><span class="line">            buildConfigField <span class="string">"String"</span>, <span class="string">"FOO_STRING"</span>, <span class="string">"\"foo\""</span></span><br><span class="line">            buildConfigField <span class="string">"boolean"</span>, <span class="string">"LOG"</span>, <span class="string">"true"</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        release &#123;</span><br><span class="line">            buildConfigField <span class="string">"int"</span>, <span class="string">"FOO"</span>, <span class="string">"52"</span></span><br><span class="line">            buildConfigField <span class="string">"String"</span>, <span class="string">"FOO_STRING"</span>, <span class="string">"\"bar\""</span></span><br><span class="line">            buildConfigField <span class="string">"boolean"</span>, <span class="string">"LOG"</span>, <span class="string">"false"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>你可以访问他们 <code>BuildConfig.FOO</code></p>
<h2 id="生成Android资源"><a href="#生成Android资源" class="headerlink" title="生成Android资源"></a>生成Android资源</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">    buildTypes &#123;</span><br><span class="line">        debug&#123;</span><br><span class="line">            resValue <span class="string">"string"</span>, <span class="string">"app_name"</span>, <span class="string">"My App Name Debug"</span></span><br><span class="line">        &#125;</span><br><span class="line">        release &#123;</span><br><span class="line">            resValue <span class="string">"string"</span>, <span class="string">"app_name"</span>, <span class="string">"My App Name"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>您可以按照通常的方式访问它们。<code>@string/app_name</code>或<code>R.string.app_name</code></p>
<p><em>乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</em></p>
]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>利用 IntelliJ IDEA 远程连接服务器并做ftp上传</title>
    <url>/5.html</url>
    <content><![CDATA[<p>对于windows用户来说上传文件到服务器有很多资源可以利用,例如xshell,xftp等可视化进行服务器的管控,但是对于mac的小伙伴来说现在找一个替代xshell的不是很好找,要么不好用要么用起来比较繁琐.小编发现idea自带ssh连接,也可以通过idea进行文件管理上传至服务器.</p>
<p>打开idea可以单独设置一个空包作为服务器管理,只需要把要上传的文件放到包里面即可.</p>
<p><strong>idea &gt;&gt; Tools &gt;&gt; Deployment &gt;&gt; Configuration 进入到配置页面</strong></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20200918131554.png" alt></p>
<p><strong>点击加号出现配置服务器信息.我们选择sftp文件上传模式,名称为为当前上产服务器设置的别名</strong></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20200918131613.png" alt></p>
<p>录入必要信息:</p>
<ul>
<li><p>SFTP host 服务器地址.</p>
</li>
<li><p>Port.     端口号</p>
</li>
<li><p>Root path  默认上传路径</p>
</li>
<li><p>User name 登录服务器用户名</p>
</li>
<li><p>Auth type 授权方式,这里小编采用密码授权模式</p>
</li>
<li><p>Password. 登录服务器密码</p>
</li>
</ul>
<p>录入完必要信息以后可以点击Test SFTP connection进行连接测试</p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20200918131521.png" alt></p>
<p><strong>通过 Tools &gt;&gt; Start SSH 进行ssh远程连接,点击后会出现配置好的ssh信息,选择即可</strong></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20200918131628.png" alt></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20200918131646.png" alt></p>
<p>链接成功后在idea的Terminal中可以看到链接成功的信息</p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20200918131702.png" alt></p>
<p><strong>通过Configuration 下选择配置好的ssh服务器进入Mappings文件夹 可以配置上传路径和本地文件存放路径</strong></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20200918131750.png" alt></p>
<p><strong>配置完以后 通过项目右键可以看到一个上传到服务器按钮点击即可把要上传的文件上传至服务器</strong></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20200918131716.png" alt></p>
<p><strong>上传后的效果.</strong></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20200918131808.png" alt></p>
<p>至此通过idea远程链接ssh并上传文件至服务器配置完毕.需要的小伙伴们可以去使用啦</p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em>乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</em></p>
]]></content>
      <tags>
        <tag>ftp技巧</tag>
      </tags>
  </entry>
  <entry>
    <title>如何使用命令行下载更新Android SDK</title>
    <url>/51.html</url>
    <content><![CDATA[<blockquote>
<p>最近需要在服务器上用Jenkins自动打包Android app，从google官网上下载的Linux版本sdk结果发现里面就只有一个tools目录有文件，其他的都没有。。。<br>无奈，服务器是没有界面的，之前都习惯用IDE去安装更新，现在尝试用命令行下载更新了。</p>
</blockquote>
<h2 id="下载Android-SDK-for-Linux"><a href="#下载Android-SDK-for-Linux" class="headerlink" title="下载Android SDK for Linux"></a>下载Android SDK for Linux</h2><p>从google的官网下载最新Linux版本SDK，由于dl.google.com域名一直没有被墙，所以才可以直接从官网下了。这点不错~</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">下载</span><br><span class="line">$ wget https://dl.google.com/android/android-sdk_r24.4.1-linux.tgz</span><br><span class="line">或者</span><br><span class="line">$curl -o https://dl.google.com/android/android-sdk_r24.4.1-linux.tgz</span><br><span class="line">或者</span><br><span class="line">$wget -O https://dl.google.com/android/android-sdk_r24.4.1-linux.tgz</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">解压</span><br><span class="line">$ tar zxvf android-sdk_r24.4.1-linux.tgz</span><br></pre></td></tr></table></figure>

<h2 id="更新Android-SDK"><a href="#更新Android-SDK" class="headerlink" title="更新Android SDK"></a>更新Android SDK</h2><p>前面说到了，我们下载的这个包其实只有tools目录下才有东西。既然google给了我们这个，表示这里面肯定有可以更新SDK的工具啦。<br>其实就是tools/android这个文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ cd android-sdk-linux/tools</span><br></pre></td></tr></table></figure>

<p>进入后</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">查看当前可安装的SDK版本</span><br><span class="line">$ ./android list sdk -a</span><br><span class="line"></span><br><span class="line">Refresh Sources:</span><br><span class="line">  Fetching https://dl.google.com/android/repository/addons_list-2.xml</span><br><span class="line">  Validate XML</span><br><span class="line">  Parse XML</span><br><span class="line">  Fetched Add-ons List successfully</span><br><span class="line">  Refresh Sources</span><br><span class="line">  Fetching URL: https://dl.google.com/android/repository/repository-11.xml</span><br><span class="line">  Validate XML: https://dl.google.com/android/repository/repository-11.xml</span><br><span class="line">  Parse XML:    https://dl.google.com/android/repository/repository-11.xml</span><br><span class="line">  Fetching URL: https://dl.google.com/android/repository/addon.xml</span><br><span class="line">  Validate XML: https://dl.google.com/android/repository/addon.xml</span><br><span class="line">  Parse XML:    https://dl.google.com/android/repository/addon.xml</span><br><span class="line">  Fetching URL: https://dl.google.com/android/repository/glass/addon.xml</span><br><span class="line">  Validate XML: https://dl.google.com/android/repository/glass/addon.xml</span><br><span class="line">  Parse XML:    https://dl.google.com/android/repository/glass/addon.xml</span><br><span class="line">  Fetching URL: https://dl.google.com/android/repository/extras/intel/addon.xml</span><br><span class="line">  Validate XML: https://dl.google.com/android/repository/extras/intel/addon.xml</span><br><span class="line">  Parse XML:    https://dl.google.com/android/repository/extras/intel/addon.xml</span><br><span class="line">  Fetching URL: https://dl.google.com/android/repository/sys-img/android/sys-img.xml</span><br><span class="line">  Validate XML: https://dl.google.com/android/repository/sys-img/android/sys-img.xml</span><br><span class="line">  Parse XML:    https://dl.google.com/android/repository/sys-img/android/sys-img.xml</span><br><span class="line">  Fetching URL: https://dl.google.com/android/repository/sys-img/android-wear/sys-img.xml</span><br><span class="line">  Validate XML: https://dl.google.com/android/repository/sys-img/android-wear/sys-img.xml</span><br><span class="line">  Parse XML:    https://dl.google.com/android/repository/sys-img/android-wear/sys-img.xml</span><br><span class="line">  Fetching URL: https://dl.google.com/android/repository/sys-img/android-tv/sys-img.xml</span><br><span class="line">  Validate XML: https://dl.google.com/android/repository/sys-img/android-tv/sys-img.xml</span><br><span class="line">  Parse XML:    https://dl.google.com/android/repository/sys-img/android-tv/sys-img.xml</span><br><span class="line">  Fetching URL: https://dl.google.com/android/repository/sys-img/google_apis/sys-img.xml</span><br><span class="line">  Validate XML: https://dl.google.com/android/repository/sys-img/google_apis/sys-img.xml</span><br><span class="line">  Parse XML:    https://dl.google.com/android/repository/sys-img/google_apis/sys-img.xml</span><br><span class="line">  </span><br><span class="line">  Packages available for installation or update: 41</span><br><span class="line">   1- Android SDK Tools, revision 25.2.2</span><br><span class="line">   2- Android SDK Platform-tools, revision 24.0.4</span><br><span class="line">   3- Android SDK Build-tools, revision 24.0.3</span><br><span class="line">   4- Documentation for Android SDK, API 24, revision 1</span><br><span class="line">   5- SDK Platform Android 7.0, API 24, revision 2</span><br><span class="line">   6- SDK Platform Android 6.0, API 23, revision 3</span><br></pre></td></tr></table></figure>

<p>因为是首次安装，所有有非常多的版本可下载。<br><strong>我们可以有2个选择：</strong></p>
<ol>
<li><p>安装所有版本的SDK</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ ./android update sdk -u</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="2">
<li><p>只安装我们需要SDK版本</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">只安装指定序号的版本</span><br><span class="line">$ ./android  update sdk -u -t 序号</span><br><span class="line">如：安装Build-tools, revision 24.0.3</span><br><span class="line"></span><br><span class="line">$ ./android update sdk -u -t 3</span><br><span class="line">需要同意license，输入 y 回车即可</span><br></pre></td></tr></table></figure>



</li>
</ol>
<p>因为是在服务器上，建议直接安装所有版本的吧，不然后续可能有些app需要这个版本，又有的需要那个版本。还不如一开始就全部安装好。</p>
<p>安装后可跳转到上一级目录查看是否已经有了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ cd ..</span><br><span class="line">$ ls</span><br><span class="line">add-ons  build-tools  platforms  SDK Readme.txt  temp  tools</span><br><span class="line">$ cd build-tools</span><br><span class="line">$ ls</span><br><span class="line">24.0.3</span><br></pre></td></tr></table></figure>

<p>可以看到安装成功了。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>通过这些我们也可以推测出其实那些IDE图形界面底层调用的也是这些命令吧</p>
<h2 id="附加可能会使用到的linux指令"><a href="#附加可能会使用到的linux指令" class="headerlink" title="附加可能会使用到的linux指令"></a>附加可能会使用到的linux指令</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">查看当前目录的实际路径</span><br><span class="line">$pwd</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">全局搜索指定文件 包括文件夹和文件</span><br><span class="line">$find . -name  &quot;文件名&quot;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">不区分大小写查找</span><br><span class="line">$find  -iname &quot;*SaleContractFromDc*&quot;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">从/开始查找以.log结尾的文件</span><br><span class="line">$find / -name &quot;*.log&quot;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">下载文件到指定路径 这将只有在路径存在时下载。下载将保留远程文件名。下载后，将返回原始位置</span><br><span class="line">$cd target/path &amp;&amp; &#123; curl -O URL ; cd -; &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">查看系统整体空间剩余情况</span><br><span class="line">$df -h</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">查看每个文件夹的占用情况</span><br><span class="line">$du -sh</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">删除非空目录</span><br><span class="line">$rm -rf 目录</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">查看 或 编辑 环境变量的配置</span><br><span class="line">$vim /etc/profile</span><br><span class="line">或者直接使用</span><br><span class="line">$export</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">配置环境变量</span><br><span class="line">export ANDROID_SDK_HOME=/root/Android/sdk/android-sdk-linux</span><br><span class="line">export PATH=$PATH:$&#123;ANDROID_SDK_HOME&#125;/tools</span><br><span class="line">export PATH=$PATH:$&#123;ANDROID_SDK_HOME&#125;/platform-tools</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">移动文件夹下所有东西到zone中</span><br><span class="line">$mv    /usr/lib/*    /zone</span><br></pre></td></tr></table></figure>

<p><strong>本帖附件</strong></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em>乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</em></p>
]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>Activity跳转之scheme跳转法</title>
    <url>/58.html</url>
    <content><![CDATA[<p><strong>Activity的跳转可以说是非常简单的了、从一个页面跳转至另一个页面，我们最常用的也就是下面这种：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Intent intent = <span class="keyword">new</span> Intent(<span class="keyword">this</span>, xxx.class);</span><br><span class="line">startActivity(intent);</span><br></pre></td></tr></table></figure>

<p><strong>当然还有我们的隐式跳转，为Intent指定一个<code>action</code>即可</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Intent intent = <span class="keyword">new</span> Intent(<span class="string">"this is an action"</span>);</span><br><span class="line">startActivity(intent);</span><br></pre></td></tr></table></figure>

<p><strong>这篇文章上面提到的两个都不讲,这里来说使用scheme协议来进行页面跳转</strong></p>
<ul>
<li><a href="https://developer.android.google.cn/guide/topics/manifest/data-element.html" target="_blank" rel="noopener">manifest / data 配置</a></li>
<li>如果需要让我们的Activity能被其他应用或者网页所打开，需要在<code>AndroidManifest</code>中进行配置（浏览网页的时候点击一些广告可以进对应的app大概就是这个原理）</li>
</ul>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&lt;activity android:name=<span class="string">".TestOneActivity"</span>&gt;</span><br><span class="line">    &lt;intent-filter&gt;</span><br><span class="line">        &lt;action android:name=<span class="string">"android.intent.action.VIEW"</span> /&gt;</span><br><span class="line">        &lt;category android:name=<span class="string">"android.intent.category.DEFAULT"</span> /&gt;</span><br><span class="line">        &lt;category android:name=<span class="string">"android.intent.category.BROWSABLE"</span> /&gt;</span><br><span class="line">        &lt;!--配置scheme--&gt;</span><br><span class="line">        &lt;data</span><br><span class="line">            android:scheme=<span class="string">"azhon.scheme"</span> /&gt;</span><br><span class="line">    &lt;/intent-filter&gt;</span><br><span class="line">&lt;/activity&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>如上代码我们只是简单的配置了一个<code>android:scheme</code>属性，那要打开这个Activity也是so easy的</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">startActivity(<span class="keyword">new</span> Intent(Intent.ACTION_VIEW,                        Uri.parse(<span class="string">"azhon.scheme://"</span>)));</span><br></pre></td></tr></table></figure>

<ul>
<li>当然&lt; data/&gt;中还可以配置更多的属性（截取自官方中文文档，可以点击上面的manifest / data 配置）</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;data android:scheme=<span class="string">"string"</span></span><br><span class="line">      android:host=<span class="string">"string"</span></span><br><span class="line">      android:port=<span class="string">"string"</span></span><br><span class="line">      android:path=<span class="string">"string"</span></span><br><span class="line">      android:pathPattern=<span class="string">"string"</span></span><br><span class="line">      android:pathPrefix=<span class="string">"string"</span></span><br><span class="line">      android:mimeType=<span class="string">"string"</span> /&gt;</span><br></pre></td></tr></table></figure>

<p><strong><em>scheme 路径的规则</em></strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;scheme&gt; :<span class="comment">// &lt;host&gt; : &lt;port&gt; [&lt;path&gt;|&lt;pathPrefix&gt;|&lt;pathPattern&gt;]</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>scheme开头 :// 主机名 : 端口号 / [路径/参数] 路径后面拼接参数也是可以的下面会用到。<br>这个地址和我们经常使用的网页地址差不多是一样滴<br>eg:<a href="https://loaclhost:8080/index.jsp" target="_blank" rel="noopener">https://loaclhost:8080/index.jsp</a></p>
</blockquote>
<p><strong>在网页中打开我们对应的页面</strong></p>
<ul>
<li>我们修改Manifest中Activity的配置在多加点料,我这里创建了两个页面</li>
</ul>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">activity android:name=<span class="string">".TestOneActivity"</span>&gt;</span><br><span class="line">    &lt;intent-filter&gt;</span><br><span class="line">        &lt;action android:name=<span class="string">"android.intent.action.VIEW"</span> /&gt;</span><br><span class="line">        &lt;category android:name=<span class="string">"android.intent.category.DEFAULT"</span> /&gt;</span><br><span class="line">        &lt;category android:name=<span class="string">"android.intent.category.BROWSABLE"</span> /&gt;</span><br><span class="line">        &lt;data</span><br><span class="line">            android:host=<span class="string">"azhon"</span></span><br><span class="line">            android:port=<span class="string">"1011"</span></span><br><span class="line">            android:scheme=<span class="string">"azhon.scheme"</span> /&gt;</span><br><span class="line">    &lt;/intent-filter&gt;</span><br><span class="line">&lt;/activity&gt;</span><br><span class="line"> </span><br><span class="line">&lt;activity android:name=<span class="string">".TestTwoActivity"</span>&gt;</span><br><span class="line">    &lt;intent-filter&gt;</span><br><span class="line">        &lt;action android:name=<span class="string">"android.intent.action.VIEW"</span> /&gt;</span><br><span class="line">        &lt;category android:name=<span class="string">"android.intent.category.DEFAULT"</span> /&gt;</span><br><span class="line">        &lt;category android:name=<span class="string">"android.intent.category.BROWSABLE"</span> /&gt;</span><br><span class="line">        &lt;data</span><br><span class="line">            android:host=<span class="string">"azhon"</span></span><br><span class="line">            android:port=<span class="string">"1012"</span></span><br><span class="line">            android:scheme=<span class="string">"azhon.scheme"</span> /&gt;</span><br><span class="line">    &lt;/intent-filter&gt;</span><br><span class="line">&lt;/activity&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>在主页面布局添加一个WebView控件，并让它加载<code>assets</code>文件夹中的html文件</li>
<li>布局文件代码：</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">WebView</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">"@+id/web"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_marginTop</span>=<span class="string">"20dp"</span> /</span></span><br></pre></td></tr></table></figure>

<ul>
<li>assets文件夹中的Html代码：</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"azhon.scheme://azhon:1011/我是路径?user=958460248&amp;psd=123456"</span>&gt;</span>跳转至TestOneActivity<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"azhon.scheme://azhon:1012/i am path?toId=25&amp;tmId=888"</span>&gt;</span>跳转至TestTwoActivity<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>效果图：<br><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/20191219175153.png" alt></p>
<blockquote>
<p>在网页中只需要使用一个超链接便可以轻松的跳转至我们的app，是不是很开心。<br>当你将这个html文件使用手机的浏览器查看时，点击也是一样可以跳转进app的<br>跳转页面的时候还可以通过 ?key=value&amp;key1=value2 键值对的方式往地址后面拼接参数</p>
</blockquote>
<ul>
<li>在跳转过去的页面接收传递过来的参数</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Intent intent = getIntent();</span><br><span class="line">Uri uri = intent.getData();</span><br><span class="line"> </span><br><span class="line"><span class="keyword">assert</span> uri != <span class="keyword">null</span>;</span><br><span class="line">sb.append(<span class="string">"scheme: "</span>).append(intent.getScheme()).append(<span class="string">"&lt;p&gt;"</span>);</span><br><span class="line">sb.append(<span class="string">"host: "</span>).append(uri.getHost()).append(<span class="string">"&lt;p&gt;"</span>);</span><br><span class="line">sb.append(<span class="string">"port: "</span>).append(uri.getPort()).append(<span class="string">"&lt;p&gt;"</span>);</span><br><span class="line">sb.append(<span class="string">"path: "</span>).append(uri.getPath()).append(<span class="string">"&lt;p&gt;"</span>);</span><br><span class="line">sb.append(<span class="string">"params: "</span>).append(uri.getQuery()).append(<span class="string">"&lt;p&gt;"</span>);</span><br><span class="line"> </span><br><span class="line"><span class="comment">//获取跳转过来携带所有参数的 键名</span></span><br><span class="line">Set&lt;String&gt; names = uri.getQueryParameterNames();</span><br><span class="line">Iterator&lt;String&gt; iterator = names.iterator();</span><br><span class="line"><span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">    String key = iterator.next();</span><br><span class="line">    sb.append(key).append(<span class="string">": "</span>).append(uri.getQueryParameter(key)).append(<span class="string">"&lt;p&gt;"</span>);</span><br><span class="line">&#125;</span><br><span class="line">tv.setText(Html.fromHtml(sb.toString()));</span><br></pre></td></tr></table></figure>

<p><strong>有了这种跳转方式 你只要知道其他app的scheme你就可以随意的跳过去了想想都刺激，比如下面代码打开微信和QQ程序。</strong></p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;a href="weixin://"&gt;打开微信&lt;/a&gt;&lt;p&gt;  </span><br><span class="line">&lt;a href="mqqzone://"&gt;打开QQ&lt;/a&gt;</span><br></pre></td></tr></table></figure>

<p>效果图：<br><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/20191219175213.png" alt></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em>乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</em></p>
]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>Markdown中图片插入的近似优雅法</title>
    <url>/54.html</url>
    <content><![CDATA[<h1 id="最终实现效果"><a href="#最终实现效果" class="headerlink" title="最终实现效果"></a>最终实现效果</h1><ul>
<li><p>在图片上右键上传，自动生成markdown<code>图片链接格式</code>到剪切板中，任意地方<code>Ctrl+v</code>均可粘贴</p>
</li>
<li><p>在文件上右键上传，自动生成markdown<code>超链接格式</code>到剪切板中，任意地方<code>Ctrl+v</code>均可粘贴</p>
</li>
</ul>
<h1 id="markdown介绍"><a href="#markdown介绍" class="headerlink" title="markdown介绍"></a>markdown介绍</h1><ul>
<li>Markdown是一种可以使用普通文本编辑器编写的标记语言，通过简单的标记语法，它可以使普通文本内容具有一定的格式。</li>
<li>Markdown的语法简洁明了、学习容易，10分钟即可完全学会掌握。Markdown 的语法全由一些符号所组成，这些符号经过精挑细选，其作用一目了然。 即使没有渲染器，以纯文本方式阅读，也毫无障碍。</li>
<li>对于开发人员还有一个特别棒的优点：得益于其纯文本属性，用markdown编写的文档、表格等，存放与svn/git/perforce以后，可以非常方便的使用比较工具，对比历史版本！这个word、excel……所不能或者不易办到的。</li>
</ul>
<h1 id="markdown的痛点"><a href="#markdown的痛点" class="headerlink" title="markdown的痛点"></a>markdown的痛点</h1><h2 id="图片保存现状"><a href="#图片保存现状" class="headerlink" title="图片保存现状"></a>图片保存现状</h2><p>成也萧何败也萧何，由于markdown的纯文本属性，决定了它不可能优雅的存储图片，在实践中有2种图形表示法</p>
<ul>
<li><p>markdown标准</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">![Alt text](/path/to/img.jpg)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这样实际是存放的图片地址，而非图片本身</p>
</blockquote>
</li>
<li><p>html转义</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">![](data:image/*;base64,iVBORw0KGgoAAAANSUhEUgAAAJgAAADZCAIAAABTpG6/AAANaklEQVR4Ae2de1BU1x3H97ILC8gCRh5RjC9sEozPaQc7TiCO02o6+aMZp8M/plOn/8TEtv/V/OMM5Z9OdPJPk5ohbWfazNSJ0o6dSf6IEkubYlLt1PgAwReagK7A4gPEFVjY7Xf3wOYII=)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>以上是base64编码以后的二进制数据</p>
</blockquote>
</li>
</ul>
<p>上述2种方法，在书写markdown的过程中，都很不方便</p>
<h2 id="便利的编辑器"><a href="#便利的编辑器" class="headerlink" title="便利的编辑器"></a>便利的编辑器</h2><ul>
<li><p>typora</p>
<p>在windows下最好的markdown编辑器，没有之一</p>
<p>拖动图片到文档中，会自动拷贝图片到硬盘的指定位置，算是半自动化解决了问题</p>
<p>但是依然存在问题：分享为博客后，这些图片的路径很难正确处理</p>
</li>
</ul>
<h1 id="理想中的解决方案"><a href="#理想中的解决方案" class="headerlink" title="理想中的解决方案"></a>理想中的解决方案</h1><ul>
<li>在“我的电脑”中任意位置找到图片，右键点击“上传”，</li>
<li>自动生成markdown格式<code>![Alt text](http://***.***.***/***.jpg)</code>或者<code>[filedes](http://****.*****.***/***.zip)</code>在剪切板中</li>
<li>在任何文本/markdown编辑器中，直接<code>Ctrl+V</code>即可完成编写</li>
</ul>
<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><h3 id="COS"><a href="#COS" class="headerlink" title="COS"></a>COS</h3><blockquote>
<p>对象存储（Cloud Object Storage，COS）</p>
</blockquote>
<p>我们需要一个空间，用于存放图片或者文件，这里推荐使用腾讯云或者七牛云</p>
<p>他们提供的免费额度足够普通用户使用了</p>
<h4 id="腾讯云的免费额度"><a href="#腾讯云的免费额度" class="headerlink" title="腾讯云的免费额度"></a>腾讯云的免费额度</h4><table>
<thead>
<tr>
<th align="left">资源类型</th>
<th align="left">资源子类型</th>
<th align="left">每月免费额度</th>
</tr>
</thead>
<tbody><tr>
<td align="left">存储空间</td>
<td align="left">存储空间</td>
<td align="left">50 GB</td>
</tr>
<tr>
<td align="left">流量</td>
<td align="left">外网下行流量</td>
<td align="left">10 GB</td>
</tr>
<tr>
<td align="left">流量</td>
<td align="left">腾讯云 CDN 回源流量</td>
<td align="left">10 GB</td>
</tr>
<tr>
<td align="left">请求</td>
<td align="left">读请求</td>
<td align="left">100 万次</td>
</tr>
<tr>
<td align="left">请求</td>
<td align="left">写请求</td>
<td align="left">100 万次</td>
</tr>
</tbody></table>
<h4 id="七牛云的免费额度"><a href="#七牛云的免费额度" class="headerlink" title="七牛云的免费额度"></a>七牛云的免费额度</h4><table>
<thead>
<tr>
<th align="left">资源类型</th>
<th align="left">免费额度</th>
</tr>
</thead>
<tbody><tr>
<td align="left">标准存储空间</td>
<td align="left">0-10 GB</td>
</tr>
<tr>
<td align="left">每月上传流量</td>
<td align="left">无上限</td>
</tr>
<tr>
<td align="left">标准存储每月写请求 Put / Delete</td>
<td align="left">0-10 万次</td>
</tr>
<tr>
<td align="left">标准存储每月读请求 Get</td>
<td align="left">0-100 万次</td>
</tr>
</tbody></table>
<h3 id="本地环境"><a href="#本地环境" class="headerlink" title="本地环境"></a>本地环境</h3><p>这里以腾讯云接口为例，本地需要<code>nodejs</code>运行环境</p>
<ul>
<li><p><a href="https://nodejs.org/en/download/" target="_blank" rel="noopener">nodejs</a></p>
</li>
<li><p><a href="https://github.com/tencentyun/cos-nodejs-sdk-v5" target="_blank" rel="noopener">腾讯云SDK</a></p>
<h3 id="环境变量配置"><a href="#环境变量配置" class="headerlink" title="环境变量配置"></a>环境变量配置</h3></li>
<li><p>在<code>windows环境变量</code>中增加一项<code>NODE_PATH</code>，最好同时指向2处，例如：<code>C:\Users\ZNMLR\node_modules</code>和<code>C:\Users\ZNMLR\AppData\Roaming\npm\node_modules</code></p>
</li>
<li><p>前者对应npm的本地安装，后者对应npm的全局安装</p>
</li>
</ul>
<h1 id="开始优雅之旅"><a href="#开始优雅之旅" class="headerlink" title="开始优雅之旅"></a>开始优雅之旅</h1><h2 id="实现右键调用某bat"><a href="#实现右键调用某bat" class="headerlink" title="实现右键调用某bat"></a>实现右键调用某bat</h2><blockquote>
<p>目标：在任意格式文件上单击右键，弹出菜单“上传”，然后调用指定bat</p>
</blockquote>
<ul>
<li><p>打开注册表编辑器</p>
<p><code>WIN+R</code>调用运行库，输入<code>regedit</code>，会打开注册表编辑器</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/markdwon%E4%B8%AD%E6%8F%92%E5%85%A5%E5%9B%BE%E7%89%87_1.png" alt></p>
</li>
<li><p>找到<code>计算机\HKEY_CLASSES_ROOT\*\shell</code></p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/markdwon%E4%B8%AD%E6%8F%92%E5%85%A5%E5%9B%BE%E7%89%87_2.png" alt></p>
</li>
<li><p>新建项，名字随意</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/markdwon%E4%B8%AD%E6%8F%92%E5%85%A5%E5%9B%BE%E7%89%87_3.png" alt></p>
</li>
<li><p>再新建<code>command</code>子项，并修改右侧默认值</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/markdwon%E4%B8%AD%E6%8F%92%E5%85%A5%E5%9B%BE%E7%89%87_4.png" alt></p>
<p>图中的D:\1.bat是我测试用的，其存放于某合理的地方</p>
</li>
<li><p>修改批处理内容，测试是否工作</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@echo off</span><br><span class="line">echo %1%</span><br><span class="line">pause</span><br><span class="line">exit</span><br></pre></td></tr></table></figure>

<p>该批处理暂时只获取输入参数，并打印出来</p>
<p>然后等待用户敲个<code>Enter</code>就自动退出了</p>
</li>
<li><p>右键点击任意文件</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/markdwon%E4%B8%AD%E6%8F%92%E5%85%A5%E5%9B%BE%E7%89%87_5.png" alt></p>
</li>
<li><p>查看运行效果</p>
</li>
</ul>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/markdwon%E4%B8%AD%E6%8F%92%E5%85%A5%E5%9B%BE%E7%89%87_6.png" alt></p>
<h2 id="不那么严肃的声明"><a href="#不那么严肃的声明" class="headerlink" title="不那么严肃的声明"></a>不那么严肃的声明</h2><p>今天是我用nodejs的第二天，代码可能写不那么符合标准不那么优雅，见谅</p>
<p>如果发现有更好的优化方法，请发邮件通知我，谢谢 yangyunzhao#qq.com</p>
<h2 id="安装腾讯云SDK"><a href="#安装腾讯云SDK" class="headerlink" title="安装腾讯云SDK"></a>安装腾讯云SDK</h2><ul>
<li><p>安装nodejs运行环境</p>
<p>这个没什么好说的，双击下一步就好了</p>
</li>
<li><p>安装sdk</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">C:\Users\ZNMLR&gt;npm i cos-nodejs-sdk-v5 --save -g</span><br><span class="line">+ cos-nodejs-sdk-v5@2.4.0</span><br><span class="line">added 68 packages in 10.082s</span><br></pre></td></tr></table></figure>
</li>
<li><p>再次安装sdk</p>
<blockquote>
<p>不要问我为何有这一步，腾讯云文档这样写的</p>
<p>先下载<a href="https://github.com/tencentyun/cos-nodejs-sdk-v5" target="_blank" rel="noopener">腾讯云SDK</a>，解压，到指定目录执行命令</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">C:\Users\ZNMLR&gt;d:</span><br><span class="line">D:\&gt;cd cos-nodejs-sdk-v5-master</span><br><span class="line">D:\cos-nodejs-sdk-v5-master&gt;npm install -g</span><br><span class="line">+ cos-nodejs-sdk-v5@2.4.0</span><br><span class="line">updated 1 package in 6.33s</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="获取腾讯云上传鉴权码"><a href="#获取腾讯云上传鉴权码" class="headerlink" title="获取腾讯云上传鉴权码"></a>获取腾讯云上传鉴权码</h2><ul>
<li><p>请到<a href="https://cloud.tencent.com/product/cos" target="_blank" rel="noopener">腾讯云</a>注册账号并实名认证，</p>
</li>
<li><p>新建存储桶</p>
</li>
<li><p>获取APPID、SecretId、SecretKey、存储桶名称、所属地域</p>
<p>以上步骤请自行阅读腾讯云文档，这里不做说明</p>
</li>
</ul>
<h2 id="编写上传脚本"><a href="#编写上传脚本" class="headerlink" title="编写上传脚本"></a>编写上传脚本</h2><h3 id="官方示例"><a href="#官方示例" class="headerlink" title="官方示例"></a>官方示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 引入模块</span><br><span class="line">var COS = require(&apos;cos-nodejs-sdk-v5&apos;);</span><br><span class="line">// 创建实例</span><br><span class="line">var cos = new COS(&#123;</span><br><span class="line">    AppId: &apos;1250000000&apos;,   // 修改为自己的appid</span><br><span class="line">    SecretId: &apos;AKIDxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx&apos;, // 修改为自己的SecretId</span><br><span class="line">    SecretKey: &apos;xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx&apos;, // 修改为自己的SecretKey</span><br><span class="line">&#125;);</span><br><span class="line">// 分片上传</span><br><span class="line">cos.sliceUploadFile(&#123;</span><br><span class="line">    Bucket: &apos;test&apos;, // 修改为自己的存储桶名称，由英文、数字和标点符号组成</span><br><span class="line">    Region: &apos;ap-guangzhou&apos;, // 修改为自己的所属地域，应该是纯英文的部分</span><br><span class="line">    Key: &apos;1.zip&apos;, // 这个是远端的地址</span><br><span class="line">    FilePath: &apos;./1.zip&apos; // 这个是本地地址</span><br><span class="line">&#125;, function (err, data) &#123;</span><br><span class="line">    console.log(err, data);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>执行js文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">D:\&gt;node 2.js</span><br><span class="line">warning: AppId has been deprecated, Please put it at the end of parameter Bucket(E.g: &quot;test-1250000000&quot;).</span><br><span class="line">(node:11824) [DEP0005] DeprecationWarning: Buffer() is deprecated due to security and usability issues. Please use the Buffer.alloc(), Buffer.allocUnsafe(), or Buffer.from() methods instead.</span><br><span class="line">null &#123; Location: &apos;**********.cos.ap-shanghai.myqcloud.com/1.png&apos;,</span><br><span class="line">  Bucket: &apos;*****&apos;,</span><br><span class="line">  Key: &apos;1.png&apos;,</span><br><span class="line">  ETag: &apos;&quot;*******************-1&quot;&apos;,</span><br><span class="line">  statusCode: 200,</span><br><span class="line">  headers:</span><br><span class="line">   &#123; &apos;content-type&apos;: &apos;application/xml&apos;,</span><br><span class="line">     &apos;transfer-encoding&apos;: &apos;chunked&apos;,</span><br><span class="line">     connection: &apos;close&apos;,</span><br><span class="line">     date: &apos;Sun, 06 May 2018 03:38:13 GMT&apos;,</span><br><span class="line">     server: &apos;tencent-cos&apos;,</span><br><span class="line">     &apos;x-cos-request-id&apos;: &apos;************************&apos; &#125; &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>上传成功了</p>
<p>敏感信息用*号代替了</p>
<p>但是文件在根目录下</p>
</blockquote>
<p>###优化：上传到指定路径</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var filepath=&apos;D:/135.png&apos;;</span><br><span class="line">var filename = filepath.substring(filepath.lastIndexOf(&quot;/&quot;)+1); </span><br><span class="line">var today = new Date();</span><br><span class="line">var year = today.getFullYear();</span><br><span class="line">var month = today.getMonth() + 1;</span><br><span class="line">var urlkey=year+&quot;/&quot;+(month&lt;10?&apos;0&apos;+month:month)+&quot;/&quot;+filename;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 引入模块</span><br><span class="line">var COS = require(&apos;cos-nodejs-sdk-v5&apos;);</span><br><span class="line">// 创建实例</span><br><span class="line">var cos = new COS(&#123;</span><br><span class="line">    AppId: &apos;*&apos;,</span><br><span class="line">    SecretId: &apos;*&apos;,</span><br><span class="line">    SecretKey: &apos;*&apos;,</span><br><span class="line">&#125;);</span><br><span class="line">// 分片上传</span><br><span class="line">cos.sliceUploadFile(&#123;</span><br><span class="line">    Bucket: &apos;*&apos;,</span><br><span class="line">    Region: &apos;*&apos;,</span><br><span class="line">    Key: urlkey,</span><br><span class="line">    FilePath: filepath</span><br><span class="line">&#125;, function (err, data) &#123;</span><br><span class="line">    console.log(err, data);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>执行脚本</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">D:\&gt;node 2.js</span><br><span class="line">warning: AppId has been deprecated, Please put it at the end of parameter Bucket(E.g: &quot;test-1250000000&quot;).</span><br><span class="line">(node:7620) [DEP0005] DeprecationWarning: Buffer() is deprecated due to security and usability issues. Please use the Buffer.alloc(), Buffer.allocUnsafe(), or Buffer.from() methods instead.</span><br><span class="line">null &#123; Location: &apos;*.cos.*.myqcloud.com/2018/05/135.png&apos;,</span><br><span class="line">  Bucket: &apos;*&apos;,</span><br><span class="line">  Key: &apos;2018/05/135.png&apos;,</span><br><span class="line">  ETag: &apos;&quot;*-1&quot;&apos;,</span><br><span class="line">  statusCode: 200,</span><br><span class="line">  headers:</span><br><span class="line">   &#123; &apos;content-type&apos;: &apos;application/xml&apos;,</span><br><span class="line">     &apos;transfer-encoding&apos;: &apos;chunked&apos;,</span><br><span class="line">     connection: &apos;close&apos;,</span><br><span class="line">     date: &apos;Sun, 06 May 2018 04:16:42 GMT&apos;,</span><br><span class="line">     server: &apos;tencent-cos&apos;,</span><br><span class="line">     &apos;x-cos-request-id&apos;: &apos;*=&apos; &#125; &#125;</span><br></pre></td></tr></table></figure>

<p>查看返回值Location生成路径已经有年月了</p>
<h3 id="优化：上传后自动存放在剪切板"><a href="#优化：上传后自动存放在剪切板" class="headerlink" title="优化：上传后自动存放在剪切板"></a>优化：上传后自动存放在剪切板</h3><p>略</p>
<h3 id="优化：生成markdown格式"><a href="#优化：生成markdown格式" class="headerlink" title="优化：生成markdown格式"></a>优化：生成markdown格式</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var picsuffix=new Array(&quot;.jpg&quot;, &quot;.png&quot;, &quot;.bmp&quot;, &quot;.jpeg&quot;);</span><br><span class="line">function contains(arr, obj) &#123;</span><br><span class="line">  var i = arr.length;</span><br><span class="line">  while (i--) &#123;</span><br><span class="line">    if (arr[i] === obj) &#123;</span><br><span class="line">      return true;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var filepath=&apos;D:/tk.db&apos;;</span><br><span class="line">var filename = filepath.substring(filepath.lastIndexOf(&quot;/&quot;)+1); </span><br><span class="line">var today = new Date();</span><br><span class="line">var year = today.getFullYear();</span><br><span class="line">var month = today.getMonth() + 1;</span><br><span class="line">var urlkey=year+&quot;/&quot;+(month&lt;10?&apos;0&apos;+month:month)+&quot;/&quot;+filename;</span><br><span class="line">var suffix=filename.substring(filename.lastIndexOf(&quot;.&quot;), filename.length);</span><br><span class="line"></span><br><span class="line">// 引入模块</span><br><span class="line">var COS = require(&apos;cos-nodejs-sdk-v5&apos;);</span><br><span class="line">// 创建实例</span><br><span class="line">var cos = new COS(&#123;</span><br><span class="line">    AppId: &apos;*&apos;,</span><br><span class="line">    SecretId: &apos;*&apos;,</span><br><span class="line">    SecretKey: &apos;*&apos;,</span><br><span class="line">&#125;);</span><br><span class="line">// 分片上传</span><br><span class="line">cos.sliceUploadFile(&#123;</span><br><span class="line">    Bucket: &apos;*&apos;,</span><br><span class="line">    Region: &apos;*&apos;,</span><br><span class="line">    Key: urlkey,</span><br><span class="line">    FilePath: filepath</span><br><span class="line">&#125;, function (err, data) &#123;</span><br><span class="line">    console.log(err, data);</span><br><span class="line">	const util = require(&apos;util&apos;);</span><br><span class="line">	var url=&apos;&apos;;</span><br><span class="line">	if (contains(picsuffix, suffix)) &#123;</span><br><span class="line">		url=&apos;![](https://&apos;+data.Location+&apos;)&apos;;</span><br><span class="line">	&#125;</span><br><span class="line">	else &#123;</span><br><span class="line">		url=&apos;[](https://&apos;+data.Location+&apos;)&apos;;</span><br><span class="line">	&#125;</span><br><span class="line">	require(&apos;child_process&apos;).spawn(&apos;clip&apos;).stdin.end(url);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<ul>
<li>这次定义了数组picsuffix，实现了图片与文件生成不同的字符串</li>
<li>实现了自动拷贝到剪切板的功能</li>
</ul>
<h2 id="关联bat与上传脚本"><a href="#关联bat与上传脚本" class="headerlink" title="关联bat与上传脚本"></a>关联bat与上传脚本</h2><ul>
<li><p>修改之前的bat批处理文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@echo off</span><br><span class="line">node D:\2.js %1%</span><br><span class="line">exit</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改js脚本</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var picsuffix=new Array(&quot;.jpg&quot;, &quot;.png&quot;, &quot;.bmp&quot;, &quot;.jpeg&quot;);</span><br><span class="line">function contains(arr, obj) &#123;</span><br><span class="line">  var i = arr.length;</span><br><span class="line">  while (i--) &#123;</span><br><span class="line">    if (arr[i] === obj) &#123;</span><br><span class="line">      return true;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var filepath=process.argv.splice(2).toString();</span><br><span class="line">var filename = filepath.substring(filepath.lastIndexOf(&quot;\\&quot;)+1); </span><br><span class="line">var today = new Date();</span><br><span class="line">var year = today.getFullYear();</span><br><span class="line">var month = today.getMonth() + 1;</span><br><span class="line">var urlkey=year+&quot;/&quot;+(month&lt;10?&apos;0&apos;+month:month)+&quot;/&quot;+filename;</span><br><span class="line">var suffix=filename.substring(filename.lastIndexOf(&quot;.&quot;), filename.length);</span><br><span class="line"></span><br><span class="line">// 引入模块</span><br><span class="line">var COS = require(&apos;cos-nodejs-sdk-v5&apos;);</span><br><span class="line">// 创建实例</span><br><span class="line">var cos = new COS(&#123;</span><br><span class="line">    AppId: &apos;*&apos;,</span><br><span class="line">    SecretId: &apos;*&apos;,</span><br><span class="line">    SecretKey: &apos;*&apos;,</span><br><span class="line">&#125;);</span><br><span class="line">// 分片上传</span><br><span class="line">cos.sliceUploadFile(&#123;</span><br><span class="line">    Bucket: &apos;*&apos;,</span><br><span class="line">    Region: &apos;*&apos;,</span><br><span class="line">    Key: urlkey,</span><br><span class="line">    FilePath: filepath</span><br><span class="line">&#125;, function (err, data) &#123;</span><br><span class="line">	if(err)&#123;</span><br><span class="line">		console.log(err);</span><br><span class="line">	&#125;</span><br><span class="line">	else&#123;</span><br><span class="line">		console.log(data);</span><br><span class="line">		const util = require(&apos;util&apos;);</span><br><span class="line">		var url=&apos;&apos;;</span><br><span class="line">		if (contains(picsuffix, suffix)) &#123;</span><br><span class="line">			url=&apos;![](https://&apos;+data.Location+&apos;)&apos;;</span><br><span class="line">		&#125;</span><br><span class="line">		else &#123;</span><br><span class="line">			url=&apos;[](https://&apos;+data.Location+&apos;)&apos;;</span><br><span class="line">		&#125;</span><br><span class="line">		require(&apos;child_process&apos;).spawn(&apos;clip&apos;).stdin.end(url);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>大功告成</p>
</li>
</ul>
<p><strong>本文为转载自:</strong><a href="http://blog.znmlr.cn/" target="_blank" rel="noopener">http://blog.znmlr.cn/</a></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em>乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</em></p>
]]></content>
      <tags>
        <tag>使用技巧</tag>
      </tags>
  </entry>
  <entry>
    <title>Android Android 获取应用签名证书的SHA1值和MD5值几种方法</title>
    <url>/59.html</url>
    <content><![CDATA[<h2 id="第一种-只有APK文件的情况下"><a href="#第一种-只有APK文件的情况下" class="headerlink" title="第一种 只有APK文件的情况下"></a>第一种 只有APK文件的情况下</h2><ol>
<li><p>首先将你的项目打包，一定要使用签名文件打包成release版本的apk文件。</p>
</li>
<li><p>将你的apk文件后缀修改成rar文件，解压。</p>
</li>
<li><p>在解压后的文件中找到META-INF文件，该目录下会存在CERT.RSA文件。</p>
</li>
<li><p>在META-INF目录下打开cmd(按住Shift，点击鼠标右键)，输入命令 ：<code>keytool -printcert -file CERT.RSA</code>，就可以在CMD命令窗口中看到签名文件的信息了，其中包括了SHA1值和MD5值。</p>
</li>
</ol>
<h2 id="第二种-你已经有了签名文件-并且知道密码"><a href="#第二种-你已经有了签名文件-并且知道密码" class="headerlink" title="第二种 你已经有了签名文件 并且知道密码"></a>第二种 你已经有了签名文件 并且知道密码</h2><p>在jks签名文件目录下打开cmd(按住Shift，点击鼠标右键)，输入命令 ：<code>keytool -list -v -keystore xxx.jks</code>，就可以在CMD命令窗口中看到签名文件的信息了，其中包括了SHA1值和MD5值。</p>
<h2 id="第三种-通过代码获取"><a href="#第三种-通过代码获取" class="headerlink" title="第三种 通过代码获取"></a>第三种 通过代码获取</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取签名工具类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppSigning</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> String MD5 = <span class="string">"MD5"</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> String SHA1 = <span class="string">"SHA1"</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> String SHA256 = <span class="string">"SHA256"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> HashMap&lt;String, ArrayList&lt;String&gt;&gt; mSignMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回一个签名的对应类型的字符串</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> context</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> type</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 因为一个安装包可以被多个签名文件签名，所以返回一个签名信息的list</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ArrayList&lt;String&gt; <span class="title">getSignInfo</span><span class="params">(Context context, String type)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (context == <span class="keyword">null</span> || type == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        String packageName = context.getPackageName();</span><br><span class="line">        <span class="keyword">if</span> (packageName == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (mSignMap.get(type) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> mSignMap.get(type);</span><br><span class="line">        &#125;</span><br><span class="line">        ArrayList&lt;String&gt; mList = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Signature[] signs = getSignatures(context, packageName);</span><br><span class="line">            <span class="keyword">for</span> (Signature sig : signs) &#123;</span><br><span class="line">                String tmp = <span class="string">"error!"</span>;</span><br><span class="line">                <span class="keyword">if</span> (MD5.equals(type)) &#123;</span><br><span class="line">                    tmp = getSignatureByteString(sig, MD5);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (SHA1.equals(type)) &#123;</span><br><span class="line">                    tmp = getSignatureByteString(sig, SHA1);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (SHA256.equals(type)) &#123;</span><br><span class="line">                    tmp = getSignatureByteString(sig, SHA256);</span><br><span class="line">                &#125;</span><br><span class="line">                mList.add(tmp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            LogUtil.e(e.toString());</span><br><span class="line">        &#125;</span><br><span class="line">        mSignMap.put(type, mList);</span><br><span class="line">        <span class="keyword">return</span> mList;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取签名sha1值</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> context</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getSha1</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        String res = <span class="string">""</span>;</span><br><span class="line">        ArrayList&lt;String&gt; mlist = getSignInfo(context, SHA1);</span><br><span class="line">        <span class="keyword">if</span> (mlist != <span class="keyword">null</span> &amp;&amp; mlist.size() != <span class="number">0</span>) &#123;</span><br><span class="line">            res = mlist.get(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取签名MD5值</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> context</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getMD5</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        String res = <span class="string">""</span>;</span><br><span class="line">        ArrayList&lt;String&gt; mlist = getSignInfo(context, MD5);</span><br><span class="line">        <span class="keyword">if</span> (mlist != <span class="keyword">null</span> &amp;&amp; mlist.size() != <span class="number">0</span>) &#123;</span><br><span class="line">            res = mlist.get(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取签名SHA256值</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> context</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getSHA256</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        String res = <span class="string">""</span>;</span><br><span class="line">        ArrayList&lt;String&gt; mlist = getSignInfo(context, SHA256);</span><br><span class="line">        <span class="keyword">if</span> (mlist != <span class="keyword">null</span> &amp;&amp; mlist.size() != <span class="number">0</span>) &#123;</span><br><span class="line">            res = mlist.get(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回对应包的签名信息</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> context</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> packageName</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Signature[] getSignatures(Context context, String packageName) &#123;</span><br><span class="line">        PackageInfo packageInfo = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            packageInfo = context.getPackageManager().getPackageInfo(packageName, PackageManager.GET_SIGNATURES);</span><br><span class="line">            <span class="keyword">return</span> packageInfo.signatures;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            LogUtil.e(e.toString());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取相应的类型的字符串（把签名的byte[]信息转换成16进制）</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> sig</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> type</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">getSignatureString</span><span class="params">(Signature sig, String type)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] hexBytes = sig.toByteArray();</span><br><span class="line">        String fingerprint = <span class="string">"error!"</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            MessageDigest digest = MessageDigest.getInstance(type);</span><br><span class="line">            <span class="keyword">if</span> (digest != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">byte</span>[] digestBytes = digest.digest(hexBytes);</span><br><span class="line">                StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">byte</span> digestByte : digestBytes) &#123;</span><br><span class="line">                    sb.append((Integer.toHexString((digestByte &amp; <span class="number">0xFF</span>) | <span class="number">0x100</span>)).substring(<span class="number">1</span>, <span class="number">3</span>));</span><br><span class="line">                &#125;</span><br><span class="line">                fingerprint = sb.toString();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            LogUtil.e(e.toString());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> fingerprint;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取相应的类型的字符串（把签名的byte[]信息转换成 95:F4:D4:FG 这样的字符串形式）</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> sig</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> type</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">getSignatureByteString</span><span class="params">(Signature sig, String type)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] hexBytes = sig.toByteArray();</span><br><span class="line">        String fingerprint = <span class="string">"error!"</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            MessageDigest digest = MessageDigest.getInstance(type);</span><br><span class="line">            <span class="keyword">if</span> (digest != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">byte</span>[] digestBytes = digest.digest(hexBytes);</span><br><span class="line">                StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">byte</span> digestByte : digestBytes) &#123;</span><br><span class="line">                    sb.append(((Integer.toHexString((digestByte &amp; <span class="number">0xFF</span>) | <span class="number">0x100</span>)).substring(<span class="number">1</span>, <span class="number">3</span>)).toUpperCase());</span><br><span class="line">                    sb.append(<span class="string">":"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                fingerprint = sb.substring(<span class="number">0</span>, sb.length() - <span class="number">1</span>).toString();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            LogUtil.e(e.toString());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> fingerprint;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="第四种-使用Gradle-Tasks"><a href="#第四种-使用Gradle-Tasks" class="headerlink" title="第四种  使用Gradle Tasks"></a>第四种  使用Gradle Tasks</h2><p>这种方法适合有源码的情况, 操作非常的简单 </p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/20200506172813.png" alt></p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/20200506172913.png" alt></p>
<p><strong>本帖附件</strong></p>
<p><a href="https://u21519047.pipipan.com/fs/21519047-395416051" target="_blank" rel="noopener">点击下载</a></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em>乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</em></p>
]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>2019主流能用的前端混合开发框架都有哪些</title>
    <url>/57.html</url>
    <content><![CDATA[<h2 id="目前可用框架"><a href="#目前可用框架" class="headerlink" title="目前可用框架"></a>目前可用框架</h2><ul>
<li>MUI</li>
<li>ReactNative </li>
<li>Weex</li>
<li>Cordova </li>
<li>Ionic</li>
<li>Flutter</li>
</ul>
<h2 id="1-MUI"><a href="#1-MUI" class="headerlink" title="1.MUI"></a>1.MUI</h2><p> mui是最接近原生App体验的前端框架。 </p>
<p><strong>体积极小</strong>：100k的js文件，60k的css文件。</p>
<p><strong>原生编写</strong>，不依赖任何三方框架 </p>
<p><strong>极强</strong>：xcode和Android studio里所有原生控件都具备 </p>
<p><strong>高性能</strong>：精练的代码、适时的5+原生动画调用，达到原生应用的体验 </p>
<p><strong>多端发布</strong>：编写一套代码，iOS、Android、浏览器、微信App、百度直达号、流应用全覆盖 </p>
<h2 id="2-ReactNative"><a href="#2-ReactNative" class="headerlink" title="2 . ReactNative"></a>2 . ReactNative</h2><p><strong>Facebook出品</strong></p>
<p><strong>文档全</strong> </p>
<p><strong>社区成熟</strong> </p>
<p><strong>组件丰富</strong> </p>
<p>劣势</p>
<p>需要维护两套代码，即 iOS，Android 各一套。并且开发调试 iOS 只能使用 Mac 设备</p>
<p>对开发设备有要求，调试不方便</p>
<h2 id="3-Weex"><a href="#3-Weex" class="headerlink" title="3.Weex"></a>3.Weex</h2><p><strong>iOS, android, H5 共用一套代码</strong>，</p>
<p><strong>基于vue</strong></p>
<p>但是</p>
<p><strong>社区极度不成熟</strong> </p>
<p><strong>文档不全</strong> </p>
<p><strong>组件有限</strong></p>
<p><strong>资料少</strong></p>
<h2 id="4-Cordova"><a href="#4-Cordova" class="headerlink" title="4.Cordova"></a>4.Cordova</h2><p>前身是PhoneGap,后被Adobe公司收购, 目前已经捐赠给Apache开源</p>
<p>优势</p>
<p><strong>集成方便</strong></p>
<p><strong>文档全</strong></p>
<p><strong>组件丰富</strong></p>
<p>劣势</p>
<p><strong>流畅度欠缺</strong></p>
<h2 id="5-ionic"><a href="#5-ionic" class="headerlink" title="5.ionic"></a>5.ionic</h2><p>优势</p>
<p> <strong>基于Angular语法,简单易学</strong> </p>
<p><strong>开发效率高</strong>(如果熟悉Angular的话)</p>
<p>劣势</p>
<p><strong>受限于Angular</strong></p>
<p><strong>流畅度一般</strong></p>
<p><strong>可定制性差</strong></p>
<h2 id="6-Flutter"><a href="#6-Flutter" class="headerlink" title="6.Flutter"></a>6.Flutter</h2><p><strong>google出品</strong></p>
<p><strong>性能强</strong></p>
<p><strong>组件丰富</strong></p>
<p><strong>跨平台</strong></p>
<p>但是</p>
<p><strong>开发门槛稍高 需要学习Dart语言</strong></p>
<p><strong>本帖附件</strong></p>
<p><a href="https://u21519047.pipipan.com/fs/21519047-395416051" target="_blank" rel="noopener">点击下载</a></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em>乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</em></p>
]]></content>
      <tags>
        <tag>大前端</tag>
      </tags>
  </entry>
  <entry>
    <title>一篇文章让你从此不再畏惧正则表达式</title>
    <url>/55.html</url>
    <content><![CDATA[<h4 id="1-什么是正则表达式"><a href="#1-什么是正则表达式" class="headerlink" title="1.什么是正则表达式"></a>1.什么是正则表达式</h4><p>正则表达式，又称正规表示式、正规表示法、正规表达式、规则表达式、常规表示法（英语：Regular Expression，在代码中常简写为regex、regexp或RE），计算机科学的一个概念。正则表达式使用单个字符串来描述、匹配一系列匹配某个句法规则的字符串。在很多文本编辑器里，正则表达式通常被用来检索、替换那些匹配某个模式的文本。</p>
<p>通俗的讲就是按照某种规则去匹配符合条件的字符串</p>
<h4 id="2-利用图形化工具理解正则表达式"><a href="#2-利用图形化工具理解正则表达式" class="headerlink" title="2.利用图形化工具理解正则表达式"></a>2.利用图形化工具理解正则表达式</h4><p>辅助理解正则表达的在线工具:</p>
<ul>
<li><p><a href="https://regexper.com/" target="_blank" rel="noopener">https://regexper.com/</a> </p>
</li>
<li><p><a href="http://rubular.com/" target="_blank" rel="noopener">http://rubular.com/</a> </p>
</li>
<li><p><a href="https://tool.lu/regex/" target="_blank" rel="noopener">https://tool.lu/regex/</a></p>
</li>
<li><p>正则匹配软件</p>
<p>​      <a href="http://pan.baidu.com/s/19Yn49" target="_blank" rel="noopener">McTracer</a> </p>
<p>我们利用这个工具辅助理解，正则表达式。语法没懂表着急，后面会有，这里只是学会用工具帮助我们学习。</p>
</li>
</ul>
<p><strong>手机号正则</strong>: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/^1[34578][0-9]&#123;9&#125;$/</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/u=592966765,1238863996&fm=173&s=40B03D728F817149547948C60000A0B2&w=376&h=168&img.JPEG" alt></p>
<blockquote>
<p>注释：以1开头，第二位为3 4 5 7 9 其中一个，以9位（本身1次加重复8次）0-9数字结尾</p>
</blockquote>
<p><strong>单词边界</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/\bis\b/</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/u=2615878050,770295845&fm=173&w=268&h=40&img.JPEG" alt></p>
<blockquote>
<p>注释： is前后都是单词的边界，比较晦涩难懂？感受下两者的区别，\b 会方道语法部分讲解</p>
</blockquote>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/u=766802235,4226265389&fm=173&s=84AA74331B485C494855B4DA000080B3&w=321&h=166&img.JPEG" alt></p>
<p><strong>URL分组替换</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/http:(\/\/.+\.jpg)/</span><br></pre></td></tr></table></figure>

<p>看不懂的不要慌语法部分后面会有介绍，这里只是展示利用可视化的图形帮助我们理解正则表达式，可以回来再看木有关系</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/u=2994882449,1200138689&fm=173&s=401AC532DCBABE015DE115C60100A0A2&w=297&h=77&img.JPEG" alt></p>
<p>正则表达式中括号用来分组，这个时候我们可以通过用$1来获取 group#1的内容</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/u=201062960,2805738176&fm=173&s=C550ED33C534C82016E591D1000080B1&w=422&h=92&img.JPEG" alt></p>
<p>说下这个正则的意义，如果网站用了https，网站引用静态资源也必须是https，否则报错。如果写成 // 会自动识别 http 或者 https</p>
<p><strong>日期匹配与分组替换</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/^\d&#123;4&#125;[/-]\d&#123;2&#125;[/-]\d&#123;2&#125;$/</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/u=3505405751,3483604314&fm=173&s=6966B853C576FE204851DD51010080B2&w=484&h=89&img.JPEG" alt></p>
<p>这个正则比较复杂，画符念咒的地方太多了，一一分析：</p>
<p>Start of line 是由^生效的表示以此开头</p>
<p>对应结尾End of line 由$生效表示以此结尾</p>
<p>接着看digit 由 \d 生效表示数字</p>
<p>3times 由{4} 生效表示重复4次，开始的时候有疑问，为什么不是 4times 。后来明白作者的用意，正则表达式是一个规则，用这个规则去从字符串开始匹配到结束（注意计算机读字符串可是不会分行的，都是一个串，我们看到的多行，人家会认为是个 \t ）这里设计好像小火车的轨道一直开到末尾。digit 传过一次，3times表示再来三次循环，共4次，后面的once同理。 自己被自己啰嗦到了。</p>
<p>接下来，是 one of 在手机正则里面已经出现了。表示什么都行。只要符合这两个都让通过。</p>
<p>好了这个正则解释完了，接下来用它做什么呢？</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/u=217541058,1393507368&fm=173&s=8492703311484D494E5484DE0000C0B1&w=341&h=181&img.JPEG" alt></p>
<p>我们可以验证日期的合法性</p>
<p>结合URL分组替换所用到的分组特性，我们可以轻松写出日期格式化的方法</p>
<p><strong>改造下这个正则</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/^(\d&#123;4&#125;)[/-](\d&#123;2&#125;)[/-](\d&#123;2&#125;)$/</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/u=1578594236,3808167222&fm=173&s=0026F813C5F676214C7DC04A010080B2&w=543&h=105&img.JPEG" alt></p>
<p>轻松的可以拿到 group#1 #2 #3 的内容，对应 $1$2$3</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/11111" alt></p>
<p>到现在已经能结合图形化工具看懂正则表达式表达式了，如果想自己写，还要在正则语法上下点功夫</p>
<h4 id="3-正则表达式语法"><a href="#3-正则表达式语法" class="headerlink" title="3. 正则表达式语法"></a>3. 正则表达式语法</h4><p><strong>1 修饰符 （三个 g i m）</strong></p>
<p>修饰符与其他语法特殊，字面量方法声名的时候放到//后，构造函数声明的时候，作为第二个参数传入。整个正则表达式可以理解为正则表达式规则字符串+修饰符</p>
<ul>
<li><p>g：global 执行一个全局匹配</p>
</li>
<li><p>i：ignore case执行一个不区分大小写的匹配</p>
</li>
<li><p>m: multiple lines多行匹配</p>
</li>
</ul>
<p>修饰符可以一起用 const reg =/\bis\b/gim</p>
<p>来说说他们有什么作用</p>
<p><strong>有g和没有g的区别</strong></p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/u=344032591,1933667552&fm=173&s=8570E033CF704C011C6590D00000C0B3&w=539&h=200&img.JPEG" alt></p>
<p>没有g只替换了第一个，有g 所有的都换了</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/u=2615754428,2250290345&fm=173&s=617E38D34D66E7225B710F7103009077&w=269&h=55&img.JPEG" alt></p>
<p><strong>有i和没有i的区别</strong></p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/u=3310944985,1165756769&fm=173&s=87F0E03315485D4B0C6D98DA000080B3&w=365&h=199&img.JPEG" alt></p>
<p>有i忽略大小写，没有i严格区分大小写</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/u=1941717778,1808875963&fm=173&s=707E38D3C714CE234A718B7103004077&w=273&h=59&img.JPEG" alt></p>
<h3 id="2-元字符"><a href="#2-元字符" class="headerlink" title="2 元字符"></a>2 元字符</h3><p>正则表达式由两种基本字符组成：</p>
<ul>
<li><p>原义字符</p>
</li>
<li><p>非打印字符</p>
</li>
<li><p>元字符 (* + ? $ ^ . | \ ( ) { } [ ])</p>
</li>
</ul>
<p><strong>原义字符</strong></p>
<p>这个没什么好解释的，我们一直在举例的 /is/ 匹配字符串’is’</p>
<p>\将下一个字符标记为一个特殊字符、或一个原义字符、或一个向后引用、或一个八进制转义符。例如，n”匹配字符“n”。“\n”匹配一个换行符。序列“\”匹配“\”而“(”则匹配“(”。</p>
<p><strong>非打印字符</strong></p>
<p>字符</p>
<p>描述</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">\cx</span><br></pre></td></tr></table></figure>

<p>匹配由x指明的控制字符。例如， \cM 匹配一个 Control-M 或回车符。x 的值必须为 A-Z 或 a-z 之一。否则，将 c 视为一个原义的 ‘c’ 字符。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">\f</span><br></pre></td></tr></table></figure>

<p>匹配一个换页符。等价于 \x0c 和 \cL。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">\n</span><br></pre></td></tr></table></figure>

<p>匹配一个换行符。等价于 \x0a 和 \cJ。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">\r</span><br></pre></td></tr></table></figure>

<p>匹配一个回车符。等价于 \x0d 和 \cM。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">\s</span><br></pre></td></tr></table></figure>

<p>匹配任何空白字符，包括空格、制表符、换页符等等。等价于 [ \f\n\r\t\v]。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">\S</span><br></pre></td></tr></table></figure>

<p>匹配任何非空白字符。等价于 [^ \f\n\r\t\v]。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">\t</span><br></pre></td></tr></table></figure>

<p>匹配一个制表符。等价于 \x09 和 \cI。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">\v</span><br></pre></td></tr></table></figure>

<p>匹配一个垂直制表符。等价于 \x0b 和 \cK。</p>
<p>非打印字符，以\n为例</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/u=1340764868,3292114517&fm=173&s=8510EC334B424D4D0CD0A1DA0000C0B0&w=382&h=208&img.JPEG" alt></p>
<p>其他的在前端引用比较少，应该在后端处理文本文件的时候会用到</p>
<p><strong>字符类 []</strong></p>
<p>在前面的手机号正则例子中，我们已经使用过[] /^1[34578][0-9]{9}$/ : [34578]表示34578任意一个数字即可。在日期匹配与分组替换例子中 <code>/^\d{4}[/-]\d{2}[/-]\d{2}$/</code> 表示符合 <code>／-</code> 都可以</p>
<p><strong>字符类取反 [^]</strong></p>
<p>表示不属于此类</p>
<p>空格也不属于，好多狗</p>
<p><strong>范围类[-]</strong></p>
<p>正则表达式支持一定范围规则比如 [a-z][A-Z][0-9] 可以连写[a-z0-9] 如果你只是想匹配-在 范围类最后加-即可。请看实例。</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/u=1856837476,3098413748&fm=173&s=8552E13305584DC84C50A4DE0000C0B1&w=332&h=197&img.JPEG" alt></p>
<h3 id="预定义类"><a href="#预定义类" class="headerlink" title="预定义类"></a>预定义类</h3><p>常用为了方便书写</p>
<p>字符</p>
<p>等价类</p>
<p>含义</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line"></span><br><span class="line">[^\n\r]</span><br></pre></td></tr></table></figure>

<p>除了回车符和换行符之外的所有字符</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">\d</span><br><span class="line"></span><br><span class="line">[0-9]</span><br></pre></td></tr></table></figure>

<p>数字字符</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">\D</span><br><span class="line"></span><br><span class="line">[^0-9]</span><br></pre></td></tr></table></figure>

<p>非数字字符</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">\s</span><br><span class="line"></span><br><span class="line">[\t\n\x0B\f\r]</span><br></pre></td></tr></table></figure>

<p>空白符</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">\S</span><br><span class="line"></span><br><span class="line">[^\t\n\x0B\f\r]</span><br></pre></td></tr></table></figure>

<p>非空白符</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">\w</span><br><span class="line"></span><br><span class="line">[a-zA-Z_0-9]</span><br></pre></td></tr></table></figure>

<p>单词字符（字母、数字、下划线）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">\W</span><br><span class="line"></span><br><span class="line">[^a-zA-Z_0-9]</span><br></pre></td></tr></table></figure>

<p>非单词字符</p>
<p>有了这些预定义类，写一些正则就很方便了，比如我们希望匹配一个 ab+数字+任意字符 的字符串，就可以这样写了 /ab\d./</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/u=2564052864,1792019635&fm=173&w=208&h=34&img.JPEG" alt></p>
<p><strong>边界</strong></p>
<p>字符</p>
<p>含义</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">^</span><br></pre></td></tr></table></figure>

<p>以xx开头</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$</span><br></pre></td></tr></table></figure>

<p>以xx结尾</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">\b</span><br></pre></td></tr></table></figure>

<p>单词边界，指[a-zA-Z_0-9]之外的字符</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">\B</span><br></pre></td></tr></table></figure>

<p>非单词边界</p>
<p> <strong>量词</strong></p>
<p>字符</p>
<p>含义</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">?</span><br></pre></td></tr></table></figure>

<p>出现零次或一次</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">*</span><br></pre></td></tr></table></figure>

<p>出现零次或多次(任意次)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+</span><br></pre></td></tr></table></figure>

<p>出现一次或多次（至少一次）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;n&#125;</span><br></pre></td></tr></table></figure>

<p>对应零次或者n次</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;n,m&#125;</span><br></pre></td></tr></table></figure>

<p>至少出现n次但不超过m次</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;n,&#125;</span><br></pre></td></tr></table></figure>

<p>至少出现n次(+的升级版)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;0,n&#125;</span><br></pre></td></tr></table></figure>

<p>至多出现n次(其实就是{n,m} 方便记忆而已)</p>
<p>如果没有量词，要匹配4位数字这样写就可以/\d\d\d\d/, 如果匹配50位100位呢？那不是要疯掉了？</p>
<p>有了量词，就可以这样写/\d{100}/, 量词的使用我们在手机号中使用过，表现在可视化中就是循环多少次。</p>
<p>凑一个上面都包含的实例/\d?@\d*@\d+@\d{10}@\d{10,20}@\d{10,}@\d{0,10}/</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/u=3700410048,913876598&fm=173&w=640&h=73&img.JPEG" alt></p>
<p><strong>贪婪与懒惰（非贪婪）</strong></p>
<p>正则表达式默认会匹配贪婪模式，什么是贪婪模式呢？如其名尽可能多的匹配。我们看个例子。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/\d&#123;3,6&#125;/</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/u=683364840,3489026062&fm=173&s=04BAE8328CF06C827664144F0300A0E0&w=121&h=67&img.JPEG" alt></p>
<p>贪婪模式下，匹配的了最多的情况。</p>
<p>与贪婪对应就是懒惰模式，懒惰对应的就是匹配的尽可能少的情况。如何开启懒惰模式？ 在量词后面加?。继续上面的例子</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/\d&#123;3,6&#125;?/</span><br></pre></td></tr></table></figure>

<p>如果想知道，正则表达式是如何匹配量词的，请看 进阶正则表达式 文中有介绍，正则是如何回溯的。</p>
<p><strong>分组与反向引用</strong></p>
<p>分组，又称为子表达式。把正则表达式拆分成小表达式。概念枯燥，说个例子为嘛用分组：</p>
<p>不分组 /abc{2}/</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/u=789192488,2437398908&fm=173&s=A643B25ACC20F40140FD50C90100E0B2&w=137&h=60&img.JPEG" alt></p>
<p>量词仅作用到最后的c</p>
<p>分组 /(abc){2}/</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/u=2955596776,864467602&fm=173&s=0636EC238CB0798A0CF5D1CE0100C0B1&w=135&h=86&img.JPEG" alt></p>
<p>注意这里 group #1</p>
<p>分组虽然和运算符() 很像，但是分组在正则表达式中，注意理解组的含义。经常有人滥用分组</p>
<p><code>/^(http|https)/</code> 真的需要这样么？其实 <code>/^https?/</code>就可以了，你正则写的特别长的时候，会出现一堆没用的结果，看着都头疼吧。</p>
<p>分组往往和反向引用一起使用，别被概念吓到：当一个正则表达式被分组后，每个分组自动被赋予一个组号，一左到右分别是 $1$2…</p>
<p>再把之前的例子拿出来</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/^(\d&#123;4&#125;)[/-](\d&#123;2&#125;)[/-](\d&#123;2&#125;)$/</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/u=2869364792,376582695&fm=173&s=2920E813CE59E4014E79E844010090B3&w=547&h=122&img.JPEG" alt></p>
<p>轻松的可以拿到 group#1 #2 #3 的内容，对应 $1$2$3</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/2222" alt></p>
<p>如果在反向引用中不想捕获年该如何操作? 加上 ?:即可</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/^(?:\d&#123;4&#125;)[/-](\d&#123;2&#125;)[/-](\d&#123;2&#125;)$/</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/u=645903390,1928085484&fm=173&s=00A4F813CDF4F4010C59E8420100A0B3&w=530&h=110&img.JPEG" alt></p>
<h4 id="12-前瞻"><a href="#12-前瞻" class="headerlink" title="12.前瞻"></a>12.前瞻</h4><p>这部分为进阶部分—选看</p>
<p>正则表达式中有前瞻（Lookahead）和后顾（Lookbehind）的概念，这两个术语非常形象的描述了正则引擎的匹配行为。需要注意一点，正则表达式中的前和后和我们一般理解的前后有点不同。一段文本，我们一般习惯把文本开头的方向称作“前面”，文本末尾方向称为“后面”。但是对于正则表达式引擎来说，因为它是从文本头部向尾部开始解析的（可以通过正则选项控制解析方向），因此对于文本尾部方向，称为“前”，因为这个时候，正则引擎还没走到那块，而对文本头部方向，则称为“后”，因为正则引擎已经走过了那一块地方。</p>
<p>注意：后顾性能损耗比较大，js只支持前瞻（知乎上看到的，具体原因不详）</p>
<p>上面的比较概念话，尝试用大白话讲讲，就说皇上选妃吧，先行条件得是美女吧，长得“如花”那样皇上可不要，漂亮这关过了，皇上想要这个美女也不行，皇室有规矩，必须是贵族血统。</p>
<p>那么“漂亮”就是正常的匹配，匹配到了，还得看看家室是不是贵族。”贵族”相当于前瞻条件</p>
<p>前瞻分两种一种是正向前瞻(?=xxx), 另一种是负向前瞻(?!xxx)</p>
<h2 id="需要区分的地方"><a href="#需要区分的地方" class="headerlink" title="需要区分的地方"></a>需要区分的地方</h2><h4 id="1-正则表达式中-的用法"><a href="#1-正则表达式中-的用法" class="headerlink" title="1.正则表达式中^的用法"></a>1.正则表达式中^的用法</h4><p><strong>用法一:   限定开头</strong></p>
<p>​    文档上给出了解释是匹配输入的开始，如果多行标示被设置成了true，同时会匹配后面紧跟的字符。    比如 /^A/会匹配”An e”中的A，但是不会匹配”ab A”中的A</p>
<p><strong>用法二：（否）取反</strong></p>
<p>​    当这个字符出现在一个字符集合模式的第一个字符时，他将会有不同的含义。</p>
<p>​    <strong>比如：</strong><code>/[^a-z\s]/会匹配&quot;my 3 sisters&quot;中的&quot;3&quot;</code>这里的”^”的意思是字符类的否定，上面的正则表达式的意思是匹配不是（a到z和空白字符）的字符。 </p>
<p><strong>总结：</strong></p>
<p>什么时候”^”是否定字符，什么时候是匹配开始行</p>
<p>表示限定开头的示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">`/``[(^\s``+``)(\s``+``$)]``/``g``(^cat)$``(^cat$)``^(cat)$``^(cat$)`</span><br></pre></td></tr></table></figure>

<p>表示否定的示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">`[^a]表示“匹配除了a的任意字符”。``[^a``-``zA``-``Z0``-``9``]表示“找到一个非字母也非数字的字符”。``[\^abc]表示“找到一个插入符或者a或者b或者c”。`</span><br></pre></td></tr></table></figure>

<p>经过对比，只要是”^”这个字符是在中括号”[]”中被使用的话就是表示字符类的否定，如果不是的话就是表示限定开头。我这里说的是直接在”[]”中使用，不包括嵌套使用。<br>其实也就是说”[]”代表的是一个字符集，”^”只有在字符集中才是反向字符集的意思。</p>
<h2 id="特殊案例"><a href="#特殊案例" class="headerlink" title="特殊案例"></a>特殊案例</h2><h4 id="1-正则匹配中括号"><a href="#1-正则匹配中括号" class="headerlink" title="1.正则匹配中括号"></a>1.正则匹配中括号</h4><p>在正则表达式中，前中括号 [ 属于特殊字符，要匹配它，需要转义，即加上 \；而后中括号 ] 不属于特殊字符，不必加转义字符</p>
<p>举例说明:</p>
<p>需要匹配以下字符串中括号里面的内容</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[&quot;www.baidu.com&quot;,&quot;www.wenta.com&quot;,&quot;www.insoan.com&quot;]</span><br></pre></td></tr></table></figure>

<p>有两种规则可以使用,任选一:</p>
<ul>
<li>第一种: <code>&quot;|]|\[</code>  过滤不需要的</li>
<li>第二种: <code>\[(.+)]</code>   取出需要的</li>
</ul>
<h3 id="整理出常用的正则供学习参考"><a href="#整理出常用的正则供学习参考" class="headerlink" title="整理出常用的正则供学习参考"></a>整理出常用的正则供学习参考</h3><ul>
<li>手机号码匹配</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/^1[34578][0-9]&#123;9&#125;$/</span><br></pre></td></tr></table></figure>

<ul>
<li>网址校验</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/^https?/</span><br></pre></td></tr></table></figure>

<ul>
<li>日期抽取</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/^(\d&#123;4&#125;)[/-](\d&#123;2&#125;)[/-](\d&#123;2&#125;)$/</span><br></pre></td></tr></table></figure>

<ul>
<li>IP校验</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">\d&#123;1,3&#125;\.\d&#123;1,3&#125;\.\d&#123;1,3&#125;\.\d&#123;1,3&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>IP单段提取</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(\d&#123;1,3&#125;)\.(\d&#123;1,3&#125;)\.(\d&#123;1,3&#125;)\.(\d&#123;1,3&#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li>提取一段内容中的所有IP地址</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">((2(5[0-5]|[0-4]\d))|[0-1]?\d&#123;1,2&#125;)(\.((2(5[0-5]|[0-4]\d))|[0-1]?\d&#123;1,2&#125;))&#123;3&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>判断字符串是否是IP地址</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">^((2(5[0-5]|[0-4]\d))|[0-1]?\d&#123;1,2&#125;)(\.((2(5[0-5]|[0-4]\d))|[0-1]?\d&#123;1,2&#125;))&#123;3&#125;$</span><br></pre></td></tr></table></figure>

<ul>
<li>邮箱校验</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">\w[-\w.+]*@([A-Za-z0-9][-A-Za-z0-9]+\.)+([A-Za-z]&#123;2,14&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="附上常用正则英文版"><a href="#附上常用正则英文版" class="headerlink" title="附上常用正则英文版"></a>附上常用正则英文版</h3><p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/1573183725749.png" alt></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em>乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</em></p>
]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>Android面试题之Activity的四种启动模式 一次性记忆</title>
    <url>/62.html</url>
    <content><![CDATA[<blockquote>
<p>每当我们换工作面试之前,总是会不由自主的刷起面试题,大部分题我们反反复复不知道刷了多少遍,但是今天记住了,等下一次面试的时候又刷着相同的面试题,我就想问在座的各位,Activity的生命周期,你们到底刷过多少遍 [哭笑]  作为一名程序员  把时间浪费在重复性劳动上是极其不能忍受的  因此 为了让自己省去不必要的脑力开销 我给自己总结了一份面试相关的记忆技巧,在这里分享给大家   记忆不是目的  把知识变成自己的才最关键</p>
</blockquote>
<h2 id="哪四种启动模式"><a href="#哪四种启动模式" class="headerlink" title="哪四种启动模式"></a>哪四种启动模式</h2><ul>
<li><strong>standard</strong>:默认启动模式,每开启一个activity就在任务栈中创建一个新的实例</li>
<li><strong>singleTop</strong>:任务栈顶部有就复用,没有就重新创建,</li>
<li><strong>singleTask</strong>:任务栈中有就将实例上方所有的实例全部销毁使其显示在最顶端,没有就重新创建一个新的实例 在搜索界面比较常用 按下主页其余网页全部被关闭</li>
<li><strong>singleInstance</strong>:重新为新创建activity(实例)开启一个单独的任务栈,且该任务栈中有且仅有一个实例 该模式特点如下图:</li>
</ul>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/clipboard.png" alt></p>
<h2 id="如果快速记忆"><a href="#如果快速记忆" class="headerlink" title="如果快速记忆"></a>如果快速记忆</h2><p>其实只要将它们的英文名称单词反过来就好理解了</p>
<ul>
<li><strong>singleTop</strong>—&gt;Top single 顶部只有一个 不允许存在两个相同的Activity</li>
<li><strong>singleTask</strong>—&gt;Task single 任务栈中只有它这一个Activity  那么一旦调用它 任务栈除它以外的所有Activity都会被销毁</li>
<li><strong>singleInstance</strong>—&gt;Instance single 实例被孤立了 进了小黑屋被单独的一个任务栈给关着</li>
<li><strong>standard</strong>—&gt;正常模式 这个应该好记忆</li>
</ul>
<p><strong>本帖附件</strong></p>
<p><a href="https://u21519047.pipipan.com/fs/21519047-395416051" target="_blank" rel="noopener">点击下载</a></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em>乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</em></p>
]]></content>
      <tags>
        <tag>面试题</tag>
      </tags>
  </entry>
  <entry>
    <title>Android Studio 常见错误异常以及解决</title>
    <url>/61.html</url>
    <content><![CDATA[<h4 id="案例1"><a href="#案例1" class="headerlink" title="案例1:"></a>案例1:</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Invoke-customs are only supported starting with Android O (--min-api 26)</span><br></pre></td></tr></table></figure>

<h5 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案:"></a>解决方案:</h5><p>将以下代码添加到app的build.gradle的android节点下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">compileOptions &#123;</span><br><span class="line">       sourceCompatibility JavaVersion.VERSION_1_8</span><br><span class="line">       targetCompatibility JavaVersion.VERSION_1_8</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h4 id="案例2"><a href="#案例2" class="headerlink" title="案例2"></a>案例2</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Could not create service of type FileAccessTimeJournal using GradleUserHomeScopeServices.createFileAccessTimeJournal()</span><br><span class="line">Owner PID: 4567</span><br></pre></td></tr></table></figure>

<h5 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a>解决方案</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#杀进程</span><br><span class="line">sudo kill -9 1902</span><br></pre></td></tr></table></figure>

<h4 id="案例3"><a href="#案例3" class="headerlink" title="案例3"></a>案例3</h4><p>在<code>Fragment</code>中显示<code>popwindow</code>报错:<code>token null is not valid; is your activity running?</code></p>
<h5 id="解决方案-2"><a href="#解决方案-2" class="headerlink" title="解决方案"></a>解决方案</h5><p>布局绘制完后显示, 如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">override fun onViewCreated(view: View, savedInstanceState: Bundle?) &#123;</span><br><span class="line">     super.onViewCreated(view, savedInstanceState)</span><br><span class="line">	//待布局绘制完成后显示</span><br><span class="line">     view.viewTreeObserver.addOnGlobalLayoutListener &#123;</span><br><span class="line">         mTipPopView.showAsDropDown(binding.topBg)</span><br><span class="line"></span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h4 id="案例4"><a href="#案例4" class="headerlink" title="案例4"></a>案例4</h4><p>Vector矢量图兼容性问题 低版本机型直接崩溃</p>
<h5 id="解决方案-3"><a href="#解决方案-3" class="headerlink" title="解决方案"></a>解决方案</h5><p>代码中使用:<code>AppCompatResources.getDrawable</code></p>
<p>不要使用:<code>ContextCompat.getDrawable</code></p>
<p>示例:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">toolbar.setBackgroundDrawable(AppCompatResources.getDrawable(this, R.drawable.bg_toolbar_v))</span><br></pre></td></tr></table></figure>

<p><strong>本文为作者原创 转载时请注明出处 谢谢</strong></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt="img"></p>
<p><em><a href="https://code.newban.cn/">乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</a></em></p>
]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux关于日期时间显示输出</title>
    <url>/6.html</url>
    <content><![CDATA[<p>1、输出当前年月日</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> $(date +%F)</span><br><span class="line">2014-02-21</span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">echo $(date +\%Y-\%m-\%d)</span><br><span class="line">2014-02-21</span><br></pre></td></tr></table></figure>

<p>2、输出当前时间(时分)</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> $(date +%R)</span><br><span class="line">12:45</span><br></pre></td></tr></table></figure>

<p>3、输出当前时间(时分秒)</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> $(date +%T)</span><br><span class="line">12:52:51</span><br></pre></td></tr></table></figure>

<p>4、输出星期</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> $(date +%A)</span><br><span class="line">星期五</span><br></pre></td></tr></table></figure>

<h3 id="5、组合输出日期时间"><a href="#5、组合输出日期时间" class="headerlink" title="5、组合输出日期时间"></a>5、组合输出日期时间</h3><p>5.1输出年月日</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> $(date +%Y/%m/%d)</span><br><span class="line">2014/02/21</span><br><span class="line">%Y参数: 年</span><br><span class="line">%m参数: 月</span><br><span class="line">%d参数: 日</span><br></pre></td></tr></table></figure>

<p>5.2输出时分秒</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> $(date +%H:%M:%S)</span><br><span class="line">12:50:44</span><br><span class="line">%H参数: 时</span><br><span class="line">%M参数: 分</span><br><span class="line">%S参数: 秒</span><br></pre></td></tr></table></figure>

<p>5.3输出年月日时分秒</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> $(date +%F%n%T)</span><br><span class="line">2014-02-21 12:56:46</span><br><span class="line">%n参数: 空格</span><br><span class="line">%F参数: 年月日</span><br><span class="line">%T参数: 时分秒</span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> $(date +\%Y-\%m-\%d-%H:%M:%S)</span><br></pre></td></tr></table></figure>

<p><strong>本文为作者原创 转载时请注明出处 谢谢</strong></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em>乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</em></p>
]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Android面试题之Service  一次性记忆</title>
    <url>/65.html</url>
    <content><![CDATA[<p>服务不能自己运行，需要通过调用Context.startService()或Context.bindService()方法启动服务。</p>
<p>这两个方法都 可以启动Service，但是它们的使用场合有所不同。</p>
<ul>
<li><p>使用startService()方法启用服务，调用者与服务之间没有关连，即使调用者退出了，服 务仍然运行。</p>
</li>
<li><p>使用bindService()方法启用服务，调用者与服务绑定在了一起，调用者一旦退出，服务也就终止，大有“不求同时生，必须同时死”的 特点。</p>
</li>
</ul>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/20210811095408.png" alt></p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/20210811095422.png" alt></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em>乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</em></p>
]]></content>
      <tags>
        <tag>Android面试题</tag>
      </tags>
  </entry>
  <entry>
    <title>Android APT快速教程</title>
    <url>/60.html</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>APT(Annotation Processing Tool)即<strong>注解处理器</strong>，是一种用来处理注解的工具。JVM会在<strong>编译期</strong>就运行APT去扫描处理代码中的注解然后输出java文件。</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/2172fb599f0546de7e005d1f1d8eb58e.JPEG" alt="image"></p>
<p>简单来说~~就是你只需要添加注解，APT就可以帮你生成需要的代码</p>
<p>许多的Android开源库都使用了APT技术，如ButterKnife、ARouter、EventBus等</p>
<h2 id="动手实现一个简单的APT"><a href="#动手实现一个简单的APT" class="headerlink" title="动手实现一个简单的APT"></a>动手实现一个简单的APT</h2><p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/91372f3181b93ad855b4780ef90124f1.JPEG" alt="image"></p>
<h3 id="小目标"><a href="#小目标" class="headerlink" title="小目标"></a>小目标</h3><p>在使用Java开发Android时，页面初始化的时候我们通常要写大量的view = findViewById(R.id.xx)代码</p>
<p>作为一个优(lan)秀(duo)的程序员，我们现在就要实现一个APT来完成这个繁琐的工作，通过一个注解就可以自动给View获得实例</p>
<p><a href="https://github.com/LiMubai2017/aptDemo" target="_blank" rel="noopener">本demo地址</a></p>
<h3 id="第零步-创建一个项目"><a href="#第零步-创建一个项目" class="headerlink" title="第零步 创建一个项目"></a>第零步 创建一个项目</h3><p>创建一个项目，名称叫 <code>apt_demo</code><br>创建一个Activity，名称叫 <code>MainActivity</code><br>在布局中添加一个TextView, id为<code>test_textview</code></p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/18fd744a3b3e298c8273e4ce9f47b366.JPEG" alt="image"></p>
<h3 id="第一步-自定义注解"><a href="#第一步-自定义注解" class="headerlink" title="第一步 自定义注解"></a>第一步 自定义注解</h3><p>创建一个Java Library Module名称叫 <code>apt-annotation</code></p>
<p>在这个module中创建自定义注解 <code>@BindView</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Retention(RetentionPolicy.CLASS)</span><br><span class="line">@Target(ElementType.FIELD)</span><br><span class="line">public @interface BindView &#123;</span><br><span class="line">    int value();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>@Retention(RetentionPolicy.CLASS)</code>：表示这个注解保留到编译期</li>
<li><code>@Target(ElementType.FIELD)</code>：表示注解范围为类成员（构造方法、方法、成员变量）</li>
</ul>
<h3 id="第二步-实现APT-Compiler"><a href="#第二步-实现APT-Compiler" class="headerlink" title="第二步 实现APT Compiler"></a>第二步 实现APT Compiler</h3><p>创建一个Java Library Module名称叫 <code>apt-compiler</code></p>
<p>在这个Module中添加依赖</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    implementation project(&apos;:apt-annotation&apos;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/0d74c8ced3f3840693e2afcf3c6b7b7b.JPEG" alt="image"></p>
<p>在这个Module中创建<code>BindViewProcessor</code>类</p>
<p>直接给出代码~~</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class BindViewProcessor extends AbstractProcessor &#123;</span><br><span class="line">    private Filer mFilerUtils;       // 文件管理工具类</span><br><span class="line">    private Types mTypesUtils;    // 类型处理工具类</span><br><span class="line">    private Elements mElementsUtils;  // Element处理工具类</span><br><span class="line"></span><br><span class="line">    private Map&lt;TypeElement, Set&lt;ViewInfo&gt;&gt; mToBindMap = new HashMap&lt;&gt;(); //用于记录需要绑定的View的名称和对应的id</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public synchronized void init(ProcessingEnvironment processingEnv) &#123;</span><br><span class="line">        super.init(processingEnv);</span><br><span class="line"></span><br><span class="line">        mFilerUtils = processingEnv.getFiler();</span><br><span class="line">        mTypesUtils = processingEnv.getTypeUtils();</span><br><span class="line">        mElementsUtils = processingEnv.getElementUtils();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Set&lt;String&gt; getSupportedAnnotationTypes() &#123;</span><br><span class="line">        HashSet&lt;String&gt; supportTypes = new LinkedHashSet&lt;&gt;();</span><br><span class="line">        supportTypes.add(BindView.class.getCanonicalName());</span><br><span class="line">        return supportTypes; //将要支持的注解放入其中</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public SourceVersion getSupportedSourceVersion() &#123;</span><br><span class="line">        return SourceVersion.latestSupported();// 表示支持最新的Java版本</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean process(Set&lt;? extends TypeElement&gt; set, RoundEnvironment roundEnv) &#123;</span><br><span class="line">        System.out.println(&quot;start process&quot;);</span><br><span class="line">        if (set != null &amp;&amp; set.size() != 0) &#123;</span><br><span class="line">            Set&lt;? extends Element&gt; elements = roundEnv.getElementsAnnotatedWith(BindView.class);//获得被BindView注解标记的element</span><br><span class="line"></span><br><span class="line">            categories(elements);//对不同的Activity进行分类</span><br><span class="line"></span><br><span class="line">            //对不同的Activity生成不同的帮助类</span><br><span class="line">            for (TypeElement typeElement : mToBindMap.keySet()) &#123;</span><br><span class="line">                String code = generateCode(typeElement);    //获取要生成的帮助类中的所有代码</span><br><span class="line">                String helperClassName = typeElement.getQualifiedName() + &quot;$$Autobind&quot;; //构建要生成的帮助类的类名</span><br><span class="line"></span><br><span class="line">                //输出帮助类的java文件，在这个例子中就是MainActivity$$Autobind.java文件</span><br><span class="line">                //输出的文件在build-&gt;source-&gt;apt-&gt;目录下</span><br><span class="line">                try &#123;</span><br><span class="line">                    JavaFileObject jfo = mFilerUtils.createSourceFile(helperClassName, typeElement);</span><br><span class="line">                    Writer writer = jfo.openWriter();</span><br><span class="line">                    writer.write(code);</span><br><span class="line">                    writer.flush();</span><br><span class="line">                    writer.close();</span><br><span class="line">                &#125; catch (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //将需要绑定的View按不同Activity进行分类</span><br><span class="line">    private void categories(Set&lt;? extends Element&gt; elements) &#123;</span><br><span class="line">        for (Element element : elements) &#123;  //遍历每一个element</span><br><span class="line">            VariableElement variableElement = (VariableElement) element;    //被@BindView标注的应当是变量，这里简单的强制类型转换</span><br><span class="line">            TypeElement enclosingElement = (TypeElement) variableElement.getEnclosingElement(); //获取代表Activity的TypeElement</span><br><span class="line">            Set&lt;ViewInfo&gt; views = mToBindMap.get(enclosingElement); //views储存着一个Activity中将要绑定的view的信息</span><br><span class="line">            if (views == null) &#123;    //如果views不存在就new一个</span><br><span class="line">                views = new HashSet&lt;&gt;();</span><br><span class="line">                mToBindMap.put(enclosingElement, views);</span><br><span class="line">            &#125;</span><br><span class="line">            BindView bindAnnotation = variableElement.getAnnotation(BindView.class);    //获取到一个变量的注解</span><br><span class="line">            int id = bindAnnotation.value();    //取出注解中的value值，这个值就是这个view要绑定的xml中的id</span><br><span class="line">            views.add(new ViewInfo(variableElement.getSimpleName().toString(), id));    //把要绑定的View的信息存进views中</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //按不同的Activity生成不同的帮助类</span><br><span class="line">    private String generateCode(TypeElement typeElement) &#123;</span><br><span class="line">        String rawClassName = typeElement.getSimpleName().toString(); //获取要绑定的View所在类的名称</span><br><span class="line">        String packageName = ((PackageElement) mElementsUtils.getPackageOf(typeElement)).getQualifiedName().toString(); //获取要绑定的View所在类的包名</span><br><span class="line">        String helperClassName = rawClassName + &quot;$$Autobind&quot;;   //要生成的帮助类的名称</span><br><span class="line"></span><br><span class="line">        StringBuilder builder = new StringBuilder();</span><br><span class="line">        builder.append(&quot;package &quot;).append(packageName).append(&quot;;\n&quot;);   //构建定义包的代码</span><br><span class="line">        builder.append(&quot;import com.example.apt_api.template.IBindHelper;\n\n&quot;); //构建import类的代码</span><br><span class="line"></span><br><span class="line">        builder.append(&quot;public class &quot;).append(helperClassName).append(&quot; implements &quot;).append(&quot;IBindHelper&quot;);   //构建定义帮助类的代码</span><br><span class="line">        builder.append(&quot; &#123;\n&quot;); //代码格式，可以忽略</span><br><span class="line">        builder.append(&quot;\t@Override\n&quot;);    //声明这个方法为重写IBindHelper中的方法</span><br><span class="line">        builder.append(&quot;\tpublic void inject(&quot; + &quot;Object&quot; + &quot; target ) &#123;\n&quot;);   //构建方法的代码</span><br><span class="line">        for (ViewInfo viewInfo : mToBindMap.get(typeElement)) &#123; //遍历每一个需要绑定的view</span><br><span class="line">            builder.append(&quot;\t\t&quot;); //代码格式，可以忽略</span><br><span class="line">            builder.append(rawClassName + &quot; substitute = &quot; + &quot;(&quot; + rawClassName + &quot;)&quot; + &quot;target;\n&quot;);    //强制类型转换</span><br><span class="line"></span><br><span class="line">            builder.append(&quot;\t\t&quot;); //代码格式，可以忽略</span><br><span class="line">            builder.append(&quot;substitute.&quot; + viewInfo.viewName).append(&quot; = &quot;);    //构建赋值表达式</span><br><span class="line">            builder.append(&quot;substitute.findViewById(&quot; + viewInfo.id + &quot;);\n&quot;);  //构建赋值表达式</span><br><span class="line">        &#125;</span><br><span class="line">        builder.append(&quot;\t&#125;\n&quot;);    //代码格式，可以忽略</span><br><span class="line">        builder.append(&apos;\n&apos;);   //代码格式，可以忽略</span><br><span class="line">        builder.append(&quot;&#125;\n&quot;);  //代码格式，可以忽略</span><br><span class="line"></span><br><span class="line">        return builder.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //要绑定的View的信息载体</span><br><span class="line">    class ViewInfo &#123;</span><br><span class="line">        String viewName;    //view的变量名</span><br><span class="line">        int id; //xml中的id</span><br><span class="line"></span><br><span class="line">        public ViewInfo(String viewName, int id) &#123;</span><br><span class="line">            this.viewName = viewName;</span><br><span class="line">            this.id = id;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/b348172e0a71245f0670ea8442693a9f.JPEG" alt="image"></p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/cb36e19ebae79e38d33c0660e024d7e7.JPEG" alt="image"></p>
<h4 id="2-1-继承AbstractProcessor抽象类"><a href="#2-1-继承AbstractProcessor抽象类" class="headerlink" title="2-1 继承AbstractProcessor抽象类"></a>2-1 继承AbstractProcessor抽象类</h4><p>我们自己实现的APT类需要继承<code>AbstractProcessor</code>这个类，其中需要重写以下方法：</p>
<ul>
<li><code>init(ProcessingEnvironment processingEnv)</code></li>
<li><code>getSupportedAnnotationTypes()</code></li>
<li><code>getSupportedSourceVersion()</code></li>
<li><code>process(Set&lt;? extends TypeElement&gt; set, RoundEnvironment roundEnv)</code></li>
</ul>
<h4 id="2-2-init-ProcessingEnvironment-processingEnv-方法"><a href="#2-2-init-ProcessingEnvironment-processingEnv-方法" class="headerlink" title="2-2 init(ProcessingEnvironment processingEnv)方法"></a>2-2 init(ProcessingEnvironment processingEnv)方法</h4><p>这不是一个抽象方法，但progressingEnv参数给我们提供了许多有用的工具,所以我们需要重写它</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">    public synchronized void init(ProcessingEnvironment processingEnv) &#123;</span><br><span class="line">        super.init(processingEnv);</span><br><span class="line"></span><br><span class="line">        mFilerUtils = processingEnv.getFiler();</span><br><span class="line">        mTypesUtils = processingEnv.getTypeUtils();</span><br><span class="line">        mElementsUtils = processingEnv.getElementUtils();</span><br><span class="line">    &#125;</span><br><span class="line">12345678</span><br></pre></td></tr></table></figure>

<ul>
<li><code>mFilterUtils</code> 文件管理工具类，在后面生成java文件时会用到</li>
<li><code>mTypesUtils</code> 类型处理工具类，本例不会用到</li>
<li><code>mElementsUtils</code> Element处理工具类,后面获取包名时会用到</li>
</ul>
<p><strong><em>限于篇幅就不展开对这几个工具的解析，读者可以自行查看文档~</em></strong></p>
<h4 id="2-3-getSupportedAnnotationTypes"><a href="#2-3-getSupportedAnnotationTypes" class="headerlink" title="2-3 getSupportedAnnotationTypes()"></a>2-3 getSupportedAnnotationTypes()</h4><p>由方法名我们就可以看出这个方法是提供我们这个APT<strong>能够处理的注解</strong></p>
<p>这也不是一个抽象方法，但仍需要重写它，否则会抛出异常（滑稽），至于为什么有兴趣可以自行查看源码~</p>
<p>这个方法有固定写法~</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">public Set&lt;String&gt; getSupportedAnnotationTypes() &#123;</span><br><span class="line">    HashSet&lt;String&gt; supportTypes = new LinkedHashSet&lt;&gt;();</span><br><span class="line">    supportTypes.add(BindView.class.getCanonicalName());</span><br><span class="line">    return supportTypes; //将要支持的注解放入其中</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-4-getSupportedSourceVersion"><a href="#2-4-getSupportedSourceVersion" class="headerlink" title="2-4 getSupportedSourceVersion()"></a>2-4 getSupportedSourceVersion()</h4><p>顾名思义，就是提供我们这个APT支持的版本号</p>
<p>这个方法和上面的getSupportedAnnotationTypes()类似，也不是一个抽象方法，但也需要重写，也有固定的写法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">    public SourceVersion getSupportedSourceVersion() &#123;</span><br><span class="line">        return SourceVersion.latestSupported();// 表示支持最新的Java版本</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-5-process-Set-lt-extends-TypeElement-gt-set-RoundEnvironment-roundEnv"><a href="#2-5-process-Set-lt-extends-TypeElement-gt-set-RoundEnvironment-roundEnv" class="headerlink" title="2-5 process(Set&lt;? extends TypeElement&gt; set, RoundEnvironment roundEnv)"></a>2-5 process(Set&lt;? extends TypeElement&gt; set, RoundEnvironment roundEnv)</h4><p>最主要的方法，用来处理注解,这也是唯一的抽象方法，有两个参数</p>
<ul>
<li><code>set</code> 参数是要处理的注解的类型集合</li>
<li><code>roundEnv</code>表示运行环境，可以通过这个参数获得被注解标注的代码块</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">    public boolean process(Set&lt;? extends TypeElement&gt; set, RoundEnvironment roundEnv) &#123;</span><br><span class="line">        System.out.println(&quot;start process&quot;);</span><br><span class="line">        if (set != null &amp;&amp; set.size() != 0) &#123;</span><br><span class="line">            Set&lt;? extends Element&gt; elements = roundEnv.getElementsAnnotatedWith(BindView.class);//获得被BindView注解标记的element</span><br><span class="line"></span><br><span class="line">            categories(elements);//对不同的Activity进行分类</span><br><span class="line"></span><br><span class="line">            //对不同的Activity生成不同的帮助类</span><br><span class="line">            for (TypeElement typeElement : mToBindMap.keySet()) &#123;</span><br><span class="line">                String code = generateCode(typeElement);    //获取要生成的帮助类中的所有代码</span><br><span class="line">                String helperClassName = typeElement.getQualifiedName() + &quot;$$Autobind&quot;; //构建要生成的帮助类的类名</span><br><span class="line"></span><br><span class="line">                //输出帮助类的java文件，在这个例子中就是MainActivity$$Autobind.java文件</span><br><span class="line">                //输出的文件在build-&gt;source-&gt;apt-&gt;目录下</span><br><span class="line">                try &#123;</span><br><span class="line">                    JavaFileObject jfo = mFilerUtils.createSourceFile(helperClassName, typeElement);</span><br><span class="line">                    Writer writer = jfo.openWriter();</span><br><span class="line">                    writer.write(code);</span><br><span class="line">                    writer.flush();</span><br><span class="line">                    writer.close();</span><br><span class="line">                &#125; catch (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>process方法的大概流程是：</p>
<ol>
<li>扫描所有被<code>@BindView</code>标记的Element</li>
<li>遍历Element，调用<code>categories</code>方法，把所有需要绑定的View变量按所在的Activity进行分类，把对应关系存在mToBindMap中</li>
<li>遍历所有Activity的TypeElment，调用<code>generateCode</code>方法获得要生成的代码，每个Activity生成一个帮助类</li>
</ol>
<h4 id="2-6-categories方法"><a href="#2-6-categories方法" class="headerlink" title="2-6 categories方法"></a>2-6 categories方法</h4><p>把所有需要绑定的View变量按所在的Activity进行分类，把对应关系存在mToBindMap中</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private void categories(Set&lt;? extends Element&gt; elements) &#123;</span><br><span class="line">    for (Element element : elements) &#123;  //遍历每一个element</span><br><span class="line">        VariableElement variableElement = (VariableElement) element;    //被@BindView标注的应当是变量，这里简单的强制类型转换</span><br><span class="line">        TypeElement enclosingElement = (TypeElement) variableElement.getEnclosingElement(); //获取代表Activity的TypeElement</span><br><span class="line">        Set&lt;ViewInfo&gt; views = mToBindMap.get(enclosingElement); //views储存着一个Activity中将要绑定的view的信息</span><br><span class="line">        if (views == null) &#123;    //如果views不存在就new一个</span><br><span class="line">            views = new HashSet&lt;&gt;();</span><br><span class="line">            mToBindMap.put(enclosingElement, views);</span><br><span class="line">        &#125;</span><br><span class="line">        BindView bindAnnotation = variableElement.getAnnotation(BindView.class);    //获取到一个变量的注解</span><br><span class="line">        int id = bindAnnotation.value();    //取出注解中的value值，这个值就是这个view要绑定的xml中的id</span><br><span class="line">        views.add(new ViewInfo(variableElement.getSimpleName().toString(), id));    //把要绑定的View的信息存进views中</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注解应该已经很详细了~<br>实现方式仅供参考，读者可以有自己的实现</p>
<h4 id="2-7-generateCode方法"><a href="#2-7-generateCode方法" class="headerlink" title="2-7 generateCode方法"></a>2-7 generateCode方法</h4><p>按照不同的TypeElement生成不同的帮助类(注：参数中的TypeElement对应一个Activity)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private String generateCode(TypeElement typeElement) &#123;</span><br><span class="line">        String rawClassName = typeElement.getSimpleName().toString(); //获取要绑定的View所在类的名称</span><br><span class="line">        String packageName = ((PackageElement) mElementsUtils.getPackageOf(typeElement)).getQualifiedName().toString(); //获取要绑定的View所在类的包名</span><br><span class="line">        String helperClassName = rawClassName + &quot;$$Autobind&quot;;   //要生成的帮助类的名称</span><br><span class="line"></span><br><span class="line">        StringBuilder builder = new StringBuilder();</span><br><span class="line">        builder.append(&quot;package &quot;).append(packageName).append(&quot;;\n&quot;);   //构建定义包的代码</span><br><span class="line">        builder.append(&quot;import com.example.apt_api.template.IBindHelper;\n\n&quot;); //构建import类的代码</span><br><span class="line"></span><br><span class="line">        builder.append(&quot;public class &quot;).append(helperClassName).append(&quot; implements &quot;).append(&quot;IBindHelper&quot;);   //构建定义帮助类的代码</span><br><span class="line">        builder.append(&quot; &#123;\n&quot;); //代码格式，可以忽略</span><br><span class="line">        builder.append(&quot;\t@Override\n&quot;);    //声明这个方法为重写IBindHelper中的方法</span><br><span class="line">        builder.append(&quot;\tpublic void inject(&quot; + &quot;Object&quot; + &quot; target ) &#123;\n&quot;);   //构建方法的代码</span><br><span class="line">        for (ViewInfo viewInfo : mToBindMap.get(typeElement)) &#123; //遍历每一个需要绑定的view</span><br><span class="line">            builder.append(&quot;\t\t&quot;); //代码格式，可以忽略</span><br><span class="line">            builder.append(rawClassName + &quot; substitute = &quot; + &quot;(&quot; + rawClassName + &quot;)&quot; + &quot;target;\n&quot;);    //强制类型转换</span><br><span class="line"></span><br><span class="line">            builder.append(&quot;\t\t&quot;); //代码格式，可以忽略</span><br><span class="line">            builder.append(&quot;substitute.&quot; + viewInfo.viewName).append(&quot; = &quot;);    //构建赋值表达式</span><br><span class="line">            builder.append(&quot;substitute.findViewById(&quot; + viewInfo.id + &quot;);\n&quot;);  //构建赋值表达式</span><br><span class="line">        &#125;</span><br><span class="line">        builder.append(&quot;\t&#125;\n&quot;);    //代码格式，可以忽略</span><br><span class="line">        builder.append(&apos;\n&apos;);   //代码格式，可以忽略</span><br><span class="line">        builder.append(&quot;&#125;\n&quot;);  //代码格式，可以忽略</span><br><span class="line"></span><br><span class="line">        return builder.toString();</span><br><span class="line">    &#125;</span><br><span class="line">123456789101112131415161718192021222324252627</span><br></pre></td></tr></table></figure>

<p>大家可以对比生成的代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.example.apt_demo;</span><br><span class="line">import com.example.apt_api.template.IBindHelper;</span><br><span class="line"></span><br><span class="line">public class MainActivity$$Autobind implements IBindHelper &#123;</span><br><span class="line">	@Override</span><br><span class="line">	public void inject(Object target ) &#123;</span><br><span class="line">		MainActivity substitute = (MainActivity)target;</span><br><span class="line">		substitute.testTextView = substitute.findViewById(2131165315);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有没有觉得字符串拼接很麻烦呢，不仅麻烦还容易出错，那么有没有更好的办法呢（留个坑）</p>
<p>同样的~ 这个方法的设计仅供参考啦啦啦<del>~</del></p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/2275ad66b214a748862a5b15bca9a63c.JPEG" alt="image"></p>
<h3 id="第三步-注册你的APT"><a href="#第三步-注册你的APT" class="headerlink" title="第三步 注册你的APT"></a>第三步 注册你的APT</h3><p>这应该是最简单的一步<br>这应该是最麻烦的一步</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/730383b052c0ca2562ff1dd1f7fc5069.JPEG" alt="image"></p>
<p>客官别急，往下看就知道了~</p>
<p>注册一个APT需要以下步骤：</p>
<ol>
<li>需要在 processors 库的 main 目录下新建 resources 资源文件夹；</li>
<li>在 resources文件夹下建立 META-INF/services 目录文件夹；</li>
<li>在 META-INF/services 目录文件夹下创建 javax.annotation.processing.Processor 文件；</li>
<li>在 javax.annotation.processing.Processor 文件写入注解处理器的全称，包括包路径；</li>
</ol>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/68b43659490a86f98c2b5daaa44b8db7.JPEG" alt="image"></p>
<p>正如我前面所说的~<br>简单是因为都是一些固定的步骤<br>麻烦也是因为都是一些固定的步骤</p>
<h3 id="最后一步-对外提供API"><a href="#最后一步-对外提供API" class="headerlink" title="最后一步 对外提供API"></a>最后一步 对外提供API</h3><p>4.1 创建一个Android Library Module，名称叫<code>apt-api</code>,并添加依赖</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    api project(&apos;:apt-annotation&apos;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4.2 分别创建launcher、template文件夹<br><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/6bd1d1cadcaf14c10c8dcb352efe5a6c.JPEG" alt="image"></p>
<p>4.3 在template文件夹中创建<code>IBindHelper</code>接口</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public interface IBindHelper &#123;</span><br><span class="line">    void inject(Object target);</span><br><span class="line">&#125;</span><br><span class="line">123</span><br></pre></td></tr></table></figure>

<p>这个接口主要供APT生成的帮助类实现</p>
<p>4.4在launcher文件夹中创建<code>AutoBind</code>类</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class AutoBind &#123;</span><br><span class="line">    private static AutoBind instance = null;</span><br><span class="line"></span><br><span class="line">    public AutoBind() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static AutoBind getInstance() &#123;</span><br><span class="line">        if(instance == null) &#123;</span><br><span class="line">            synchronized (AutoBind.class) &#123;</span><br><span class="line">                if (instance == null) &#123;</span><br><span class="line">                    instance = new AutoBind();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void inject(Object target) &#123;</span><br><span class="line">        String className = target.getClass().getCanonicalName();</span><br><span class="line">        String helperName = className + &quot;$$Autobind&quot;;</span><br><span class="line">        try &#123;</span><br><span class="line">            IBindHelper helper = (IBindHelper) (Class.forName(helperName).getConstructor().newInstance());</span><br><span class="line">            helper.inject(target);</span><br><span class="line">        &#125;   catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个类是我们的API的入口类，使用了单例模式<br>inject方法是最主要的方法，但实现很简单，就是通过<strong>反射</strong>去调用APT生成的帮助类的方法去实现View的自动绑定</p>
<h3 id="完成！拉出来遛遛"><a href="#完成！拉出来遛遛" class="headerlink" title="完成！拉出来遛遛"></a>完成！拉出来遛遛</h3><p>在app module里添加依赖</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    ...</span><br><span class="line">    annotationProcessor project(&apos;:apt-compiler&apos;)</span><br><span class="line">    implementation project(&apos;:apt-api&apos;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们来修改MainActivity中的代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class MainActivity extends AppCompatActivity &#123;</span><br><span class="line"></span><br><span class="line">    @BindView(value = R.id.test_textview)</span><br><span class="line">    public TextView testTextView;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line"></span><br><span class="line">        AutoBind.getInstance().inject(this);</span><br><span class="line">        testTextView.setText(&quot;APT 测试&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">1234567891011121314</span><br></pre></td></tr></table></figure>

<p>大功告成！我们来运行项目试试看<br><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/8f10e8f50bc1613713bfa437d1e557bf.JPEG" alt="image"></p>
<p>TextView已经正确显示了文字，我们的小demo到这里就完成啦~</p>
<h2 id="还可以更好"><a href="#还可以更好" class="headerlink" title="还可以更好"></a>还可以更好</h2><p>我们的APT还可以变得更简单！</p>
<h3 id="痛点"><a href="#痛点" class="headerlink" title="痛点"></a>痛点</h3><ul>
<li>生成代码时字符串拼接麻烦且容易出错</li>
<li>继承AbstrctProcessor时要重写多个方法</li>
<li>注册APT的步骤繁琐</li>
</ul>
<p>下面我们来逐个击破~</p>
<h3 id="使用JavaPoet来替代拼接字符串"><a href="#使用JavaPoet来替代拼接字符串" class="headerlink" title="使用JavaPoet来替代拼接字符串"></a>使用JavaPoet来替代拼接字符串</h3><p>JavaPoet是一个用来生成Java代码的框架，对JavaPoet不了解的请移步<a href="https://github.com/square/javapoet" target="_blank" rel="noopener">官方文档</a><br>JavaPoet生成代码的步骤大概是这样（摘自官方文档）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    MethodSpec main = MethodSpec.methodBuilder(&quot;main&quot;)</span><br><span class="line">    .addModifiers(Modifier.PUBLIC, Modifier.STATIC)</span><br><span class="line">    .returns(void.class)</span><br><span class="line">    .addParameter(String[].class, &quot;args&quot;)</span><br><span class="line">    .addStatement(&quot;$T.out.println($S)&quot;, System.class, &quot;Hello, JavaPoet!&quot;)</span><br><span class="line">    .build();</span><br><span class="line"></span><br><span class="line">TypeSpec helloWorld = TypeSpec.classBuilder(&quot;HelloWorld&quot;)</span><br><span class="line">    .addModifiers(Modifier.PUBLIC, Modifier.FINAL)</span><br><span class="line">    .addMethod(main)</span><br><span class="line">    .build();</span><br><span class="line"></span><br><span class="line">JavaFile javaFile = JavaFile.builder(&quot;com.example.helloworld&quot;, helloWorld)</span><br><span class="line">    .build();</span><br><span class="line"></span><br><span class="line">javaFile.writeTo(System.out);</span><br></pre></td></tr></table></figure>

<p>使用JavaPoet来生成代码有很多的优点，不容易出错，可以自动import等等，这里不过多介绍，有兴趣的同学可以自行了解</p>
<h3 id="使用注解来代替getSupportedAnnotationTypes-和getSupportedSourceVersion"><a href="#使用注解来代替getSupportedAnnotationTypes-和getSupportedSourceVersion" class="headerlink" title="使用注解来代替getSupportedAnnotationTypes()和getSupportedSourceVersion()"></a>使用注解来代替getSupportedAnnotationTypes()和getSupportedSourceVersion()</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@SupportedSourceVersion(SourceVersion.RELEASE_7)</span><br><span class="line">@SupportedAnnotationTypes(&quot;com.example.apt_annotation.BindView&quot;)</span><br><span class="line">public class BindViewProcessor extends AbstractProcessor &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是javax.annotation.processing中提供的注解，直接使用即可</p>
<h3 id="使用Auto-Service来自动注册APT"><a href="#使用Auto-Service来自动注册APT" class="headerlink" title="使用Auto-Service来自动注册APT"></a>使用Auto-Service来自动注册APT</h3><p>这是谷歌官方出品的一个开源库，可以省去注册APT的步骤，只需要一行注释<br>先在apt-compiler模块中添加依赖</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    implementation &apos;com.google.auto.service:auto-service:1.0-rc2&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后添加注释即可</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@AutoService(Processor.class)</span><br><span class="line">public class BindViewProcessor extends AbstractProcessor &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>APT是一个非常强大而且频繁出现在各种开源库的工具，学习APT不仅可以让我们在阅读开源库源码时游刃有余也可以自己开发注解框架来帮自己写代码~</p>
<p>本文转载自：<a href="https://juejin.im/post/5bcdb901f265da0ac8496fed" target="_blank" rel="noopener">https://juejin.im/post/5bcdb901f265da0ac8496fed</a></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em>乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</em></p>
]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>Android面试题之Activity和Fragment生命周期 一次性记忆</title>
    <url>/63.html</url>
    <content><![CDATA[<blockquote>
<p>每当我们换工作面试之前,总是会不由自主的刷起面试题,大部分题我们反反复复不知道刷了多少遍,但是今天记住了,等下一次面试的时候又刷着相同的面试题,我就想问在座的各位,Activity的生命周期,你们到底刷过多少遍 [哭笑]  作为一名程序员  把时间浪费在重复性劳动上是极其不能忍受的  因此 为了让自己省去不必要的脑力开销 我给自己总结了一份面试相关的记忆技巧,在这里分享给大家   记忆不是目的  把知识变成自己的才最关键</p>
</blockquote>
<h2 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h2><p>需要熟悉Activity的生命周期 通过Activity的周期去对比理解和记忆Fragment生命周期</p>
<h2 id="Activity的生命周期"><a href="#Activity的生命周期" class="headerlink" title="Activity的生命周期"></a>Activity的生命周期</h2><p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20180405184622584" alt></p>
<p><strong>假设你已经非常熟悉Activity的生命周期了,那么接下来咱们看Fragment的生命周期图</strong></p>
<h2 id="Fragment的生命周期"><a href="#Fragment的生命周期" class="headerlink" title="Fragment的生命周期"></a>Fragment的生命周期</h2><p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20180405184635884" alt></p>
<p><strong>找出他和Activity的相同之处</strong></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191126135718.png" alt></p>
<p><strong>这部分完全和Activity一模一样 可以不用记忆它,咱们来看不同的地方</strong></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20180405184635884.png" alt></p>
<p>其实这部分才是人们最容易搞混和记不住的地方 那咱们来分析一下:</p>
<p>Fragment比Activity多了几个生命周期的回调方法</p>
<ul>
<li><strong>onAttach(Activity)</strong> 当Fragment与Activity发生关联的时候调用</li>
<li><strong>onCreateView(LayoutInflater, ViewGroup, Bundle)</strong> 创建该F</li>
<li><strong>onActivityCreated(Bundle)</strong>当Activity的onCreated方法返回时调用</li>
<li><strong>onDestroyView()</strong> 与onCreateView方法相对应，当该Fragment的视图被移除时调用</li>
<li><strong>onDetach()</strong> 与onAttach方法相对应，当Fragment与Activity取消关联时调用<br><strong>PS：注意：除了onCreateView，其他的所有方法如果你重写了，必须调用父类对于该方法的实现</strong></li>
</ul>
<p>这些方法理解起来并不费劲 但是要完美记在脑子里  还是需要花上一番功夫的</p>
<p>那咱们一个一个来 先从创建开始:</p>
<p>1.<strong>首先 onAttach方法: 和Activity进行关联的时候调用  这个放在第一个 应该好理解</strong></p>
<p>2.<strong>我们知道 Activity在onCreate方法中需要调用setContentVIew()进行布局的加载,那么在Fragment中onCreateView就相当于Activity中的setContentVIew</strong> </p>
<p>3.<strong>onActivityCreate是一个额外的方法 为了告诉Fragment当前Activity的创建执行情况 方便Fragment的后续操作</strong></p>
<h2 id="先后顺序"><a href="#先后顺序" class="headerlink" title="先后顺序"></a>先后顺序</h2><p>已知Fragment是依赖Activity而存在的 它们都有着相同的生命周期方法 那么先调用Activity的还是Fragment的呢?  这里分两种情况</p>
<ul>
<li><strong>如果是创建 那么先创建Activity 后创建Fragment</strong></li>
<li><strong>如果是销毁 那么先销毁Fragment 后销毁Activity</strong></li>
</ul>
<p>网上有很多文章说Activity的onCreate方法在Fragment的onCreateView之后执行,这是不正确的  Fragment一般都是在Activity的onCreate()中创建 要么通过布局加载的方式 要么通过new创建Fragment对象的方式  如果没有Activity的onCreate 哪来的Fragment</p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/1354170682_3824.png" alt></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>上面的理解好后,咱们再整理记忆一下</p>
<p>一句话 <strong>Activity是老子 Fragment是小子  进门先让老子进 滚蛋先让小子滚   加载布局createView   老子完事吱一声(ActivityCreated)</strong></p>
<p>希望有帮到你</p>
<p><strong>本帖附件</strong></p>
<p><a href="https://u21519047.pipipan.com/fs/21519047-395416051" target="_blank" rel="noopener">点击下载</a></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em>乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</em></p>
]]></content>
      <tags>
        <tag>面试题</tag>
      </tags>
  </entry>
  <entry>
    <title>Android面试题之Handler内存泄漏处理  一次性记忆</title>
    <url>/64.html</url>
    <content><![CDATA[<h2 id="为什么会内存泄漏"><a href="#为什么会内存泄漏" class="headerlink" title="为什么会内存泄漏"></a>为什么会内存泄漏</h2><p>内部类持有外部类对象引用,导致外部类无法被回收  </p>
<h2 id="如何解决内存泄露"><a href="#如何解决内存泄露" class="headerlink" title="如何解决内存泄露"></a>如何解决内存泄露</h2><ul>
<li>使用静态内部类</li>
<li>Activity销毁时handler.removeCallback()</li>
<li>使用弱引用</li>
</ul>
<p><strong>本帖附件</strong></p>
<p><a href="https://u21519047.pipipan.com/fs/21519047-395416051" target="_blank" rel="noopener">点击下载</a></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em>乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</em></p>
]]></content>
      <tags>
        <tag>Android面试题</tag>
      </tags>
  </entry>
  <entry>
    <title>Android面试题之事件分发机制  一次性记忆</title>
    <url>/66.html</url>
    <content><![CDATA[<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191126221917.png" alt></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/timg" alt></p>
<p><strong>本帖附件</strong></p>
<p><a href="https://u21519047.pipipan.com/fs/21519047-395416051" target="_blank" rel="noopener">点击下载</a></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em>乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</em></p>
]]></content>
      <tags>
        <tag>Android面试题</tag>
      </tags>
  </entry>
  <entry>
    <title>Android面试题之四大组件 一次性记忆</title>
    <url>/67.html</url>
    <content><![CDATA[<blockquote>
<p>每当我们换工作面试之前,总是会不由自主的刷起面试题,大部分题我们反反复复不知道刷了多少遍,但是今天记住了,等下一次面试的时候又刷着相同的面试题,我就想问在座的各位,Activity的生命周期,你们到底刷过多少遍 [哭笑]  作为一名程序员  把时间浪费在重复性劳动上是极其不能忍受的  因此 为了让自己省去不必要的脑力开销 我给自己总结了一份面试相关的记忆技巧,在这里分享给大家   记忆不是目的  把知识变成自己的才最关键</p>
</blockquote>
<h2 id="四大组件是什么？"><a href="#四大组件是什么？" class="headerlink" title="四大组件是什么？"></a>四大组件是什么？</h2><p><strong>Activity【活动】</strong>：用于页面展示和交互。<br><strong>Service【服务】</strong>：后台运行服务，不提供界面呈现。<br><strong>BroadcastReceiver【广播接收器】</strong>：用来接收广播。<br><strong>Content Provider【内容提供商】</strong>：支持在多个应用中存储和读取数据，相当于数据库。</p>
<h3 id="如何一次性记忆四大组件"><a href="#如何一次性记忆四大组件" class="headerlink" title="如何一次性记忆四大组件"></a>如何一次性记忆四大组件</h3><p>如果让你去设计一款操作系统,你会怎么设计?</p>
<p>针对具有交互性的操作系统而言,需要具备以下几种基础功能 : </p>
<ul>
<li>首先 程序的界面的展示是必不可少的 这是其一　（Activity）</li>
<li>其二 程序中也许不止一个界面 多个界面之间需要进行通信和数据传递    (BroadcastReceiver)</li>
<li>第三  多个程序之间需要进行通信和数据传递  (Content Provider)</li>
<li>第四　程序界面未显示的时也能随时响应用户操作　可后台运行 (Service)</li>
</ul>
<p>*<em>当你理解了设计者的用意后 确实能很好的理解四大组件的含义, 但是并不意味着你能很好的记忆住他们   在面试过程中你必须要有较快的反应速度    *</em></p>
<p><strong>在这里我抛出几种右脑记忆思路:</strong></p>
<ul>
<li>取四大组件英文首字母得到 <strong>ABCS</strong>   当对方问你四大组件都有哪些时 你能立马联想到英文字母ABC</li>
<li>这四大组件能让你联想到什么画面?</li>
</ul>
<p>到这里 有些人可能会说了  四大组件这么好记 还用得着这么费劲记忆?   </p>
<p>我想说的是  如果你在工作中经常使用这些知识  那么它们对你来讲是非常熟悉的  但是针对初学者或者很长时间没有使用的开发者而言 一套合理的记忆技巧是非常有帮助的  我想若干年后 你也许忘了四大组件都有哪些了  但是你依然记得文本所说的<strong>ABC</strong>  这个时候 回忆起来 也只是一念之间的事儿</p>
<p><strong>本帖附件</strong></p>
<p><a href="https://u21519047.pipipan.com/fs/21519047-395416051" target="_blank" rel="noopener">点击下载</a></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em>乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</em></p>
]]></content>
      <tags>
        <tag>面试题</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux环境下docker常用指令集合</title>
    <url>/7.html</url>
    <content><![CDATA[<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/20200122180634.png" alt></p>
<h3 id="使用前提"><a href="#使用前提" class="headerlink" title="使用前提"></a>使用前提</h3><p>需要先安装docker, 可参考<a href="http://codesan.github.io/ubuntu安装docker详细步骤.html" target="_blank" rel="noopener">《ubuntu安装docker详细步骤》</a></p>
<h3 id="Docker容器基础指令"><a href="#Docker容器基础指令" class="headerlink" title="Docker容器基础指令"></a>Docker容器基础指令</h3><ol>
<li><p>启动docker</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo systemctl start docker</span><br></pre></td></tr></table></figure>
</li>
<li><p>停止docker</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo systemctl stop docker</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看docker状态</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo systemctl status docker</span><br></pre></td></tr></table></figure>
</li>
<li><p>重启docker</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo systemctl restart docker</span><br></pre></td></tr></table></figure>
</li>
<li><p>设置开启启动docker</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo systemctl enable docker</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="常用Docker镜像指令"><a href="#常用Docker镜像指令" class="headerlink" title="常用Docker镜像指令"></a>常用Docker镜像指令</h3><ol>
<li><p>查看本地镜像</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo docker images</span><br></pre></td></tr></table></figure>
</li>
<li><p>拉取最新镜像</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo docker pull [镜像名]:latest</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建并后台运行容器</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo docker run -itd --name=[名称] [镜像名]:版本名</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看当前所有运行的容器信息</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo docker ps</span><br><span class="line">另外</span><br><span class="line">sudo docker ps -a //查看所有容器</span><br></pre></td></tr></table></figure>
</li>
<li><p>运行容器  并设置在后台一直运行</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo docker run -itd --name [名称]  -d [镜像名]</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看镜像可用版本</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo docker search [镜像名]</span><br></pre></td></tr></table></figure>
</li>
<li><p>进入指定容器</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo docker exec -it [镜像名] /bin/bash</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建容器 并将本地 8080 端口映射到容器内部的 80 端口</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo docker run --name [镜像名] -p 8080:80</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建容器 并将主机中当前目录下的 test 挂载到容器的指定目录</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo docker run --name [镜像名]  -v $PWD/test:[容器目录]</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建容器 并指定工作目录</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo docker run --name [镜像名]  -w [工作目录]</span><br></pre></td></tr></table></figure>
</li>
<li><p>停止运行容器</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker stop [容器id]</span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker stop [容器名]</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建容器 并设置需要密码才能访问容器服务</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo docker run --name [镜像名]  --auth</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看容器内的标准输出</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo docker logs [容器名]</span><br><span class="line">另外</span><br><span class="line">sudo docker logs -f [容器名] //停留在尾部</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除容器</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo docker rm -f [容器id] [容器id2] //多个容器以空格隔开-f表示强制删除</span><br></pre></td></tr></table></figure>
</li>
<li><p>重启容器</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo docker restart [容器id]</span><br></pre></td></tr></table></figure>
</li>
<li><p>导出容器</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo docker export [容器id] &gt; [目标文件]</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看容器内部运行的进程</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo docker top [容器名]</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看容器的配置和状态信息</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo docker inspect  [容器名]</span><br></pre></td></tr></table></figure>
</li>
<li><p>查询最后一次创建的容器</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo docker ps -l</span><br></pre></td></tr></table></figure>
</li>
<li><p>为镜像添加一个新的标签</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo docker tag [镜像名]</span><br></pre></td></tr></table></figure>
</li>
<li><p>查询镜像在什么位置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">which [镜像名]</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看容器资源占用情况</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo docker stats</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除所有容器</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo docker rm $(docker ps -aq)</span><br></pre></td></tr></table></figure>
</li>
<li><p>暂停指定容器</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo docker pause [容器名]</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看具体指令的使用方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo docker help [具体指令]</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看当前已有的网络</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo docker network ls</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建自定义网络</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker network create [网络名]</span><br></pre></td></tr></table></figure>
</li>
<li><p>后台运行容器 并指定容器想要连接的网络</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run -dit --name [容器名] --network [网络名] alpine</span><br></pre></td></tr></table></figure>
</li>
<li><p>将指定容器连接到指定网络上</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker network connect [网络名] [容器名]</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除指定网络</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker network rm [网络名]</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看某时间段日志</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker logs -t --since=&quot;2019-10-24T13:23:37&quot; --until &quot;2019-10-25T12:23:37&quot; [容器名]</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看某时间之后的日志</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker logs -t --since=&quot;2019-10-24T13:23:37&quot; [容器名]</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看最近30分钟的日志</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker logs --since 30m [容器名]</span><br></pre></td></tr></table></figure>
</li>
<li><p>只打印最后50行日志</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker logs --tail=50 [容器名]</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看指定时间后的日志，只显示最后100行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker logs -f -t --since=&quot;2019-10-24&quot; --tail=100 CONTAINER_ID</span><br></pre></td></tr></table></figure>
</li>
<li><p>设置开机自动启动docker服务</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo systemctl enable docker</span><br></pre></td></tr></table></figure>
</li>
<li><p>禁止自启 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo systemctl disable docker</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看docker版本</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker version</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建数据卷容器</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run -it --name=data -v /volume ubuntu:latest /bin/bash</span><br></pre></td></tr></table></figure>
</li>
<li><p>其他容器挂载数据卷容器</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run -it --name=c1 --volumes-from data ubuntu:latest /bin/bash</span><br></pre></td></tr></table></figure>
</li>
<li><p>启动已经停止的容器</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker start [容器名]</span><br></pre></td></tr></table></figure>
</li>
<li><p>强制停止正在运行的容器</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker kill [容器名]</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看所有容器<code>id</code>, 包括已经停止的容器</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker ps -aq</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看所有已启动容器<code>id</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker ps -q</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看容器内部的进程</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker top 容器名</span><br></pre></td></tr></table></figure>
</li>
<li><p>容器配置更新</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker update xxx</span><br></pre></td></tr></table></figure>

<p>比如 更新是否自启动:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker update --restart=always</span><br></pre></td></tr></table></figure>





</li>
</ol>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em>乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</em></p>
]]></content>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Android系统的启动过程大致介绍</title>
    <url>/69.html</url>
    <content><![CDATA[<p>安卓手机从开机到桌面显示的这个过程,即为Android系统启动过程,那么在这个过程中, Android系统内部都做了哪些操作呢?</p>
<p>首先咱们来看一张Android系统架构图:</p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/1141244-20190603163616072-1939226625.png" alt></p>
<p><strong>Android系统的启动是由下往上进行的</strong></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191205120344.png" alt></p>
<p><strong>从系统核心库Init.c的main函数开始执行—&gt;Android Runtime—&gt;执行init1函数初始化native也就是Libraries层—&gt;执行init2函数初始化Framework层—&gt;最后是Application层</strong></p>
<p>具体流程图如下:</p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191205121251.png" alt></p>
<p><strong>具体时序图如下:</strong></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/Android%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%90%AF%E5%8A%A8%E6%97%B6%E5%BA%8F%E5%9B%BE.png" alt></p>
<p><strong>当然 还有详细的思维导图供大家参考</strong></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/Android%E7%B3%BB%E7%BB%9F%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E5%AF%BC%E5%9B%BE.png" alt></p>
<p><strong>本帖附件</strong></p>
<p><a href="https://u21519047.pipipan.com/fs/21519047-395416051" target="_blank" rel="noopener">点击下载</a></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em>乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</em></p>
]]></content>
      <tags>
        <tag>Android系统开发</tag>
      </tags>
  </entry>
  <entry>
    <title>Android应用流程简介</title>
    <url>/72.html</url>
    <content><![CDATA[<p>我们知道Android系统的启动是从Init.c开始</p>
<p>那么Android应用的启动过程是从哪里开始呢?</p>
<p>下面是具体的时序图参考:</p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/Android%E5%BA%94%E7%94%A8%E5%90%AF%E5%8A%A8%E6%97%B6%E5%BA%8F%E5%9B%BE.png" alt></p>
<p>从Launcher.java开始 由于虚拟机的特性每个应用都会独占一个进程,ActivityThead是应用启动的标志</p>
<p><strong>本帖附件</strong></p>
<p><a href="https://u21519047.pipipan.com/fs/21519047-395416051" target="_blank" rel="noopener">点击下载</a></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em>乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</em></p>
]]></content>
      <tags>
        <tag>Android系统</tag>
      </tags>
  </entry>
  <entry>
    <title>Android源码编译</title>
    <url>/73.html</url>
    <content><![CDATA[<h3 id="在编译源码之前需要做一些准备操作-详细步骤如下"><a href="#在编译源码之前需要做一些准备操作-详细步骤如下" class="headerlink" title="在编译源码之前需要做一些准备操作, 详细步骤如下:"></a>在编译源码之前需要做一些准备操作, 详细步骤如下:</h3><blockquote>
<h4 id="1-安装JDK-google官方要求编译2-3源码需要JDK1-6"><a href="#1-安装JDK-google官方要求编译2-3源码需要JDK1-6" class="headerlink" title="1. 安装JDK, google官方要求编译2.3源码需要JDK1.6."></a>1. 安装JDK, google官方要求编译2.3源码需要JDK1.6.</h4></blockquote>
<ul>
<li><p>1). 下载JDK1.6, 下载地址:<a href="http://www.oracle.com/technetwork/java/javasebusiness/downloads/java-archive-downloads-javase6-419409.html、http://download.oracle.com/otn/java/jdk/6u45-b06/jdk-6u45-linux-x64.bin" target="_blank" rel="noopener">http://www.oracle.com/technetwork/java/javasebusiness/downloads/java-archive-downloads-javase6-419409.html、http://download.oracle.com/otn/java/jdk/6u45-b06/jdk-6u45-linux-x64.bin</a></p>
</li>
<li><p>2). 创建目录.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo mkdir /usr/java</span><br></pre></td></tr></table></figure>
</li>
<li><p>3). 在文件系统中右击上面的创建的文件夹，选择“以管理员权限打开”，然后把下载好的jdk-6u45-linux-x64.bin拖动到/usr/java目录中</p>
</li>
<li><p>4). 添加可执行权限.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo chmod 755 /usr/java/jdk-6u45-linux-x64.bin</span><br></pre></td></tr></table></figure>
</li>
<li><p>5). 解压.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd /usr/java</span><br><span class="line">sudo ./jdk-6u45-linux-x64.bin</span><br></pre></td></tr></table></figure>
</li>
<li><p>6). 配置环境变量.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export JAVA_HOME=/usr/java/jdk1.6.0_45</span><br><span class="line">export PATH=$PATH:$JAVA_HOME/bin</span><br><span class="line">export CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar</span><br></pre></td></tr></table></figure>
</li>
<li><p>7). 验证是否成功.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java -version</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="2-安装其他编译时依赖的软件"><a href="#2-安装其他编译时依赖的软件" class="headerlink" title="2. 安装其他编译时依赖的软件."></a>2. 安装其他编译时依赖的软件.</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get install gnupg</span><br><span class="line">sudo apt-get install flex</span><br><span class="line">sudo apt-get install bison</span><br><span class="line">sudo apt-get install gperf</span><br><span class="line">sudo apt-get install zip</span><br><span class="line">sudo apt-get install curl</span><br><span class="line">sudo apt-get install build-essential</span><br><span class="line">sudo apt-get install libesd0-dev</span><br><span class="line">sudo apt-get install libwxgtk2.8-dev</span><br><span class="line">sudo apt-get install libsdl-dev</span><br><span class="line">sudo apt-get install lsb-core</span><br><span class="line">sudo apt-get install lib32readline-gplv2-dev</span><br><span class="line">sudo apt-get install g++-multilib</span><br><span class="line">sudo apt-get install lib32z1-dev</span><br><span class="line">sudo apt-get install libswitch-perl</span><br></pre></td></tr></table></figure>

<p>安装注意事项： <img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/20191224165624.png" alt></p>
<h4 id="3-开始编译-在源码的目录下-执行一下命令"><a href="#3-开始编译-在源码的目录下-执行一下命令" class="headerlink" title="3. 开始编译, 在源码的目录下, 执行一下命令:"></a>3. 开始编译, 在源码的目录下, 执行一下命令:</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd ~/android_source</span><br><span class="line">make clean(如果之前有编译过，则需要调用这个命令)</span><br><span class="line">make</span><br></pre></td></tr></table></figure>

<h4 id="注意-ubuntu自带的源中速度比较慢-有些软件找不到-所以需要修改为国内的源-修改源步骤如下"><a href="#注意-ubuntu自带的源中速度比较慢-有些软件找不到-所以需要修改为国内的源-修改源步骤如下" class="headerlink" title="注意: ubuntu自带的源中速度比较慢, 有些软件找不到, 所以需要修改为国内的源, 修改源步骤如下:"></a>注意: ubuntu自带的源中速度比较慢, 有些软件找不到, 所以需要修改为国内的源, 修改源步骤如下:</h4><ul>
<li><p>1). 备份ubuntu自带的源.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo cp /etc/apt/sources.list /etc/apt/sources.list.old</span><br></pre></td></tr></table></figure>
</li>
<li><p>2). 修改源文件.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo gedit /etc/apt/sources.list</span><br></pre></td></tr></table></figure>
</li>
<li><p>3). 这时会弹出一个文本编辑框, 先删除所有内容, 然后把以下内容拷贝进去, 并保存.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">deb http://mirrors.163.com/ubuntu/ trusty main restricted universe multiverse</span><br><span class="line">deb http://mirrors.163.com/ubuntu/ trusty-security main restricted universe multiverse</span><br><span class="line">deb http://mirrors.163.com/ubuntu/ trusty-updates main restricted universe multiverse</span><br><span class="line">deb http://mirrors.163.com/ubuntu/ trusty-proposed main restricted universe multiverse</span><br><span class="line">deb http://mirrors.163.com/ubuntu/ trusty-backports main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.163.com/ubuntu/ trusty main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.163.com/ubuntu/ trusty-security main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.163.com/ubuntu/ trusty-updates main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.163.com/ubuntu/ trusty-proposed main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.163.com/ubuntu/ trusty-backports main restricted universe multiverse</span><br><span class="line"></span><br><span class="line">deb http://mirrors.sohu.com/ubuntu/ trusty main restricted universe multiverse</span><br><span class="line">deb http://mirrors.sohu.com/ubuntu/ trusty-security main restricted universe multiverse</span><br><span class="line">deb http://mirrors.sohu.com/ubuntu/ trusty-updates main restricted universe multiverse</span><br><span class="line">deb http://mirrors.sohu.com/ubuntu/ trusty-proposed main restricted universe multiverse</span><br><span class="line">deb http://mirrors.sohu.com/ubuntu/ trusty-backports main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.sohu.com/ubuntu/ trusty main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.sohu.com/ubuntu/ trusty-security main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.sohu.com/ubuntu/ trusty-updates main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.sohu.com/ubuntu/ trusty-proposed main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.sohu.com/ubuntu/ trusty-backports main restricted universe multiverse</span><br></pre></td></tr></table></figure>
</li>
<li><p>4). 保存之后, 更新数据源.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get update</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p><strong>本帖附件</strong></p>
<p><a href="https://u21519047.pipipan.com/fs/21519047-395416051" target="_blank" rel="noopener">点击下载</a></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em>乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</em></p>
]]></content>
      <tags>
        <tag>android源码</tag>
      </tags>
  </entry>
  <entry>
    <title>Android 设置TextView Drawable大小的几种方法</title>
    <url>/68.html</url>
    <content><![CDATA[<h2 id="第一种-使用-layer-list"><a href="#第一种-使用-layer-list" class="headerlink" title="第一种 使用 layer-list"></a>第一种 使用 layer-list</h2><figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"utf-8"</span>?&gt;</span><br><span class="line">&lt;layer-list xmlns:android=<span class="string">"http://schemas.android.com/apk/res/android"</span>&gt;</span><br><span class="line">&lt;!--设置图片的大小  --&gt;</span><br><span class="line">    &lt;item</span><br><span class="line">        android:width=<span class="string">"45dp"</span></span><br><span class="line">        android:height=<span class="string">"45dp"</span>&gt;</span><br><span class="line">        &lt;bitmap android:src=<span class="string">"@drawable/icon_profit"</span> /&gt;</span><br><span class="line">    &lt;/item&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;/layer-list&gt;</span><br></pre></td></tr></table></figure>

<h2 id="第二种-使用自定义控件"><a href="#第二种-使用自定义控件" class="headerlink" title="第二种 使用自定义控件"></a>第二种 使用自定义控件</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 可自定义设置drawable宽高的TextView</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DrawableTextView</span> <span class="keyword">extends</span> <span class="title">AppCompatTextView</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Drawable drawableLeft;</span><br><span class="line">    <span class="keyword">private</span> Drawable drawableRight;</span><br><span class="line">    <span class="keyword">private</span> Drawable drawableTop;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> leftWidth;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> rightWidth;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> topWidth;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> leftHeight;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> rightHeight;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> topHeight;</span><br><span class="line">    <span class="keyword">private</span> Context mContext;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DrawableTextView</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context);</span><br><span class="line">        <span class="keyword">this</span>.mContext = context;</span><br><span class="line">        init(context, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DrawableTextView</span><span class="params">(Context context, AttributeSet attrs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context, attrs);</span><br><span class="line">        <span class="keyword">this</span>.mContext = context;</span><br><span class="line">        init(context, attrs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DrawableTextView</span><span class="params">(Context context, AttributeSet attrs, <span class="keyword">int</span> defStyleAttr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context, attrs, defStyleAttr);</span><br><span class="line">        <span class="keyword">this</span>.mContext = context;</span><br><span class="line">        init(context, attrs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(Context context, AttributeSet attrs)</span> </span>&#123;</span><br><span class="line">        TypedArray typedArray = context.obtainStyledAttributes(attrs, R.styleable.DrawableTextView);</span><br><span class="line">        drawableLeft = typedArray.getDrawable(R.styleable.DrawableTextView_leftDrawable);</span><br><span class="line">        drawableRight = typedArray.getDrawable(R.styleable.DrawableTextView_rightDrawable);</span><br><span class="line">        drawableTop = typedArray.getDrawable(R.styleable.DrawableTextView_topDrawable);</span><br><span class="line">        <span class="keyword">if</span> (drawableLeft != <span class="keyword">null</span>) &#123;</span><br><span class="line">            leftWidth = typedArray.getDimensionPixelOffset(R.styleable.DrawableTextView_leftDrawableWidth, dip2px(context, <span class="number">20</span>));</span><br><span class="line">            leftHeight = typedArray.getDimensionPixelOffset(R.styleable.DrawableTextView_leftDrawableHeight, dip2px(context, <span class="number">20</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (drawableRight != <span class="keyword">null</span>) &#123;</span><br><span class="line">            rightWidth = typedArray.getDimensionPixelOffset(R.styleable.DrawableTextView_rightDrawableWidth, dip2px(context, <span class="number">20</span>));</span><br><span class="line">            rightHeight = typedArray.getDimensionPixelOffset(R.styleable.DrawableTextView_rightDrawableHeight, dip2px(context, <span class="number">20</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (drawableTop != <span class="keyword">null</span>) &#123;</span><br><span class="line">            topWidth = typedArray.getDimensionPixelOffset(R.styleable.DrawableTextView_topDrawableWidth, dip2px(context, <span class="number">20</span>));</span><br><span class="line">            topHeight = typedArray.getDimensionPixelOffset(R.styleable.DrawableTextView_topDrawableHeight, dip2px(context, <span class="number">20</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">dip2px</span><span class="params">(Context context, <span class="keyword">float</span> dpValue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">float</span> scale = context.getResources().getDisplayMetrics().density;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>) (dpValue * scale + <span class="number">0.5f</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onMeasure(widthMeasureSpec, heightMeasureSpec);</span><br><span class="line">        <span class="keyword">if</span> (drawableLeft != <span class="keyword">null</span>) &#123;</span><br><span class="line">            drawableLeft.setBounds(<span class="number">0</span>, <span class="number">0</span>, leftWidth, leftHeight);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (drawableRight != <span class="keyword">null</span>) &#123;</span><br><span class="line">            drawableRight.setBounds(<span class="number">0</span>, <span class="number">0</span>, rightWidth, rightHeight);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (drawableTop != <span class="keyword">null</span>) &#123;</span><br><span class="line">            drawableTop.setBounds(<span class="number">0</span>, <span class="number">0</span>, topWidth, topHeight);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDraw</span><span class="params">(Canvas canvas)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onDraw(canvas);</span><br><span class="line">        <span class="keyword">this</span>.setCompoundDrawables(drawableLeft, drawableTop, drawableRight, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置左侧图片并重绘</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDrawableLeft</span><span class="params">(Drawable drawableLeft)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.drawableLeft = drawableLeft;</span><br><span class="line">        invalidate();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置左侧图片并重绘</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDrawableLeft</span><span class="params">(<span class="keyword">int</span> drawableLeftRes)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.drawableLeft = mContext.getResources().getDrawable(drawableLeftRes);</span><br><span class="line">        invalidate();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置右侧图片并重绘</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDrawableRight</span><span class="params">(Drawable drawableRight)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.drawableRight = drawableLeft;</span><br><span class="line">        invalidate();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置右侧图片并重绘</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDrawableRight</span><span class="params">(<span class="keyword">int</span> drawableRightRes)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.drawableRight = mContext.getResources().getDrawable(drawableRightRes);</span><br><span class="line">        invalidate();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置上部图片并重绘</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDrawable</span><span class="params">(Drawable drawableTop)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.drawableTop = drawableTop;</span><br><span class="line">        invalidate();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置右侧图片并重绘</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDrawableTop</span><span class="params">(<span class="keyword">int</span> drawableTopRes)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.drawableTop = mContext.getResources().getDrawable(drawableTopRes);</span><br><span class="line">        invalidate();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>本帖附件</strong></p>
<p><a href="https://u21519047.pipipan.com/fs/21519047-395416051" target="_blank" rel="noopener">点击下载</a></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em>乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</em></p>
]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>Android系统架构简介</title>
    <url>/71.html</url>
    <content><![CDATA[<p>Android系统架构师安卓系统的体系机构，Android的系统架构和其他操作系统一样，采用了分层的架构，共分为4层，从高到低分别是Android应用层，Android应用架构层，Android系统运行层和Linux内核层。</p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/1141244-20190603163616072-1939226625.png" alt></p>
<p><strong>1. 应用程序</strong></p>
<p>顶层中有所有的Android应用程序，包括通讯录、浏览器等，你写的应用程序也被安装在这层；所有的的应用程序都是使用Java语言编写的。</p>
<p><strong>2.  应用框架层</strong></p>
<p>这一层主要提供构建应用程序是可能用到的各种API，Android自带的一些核心应用就是使用这些API完成的，开发者也可以通过使用API来构建自己的应用程序</p>
<p>活动管理者（Activity Manager）：控制应用程序生命周期和活动栈的所有方面</p>
<p>内容提供器（Content Providers）：允许程序之间发布和分享数据。</p>
<p>资源管理器（Resource Manager）：提供对非代码嵌入资源的访问，如字符串、颜色设置和用户界面布局。</p>
<p>通知管理器（Notification Manager）：允许应用程序显示对话框或者通知给用户</p>
<p>视图系统（View System）：一个可拓展的视图集合，用于创建应用程序用户界面</p>
<p><strong>3. 系统运行库层</strong></p>
<p>1） 程序库</p>
<p>Android包含一些C/C++库，这些库能被Android系统中不同的组件使用。他们通过Android应用程序框架为开发者提供服务，以下是一些核心库：</p>
<ul>
<li>系统C库（libc）:一个从BSD继承来的标准C系统函数库，他是专门为基于embedded linux的设备定制的媒体库（Media Framework）：基于Packet Video opencore; 该库支持多种常用的音频、视频格式回放和录制，同时支持静态图像文件。编码格式包括 MPEG4。H264、MP3、AAC、AMR、JPG、PNG。</li>
<li>Surface Manager：对显示子系统的管理，并且为多个应用程序提供了2D和3D图层的无缝融合。</li>
<li>SGL：底层的2D图形引擎</li>
<li>3D libraries：基于OpenFLES1.0 APLs实现，该库可以使用硬件3D加速或者使用高度优化3D软加速</li>
<li>FreeType：位图（bitmap）和矢量（vector）字体显示</li>
<li>SQLite：一个对于所有应用程序可用，功能强劲的轻型关系型数据库引擎。</li>
</ul>
<p>2） Android运行库</p>
<p>Android包括了一个核心库，该核心库提供了Java编程语言核心库的大多数功能。</p>
<p>每一个Android应用程序都在它自己的进程中运行，都拥有一个独立的Dalvik虚拟机实例。Dalvik被设计成一个设备可以同时高效地运行多个虚拟系统。Dalvik虚拟机执行（.dex）的Dalvik可执行文件，该个税文件针对小内存使用做了优化。同时虚拟机是基于寄存器的，所有的类都经由java编译器编译，然后通过SDK中的”dx”工具转化成 .dex格式由虚拟机执行</p>
<p>Dalvik虚拟机依赖于linux内核的一些功能，比如线程机制和底层内存管理机制。</p>
<p><strong>4. Linux内核层</strong></p>
<p>Android系统基于Linux2.6内核，这一层为Android设备各种硬件提供了底层驱动，如显示驱动，音频驱动，照相机驱动，蓝牙驱动，WIFI驱动，电源管理等</p>
<p><strong>区别DVM与JVM</strong></p>
<ol>
<li>首要差别</li>
</ol>
<p>1Dalvik：基于寄存器，编译和运行都会更快些</p>
<p>JVM：基于栈，编译和运行都会慢一些</p>
<ol start="2">
<li>字节码的区别</li>
</ol>
<p>Dalvik：执行.dex格式的字节码，是对.class文件进行压缩后产生的，文件变小</p>
<p>JVM：执行.class格式的字节码</p>
<ol start="3">
<li>运行环境的区别</li>
</ol>
<p>Dalvik： 一个应用启动都运行一个单独的虚拟机运行在一个单独的进程中</p>
<p>JVM：只能运行一个实例，也就是所有应用都运行在同一个JVM中</p>
<p><strong>本帖附件</strong></p>
<p><a href="https://u21519047.pipipan.com/fs/21519047-395416051" target="_blank" rel="noopener">点击下载</a></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em>乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</em></p>
]]></content>
      <tags>
        <tag>Android系统开发</tag>
      </tags>
  </entry>
  <entry>
    <title>Android系统的启动流程详解</title>
    <url>/70.html</url>
    <content><![CDATA[<h1 id="Android系统启动流程"><a href="#Android系统启动流程" class="headerlink" title="Android系统启动流程."></a>Android系统启动流程.</h1><h4 id="1-当系统引导程序启动Linux内核时-内核会加载各种数据结构和驱动程序-有了驱动之后-开始启动Android系统并加载用户级别的第一个进程init-system-core-init-Init-c"><a href="#1-当系统引导程序启动Linux内核时-内核会加载各种数据结构和驱动程序-有了驱动之后-开始启动Android系统并加载用户级别的第一个进程init-system-core-init-Init-c" class="headerlink" title="1.当系统引导程序启动Linux内核时, 内核会加载各种数据结构和驱动程序. 有了驱动之后, 开始启动Android系统并加载用户级别的第一个进程init(system/core/init/Init.c)."></a>1.当系统引导程序启动Linux内核时, 内核会加载各种数据结构和驱动程序. 有了驱动之后, 开始启动Android系统并加载用户级别的第一个进程init(system/core/init/Init.c).</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int main(int argc, char **argv)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    // 创建各种文件夹和挂载目录.</span><br><span class="line">    mkdir(&quot;/dev&quot;, 0755);</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    // 初始化日志.</span><br><span class="line">    log_init();</span><br><span class="line"></span><br><span class="line">    // 解析配置文件.</span><br><span class="line">    init_parse_config_file(&quot;/init.rc&quot;);</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-加载Init-rc文件-主要启动了一个Zygote-孵化器-进程-此进程是Android系统启动关键服务的一个母进程"><a href="#2-加载Init-rc文件-主要启动了一个Zygote-孵化器-进程-此进程是Android系统启动关键服务的一个母进程" class="headerlink" title="2.加载Init.rc文件. 主要启动了一个Zygote(孵化器)进程, 此进程是Android系统启动关键服务的一个母进程."></a>2.加载Init.rc文件. 主要启动了一个Zygote(孵化器)进程, 此进程是Android系统启动关键服务的一个母进程.</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">service zygote /system/bin/app_process -Xzygote /system/bin --zygote --start-system-server</span><br><span class="line">    socket zygote stream 666</span><br><span class="line">    onrestart write /sys/android_power/request_state wake</span><br><span class="line">    onrestart write /sys/power/state on</span><br><span class="line">    onrestart restart media</span><br><span class="line">    onrestart restart netd</span><br></pre></td></tr></table></figure>

<h4 id="3-Zygote进程的初始化在App-main-cpp文件中开启-代码片段如下"><a href="#3-Zygote进程的初始化在App-main-cpp文件中开启-代码片段如下" class="headerlink" title="3.Zygote进程的初始化在App_main.cpp文件中开启, 代码片段如下:"></a>3.Zygote进程的初始化在App_main.cpp文件中开启, 代码片段如下:</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int main(int argc, const char* const argv[])</span><br><span class="line">&#123;</span><br><span class="line">    // 定义Android运行时环境.</span><br><span class="line">    AppRuntime runtime;</span><br><span class="line">    int i = runtime.addVmArguments(argc, argv);</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    bool startSystemServer = (i &lt; argc) ? </span><br><span class="line">            strcmp(argv[i], &quot;--start-system-server&quot;) == 0 : false;</span><br><span class="line">    setArgv0(argv0, &quot;zygote&quot;);</span><br><span class="line">    set_process_name(&quot;zygote&quot;);</span><br><span class="line"></span><br><span class="line">    // 使用运行时环境启动Zygote的初始化类.</span><br><span class="line">    runtime.start(&quot;com.android.internal.os.ZygoteInit&quot;,</span><br><span class="line">        startSystemServer);</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-现在从c或c-代码进入到java代码中-ZygoteInit-java初始化类-代码如下"><a href="#4-现在从c或c-代码进入到java代码中-ZygoteInit-java初始化类-代码如下" class="headerlink" title="4.现在从c或c++代码进入到java代码中, ZygoteInit.java初始化类, 代码如下:"></a>4.现在从c或c++代码进入到java代码中, ZygoteInit.java初始化类, 代码如下:</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void main(String argv[]) &#123;</span><br><span class="line">    // 加载系统运行依赖的class类.</span><br><span class="line">    preloadClasses();</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    if (argv[1].equals(&quot;true&quot;)) &#123;</span><br><span class="line">        // Zygote孵化器进程开始孵化系统核心服务.</span><br><span class="line">        startSystemServer();</span><br><span class="line">    &#125; else if (!argv[1].equals(&quot;false&quot;)) &#123;</span><br><span class="line">        throw new RuntimeException(argv[0] + USAGE_STRING);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static boolean startSystemServer()</span><br><span class="line">    throws MethodAndArgsCaller, RuntimeException &#123;</span><br><span class="line">    String args[] = &#123;</span><br><span class="line">        &quot;--setuid=1000&quot;,</span><br><span class="line">        &quot;--setgid=1000&quot;,</span><br><span class="line">        &quot;--setgroups=1001,1002,1003,1004,1005,1006,1007,1008,1009,1010,3001,3002,3003&quot;,</span><br><span class="line">        &quot;--capabilities=130104352,130104352&quot;,</span><br><span class="line">        &quot;--runtime-init&quot;,</span><br><span class="line">        &quot;--nice-name=system_server&quot;,</span><br><span class="line">        &quot;com.android.server.SystemServer&quot;,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    // 孵化器分叉开启SystemServer类, 并且把上面定义的参数.</span><br><span class="line">    // 传递给此类. 用于启动系统关键服务.</span><br><span class="line">    pid = Zygote.forkSystemServer(</span><br><span class="line">            parsedArgs.uid, parsedArgs.gid,</span><br><span class="line">            parsedArgs.gids, debugFlags, null,</span><br><span class="line">            parsedArgs.permittedCapabilities,</span><br><span class="line">            parsedArgs.effectiveCapabilities);</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5-Zygote进程分叉出SystemServer类-main函数如下"><a href="#5-Zygote进程分叉出SystemServer类-main函数如下" class="headerlink" title="5.Zygote进程分叉出SystemServer类, main函数如下:"></a>5.Zygote进程分叉出SystemServer类, main函数如下:</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    // 加载本地的动态链接库.</span><br><span class="line">    System.loadLibrary(&quot;android_servers&quot;);</span><br><span class="line"></span><br><span class="line">    // 调用动态链接库中的c函数.</span><br><span class="line">    init1(args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 这里init1的函数定义在frameworks\base\services\jni\com_android_server_SystemServer.cpp下的方法.</span><br><span class="line">native public static void init1(String[] args);</span><br></pre></td></tr></table></figure>

<h4 id="6-comandroidserver-SystemServer-cpp的代码片段如下"><a href="#6-comandroidserver-SystemServer-cpp的代码片段如下" class="headerlink" title="6.comandroidserver_SystemServer.cpp的代码片段如下:"></a>6.com<em>android</em>server_SystemServer.cpp的代码片段如下:</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static JNINativeMethod gMethods[] = &#123;</span><br><span class="line">    /* name, signature, funcPtr */</span><br><span class="line">    // 把native方法init1, 映射到android_server_SystemServer_init1. (这里是定义的函数指针)</span><br><span class="line">    &#123; &quot;init1&quot;, &quot;([Ljava/lang/String;)V&quot;, (void*) android_server_SystemServer_init1 &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">static void android_server_SystemServer_init1(JNIEnv* env, jobject clazz)</span><br><span class="line">&#123;</span><br><span class="line">    // 转调</span><br><span class="line">    system_init();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 此方法没有方法体.</span><br><span class="line">extern &quot;C&quot; int system_init();</span><br></pre></td></tr></table></figure>

<h4 id="7-system-init方法的方法体-在System-init-cpp类中-代码如下"><a href="#7-system-init方法的方法体-在System-init-cpp类中-代码如下" class="headerlink" title="7.system_init方法的方法体, 在System_init.cpp类中. 代码如下:"></a>7.system_init方法的方法体, 在System_init.cpp类中. 代码如下:</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">extern &quot;C&quot; status_t system_init()</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    // 开启一些硬件相关的服务.</span><br><span class="line">    SensorService::instantiate();</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    // 获取Android运行时环境</span><br><span class="line">    AndroidRuntime* runtime = AndroidRuntime::getRuntime();</span><br><span class="line"></span><br><span class="line">    LOGI(&quot;System server: starting Android services.\n&quot;);</span><br><span class="line">    // 调用SystemServer类中静态方法init2. 从native层转到java层.</span><br><span class="line">    runtime-&gt;callStatic(&quot;com/android/server/SystemServer&quot;, &quot;init2&quot;);</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="8-SystemServer下init2方法如下"><a href="#8-SystemServer下init2方法如下" class="headerlink" title="8.SystemServer下init2方法如下:"></a>8.SystemServer下init2方法如下:</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static final void init2() &#123;</span><br><span class="line">    Slog.i(TAG, &quot;Entered the Android system server!&quot;);</span><br><span class="line"></span><br><span class="line">    // 进入Android系统服务的初始化.</span><br><span class="line">    Thread thr = new ServerThread();</span><br><span class="line">    thr.setName(&quot;android.server.ServerThread&quot;);</span><br><span class="line">    thr.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="9-ServerThread中的run方法如下"><a href="#9-ServerThread中的run方法如下" class="headerlink" title="9.ServerThread中的run方法如下:"></a>9.ServerThread中的run方法如下:</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void run() &#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    // 初始化系统的服务, 并且把服务添加ServiceManager中, 便于以后系统进行统一管理.</span><br><span class="line">    ServiceManager.addService(&quot;entropy&quot;, new EntropyService());</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    // 调用了ActivityManagerService的systemReady的方法.</span><br><span class="line">    ((ActivityManagerService)ActivityManagerNative.getDefault())</span><br><span class="line">            .systemReady(new Runnable() &#123;</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="10-ActivityManagerService下的systemReady方法如下"><a href="#10-ActivityManagerService下的systemReady方法如下" class="headerlink" title="10.ActivityManagerService下的systemReady方法如下:"></a>10.ActivityManagerService下的systemReady方法如下:</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void systemReady(final Runnable goingCallback) &#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    // 调用了ActivityStack中的resumeTopActivityLocked去启动Activity</span><br><span class="line">    mMainStack.resumeTopActivityLocked(null);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="11-ActivityStack中的resumeTopActivityLocked方法如下"><a href="#11-ActivityStack中的resumeTopActivityLocked方法如下" class="headerlink" title="11.ActivityStack中的resumeTopActivityLocked方法如下:"></a>11.ActivityStack中的resumeTopActivityLocked方法如下:</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">final boolean resumeTopActivityLocked(ActivityRecord prev) &#123;</span><br><span class="line">        // 找到第一个当前没有关闭的Activity, 系统刚刚系统没有任何Activity执行, 所以next为null</span><br><span class="line">        ActivityRecord next = topRunningActivityLocked(null);</span><br><span class="line"></span><br><span class="line">        // Remember how we&apos;ll process this pause/resume situation, and ensure</span><br><span class="line">        // that the state is reset however we wind up proceeding.</span><br><span class="line">        final boolean userLeaving = mUserLeaving;</span><br><span class="line">        mUserLeaving = false;</span><br><span class="line"></span><br><span class="line">        if (next == null) &#123;</span><br><span class="line">            // There are no more activities!  Let&apos;s just start up the</span><br><span class="line">            // Launcher...</span><br><span class="line">            if (mMainStack) &#123;</span><br><span class="line">                // 开启Launcher应用的第一个Activity界面.</span><br><span class="line">                return mService.startHomeActivityLocked();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="12-home界面显示-这时Android系统启动完毕-进入到待机画面"><a href="#12-home界面显示-这时Android系统启动完毕-进入到待机画面" class="headerlink" title="12.home界面显示, 这时Android系统启动完毕. 进入到待机画面."></a>12.home界面显示, 这时Android系统启动完毕. 进入到待机画面.</h4><p><strong>本帖附件</strong></p>
<p><a href="https://u21519047.pipipan.com/fs/21519047-395416051" target="_blank" rel="noopener">点击下载</a></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em>乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</em></p>
]]></content>
      <tags>
        <tag>Android系统</tag>
      </tags>
  </entry>
  <entry>
    <title>dom4j解析XML常用方法</title>
    <url>/77.html</url>
    <content><![CDATA[<h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">//读取xml</span></span><br><span class="line">SAXReader reader = <span class="keyword">new</span> SAXReader();  </span><br><span class="line">Document   <span class="built_in">document</span> = reader.read(<span class="keyword">new</span> File(<span class="string">"input.xml"</span>));  </span><br><span class="line"><span class="comment">// 获取根节点</span></span><br><span class="line"><span class="built_in">Element</span> root = <span class="built_in">document</span>.getRootElement();      </span><br><span class="line"><span class="comment">// 获取孩子节点</span></span><br><span class="line"><span class="built_in">Iterator</span>&lt;<span class="built_in">Element</span>&gt; it1 = root.elementIterator();</span><br><span class="line"><span class="comment">// 获取属性</span></span><br><span class="line"><span class="built_in">Iterator</span>&lt;Attribute&gt; attributes = ele.attributeIterator();</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">以上两个获取孩子节点和属性都是获取迭代器, 通过it.hasnext()方法可以遍历得到所有的节点和属性.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 获取节点名</span></span><br><span class="line">ele.getName()</span><br><span class="line"><span class="comment">// 获取节点值</span></span><br><span class="line">ele.getText()</span><br><span class="line"><span class="comment">// 获取属性名</span></span><br><span class="line">ele.getBName</span><br><span class="line"><span class="comment">// 获取属性值</span></span><br><span class="line">ele.getValue()    </span><br><span class="line"><span class="comment">// 设置文本</span></span><br><span class="line">ele.setText(<span class="string">"张三"</span>);</span><br><span class="line"><span class="comment">//设置属性</span></span><br><span class="line">ele.addAttribute(<span class="string">"show"</span>, <span class="string">"yes"</span>);</span><br><span class="line"><span class="comment">//添加注释</span></span><br><span class="line">ele.addComment(<span class="string">"This is a test for dom4j "</span>)</span><br><span class="line"><span class="comment">// 删除子节点</span></span><br><span class="line">ele.remove(element);</span><br></pre></td></tr></table></figure>

<h3 id="创建XML"><a href="#创建XML" class="headerlink" title="创建XML"></a>创建XML</h3><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">CreateXML</span> </span>&#123;</span><br><span class="line">    public <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="built_in">String</span>[] args) throws Exception &#123;</span><br><span class="line">        <span class="comment">// 创建文档对象</span></span><br><span class="line">        Document <span class="built_in">document</span> = DocumentHelper.createDocument();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 创建根节点</span></span><br><span class="line">        <span class="built_in">Element</span> root = <span class="built_in">document</span>.addElement(<span class="string">"root"</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 添加节点信息</span></span><br><span class="line">        <span class="built_in">Element</span> auther1 = root.addElement(<span class="string">"auther"</span>)</span><br><span class="line">                .addAttribute(<span class="string">"name"</span>, <span class="string">"Tom"</span>)        <span class="comment">// 属性</span></span><br><span class="line">                .addAttribute(<span class="string">"loation"</span>, <span class="string">"UK"</span>)      </span><br><span class="line">                .addText(<span class="string">"Tom Wang"</span>);               <span class="comment">// 节点内容</span></span><br><span class="line">        </span><br><span class="line">        <span class="built_in">Element</span> auther2 = root.addElement(<span class="string">"auther"</span>)</span><br><span class="line">                .addAttribute(<span class="string">"name"</span>, <span class="string">"Ted"</span>)</span><br><span class="line">                .addAttribute(<span class="string">"loation"</span>, <span class="string">"USA"</span>)</span><br><span class="line">                .addText(<span class="string">"Ted Chen"</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 输出到xml文件</span></span><br><span class="line">        FileWriter out = <span class="keyword">new</span> FileWriter(<span class="string">"src/new.xml"</span>);</span><br><span class="line">        <span class="built_in">document</span>.write(out);</span><br><span class="line">        out.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="输出的内容为"><a href="#输出的内容为" class="headerlink" title="输出的内容为"></a>输出的内容为</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--new.xml--&gt;</span></span><br><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">root</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">auther</span> <span class="attr">name</span>=<span class="string">"Tom"</span> <span class="attr">loation</span>=<span class="string">"UK"</span>&gt;</span>Tom Wang<span class="tag">&lt;/<span class="name">auther</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">auther</span> <span class="attr">name</span>=<span class="string">"Ted"</span> <span class="attr">loation</span>=<span class="string">"USA"</span>&gt;</span>Ted Chen<span class="tag">&lt;/<span class="name">auther</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="修改XML"><a href="#修改XML" class="headerlink" title="修改XML"></a>修改XML</h3><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建xml解析器对象reader</span></span><br><span class="line">SAXReader reader = <span class="keyword">new</span> SAXReader();</span><br><span class="line"><span class="comment">// 加载xml文件, 获取document对象</span></span><br><span class="line">Document <span class="built_in">document</span> = reader.read(<span class="string">"src/test_xml/first.xml"</span>);</span><br><span class="line"><span class="comment">//选定节点属性集 xpath写法 </span></span><br><span class="line"><span class="built_in">List</span> arrList = <span class="built_in">document</span>.selectNodes(<span class="string">"/books/book/@show"</span>)</span><br><span class="line"><span class="built_in">Iterator</span> arrIter = arrList.iterator();  </span><br><span class="line"></span><br><span class="line"><span class="comment">//选定节点集</span></span><br><span class="line"><span class="built_in">List</span> list = <span class="built_in">document</span>.selectNodes(<span class="string">"/books/book/title"</span>)</span><br><span class="line"><span class="built_in">Iterator</span> texIter = list.iterator(); </span><br><span class="line"><span class="comment">//修改节点属性</span></span><br><span class="line"><span class="keyword">while</span> (arrIter.hasNext()) &#123;  </span><br><span class="line">    Attribute attribute = (Attribute) iter.next();  </span><br><span class="line">    <span class="keyword">if</span> (attribute.getValue().equals(<span class="string">"yes"</span>))   </span><br><span class="line">        attribute.setValue(<span class="string">"no"</span>); </span><br><span class="line">&#125;  </span><br><span class="line"> <span class="comment">//修改节点文本内容 </span></span><br><span class="line"><span class="keyword">while</span> (texIter.hasNext()) &#123;  </span><br><span class="line">     <span class="built_in">Element</span> element = (<span class="built_in">Element</span>) iter.next();  </span><br><span class="line">  	 element.setText(<span class="string">"xxx"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="字符串转XML"><a href="#字符串转XML" class="headerlink" title="字符串转XML"></a>字符串转XML</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">String text = &quot;&lt;members&gt; &lt;member&gt;sitinspring&lt;/member&gt; &lt;/members&gt;&quot;;      </span><br><span class="line">Document document = DocumentHelper.parseText(text);</span><br></pre></td></tr></table></figure>

<h3 id="XML转字符串"><a href="#XML转字符串" class="headerlink" title="XML转字符串"></a>XML转字符串</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 创建xml解析器对象reader</span><br><span class="line">SAXReader reader = new SAXReader();</span><br><span class="line">// 加载xml文件, 获取document对象</span><br><span class="line">Document document = reader.read(&quot;src/test_xml/first.xml&quot;);</span><br><span class="line">//xml转换成字符串</span><br><span class="line">String memberXmlText=document.asXML();</span><br></pre></td></tr></table></figure>

<p><strong>本帖附件</strong></p>
<p><a href="https://u21519047.pipipan.com/fs/21519047-395416051" target="_blank" rel="noopener">点击下载</a></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em>乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</em></p>
]]></content>
      <tags>
        <tag>xml</tag>
      </tags>
  </entry>
  <entry>
    <title>Android源码下载</title>
    <url>/74.html</url>
    <content><![CDATA[<blockquote>
<p>Android源码下载支持的系统目前只有Ubuntu和Mac OS两种操作系统, 本次以Ubuntu系统为例.</p>
<p>官方网站: <a href="http://source.android.com/source/downloading.html" target="_blank" rel="noopener">http://source.android.com/source/downloading.html</a></p>
<p>下载单独项目的源码：<a href="https://github.com/android" target="_blank" rel="noopener">https://github.com/android</a></p>
</blockquote>
<ol>
<li><p>下载Git(版本控制工具). 调出命令行: ctrl + alt + T</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get install git   （下载地址在源中,&quot;系统设置/软件和更新&quot;,路径：/etc/apt/sources.list）</span><br></pre></td></tr></table></figure>
</li>
<li><p>安装curl(上传和下载数据的工具).</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get install curl</span><br></pre></td></tr></table></figure>
</li>
<li><p>安装repo(一个基于git的版本库管理工具, 这里用于自动批量下载android整个项目.).</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 创建目录</span><br><span class="line">mkdir ~/bin</span><br><span class="line"></span><br><span class="line">// 下载repo脚本到本地bin文件夹下</span><br><span class="line">curl http://android.git.kernel.org/repo &gt;~/bin/repo  （官网：curl https://storage.googleapis.com/git-repo-downloads/repo &gt; ~/bin/repo）</span><br><span class="line">// 如果上面下载失败, 采用下面这种方式</span><br><span class="line">curl &quot;http://php.webtutor.pl/en/wp-content/uploads/2011/09/repo&quot; &gt;~/bin/repo</span><br><span class="line"></span><br><span class="line">// 给所有用户追加可执行的权限</span><br><span class="line">chmod a+x ~/bin/repo</span><br><span class="line"></span><br><span class="line">// 临时把repo添加到环境变量中, 方便后面执行.</span><br><span class="line">// 注意: 每次重启ubuntu之后此环境变量失效, 重新配置就可以了.</span><br><span class="line">export PATH=~/bin:$PATH</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建文件夹, 用于存放下载的Android源码.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 创建目录</span><br><span class="line">mkdir ~/android_source </span><br><span class="line"></span><br><span class="line">// 修改权限</span><br><span class="line">chmod 777 ~/android_source</span><br><span class="line"></span><br><span class="line">cd ~/android_source</span><br></pre></td></tr></table></figure>
</li>
<li><p>初始化库.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 需要先配置git的用户信息</span><br><span class="line">git config --global user.email &quot;dai_zhenliang@163.com&quot;</span><br><span class="line">git config --global user.name &quot;haha&quot;</span><br><span class="line"></span><br><span class="line">repo init -u https://android.googlesource.com/platform/manifest -b android-2.3_r1</span><br><span class="line"></span><br><span class="line">// 如果上面初始化失败, 用下面的代码</span><br><span class="line">repo init -u git://codeaurora.org/platform/manifest.git -b gingerbread</span><br></pre></td></tr></table></figure>

<h6 id="当屏幕出现以下信息表示成功初始化"><a href="#当屏幕出现以下信息表示成功初始化" class="headerlink" title="当屏幕出现以下信息表示成功初始化"></a>当屏幕出现以下信息表示成功初始化</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">repo initialized in /home/haha/android_source</span><br></pre></td></tr></table></figure>
</li>
<li><p>开始同步下载.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">repo sync</span><br></pre></td></tr></table></figure>

<p><strong>注意: 下载过程中, 因为网络问题, 可能会中断下载. 当中断下载时, 继续使用repo sync命令继续下载.</strong></p>
</li>
</ol>
<p><strong>本帖附件</strong></p>
<p><a href="https://u21519047.pipipan.com/fs/21519047-395416051" target="_blank" rel="noopener">点击下载</a></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em>乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</em></p>
]]></content>
      <tags>
        <tag>android源码</tag>
      </tags>
  </entry>
  <entry>
    <title>Android中Aop和Apt有什么区别?</title>
    <url>/75.html</url>
    <content><![CDATA[<h3 id="什么是Aop"><a href="#什么是Aop" class="headerlink" title="什么是Aop?"></a>什么是Aop?</h3><p>AOP指的是:<strong>面向切面编程(Aspect-Oriented Programming)</strong>。如果说，OOP如果是把问题划分到单个模块的话，那么AOP就是把涉及到众多模块的某一类问题进行统一管理。</p>
<p><strong>代表框架：</strong></p>
<ul>
<li>Hugo(Jake Wharton)</li>
<li>SSH</li>
<li>SpringMVC</li>
</ul>
<p><strong>Android 中应用</strong></p>
<ul>
<li>日志</li>
<li>持久化</li>
<li>性能监控</li>
<li>数据校验</li>
<li>缓存</li>
<li>按钮防抖</li>
<li><a href="https://link.jianshu.com/?t=http://en.wikipedia.org/wiki/Cross-cutting_concern" target="_blank" rel="noopener">其他更多</a></li>
</ul>
<p>Android AOP就是通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术。利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，提高开发效率</p>
<h4 id="使用姿势"><a href="#使用姿势" class="headerlink" title="使用姿势"></a><strong>使用姿势</strong></h4><p>在Java中使用aop编程需要用到AspectJ切面框架,AspectJ定义了AOP语法，它有一个专门的编译器用来生成遵守Java字节编码规范的Class文件。</p>
<p><strong>1.在build.gradle文件中引入AspectJ</strong></p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">pply plugin: <span class="string">'com.android.application'</span></span><br><span class="line"><span class="keyword">import</span> org.aspectj.bridge.IMessage</span><br><span class="line"><span class="keyword">import</span> org.aspectj.bridge.MessageHandler</span><br><span class="line"><span class="keyword">import</span> org.aspectj.tools.ajc.Main</span><br><span class="line">android &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> def log = project.logger</span><br><span class="line"><span class="keyword">final</span> def variants = project.android.applicationVariants</span><br><span class="line">variants.all &#123; variant -&gt;</span><br><span class="line">    <span class="keyword">if</span> (!variant.buildType.isDebuggable()) &#123;</span><br><span class="line">        log.debug(<span class="string">"Skipping non-debuggable build type '<span class="subst">$&#123;variant.buildType.name&#125;</span>'."</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    JavaCompile javaCompile = variant.javaCompile</span><br><span class="line">    javaCompile.doLast &#123;</span><br><span class="line">        <span class="built_in">String</span>[] args = [<span class="string">"-showWeaveInfo"</span>,</span><br><span class="line">                         <span class="string">"-1.8"</span>,</span><br><span class="line">                         <span class="string">"-inpath"</span>, javaCompile.destinationDir.toString(),</span><br><span class="line">                         <span class="string">"-aspectpath"</span>, javaCompile.classpath.asPath,</span><br><span class="line">                         <span class="string">"-d"</span>, javaCompile.destinationDir.toString(),</span><br><span class="line">                         <span class="string">"-classpath"</span>, javaCompile.classpath.asPath,</span><br><span class="line">                         <span class="string">"-bootclasspath"</span>, project.android.bootClasspath.join(File.pathSeparator)]</span><br><span class="line">        log.debug <span class="string">"ajc args: "</span> + Arrays.toString(args)</span><br><span class="line"></span><br><span class="line">        MessageHandler handler = <span class="keyword">new</span> MessageHandler(<span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">new</span> Main().run(args, handler);</span><br><span class="line">        <span class="keyword">for</span> (IMessage message : handler.getMessages(<span class="keyword">null</span>, <span class="keyword">true</span>)) &#123;</span><br><span class="line">            <span class="keyword">switch</span> (message.getKind()) &#123;</span><br><span class="line">                <span class="keyword">case</span> IMessage.ABORT:</span><br><span class="line">                <span class="keyword">case</span> IMessage.ERROR:</span><br><span class="line">                <span class="keyword">case</span> IMessage.FAIL:</span><br><span class="line">                    log.error message.message, message.thrown</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> IMessage.WARNING:</span><br><span class="line">                    log.warn message.message, message.thrown</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> IMessage.INFO:</span><br><span class="line">                    log.info message.message, message.thrown</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> IMessage.DEBUG:</span><br><span class="line">                    log.debug message.message, message.thrown</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">    ...</span><br><span class="line">    implementation <span class="string">'org.aspectj:aspectjrt:1.8.9'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2.创建注解类</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.CLASS)</span><br><span class="line"><span class="meta">@Target</span>(ElementType.METHOD)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SingleClick &#123;</span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="title">clickIntervals</span><span class="params">()</span> <span class="keyword">default</span> 800</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>3.创建切面类</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 添加切面注解</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AopTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">"linhaojian"</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 定义切入点（定义那些类或者方法需要改变）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Pointcut</span>(<span class="string">"execution(*  com.lhj.test_apt..*ck(..))"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pointcut1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用注解方式，定义注解</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Pointcut</span>(<span class="string">"execution(@com.lhj.test_apt.DebugLog * *ck(..))"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pointcut</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 前置通知，切点之前执行</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> point</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Before</span>(<span class="string">"pointcut()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">logBefore</span><span class="params">(JoinPoint point)</span></span>&#123;</span><br><span class="line">        Log.e(TAG,<span class="string">"logBefore"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 环绕通知，切点前后执行</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> joinPoint</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Throwable</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Around</span>(<span class="string">"pointcut()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">logAround</span><span class="params">(ProceedingJoinPoint joinPoint)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        Log.e(TAG,<span class="string">"logAround"</span>);</span><br><span class="line">        <span class="comment">// 1.执行切点函数（如果不调用该方法，切点函数不被执行）</span></span><br><span class="line">        joinPoint.proceed();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 后置通知，切点之后执行</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Throwable</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@After</span>(<span class="string">"pointcut()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">logAfter</span><span class="params">(JoinPoint point)</span></span>&#123;</span><br><span class="line">        Log.e(TAG,<span class="string">"logAfter"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回通知，切点方法返回结果之后执行</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Throwable</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@AfterReturning</span>(<span class="string">"pointcut()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">logAfterReturning</span><span class="params">(JoinPoint point, Object returnValue)</span></span>&#123;</span><br><span class="line">        Log.e(TAG,<span class="string">"logAfterReturning "</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 异常通知，切点抛出异常时执行</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Throwable</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@AfterThrowing</span>(value = <span class="string">"pointcut()"</span>,throwing = <span class="string">"ex"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">logAfterThrowing</span><span class="params">(Throwable ex)</span></span>&#123;</span><br><span class="line">        Log.e(TAG,<span class="string">"logAfterThrowing : "</span>+ex.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>4.使用</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SingleClick</span>(clickIntervals = <span class="number">2000</span>)</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">        Toast.makeText(<span class="keyword">this</span>, <span class="string">"1"</span>, Toast.LENGTH_SHORT).show();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong>难点：</strong><br> AspectJ语法比较多，但是掌握几个简单常用的，就能实现绝大多数切片，完全兼容Java（纯Java语言开发，然后使用AspectJ注解，简称@AspectJ。）</p>
<p><strong>优点：</strong><br> AspectJ除了hook之外，AspectJ还可以为目标类添加变量,接口。另外，AspectJ也有抽象，继承等各种更高级的玩法。它能够在编译期间直接修改源代码生成class，强大的团战切入功能，指哪打哪，鞭辟入里。有了此神器，编程亦如庖丁解牛，游刃而有余。</p>
<h3 id="什么是Apt"><a href="#什么是Apt" class="headerlink" title="什么是Apt?"></a>什么是Apt?</h3><p><strong>APT(Annotation Processing Tool 的简称)</strong>，可以在代码编译期解析注解，并且生成新的 Java 文件，减少手动的代码输入</p>
<p><strong>代表框架：</strong></p>
<ul>
<li>DataBinding</li>
<li>Dagger2</li>
<li>ButterKnife</li>
<li>EventBus3</li>
<li>DBFlow</li>
<li>AndroidAnnotation</li>
</ul>
<h4 id="使用姿势-1"><a href="#使用姿势-1" class="headerlink" title="使用姿势"></a><strong>使用姿势</strong></h4><p><strong>1，在android工程中，创建一个java的Module，写一个类继承AbstractProcessor</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@AutoService(Processor.class) // javax.annotation.processing.IProcessor </span><br><span class="line">@SupportedSourceVersion(SourceVersion.RELEASE_7) //java </span><br><span class="line">@SupportedAnnotationTypes(&#123; // 标注注解处理器支持的注解类型 </span><br><span class="line">    &quot;com.annotation.SingleDelegate&quot;, </span><br><span class="line">    &quot;com.annotation.MultiDelegate&quot; </span><br><span class="line">&#125;) </span><br><span class="line">public class AnnotationProcessor extends AbstractProcessor &#123; </span><br><span class="line"> </span><br><span class="line">public static final String PACKAGE = &quot;com.poet.delegate&quot;; </span><br><span class="line">public static final String CLASS_DESC = &quot;From poet compiler&quot;; </span><br><span class="line"> </span><br><span class="line">public Filer filer; //文件相关的辅助类 </span><br><span class="line">public Elements elements; //元素相关的辅助类 </span><br><span class="line">public Messager messager; //日志相关的辅助类 </span><br><span class="line">public Types types; </span><br><span class="line"> </span><br><span class="line">@Override </span><br><span class="line">public boolean process(Set&lt;? extends TypeElement&gt; set, RoundEnvironment roundEnvironment) &#123; </span><br><span class="line">    filer = processingEnv.getFiler(); </span><br><span class="line">    elements = processingEnv.getElementUtils(); </span><br><span class="line">    messager = processingEnv.getMessager(); </span><br><span class="line">    types = processingEnv.getTypeUtils(); </span><br><span class="line"> </span><br><span class="line">    new SingleDelegateProcessor().process(set, roundEnvironment, this); </span><br><span class="line">    new MultiDelegateProcessor().process(set, roundEnvironment, this); </span><br><span class="line"> </span><br><span class="line">    return true; </span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2，重写AbstractProcessor类中的process方法，处理我们自定义的注解，生成代码：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class SingleDelegateProcessor implements IProcessor &#123;  </span><br><span class="line">@Override </span><br><span class="line">public void process(Set&lt;? extends TypeElement&gt; set, RoundEnvironment roundEnv, </span><br><span class="line">                AnnotationProcessor abstractProcessor) &#123; </span><br><span class="line">// 查询注解是否存在 </span><br><span class="line">Set&lt;? extends Element&gt; elementSet = </span><br><span class="line">        roundEnv.getElementsAnnotatedWith(SingleDelegate.class); </span><br><span class="line">Set&lt;TypeElement&gt; typeElementSet = ElementFilter.typesIn(elementSet); </span><br><span class="line">if (typeElementSet == null || typeElementSet.isEmpty()) &#123; </span><br><span class="line">    return; </span><br><span class="line">&#125;  </span><br><span class="line">// 循环处理注解 </span><br><span class="line">for (TypeElement typeElement : typeElementSet) &#123; </span><br><span class="line">    if (!(typeElement.getKind() == ElementKind.INTERFACE)) &#123; // 只处理接口类型 </span><br><span class="line">        continue; </span><br><span class="line">    &#125; </span><br><span class="line"> </span><br><span class="line">    // 处理 SingleDelegate，只处理 annotation.classNameImpl() 不为空的注解 </span><br><span class="line">    SingleDelegate annotation = typeElement.getAnnotation(SingleDelegate.class); </span><br><span class="line">    if (&quot;&quot;.equals(annotation.classNameImpl())) &#123; </span><br><span class="line">        continue; </span><br><span class="line">    &#125; </span><br><span class="line">    Delegate delegate = annotation.delegate(); </span><br><span class="line"> </span><br><span class="line">    // 添加构造器 </span><br><span class="line">    MethodSpec.Builder constructorBuilder = MethodSpec.constructorBuilder() </span><br><span class="line">            .addModifiers(Modifier.PUBLIC); </span><br><span class="line"> </span><br><span class="line">    // 创建类名相关 class builder </span><br><span class="line">    TypeSpec.Builder builder = </span><br><span class="line">            ProcessUtils.createTypeSpecBuilder(typeElement, annotation.classNameImpl()); </span><br><span class="line"> </span><br><span class="line">    // 处理 delegate </span><br><span class="line">    builder = ProcessUtils.processDelegate(typeElement, builder, </span><br><span class="line">            constructorBuilder, delegate); </span><br><span class="line"> </span><br><span class="line">    // 检查是否继承其它接口 </span><br><span class="line">    builder = processSuperSingleDelegate(abstractProcessor, builder, constructorBuilder, typeElement); </span><br><span class="line"> </span><br><span class="line">    // 完成构造器 </span><br><span class="line">    builder.addMethod(constructorBuilder.build()); </span><br><span class="line"> </span><br><span class="line">    // 创建 JavaFile </span><br><span class="line">    JavaFile javaFile = JavaFile.builder(AnnotationProcessor.PACKAGE, builder.build()).build(); </span><br><span class="line">    try &#123; </span><br><span class="line">        javaFile.writeTo(abstractProcessor.filer); </span><br><span class="line">    &#125; catch (IOException e) &#123; </span><br><span class="line">        e.printStackTrace(); </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>3，在项目Gradle中添加 annotationProcessor project 引用</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">compile project(&apos;:apt-delegate-annotation&apos;)  </span><br><span class="line">annotationProcessor project(&apos;:apt-delegate-compiler&apos;)</span><br></pre></td></tr></table></figure>

<p><strong>4，如果有自定义注解的话，创建一个java的Module，专门放入自定义注解。项目与apt Module都需引用自定义注解Module</strong></p>
<p><strong>4-1，主工程：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">compile project(&apos;:apt-delegate-annotation&apos;)  </span><br><span class="line">annotationProcessor project(&apos;:apt-delegate-compiler&apos;)</span><br></pre></td></tr></table></figure>

<p><strong>4-2，apt Module：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">compile project(&apos;:apt-delegate-annotation&apos;)  </span><br><span class="line">compile &apos;com.google.auto.service:auto-service:1.0-rc2&apos; </span><br><span class="line">compile &apos;com.squareup:javapoet:1.4.0&apos;</span><br></pre></td></tr></table></figure>

<p><strong>5，生成的源代码在build/generated/source/apt下可以看到</strong></p>
<p><strong>难点</strong></p>
<p>就apt本身来说没有任何难点可言，难点一在于设计模式和解耦思想的灵活应用，二在与代码生成的繁琐，你可以手动字符串拼接，当然有更高级的玩法用squareup的javapoet，用建造者的模式构建出任何你想要的源代码</p>
<p><strong>优点</strong></p>
<p>它的强大之处无需多言，看代表框架的源码，你可以学到很多新姿势。总的一句话：它可以做任何你不想做的繁杂的工作，它可以帮你写任何你不想重复代码。懒人福利，老司机必备神技，可以提高车速，让你以任何姿势漂移。它可以生成任何源代码供你在任何地方使用，就像剑客的剑，快疾如风，无所不及</p>
<h3 id="Aop和Apt对比"><a href="#Aop和Apt对比" class="headerlink" title="Aop和Apt对比"></a>Aop和Apt对比</h3><p>如图所示:</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/20191216203909.png" alt></p>
<p>和</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/20191216205936.png" alt></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em>乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</em></p>
]]></content>
      <tags>
        <tag>Aop</tag>
      </tags>
  </entry>
  <entry>
    <title>Git如何删除某次commit</title>
    <url>/78.html</url>
    <content><![CDATA[<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/20200106104212.png" alt></p>
<blockquote>
<p>在团队开发的时候, 经常会出现某次commit导致整个项目出现无法名状的错误, 这个时候, 最好的解决办法就是删除错误的commit</p>
</blockquote>
<h3 id="场景复现一"><a href="#场景复现一" class="headerlink" title="场景复现一"></a>场景复现一</h3><p><strong>1.假设有2个提交记录</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">commit def5adef853da4cc05752bdb36577c127be71ba5</span><br><span class="line"></span><br><span class="line">Author: xxx</span><br><span class="line">Date:   Thu Dec 28 16:01:36 2017 +0800</span><br><span class="line"></span><br><span class="line">优化代码</span><br><span class="line"></span><br><span class="line">commit f36801544670e00b2f59a28e19017d2786c4085e</span><br><span class="line">Author: xxx</span><br><span class="line">Date:   Thu Dec 28 15:59:46 2017 +0800</span><br><span class="line"></span><br><span class="line">修复</span><br><span class="line">(END)</span><br></pre></td></tr></table></figure>

<p><strong>2.现在需要回滚到上一次提交</strong></p>
<p>那么 我们可以使用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git reset --hard HEAD^</span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git reset --hard HEAD~1</span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git reset --hard f36801544670e00b2f59a28e19017d2786c4085e</span><br></pre></td></tr></table></figure>

<p><strong>3.执行完后 查看日志，就会发现只剩下一个提交了</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git log</span><br><span class="line"></span><br><span class="line">commit f36801544670e00b2f59a28e19017d2786c4085e</span><br><span class="line">Author: xxx</span><br><span class="line">Date:   Thu Dec 28 15:59:46 2017 +0800</span><br><span class="line"></span><br><span class="line">修复</span><br><span class="line">(END)</span><br></pre></td></tr></table></figure>

<p><strong>4.如果这个时候，你突然发现回退版本错了，那么就用git reflog查看提交记录</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git reflog</span><br><span class="line"></span><br><span class="line">f368015 HEAD@&#123;0&#125;: reset: moving to f36801544670e00b2f59a28e19017d2786c4085e</span><br><span class="line">def5ade HEAD@&#123;1&#125;: reset: moving to def5ade</span><br><span class="line">f368015 HEAD@&#123;2&#125;: reset: moving to f36801544670e00b2f59a28e19017d2786c4085e</span><br><span class="line">def5ade HEAD@&#123;3&#125;: commit: 优化代码</span><br><span class="line">f368015 HEAD@&#123;4&#125;: commit (initial): 修复</span><br></pre></td></tr></table></figure>

<p><strong>5.然后找出想要回退的版本，进行回退</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git reset --hard def5ade</span><br></pre></td></tr></table></figure>

<p> <strong>6.如果此时需要同步远程仓库, 需要使用强推</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git push -f</span><br></pre></td></tr></table></figure>

<p>因为我们本地库HEAD指向的版本比远程库的要旧</p>
<p>由此可见, <code>git reset</code>可以很方便的回滚到指定的历史commit, </p>
<p> <strong>但是它的劣势也很明显, 一旦回滚到指定commit, 那么后面提交的commit都会一并删除</strong></p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/20200103163234.png" alt></p>
<p>*<em>为了保留后面需要的的commit内容, 咱们可以使用另一种指令 *</em><code>git revert</code></p>
<h3 id="场景复现二"><a href="#场景复现二" class="headerlink" title="场景复现二"></a>场景复现二</h3><p><strong>1.假设有3个提交记录</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">commit def5adef853da4cc05752bdb36577c127be71ba5</span><br><span class="line"></span><br><span class="line">Author: xxx</span><br><span class="line">Date:   Thu Dec 28 16:01:36 2017 +0800</span><br><span class="line"></span><br><span class="line">优化代码</span><br><span class="line">commit 853dadef5adef4cc05752bdb36577c127be71ba5</span><br><span class="line"></span><br><span class="line">Author: xxx</span><br><span class="line">Date:   Thu Dec 28 16:01:36 2017 +0800</span><br><span class="line"></span><br><span class="line">增加文件</span><br><span class="line">commit f36801544670e00b2f59a28e19017d2786c4085e</span><br><span class="line">Author: xxx</span><br><span class="line">Date:   Thu Dec 28 15:59:46 2017 +0800</span><br><span class="line"></span><br><span class="line">修复</span><br><span class="line">(END)</span><br></pre></td></tr></table></figure>

<p><strong>2.现在我们不需要第二个commit的操作,也就是不需要  <em>增加文件</em>   这个操作</strong></p>
<p>那么, 我们可以使用<code>git revert -n</code> +版本号 命令进行反做</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git revert -n 853dadef5adef4cc05752bdb36577c127be71ba5</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong> 这里可能会出现冲突，那么需要手动修改冲突的文件, 然后重新add提交</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commit -m &quot;重做 增加文件&quot;</span><br></pre></td></tr></table></figure>

<p><strong>3.执行完后 查看日志，会发现原来的commit记录还在,同时新增了一个commit版本</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git log</span><br><span class="line"></span><br><span class="line">commit 05752def5adef853da4ccbdb36577c127be71ba5</span><br><span class="line">Author: xxx</span><br><span class="line">Date:   Thu Dec 28 16:01:36 2017 +0800</span><br><span class="line"></span><br><span class="line">重做 增加文件</span><br><span class="line"></span><br><span class="line">commit def5adef853da4cc05752bdb36577c127be71ba5</span><br><span class="line">Author: xxx</span><br><span class="line">Date:   Thu Dec 28 16:01:36 2017 +0800</span><br><span class="line"></span><br><span class="line">优化代码</span><br><span class="line">commit 853dadef5adef4cc05752bdb36577c127be71ba5</span><br><span class="line">Author: xxx</span><br><span class="line">Date:   Thu Dec 28 16:01:36 2017 +0800</span><br><span class="line"></span><br><span class="line">增加文件</span><br><span class="line">commit f36801544670e00b2f59a28e19017d2786c4085e</span><br><span class="line">Author: xxx</span><br><span class="line">Date:   Thu Dec 28 15:59:46 2017 +0800</span><br><span class="line"></span><br><span class="line">修复</span><br><span class="line">(END)</span><br></pre></td></tr></table></figure>

<p> <strong>4.如果此时需要同步远程仓库</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git push</span><br></pre></td></tr></table></figure>

<p>使用<code>git revert</code>这种方式既可以清除指定的commit操作, 同时可以保留后面的commit</p>
<p><strong>但是也存在一个让人不舒服的地方, 虽然操作被重写了,但是记录还在, 而且由新增了一个记录,感觉有些冗余</strong></p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/20200103173518.png" alt></p>
<p>为了解决这个问题, 最后我选择了第三种方式, 也就是使用 <code>git rebase</code> <strong>节点切片</strong></p>
<h3 id="场景复现三"><a href="#场景复现三" class="headerlink" title="场景复现三"></a>场景复现三</h3><p><strong>1.假设有3个提交记录</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">commit def5adef853da4cc05752bdb36577c127be71ba5</span><br><span class="line"></span><br><span class="line">Author: xxx</span><br><span class="line">Date:   Thu Dec 28 16:01:36 2017 +0800</span><br><span class="line"></span><br><span class="line">优化代码</span><br><span class="line">commit 853dadef5adef4cc05752bdb36577c127be71ba5</span><br><span class="line"></span><br><span class="line">Author: xxx</span><br><span class="line">Date:   Thu Dec 28 16:01:36 2017 +0800</span><br><span class="line"></span><br><span class="line">增加文件</span><br><span class="line">commit f36801544670e00b2f59a28e19017d2786c4085e</span><br><span class="line">Author: xxx</span><br><span class="line">Date:   Thu Dec 28 15:59:46 2017 +0800</span><br><span class="line"></span><br><span class="line">修复</span><br><span class="line">(END)</span><br></pre></td></tr></table></figure>

<p><strong>2.现在我们不需要第二个commit的操作,也就是不需要  <em>增加文件</em>   这个操作</strong></p>
<p>假设是master分值那么, 我们可以使用<code>git rebase --onto  [startpoint]  [endpoint]</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git rebase --onto master~853dade master~def5ade master</span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git rebase --onto master~2 master~1 master</span><br></pre></td></tr></table></figure>

<p>或者使用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git rebase i f368015 /把 需要改动那条 commit 前面的 pick 改成drop 然后, 保存退出即可</span><br></pre></td></tr></table></figure>

<p><strong>3.执行完后 查看日志 指定的commit已被切除</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git log</span><br><span class="line"></span><br><span class="line">commit def5adef853da4cc05752bdb36577c127be71ba5</span><br><span class="line">Author: xxx</span><br><span class="line">Date:   Thu Dec 28 16:01:36 2017 +0800</span><br><span class="line"></span><br><span class="line">优化代码</span><br><span class="line"></span><br><span class="line">commit f36801544670e00b2f59a28e19017d2786c4085e</span><br><span class="line">Author: xxx</span><br><span class="line">Date:   Thu Dec 28 15:59:46 2017 +0800</span><br><span class="line"></span><br><span class="line">修复</span><br><span class="line">(END)</span><br></pre></td></tr></table></figure>

<p> <strong>4.如果此时需要同步远程仓库</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git push  -f</span><br></pre></td></tr></table></figure>

<p>要注意的是，这样做会 <strong>彻底</strong> 删掉那条 commit。唯一的找回方式是通过 <code>git reflog</code>。</p>
<p><strong>5.如果你只是想改下那条 commit 的 author</strong></p>
<p>这样就行：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git rebase -i f368015</span><br></pre></td></tr></table></figure>

<p>把 需要改动那条 commit 前面的 pick 改成 edit</p>
<p>然后</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git commit --amend --author=&quot;xxxxxxxx&quot;</span><br></pre></td></tr></table></figure>

<p>然后</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git rebase --continue</span><br></pre></td></tr></table></figure>

<p>最后保存退出即可</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li><strong>git reset</strong></li>
</ul>
<p><strong>适用场景：</strong> 如果想恢复到之前某个提交的版本，且那个版本之后提交的版本我们都不要了，就可以用这种方法。</p>
<ul>
<li><strong>git revert</strong></li>
</ul>
<p><strong>适用场景：</strong> 如果我们想撤销之前的某一版本，但是又想保留该目标版本后面的版本，记录下这整个版本变动流程，就可以用这种方法。</p>
<ul>
<li><strong>git rebase –onto</strong>和<strong>git rebase i</strong></li>
</ul>
<p><strong>适用场景：</strong> 如果我们想撤销之前的某一版本，但是又想保留该目标版本后面的版本，彻底清除commit记录, 而又不增加新的commit记录, 就可以用这种方法</p>
<p><strong>本帖附件</strong></p>
<p><a href="https://u21519047.pipipan.com/fs/21519047-395416051" target="_blank" rel="noopener">点击下载</a></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em>乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</em></p>
]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>Git Submodule的介绍与使用</title>
    <url>/80.html</url>
    <content><![CDATA[<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/20200106104558.png" alt></p>
<h2 id="场景复现"><a href="#场景复现" class="headerlink" title="场景复现"></a>场景复现</h2><p>公司有10个项目正在开发, 以后会陆陆续续增加新项目, 而这些项目都用到公共的一些类库, 如果你是技术负责人, 你会选择哪个方案?</p>
<p><strong>方案一</strong>: 将公共类库依次拷贝至10个项目中 <strong>(不推荐  一旦类库需要修改, 你需要修改不只10遍)</strong></p>
<p><strong>方案二</strong>: 将公共类库封装成第三方框架, 放在公共仓库, 每个项目各自引入,<strong>(使用方便, 但是不方便修改源代码 不推荐)</strong></p>
<p><strong>方案三</strong>: 将公共类库源代码放在公有仓库, 每个项目下分别clone, <strong>( 方便修改类库代码, 也方便同步修改,但是主工程项目会将类库代码并入主工程提交, 两个仓库独立性不够, 有时候我可能只想先pull没有类库的代码, 这个时候就不方便了)</strong></p>
<h2 id="引出Git-Submodule"><a href="#引出Git-Submodule" class="headerlink" title="引出Git Submodule"></a>引出Git Submodule</h2><p>为了增加公共类库与主项目的独立性, Git 给大家提供了子模块功能 允许你将一个 Git 仓库作为另一个 Git 仓库的子目录 ,  它能让你将另一个仓库克隆到自己的项目中，同时还保持提交的独立 </p>
<h2 id="开始使用"><a href="#开始使用" class="headerlink" title="开始使用"></a>开始使用</h2><h4 id="添加子模块"><a href="#添加子模块" class="headerlink" title="添加子模块"></a>添加子模块</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git submodule add &lt;仓库地址&gt; &lt;本地路径&gt;//如果不指定本地路径 默认放在当前目录下</span><br></pre></td></tr></table></figure>

<h4 id="将子模块代码同步至远程仓库"><a href="#将子模块代码同步至远程仓库" class="headerlink" title="将子模块代码同步至远程仓库"></a>将子模块代码同步至远程仓库</h4><p>进入到子模块目录下, 指定分支:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git checkout master //这里以master分支为例</span><br></pre></td></tr></table></figure>

<p>然后</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git commit -am <span class="string">"修改类库"</span></span><br><span class="line">git push</span><br></pre></td></tr></table></figure>

<h3 id="从远程仓库更新代码"><a href="#从远程仓库更新代码" class="headerlink" title="从远程仓库更新代码"></a>从远程仓库更新代码</h3><p>在父模块目录下执行以下命令:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git submodule update --remote</span><br></pre></td></tr></table></figure>

<p>或者</p>
<p>直接进入到子模块目录下:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git pull</span><br></pre></td></tr></table></figure>

<p>两者效果都是一样的</p>
<p>除此之外还可以使用以下指令对多个子模块进行批量更新:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git submodule foreach --recursive git pull</span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git pull --recurse-submodules</span><br></pre></td></tr></table></figure>

<p><strong>注意:如果你的子模块内部也包含了一个子模块, 你可以使用:</strong></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git submodule foreach git submodule update</span><br></pre></td></tr></table></figure>

<p>进行遍历更新</p>
<h4 id="删除子模块"><a href="#删除子模块" class="headerlink" title="删除子模块"></a>删除子模块</h4><ol>
<li><p>首先执行以下命令移除子模块引用:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git submodule deinit &lt;submodule_path&gt;</span><br></pre></td></tr></table></figure>

<p>其中，<code>&lt;submodule_path&gt;</code> 是子模块的相对路径或<code>URL</code>。这将取消子模块的连接，并使其变回普通的目录。</p>
</li>
<li><p>执行以下命令来从 <code>.gitmodules</code> 文件中移除子模块的记录：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git rm --cached &lt;submodule_path&gt;</span><br></pre></td></tr></table></figure>

<p>同样，<code>&lt;submodule_path&gt;</code> 是子模块的相对路径或 URL。该命令会将子模块的相关配置从<code>Git</code>仓库中移除。</p>
</li>
<li><p>执行以下命令删除子模块的相关目录和文件</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git rm &lt;submodule_path&gt;</span><br><span class="line">rm &lt;submodule_path&gt;</span><br></pre></td></tr></table></figure>






</li>
</ol>
<h4 id="移动子模块"><a href="#移动子模块" class="headerlink" title="移动子模块"></a>移动子模块</h4><p>要将 <code>Git</code> 中的子模块移动到另一个目录，可以按照以下步骤进行操作：</p>
<ol>
<li><p>进入包含子模块的 Git 仓库的根目录。</p>
</li>
<li><p>执行以下命令来修改子模块的路径：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git mv &lt;current_submodule_path&gt; &lt;new_submodule_path&gt;</span><br></pre></td></tr></table></figure>

<p>其中，<code>&lt;current_submodule_path&gt;</code> 是当前子模块的路径，<code>&lt;new_submodule_path&gt;</code> 是你想要将子模块移动到的新路径。该命令会将子模块在 Git 仓库中的路径更改为新路径。</p>
</li>
<li><p>修改包含子模块的父项目中 <code>.gitmodules</code> 文件中子模块的路径记录。打开该文件，并将与子模块相关的路径修改为新的路径。</p>
</li>
<li><p>提交代码变更：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git add .gitmodules</span><br><span class="line">git commit -m <span class="string">"Move submodule to new directory"</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>更新子模块引用：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git submodule sync --recursive</span><br></pre></td></tr></table></figure>

<p>这将使父项目更新其对子模块的引用，以适应新的路径。</p>
</li>
<li><p>执行以下命令来完成子模块路径的更新：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git submodule update --init --recursive</span><br></pre></td></tr></table></figure>

<p>该命令会更新父项目中的子模块路径，并将子模块检出到新的目录中。</p>
</li>
</ol>
<h4 id="将本地仓库添加为子模块"><a href="#将本地仓库添加为子模块" class="headerlink" title="将本地仓库添加为子模块"></a>将本地仓库添加为子模块</h4><p>如果你的本地已经有了一个仓库，并希望将其设置为某个项目的子模块，而不重新下载该仓库，可以按照以下步骤操作：</p>
<ol>
<li><p>在父项目的根目录下打开命令行工具。</p>
</li>
<li><p>使用 <code>git submodule add</code> 命令添加子模块，但是在这里我们指定本地路径作为子模块的位置而不是远程仓库的<code>URL</code>。例如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git submodule add /path/to/local/repo path/to/submodule</span><br></pre></td></tr></table></figure>

<p>将 <code>/path/to/local/repo</code>替换为你本地仓库的实际路径，<code>path/to/submodule</code> 替换为你希望子模块存放的相对路径（相对于父项目的根目录）。</p>
</li>
<li><p>接下来将子模块的引用地址改为远程仓库地址</p>
<p>进入父项目的根目录，在命令行工具中执行以下命令来修改子模块的引用地址：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git submodule <span class="built_in">set</span>-url &lt;submodule_path&gt; &lt;remote_repository_url&gt;</span><br></pre></td></tr></table></figure>

<p>其中 <code>&lt;submodule_path&gt;</code> 是子模块所在的路径（相对于父项目的根目录），<code>&lt;remote_repository_url&gt;</code>是子模块的远程仓库地址</p>
</li>
</ol>
<ol start="4">
<li>运行上述命令后，Git 会将本地仓库的当前状态作为子模块的初始状态，而无需重新下载。</li>
</ol>
<p><strong>注意:</strong> <code>git submodule set-url是``Git</code> 2.25以上版本才有的功能, 使用前需要先检查一下您当前的<code>git</code>版本</p>
<h4 id="工程克隆"><a href="#工程克隆" class="headerlink" title="工程克隆"></a>工程克隆</h4><p>团队开发的时候, 进来一个新的成员, 他首次clone项目的时候, 并不会将子模块一并clone进来</p>
<p>这个时候, 需要先初始化子模块:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 用来初始化本地配置文件</span></span><br><span class="line">git submodule init</span><br><span class="line"><span class="comment"># 从该项目中抓取所有数据并检出父项目中列出的合适的提交(指定的提交)。</span></span><br><span class="line">git submodule update</span><br><span class="line">(以上两条命令也可以合并成一条组合命令：git submodule update --init --recursive)</span><br></pre></td></tr></table></figure>

<p>或者直接:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># clone 父仓库的时候加上 --recursive，会自动初始化并更新仓库中的每一个子模块</span></span><br><span class="line">git <span class="built_in">clone</span> --recursive https://gitee.com/xiaomumaozi/SubModule_Test.git</span><br></pre></td></tr></table></figure>

<p><strong>本文为作者原创 转载时请注明出处 谢谢</strong></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em>乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</em></p>
]]></content>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>C++中类的构造函数和析构函数</title>
    <url>/76.html</url>
    <content><![CDATA[<h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p>对象创建的时候执行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">student s //空参构造函数 栈内存中</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">student s(&quot;测试&quot;)//带参构造函数 栈内存中</span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">student *s=new student//空参构造函数 堆内存中</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">student *s=new student(&quot;测试&quot;)//带参构造函数 堆内存中</span><br></pre></td></tr></table></figure>

<h3 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h3><p>对象销毁的时候执行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">delete s</span><br></pre></td></tr></table></figure>

<p><strong>在构造函数中分配的堆内存空间需要在析构函数中进行释放</strong></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191205191346.png" alt></p>
<p><strong>带参构造函数变量重名问题 使用关键字this解决</strong></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191205192532.png" alt></p>
<p><strong>本帖附件</strong></p>
<p><a href="https://u21519047.pipipan.com/fs/21519047-395416051" target="_blank" rel="noopener">点击下载</a></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em>乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</em></p>
]]></content>
      <tags>
        <tag>c语言</tag>
      </tags>
  </entry>
  <entry>
    <title>ubuntu安装docker详细步骤</title>
    <url>/8.html</url>
    <content><![CDATA[<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/20200122180203.png" alt></p>
<p>这里建议大家使用阿里云的镜像源</p>
<h3 id="第一步-安装所需的工具包"><a href="#第一步-安装所需的工具包" class="headerlink" title="第一步 安装所需的工具包"></a>第一步 安装所需的工具包</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get install \</span><br><span class="line">    apt-transport-https \</span><br><span class="line">    ca-certificates \</span><br><span class="line">    curl \</span><br><span class="line">    gnupg-agent \</span><br><span class="line">    software-properties-common</span><br></pre></td></tr></table></figure>

<h3 id="第二步-修改源文件权限"><a href="#第二步-修改源文件权限" class="headerlink" title="第二步 修改源文件权限"></a>第二步 修改源文件权限</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo chmod 777 /etc/apt/sources.list //设置文件可读可写可执行</span><br></pre></td></tr></table></figure>

<h3 id="第三步-将以下内容添加至源文件中-替换成阿里源-如下"><a href="#第三步-将以下内容添加至源文件中-替换成阿里源-如下" class="headerlink" title="第三步 将以下内容添加至源文件中 替换成阿里源 如下:"></a>第三步 将以下内容添加至源文件中 替换成阿里源 如下:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">deb http://mirrors.aliyun.com/ubuntu/ trusty main restricted universe multiverse</span><br><span class="line"></span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ trusty-security main restricted universe multiverse</span><br><span class="line"></span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ trusty-updates main restricted universe multiverse</span><br><span class="line"></span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ trusty-proposed main restricted universe multiverse</span><br><span class="line"></span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ trusty-backports main restricted universe multiverse</span><br><span class="line"></span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ trusty main restricted universe multiverse</span><br><span class="line"></span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ trusty-security main restricted universe multiverse</span><br><span class="line"></span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ trusty-updates main restricted universe multiverse</span><br><span class="line"></span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ trusty-proposed main restricted universe multiverse</span><br><span class="line"></span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ trusty-backports main restricted universe multiverse</span><br></pre></td></tr></table></figure>

<h3 id="第四步-添加阿里公钥-以便于访问仓库"><a href="#第四步-添加阿里公钥-以便于访问仓库" class="headerlink" title="第四步 添加阿里公钥 以便于访问仓库"></a>第四步 添加阿里公钥 以便于访问仓库</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">curl -sSL http://acs-public-mirror.oss-cn-hangzhou.aliyuncs.com/docker-engine/internet | sh -</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> curl -fsSL https://mirrors.aliyun.com/docker-ce/linux/ubuntu/gpg | sudo apt-key add -</span><br></pre></td></tr></table></figure>

<h3 id="第五步-添加Docker软件源"><a href="#第五步-添加Docker软件源" class="headerlink" title="第五步 添加Docker软件源"></a>第五步 添加Docker软件源</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo add-apt-repository \</span><br><span class="line">     &quot;deb [arch=amd64] https://mirrors.aliyun.com/docker-ce/linux/ubuntu \</span><br><span class="line">     $(lsb_release -cs) \</span><br><span class="line">     stable&quot;</span><br></pre></td></tr></table></figure>

<h3 id="第六步-更新软件包缓存"><a href="#第六步-更新软件包缓存" class="headerlink" title="第六步 更新软件包缓存"></a>第六步 更新软件包缓存</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get update</span><br></pre></td></tr></table></figure>

<h3 id="第七步-安装docker"><a href="#第七步-安装docker" class="headerlink" title="第七步 安装docker"></a>第七步 安装docker</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get install docker-engine</span><br></pre></td></tr></table></figure>

<h3 id="第八部-启动docker"><a href="#第八部-启动docker" class="headerlink" title="第八部 启动docker"></a>第八部 启动docker</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo systemctl enable docker</span><br><span class="line">sudo systemctl start docker</span><br></pre></td></tr></table></figure>

<h3 id="第9步-测试经典的hello-world"><a href="#第9步-测试经典的hello-world" class="headerlink" title="第9步 测试经典的hello world"></a>第9步 测试经典的hello world</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo docker run hello-world</span><br></pre></td></tr></table></figure>

<p>执行 <code>sudo docker run hello-world</code> 的时候，如果你没有构建过这个hello-world镜像，或从其它地方拉取过这个镜像，docker自动去docker上拉取最新的hello-world 镜像</p>
<p>至此 docker安装完成</p>
<h2 id="附带Docker国内镜像源"><a href="#附带Docker国内镜像源" class="headerlink" title="附带Docker国内镜像源"></a>附带Docker国内镜像源</h2><p>创建或修改 /etc/docker/daemon.json 文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># vi /etc/docker/daemon.json</span><br><span class="line">&#123;</span><br><span class="line">    &quot;registry-mirrors&quot;: [&quot;https://cr.console.aliyun.com/&quot;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Docker中国区官方镜像</span><br><span class="line">https://registry.docker-cn.com</span><br><span class="line"></span><br><span class="line">网易</span><br><span class="line">http://hub-mirror.c.163.com</span><br><span class="line"></span><br><span class="line">ustc </span><br><span class="line">https://docker.mirrors.ustc.edu.cn</span><br><span class="line"></span><br><span class="line">中国科技大学</span><br><span class="line">https://docker.mirrors.ustc.edu.cn</span><br><span class="line"></span><br><span class="line">阿里云容器 服务</span><br><span class="line">https://cr.console.aliyun.com/</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em>乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</em></p>
]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>如何将gradle插件发布到插件门户网站</title>
    <url>/82.html</url>
    <content><![CDATA[<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/20200106104352.png" alt></p>
<h2 id="Step-1-创建账户"><a href="#Step-1-创建账户" class="headerlink" title="Step 1: 创建账户."></a>Step 1: 创建账户.</h2><p> <a href="https://plugins.gradle.org/user/register" target="_blank" rel="noopener">点击注册</a>.</p>
<p>注册地址:<a href="https://plugins.gradle.org/user/register" target="_blank" rel="noopener">https://plugins.gradle.org/user/register</a></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20200104124134.png" alt></p>
<h2 id="Step-2-生成API-key"><a href="#Step-2-生成API-key" class="headerlink" title="Step 2: 生成API key."></a>Step 2: 生成API key.</h2><p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20200104125228.png" alt></p>
<h2 id="Step-3-将-API-key-添加到Gradle-配置中"><a href="#Step-3-将-API-key-添加到Gradle-配置中" class="headerlink" title="Step 3: 将 API key 添加到Gradle 配置中."></a>Step 3: 将 API key 添加到Gradle 配置中.</h2><p>拷贝API Key到电脑<code>$USER_HOME/.gradle/gradle.properties</code>文件中,如果电脑没有该文件, 就自行创建一个</p>
<p> <code>$USER_HOME</code> 指的是你的电脑用户名</p>
<p>如果你嫌手动配置api麻烦, 可以使用官方的<code>login</code> task进行自动注册, </p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20210727105738873.png" alt="image-20210727105738873"></p>
<p>执行<code>login task</code> 执行窗口会出现授权链接 点击浏览器打开即可</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20210727110154697.png" alt="image-20210727110154697"></p>
<p>在此之前需要先应用插件, 往下看:</p>
<h2 id="Step-4-使用官方插件进行代码的推送"><a href="#Step-4-使用官方插件进行代码的推送" class="headerlink" title="Step 4: 使用官方插件进行代码的推送."></a>Step 4: 使用官方插件进行代码的推送.</h2><p>在你自己的插件工程build.gradle中添加如下代码</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 第一步 应用插件</span></span><br><span class="line">plugins &#123;</span><br><span class="line">  id <span class="string">"com.gradle.plugin-publish"</span> version <span class="string">"0.10.1"</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">pluginBundle &#123;</span><br><span class="line">  website = <span class="string">'http://www.gradle.org/'</span><span class="comment">//你自己的插件官网地址</span></span><br><span class="line">  vcsUrl = <span class="string">'https://github.com/gradle/gradle'</span><span class="comment">//插件版本同步地址 填写你的github地址即可</span></span><br><span class="line">  description = <span class="string">'Greetings from here!'</span><span class="comment">//插件描述</span></span><br><span class="line">  tags = [<span class="string">'greetings'</span>, <span class="string">'salutations'</span>]<span class="comment">//标签 便于搜索</span></span><br><span class="line"></span><br><span class="line">  plugins &#123;</span><br><span class="line">    greetingsPlugin &#123;</span><br><span class="line">     version = <span class="string">"1.2"</span> <span class="comment">//插件版本号</span></span><br><span class="line">	group = <span class="string">"com.foo.myplugin"</span><span class="comment">//插件包名</span></span><br><span class="line">      displayName = <span class="string">'这里填写在插件官网中显示的名称'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>配置完成后,执行 <code>publishPlugins</code> task即可自动上传代码</p>
<h2 id="Step-5-等待审核"><a href="#Step-5-等待审核" class="headerlink" title="Step 5: 等待审核."></a>Step 5: 等待审核.</h2><p>审核通过后,即可在官网搜索到你的插件, 上面附有插件的使用方法</p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20200104130609.png" alt></p>
<h2 id="Step-6-完成"><a href="#Step-6-完成" class="headerlink" title="Step 6: 完成."></a>Step 6: 完成.</h2><p><strong>本帖附件</strong></p>
<p><a href="https://u21519047.pipipan.com/fs/21519047-395416051" target="_blank" rel="noopener">点击下载</a></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em>乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</em></p>
]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>git stash 详解</title>
    <url>/79.html</url>
    <content><![CDATA[<h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><ol>
<li>当正在dev分支上开发某个项目，这时项目中出现一个bug，需要紧急修复，但是正在开发的内容只是完成一半，还不想提交，这时可以用git stash命令将修改的内容保存至堆栈区，然后顺利切换到hotfix分支进行bug修复，修复完成后，再次切回到dev分支，从堆栈中恢复刚刚保存的内容。</li>
<li>由于疏忽，本应该在dev分支开发的内容，却在master上进行了开发，需要重新切回到dev分支上进行开发，可以用git stash将内容保存至堆栈中，切回到dev分支后，再次恢复内容即可。</li>
</ol>
<p>总的来说，git stash命令的作用就是<strong>将目前还不想提交的但是已经修改的内容进行保存至堆栈中，后续可以在某个分支上恢复出堆栈中的内容</strong>。</p>
<p>这也就是说，<strong>stash中的内容不仅仅可以恢复到原先开发的分支，也可以恢复到其他任意指定的分支上</strong>。git stash作用的范围包括工作区和暂存区中的内容，也就是说没有提交的内容都会保存至堆栈中。</p>
<p><strong>注: stash只对被追踪的文件才有效, 也就是说 是针对被add的文件 。</strong></p>
<h3 id="命令详解"><a href="#命令详解" class="headerlink" title="命令详解"></a>命令详解</h3><h4 id="1-git-stash"><a href="#1-git-stash" class="headerlink" title="1. git stash"></a>1. git stash</h4><blockquote>
<p>能够将所有未提交的修改（工作区和暂存区）保存至堆栈中，用于后续恢复当前工作目录</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes not staged for commit:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)</span><br><span class="line"></span><br><span class="line">        modified:   src/main/java/com/wy/CacheTest.java</span><br><span class="line">        modified:   src/main/java/com/wy/StringTest.java</span><br><span class="line"></span><br><span class="line">no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)</span><br><span class="line"></span><br><span class="line">$ git stash</span><br><span class="line">Saved working directory and index state WIP on master: b2f489c second</span><br><span class="line"></span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">nothing to commit, working tree clean</span><br></pre></td></tr></table></figure>

<h4 id="2-git-stash-save"><a href="#2-git-stash-save" class="headerlink" title="2. git stash save"></a>2. git stash save</h4><blockquote>
<p>作用等同于git stash，区别是可以加一些注释，git stash save “test1”的效果 如下：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">stash@&#123;0&#125;: On master: test1</span><br></pre></td></tr></table></figure>

<h4 id="3-git-stash-list"><a href="#3-git-stash-list" class="headerlink" title="3. git stash list"></a>3. git stash list</h4><blockquote>
<p>查看当前stash中的内容</p>
</blockquote>
<h4 id="4-git-stash-pop"><a href="#4-git-stash-pop" class="headerlink" title="4. git stash pop"></a>4. git stash pop</h4><blockquote>
<p>将当前stash中的内容弹出，并应用到当前分支对应的工作目录上。<br>注：该命令将堆栈中最近保存的内容删除（栈是先进后出）<br>顺序执行git stash save “test1”和git stash save “test2”命令，效果如下：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git stash list</span><br><span class="line">stash@&#123;0&#125;: On master: test2</span><br><span class="line">stash@&#123;1&#125;: On master: test1</span><br><span class="line"></span><br><span class="line">$ git stash pop</span><br><span class="line">On branch master</span><br><span class="line">Changes not staged for commit:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)</span><br><span class="line"></span><br><span class="line">        modified:   src/main/java/com/wy/StringTest.java</span><br><span class="line"></span><br><span class="line">no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)</span><br><span class="line">Dropped refs/stash@&#123;0&#125; (afc530377eacd4e80552d7ab1dad7234edf0145d)</span><br><span class="line"></span><br><span class="line">$ git stash list</span><br><span class="line">stash@&#123;0&#125;: On master: test1</span><br></pre></td></tr></table></figure>

<p>可见，test2的stash是首先pop出来的。<br>如果从stash中恢复的内容和当前目录中的内容发生了冲突，也就是说，恢复的内容和当前目录修改了同一行的数据，那么会提示报错，需要解决冲突，可以通过创建新的分支来解决冲突。</p>
<h4 id="5-git-stash-apply"><a href="#5-git-stash-apply" class="headerlink" title="5. git stash apply"></a>5. git stash apply</h4><blockquote>
<p>将堆栈中的内容应用到当前目录，不同于git stash pop，该命令不会将内容从堆栈中删除，也就说该命令能够将堆栈的内容多次应用到工作目录中，适应于多个分支的情况。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git stash apply</span><br><span class="line">On branch master</span><br><span class="line">Changes not staged for commit:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)</span><br><span class="line"></span><br><span class="line">        modified:   src/main/java/com/wy/StringTest.java</span><br><span class="line"></span><br><span class="line">no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)</span><br><span class="line"></span><br><span class="line">$ git stash list</span><br><span class="line">stash@&#123;0&#125;: On master: test2</span><br><span class="line">stash@&#123;1&#125;: On master: test1</span><br></pre></td></tr></table></figure>

<p>堆栈中的内容并没有删除。<br>可以使用<code>git stash apply + stash名字</code>（如stash@{1}）指定恢复哪个stash到当前的工作目录。</p>
<h4 id="6-git-stash-drop-名称"><a href="#6-git-stash-drop-名称" class="headerlink" title="6. git stash drop + 名称"></a>6. git stash drop + 名称</h4><blockquote>
<p>从堆栈中移除某个指定的stash</p>
</blockquote>
<h4 id="7-git-stash-clear"><a href="#7-git-stash-clear" class="headerlink" title="7. git stash clear"></a>7. git stash clear</h4><p>清除堆栈中的所有 内容</p>
<h4 id="8-git-stash-show"><a href="#8-git-stash-show" class="headerlink" title="8. git stash show"></a>8. git stash show</h4><blockquote>
<p>查看堆栈中最新保存的stash和当前目录的差异。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git stash show</span><br><span class="line"> src/main/java/com/wy/StringTest.java | 2 +-</span><br><span class="line"> 1 file changed, 1 insertion(+), 1 deletion(-)</span><br></pre></td></tr></table></figure>

<p><code>git stash show stash@{1}</code>查看指定的stash和当前目录差异。<br>通过 <code>git stash show -p</code> 查看详细的不同：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git stash show -p</span><br><span class="line">diff --git a/src/main/java/com/wy/CacheTest.java b/src/main/java/com/wy/CacheTest.java</span><br><span class="line">index 6e90837..de0e47b 100644</span><br><span class="line">--- a/src/main/java/com/wy/CacheTest.java</span><br><span class="line">+++ b/src/main/java/com/wy/CacheTest.java</span><br><span class="line">@@ -7,6 +7,6 @@ package com.wy;</span><br><span class="line">  */</span><br><span class="line"> public class CacheTest &#123;</span><br><span class="line">     public static void main(String[] args) &#123;</span><br><span class="line">-        System.out.println(&quot;git stash test&quot;);</span><br><span class="line">+        System.out.println(&quot;git stash test1&quot;);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line">diff --git a/src/main/java/com/wy/StringTest.java b/src/main/java/com/wy/StringTest.java</span><br><span class="line">index a7e146c..711d63f 100644</span><br><span class="line">--- a/src/main/java/com/wy/StringTest.java</span><br><span class="line">+++ b/src/main/java/com/wy/StringTest.java</span><br><span class="line">@@ -12,7 +12,7 @@ public class StringTest &#123;</span><br><span class="line"></span><br><span class="line">     @Test</span><br><span class="line">     public void test1() &#123;</span><br><span class="line">-        System.out.println(&quot;=================&quot;);</span><br><span class="line">+        System.out.println(&quot;git stash test1&quot;);</span><br><span class="line">         System.out.println(Strings.isNullOrEmpty(&quot;&quot;));//true</span><br><span class="line">         System.out.println(Strings.isNullOrEmpty(&quot; &quot;));//false</span><br><span class="line">         System.out.println(Strings.nullToEmpty(null));//&quot;&quot;</span><br></pre></td></tr></table></figure>

<p>同样，通过git stash show stash@{1} -p查看指定的stash的差异内容</p>
<h4 id="9-git-stash-branch"><a href="#9-git-stash-branch" class="headerlink" title="9. git stash branch"></a>9. git stash branch</h4><blockquote>
<p>从最新的stash创建分支。</p>
</blockquote>
<p><strong>应用场景</strong>：当储藏了部分工作，暂时不去理会，继续在当前分支进行开发，后续想将stash中的内容恢复到当前工作目录时，如果是针对同一个文件的修改（即便不是同行数据），那么可能会发生冲突，恢复失败，这里通过创建新的分支来解决。可以用于解决stash中的内容和当前目录的内容发生冲突的情景。<br>发生冲突时，需手动解决冲突。</p>
<p><strong>本帖附件</strong></p>
<p><a href="https://u21519047.pipipan.com/fs/21519047-395416051" target="_blank" rel="noopener">点击下载</a></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em>乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</em></p>
]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>Handler机制详解</title>
    <url>/81.html</url>
    <content><![CDATA[<h3 id="Handler机制主要涉及到五个类"><a href="#Handler机制主要涉及到五个类" class="headerlink" title="Handler机制主要涉及到五个类"></a>Handler机制主要涉及到五个类</h3><ul>
<li>Handler (用于处理消息)</li>
<li>Message (消息对象)</li>
<li>MessageQueue (按一定顺序储存消息对象)</li>
<li>looper  (内部是死循环, 不断从MessageQueue 中取消息)</li>
<li>HandlerThead</li>
</ul>
<h3 id="首先咱们来看一张Handler消息机制图"><a href="#首先咱们来看一张Handler消息机制图" class="headerlink" title="首先咱们来看一张Handler消息机制图"></a>首先咱们来看一张Handler消息机制图</h3><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/Handler机制.png" style="zoom:150%;">

<p><strong>些许懵逼?</strong></p>
<p><strong>那咱们从源码开始入手,先从Handler.java开始</strong></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191222180401.png" alt></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191222180500.png" alt></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191222180541.png" alt></p>
<p>得出结论:</p>
<ul>
<li><strong>handler利用MessageQueue对象,调用其enquequeMessage方法将消息塞给MessageQueue</strong></li>
<li><strong>msg.target为handler自身对象</strong></li>
</ul>
<p>那么enquequeMessage具体是怎么个塞法呢?</p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191222181226.png" alt></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191222181333.png" alt></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191222181708.png" alt></p>
<p>得出结论:</p>
<ul>
<li>enquequeMessage将传入的消息根据延时时间进行排序,0毫秒在前,非0毫秒在后</li>
</ul>
<p><strong>咱们接着看Lopper.java</strong></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191222181925.png" alt></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191222182436.png" alt></p>
<p>得出结论</p>
<ul>
<li><p>loop方法内部实际是一个死循环</p>
</li>
<li><p>通过queque.next()从消息队列中取消息,如果没有消息就阻塞住,有消息就往下执行</p>
</li>
<li><p>如果有消息, 通过dispatchMessage进行消息分发, 注意 这个dispatchMessage方法是Handler对象的</p>
</li>
</ul>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191222182656.png" alt></p>
<p>进入到Message.java中</p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191222190622.png" alt><br>得出结论:</p>
<ul>
<li>到最后调用了handleMessage交由用户去处理</li>
<li>之所以系统创建多个Handler处理成百上千的消息而不会乱套,主要靠的就是target变量,相当于给每个消息绑定了一个Handler, 指定该Handler进行处理</li>
<li>从sendMessage到handleMessage大致就是这么一个流程</li>
</ul>
<p><strong>那么到此为止, 问题来了:</strong></p>
<ul>
<li>前面说到, loop方法内部是一个死循环, 那这个循环是如果实在UI线程,岂不是会造成线程阻塞?</li>
</ul>
<p>android肯定不会允许这种情况发生的, 为了解决这个问题, <strong>HandlerThread</strong>上场了,单独开启了一个子线程用于handler</p>
<p><strong>HandlerThread</strong>继承自<strong>Thread</strong>进入到<strong>HandlerThread.java</strong>中我们先找到关键方法run</p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191222183746.png" alt></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191222184127.png" alt></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191222184203.png" alt></p>
<p>得出结论:</p>
<ul>
<li>perpare()主要用于初始化创建looper对象, 并将该对象存放到线程变量中,供线程对象使用</li>
<li>初始化完成后调用loop方法开始死循环</li>
<li>如果自己使用looper需要开启一个线程, 否则会阻塞UI线程, 并且调用perpare和loop方法</li>
<li>平常我们在使用的handler的时候不需要开启线程, 是因为系统已经替我们开启了ActivityThread线程</li>
</ul>
<h3 id="Handler消息分发流程"><a href="#Handler消息分发流程" class="headerlink" title="Handler消息分发流程"></a>Handler消息分发流程</h3><p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/Handler%E5%88%86%E5%8F%91%E6%B6%88%E6%81%AF%E6%B5%81%E7%A8%8B.png" alt></p>
<h3 id="附加"><a href="#附加" class="headerlink" title="附加"></a>附加</h3><p><strong>ActivityThread中也有一个loop方法</strong></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191222185511.png" alt></p>
<p>实际上, Android应用的启动运行靠的也是handler, 不断地处理系统消息, 这样四大组件才能正常运转起来</p>
<p><strong>本帖附件</strong></p>
<p><a href="https://u21519047.pipipan.com/fs/21519047-395416051" target="_blank" rel="noopener">点击下载</a></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em>乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</em></p>
]]></content>
      <tags>
        <tag>Android源码</tag>
      </tags>
  </entry>
  <entry>
    <title>如何利用百度文库上传付费文档，实现持续收益</title>
    <url>/83.html</url>
    <content><![CDATA[<p>最近有一个很火的概念，称之为“<strong>个人商业模式</strong>”！所谓个人商业模式，就是个人出售时间的方式，我们每个为生活奔走忙碌的人都有自己的商业模式。本质上都是在出售自己的时间在赚钱！</p>
<p>“个人商业模式”一般情况有以下三种。</p>
<h4 id="1、一份时间出售一次。"><a href="#1、一份时间出售一次。" class="headerlink" title="1、一份时间出售一次。"></a>1、一份时间出售一次。</h4><p>比如每天工作8小时，为老板打工，即出售自己的时间为老板打工，这八小时只能为我们带来一次收入！这是第一种商业模式，即一次时间出售一次。</p>
<h4 id="2、一份时间出售多次。"><a href="#2、一份时间出售多次。" class="headerlink" title="2、一份时间出售多次。"></a>2、一份时间出售多次。</h4><p>持续收益，躺着赚钱。比如作家出了一本书，然后进行出版吗，畅销5年。那么作家在睡觉的时候都会有人为我的书籍付费。这就是第二种商业模式。即一份时间出售多次。</p>
<h4 id="3、购买别人的时间，再卖出去。"><a href="#3、购买别人的时间，再卖出去。" class="headerlink" title="3、购买别人的时间，再卖出去。"></a>3、购买别人的时间，再卖出去。</h4><p>比如作为一个老板，招聘了5个员工，员工为老板打工。其实就是老板在买下员工的时间，然后再卖出去！</p>
<p>我们大多数人都是第一种商业模式，赚的钱都是辛苦钱。如果我们想赚更多的钱，就要学会第二种商业模式，即躺着也能有收入。</p>
<p>那么今天就有一个躺着也能有收入的点子，小编想要分享给大家，希望能帮助到你们！</p>
<p>这个点子被大多数人给疏忽了，其实就是利用百度文库上传付费文档项目，“搬砖”赚钱，尤其是在这个知识付费的年代显得更有优势！</p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/u=3270836336,97604862&fm=173&app=25&f=JPEG" alt></p>
<p>接下来为大家分析一下项目的具体操作！</p>
<h3 id="一、项目简介。"><a href="#一、项目简介。" class="headerlink" title="一、项目简介。"></a>一、项目简介。</h3><p>百度相信很多朋友都知道，他是百度发布的供网友在线分享文档的平台。</p>
<p>有很多为了学习，查资料的伙伴都会时不时的上百度文库搜寻查找相关资料。搜着搜着，搜到很多，有免费的，有付费的，但一般写的好的，都需要下载券，也不贵，两块钱就可以了，如果找到我们适合的，说不定我们就直接买了。</p>
<p>可是钱都到哪里去了？百度文库的文档由百度用户上传，需要经过百度的审核才能发布。</p>
<p>没错，钱都到上传者手中去了！一篇文章一块两块，中国用户这么多，如果是多个文档呢？想必就会越多，并且文档长久都有效！</p>
<p>我们看下面这个账号</p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/u=3650677491,324198756&fm=173&app=25&f=JPEG" alt></p>
<p>付费文档有10元，15元，5元，大多数都是5元，已经有接近6万次的下载，即使是除去一半的免费文档，也有3万次的下载量，一篇5元，也有15万元左右的收益。并且是重复多次收益。用户躺着睡觉也有收益！</p>
<p>通过研究多个百度文库用户的账号，我发现了他们的赚钱套路，一般都是先给免费的看，然后看到后面就需要付费。</p>
<p>这个项目就是，在百度文库（道客巴巴、豆丁网也是一样的）成为认证用户，上传你的资料，并设置合理的价格，来钱就是这么简单，借助平台自身流量，不需你做太多的推广。</p>
<h3 id="第二步、项目具体操作"><a href="#第二步、项目具体操作" class="headerlink" title="第二步、项目具体操作"></a>第二步、项目具体操作</h3><p><strong>1、注册账号。</strong></p>
<p>这个按照规则去做就可以了。</p>
<p><strong>2、上传文档。</strong></p>
<p>建议伙伴们先了解百度文库上传的规则，否则上传不通过的话，就白做了哦<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">!![](https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/u=2179562780,1282340770&amp;fm=173&amp;app=25&amp;f=JPEG)</span><br><span class="line"></span><br><span class="line">另外再上传文档的时候给大家分享几个技巧。</span><br><span class="line"></span><br><span class="line">1. 页眉可以设置信息。设置的信息可以用来打造个人ip！</span><br><span class="line"></span><br><span class="line">2. 标题和描述都可以布局出现需要优化的长尾关键词，有助于文档的排名，让更多的人看到！</span><br><span class="line"></span><br><span class="line">3. 文档的开头、中间、结尾都可以适当的出现需要优化的关键词！</span><br><span class="line"></span><br><span class="line">4. 排版干净利落，层次分明！</span><br><span class="line"></span><br><span class="line">三、那么上传的内容从哪里获得呢？</span><br><span class="line"></span><br><span class="line">文档上传内容是有讲究的，只有你的文档有价值了，才会有人付费下载你的上传的文档的，所以上传一些干货才是能赚钱的法宝。</span><br><span class="line"></span><br><span class="line">#### 干货去哪里找？有两种方法。</span><br><span class="line"></span><br><span class="line">1、伙伴们可以去资源整合网上找。</span><br><span class="line"></span><br><span class="line">2、如果不想出钱的话就自个去整理，自己去生产原创干货内容。但注意一定得是干货，否则上传上去不会翻出什么花来哦~</span><br></pre></td></tr></table></figure></p>
<p>其实整个项目都很简单，只是被大多数人给忽略掉了，看的上的伙伴可以去尝试一下，这样长期下来也算是一笔财富！</p>
<p>一次付出，躺着也有收入，虽然一次不多，但是积少成多嘛<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">不仅仅是上传到百度文库，豆丁网，道客巴巴我们都可以操作哦</span><br></pre></td></tr></table></figure></p>
<p>关于“个人商业模式”，说白了就是赚钱的事。我觉得我们都应该去思考自己的商业模式以及如何打造更好的商业模式！</p>
<p>因为持续收益才是我们实现财务自由的唯一方式！</p>
<p><strong>本帖附件</strong></p>
<p><a href="https://u21519047.pipipan.com/fs/21519047-395416051" target="_blank" rel="noopener">点击下载</a></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em>乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</em></p>
]]></content>
      <tags>
        <tag>税后收入</tag>
      </tags>
  </entry>
  <entry>
    <title>Java面试题之TCP和UDP的区别</title>
    <url>/85.html</url>
    <content><![CDATA[<h2 id="网络层的划分"><a href="#网络层的划分" class="headerlink" title="网络层的划分"></a>网络层的划分</h2><h3 id="一-网络层的划分"><a href="#一-网络层的划分" class="headerlink" title="一 网络层的划分"></a>一 网络层的划分</h3><ul>
<li><p>物理层 :负责在物理线路上传输原始的二进制数据（0和1），该层数据以比特流的形式传输 </p>
</li>
<li><p>链路层:  负责在通信的实体间建立数据链路连接，该层数据以帧的形式传输 </p>
</li>
<li><p>网络层:  负责创建逻辑链路，以及实现数据包的分片和重组，实现拥塞控制、网络互连等功能，该层数据以IP数据报(IP分组)的形式传输 </p>
</li>
<li><p>传输层:   负责向用户提供端到端的通信服务，实现流量控制以及差错控制，这一层主要重点是两个协议 : <strong>UDP 和 TCP</strong> </p>
</li>
<li><p>应用层:  为应用程序提供了网络服务，应用层协议最著名的就是<strong>HTTP, FTP了</strong>, 还有一个重要的DNS </p>
<h3 id="二、TCP和UDP的区别"><a href="#二、TCP和UDP的区别" class="headerlink" title="二、TCP和UDP的区别"></a>二、TCP和UDP的区别</h3></li>
</ul>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/1600629-20190325093559181-511608101.jpg" alt></p>
<h3 id="三-TCP的三次握手"><a href="#三-TCP的三次握手" class="headerlink" title="三 TCP的三次握手"></a>三 TCP的三次握手</h3><ul>
<li><strong>第一次握手：</strong>建立连接</li>
<li><strong>第二次握手</strong>：响应连接</li>
<li><strong>第三次握手：</strong>测试数据</li>
</ul>
<p><strong>本帖附件</strong></p>
<p><a href="https://u21519047.pipipan.com/fs/21519047-395416051" target="_blank" rel="noopener">点击下载</a></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em>乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</em></p>
]]></content>
      <tags>
        <tag>Java面试题</tag>
      </tags>
  </entry>
  <entry>
    <title>如何在一台电脑上创建多个sshkey达到操控多个github账号的目的</title>
    <url>/84.html</url>
    <content><![CDATA[<blockquote>
<p>老司机一般都不只有一个github账号,多个账号同一台电脑部署代码 如果使用同一个公钥肯定是不行的,会报权限拒绝,那么如果解决这个问题呢</p>
</blockquote>
<h3 id="首先"><a href="#首先" class="headerlink" title="首先"></a>首先</h3><p><strong>生成一个新的sshkey</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;YOUR_EMAIL@YOUREMAIL.COM&quot; -f ~/.ssh/名字(如abc)</span><br></pre></td></tr></table></figure>

<p>此时 在<code>.ssh</code>目录下会生成一个<code>abc.pub</code>和<code>abc</code> (<code>.ssh</code>目录一般位于<code>C:\Users\windows\.ssh</code>)</p>
<h3 id="第二步-添加config配置文件"><a href="#第二步-添加config配置文件" class="headerlink" title="第二步 添加config配置文件"></a>第二步 添加config配置文件</h3><p>在<code>.ssh</code>目录下进行<code>config</code>文件的配置(如果没有就新建一个,不用后缀名)</p>
<p>以下是<code>config</code>文件的内容(直接拷贝的话 记得把注释去掉)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 这个是原来的key</span><br><span class="line"># github</span><br><span class="line">Host github.com</span><br><span class="line">HostName github.com</span><br><span class="line">PreferredAuthentications publickey</span><br><span class="line">IdentityFile ~/.ssh/id-rsa</span><br><span class="line">	</span><br><span class="line"># 这个是新加的key</span><br><span class="line"># github_2</span><br><span class="line">Host github_1.com   (此处的host名是自己取的,你也可以自己改)</span><br><span class="line">HostName github.com		(gitlab的话写gitlab.com?)</span><br><span class="line">PreferredAuthentications publickey		</span><br><span class="line">IdentityFile ~/.ssh/abc		(这是你的key的路径名)</span><br></pre></td></tr></table></figure>

<h3 id="第三步-将新生成的密钥添加到SSH-agent中"><a href="#第三步-将新生成的密钥添加到SSH-agent中" class="headerlink" title="第三步 将新生成的密钥添加到SSH agent中"></a>第三步 将新生成的密钥添加到SSH agent中</h3><p>因为系统默认只读取<code>id_rsa</code>，为了让<code>SSH</code>识别新的私钥，需将其添加到<code>SSH agent</code>中：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh-add ~/.ssh/abc</span><br></pre></td></tr></table></figure>

<p>如果出现<code>Could not open a connection to your authentication agent</code>的错误，就试着用以下命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh-agent bash</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh-add ~/.ssh/abc</span><br></pre></td></tr></table></figure>

<h3 id="第四步-在你需要连接的github的settings里配置sshkey"><a href="#第四步-在你需要连接的github的settings里配置sshkey" class="headerlink" title="第四步 在你需要连接的github的settings里配置sshkey"></a>第四步 在你需要连接的github的settings里配置sshkey</h3><p>将新生成的公钥(<code>.pub</code>后缀)复制过去</p>
<h3 id="第五步-修改克隆或者关联远程仓库的地址-关键"><a href="#第五步-修改克隆或者关联远程仓库的地址-关键" class="headerlink" title="第五步 修改克隆或者关联远程仓库的地址(关键)"></a>第五步 修改克隆或者关联远程仓库的地址(关键)</h3><p>平常咱们关联远程仓库代码是这样的</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git remote add origin git@github.com:name/project.git</span><br></pre></td></tr></table></figure>

<p>如果你想关联新github账户的仓库  需要改成</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git remote add origin git@github_1.com:name/project.git</span><br></pre></td></tr></table></figure>

<p>只要把<code>github</code>域名改成<code>config</code>中配置的就行</p>
<p>到此,就完事了</p>
<p><strong>本帖附件</strong></p>
<p><a href="https://u21519047.pipipan.com/fs/21519047-395416051" target="_blank" rel="noopener">点击下载</a></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em>乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</em></p>
]]></content>
      <tags>
        <tag>基础必备</tag>
      </tags>
  </entry>
  <entry>
    <title>java五大排序算法之冒泡排序</title>
    <url>/87.html</url>
    <content><![CDATA[<h1 id="一-冒泡排序介绍"><a href="#一-冒泡排序介绍" class="headerlink" title="一.冒泡排序介绍"></a>一.冒泡排序介绍</h1><p>冒泡排序是我们得最多的排序方式之一，原因是简单易实现，且原理易懂。顾名思义，冒泡排序，它的排序过程就像水中的气泡一样，一个一个上浮到水面。<br><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/1084627-20190108142731138-369925737.gif" alt="img"></p>
<h1 id="二-冒泡排序原理分析"><a href="#二-冒泡排序原理分析" class="headerlink" title="二.冒泡排序原理分析"></a>二.冒泡排序原理分析</h1><p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/1084627-20190108101356028-1670962340.png" alt="img"></p>
<h1 id="三-冒泡排序代码实现"><a href="#三-冒泡排序代码实现" class="headerlink" title="三.冒泡排序代码实现"></a>三.冒泡排序代码实现</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @Author &#123;LearnAndGet&#125;</span><br><span class="line"> * @Time 2019年1月8日</span><br><span class="line"> * @Discription:</span><br><span class="line"> */</span><br><span class="line">package com.sort;</span><br><span class="line"></span><br><span class="line">import java.util.Arrays;</span><br><span class="line"></span><br><span class="line">public class MaopaoSort &#123;</span><br><span class="line">    </span><br><span class="line">    static int[] array = &#123;3,2,4,1,5,0&#125;;</span><br><span class="line">    </span><br><span class="line">    public static void maopaoSort(int[] a) </span><br><span class="line">    &#123;</span><br><span class="line">        //外层循环，是需要进行比较的轮数，一共进行5次即可</span><br><span class="line">        for(int i=0;i&lt;a.length-1;i++) </span><br><span class="line">        &#123;</span><br><span class="line">            //内存循环，是每一轮中进行的两两比较</span><br><span class="line">            for(int j=0;j&lt;a.length-1;j++) </span><br><span class="line">            &#123;</span><br><span class="line">                if(a[j] &gt; a[j+1]) </span><br><span class="line">                &#123;</span><br><span class="line">                    int temp = a[j];</span><br><span class="line">                    a[j] = a[j+1];</span><br><span class="line">                    a[j+1] = temp; </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(&quot;第&quot;+(i+1)+&quot;轮排序后的数组为: &quot;+Arrays.toString(a));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        maopaoSort(array);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>输出结果</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第1轮排序后的数组为: [2, 3, 1, 4, 0, 5]</span><br><span class="line">第2轮排序后的数组为: [2, 1, 3, 0, 4, 5]</span><br><span class="line">第3轮排序后的数组为: [1, 2, 0, 3, 4, 5]</span><br><span class="line">第4轮排序后的数组为: [1, 0, 2, 3, 4, 5]</span><br><span class="line">第5轮排序后的数组为: [0, 1, 2, 3, 4, 5]</span><br></pre></td></tr></table></figure>

<h1 id="四-冒泡排序的优化"><a href="#四-冒泡排序的优化" class="headerlink" title="四.冒泡排序的优化"></a>四.冒泡排序的优化</h1><p>1 .观察上述代码和运行结果，我们可以发现，当第一轮结束后，最后一个数字一定是数组中最大的元素，那么我们在进行第二趟的两两比较时，实际上是没有必要再对第5个和第6个进行比较的。那么我们可以修改代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void maopaoSort(int[] a) </span><br><span class="line">&#123;</span><br><span class="line">    //外层循环，是需要进行比较的轮数，一共进行5次即可</span><br><span class="line">    for(int i=0;i&lt;a.length-1;i++) </span><br><span class="line">    &#123;</span><br><span class="line">        //内存循环，是每一轮中进行的两两比较</span><br><span class="line">        //并且每一轮结束后，下一次的两两比较中可以少比较一次</span><br><span class="line">        for(int j=0;j&lt;a.length-i-1;j++) </span><br><span class="line">        &#123;</span><br><span class="line">            if(a[j] &gt; a[j+1]) </span><br><span class="line">            &#123;</span><br><span class="line">                int temp = a[j];</span><br><span class="line">                a[j] = a[j+1];</span><br><span class="line">                a[j+1] = temp; </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;第&quot;+(i+1)+&quot;轮排序后的数组为: &quot;+Arrays.toString(a));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>继续运行后，可以发现运行结果是一样的。</p>
<p>2 .当我们用数组：{1,2,0,3,5,4}来测试上述冒泡排序时，运行结果如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第1轮排序后的数组为: [1, 0, 2, 3, 4, 5]</span><br><span class="line">第2轮排序后的数组为: [0, 1, 2, 3, 4, 5]</span><br><span class="line">第3轮排序后的数组为: [0, 1, 2, 3, 4, 5]</span><br><span class="line">第4轮排序后的数组为: [0, 1, 2, 3, 4, 5]</span><br><span class="line">第5轮排序后的数组为: [0, 1, 2, 3, 4, 5]</span><br></pre></td></tr></table></figure>

<p>可以看到，在第2轮排序完成后，其实我们就已经的到了排好序的数组，但是我们的程序并不知道，仍然进行了后续的无用工作。那么，我们如何来让程序知道已经完成好排序了呢？</p>
<p>这里可以想到，当某一轮的两两比较中，如果都没有发生数组元素的互换，那么其实排序工作已经完成了，所以我们可以考虑在程序中加入一个flag，默认为false，含义是该轮比较中是否发生了元素互换，当程序中执行到元素互换时，将该flag置为true，当该轮比较结束时，若flag为flase，则说明该轮比较未发生元素互换，那么排序完成，若flag为true，说明本轮比较仍然有元素互换，需要继续进行下轮排序。代码实现如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @Author &#123;LearnAndGet&#125;</span><br><span class="line"> * @Time 2019年1月8日</span><br><span class="line"> * @Discription:</span><br><span class="line"> */</span><br><span class="line">package com.sort;</span><br><span class="line"></span><br><span class="line">import java.util.Arrays;</span><br><span class="line"></span><br><span class="line">public class MaopaoSort &#123;</span><br><span class="line">    </span><br><span class="line">    static int[] array = &#123;1,2,0,3,5,4&#125;;</span><br><span class="line">    </span><br><span class="line">    public static void maopaoSort(int[] a) </span><br><span class="line">    &#123;</span><br><span class="line">        //外层循环，是需要进行比较的轮数，一共进行5次即可</span><br><span class="line">        for(int i=0;i&lt;a.length-1;i++) </span><br><span class="line">        &#123;</span><br><span class="line">            boolean flag = false;</span><br><span class="line">            //内存循环，是每一轮中进行的两两比较</span><br><span class="line">            for(int j=0;j&lt;a.length-i-1;j++) </span><br><span class="line">            &#123;</span><br><span class="line">                if(a[j] &gt; a[j+1]) </span><br><span class="line">                &#123;</span><br><span class="line">                    int temp = a[j];</span><br><span class="line">                    a[j] = a[j+1];</span><br><span class="line">                    a[j+1] = temp;</span><br><span class="line">                    flag = true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(&quot;第&quot;+(i+1)+&quot;轮排序后的数组为: &quot;+Arrays.toString(a));</span><br><span class="line">            if(flag == false)</span><br><span class="line">            &#123;</span><br><span class="line">                System.out.println(&quot;本轮中的两两比较未发生元素互换，排序已经完成啦&quot;);</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        maopaoSort(array);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>运行结果：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第1轮排序后的数组为: [1, 0, 2, 3, 4, 5]</span><br><span class="line">第2轮排序后的数组为: [0, 1, 2, 3, 4, 5]</span><br><span class="line">第3轮排序后的数组为: [0, 1, 2, 3, 4, 5]</span><br><span class="line">本轮中的两两比较未发生元素互换，排序已经完成啦</span><br></pre></td></tr></table></figure>

<h1 id="五-冒泡排序的时间复杂度"><a href="#五-冒泡排序的时间复杂度" class="headerlink" title="五.冒泡排序的时间复杂度"></a>五.冒泡排序的时间复杂度</h1><p>冒泡排序是一种用时间换空间的排序方法，最坏情况是把顺序的排列变成逆序，或者把逆序的数列变成顺序。在这种情况下，每一次比较都需要进行交换运算。举个例子来说，一个数列 5 4 3 2 1 进行冒泡升序排列</p>
<p>第一轮的两两比较，需要比较4次；得到 4 3 2 1 5<br>第二轮的两两比较，需要比较3次；得到 3 2 1 4 5<br>第三轮的两两比较，需要比较2次；得到 2 1 3 4 5<br>第四轮的两两比较，需要比较1次；得到 1 2 3 4 5</p>
<p>所以总的比较次数为 4 + 3 + 2 + 1 = 10次<br>对于n位的数列则有比较次数为 (n-1) + (n-2) + … + 1 = n * (n - 1) / 2，这就得到了最大的比较次数。<br>而O(N^2)表示的是复杂度的数量级。举个例子来说，如果n = 10000，那么 n(n-1)/2 = (n^2 - n) / 2 = (100000000 - 10000) / 2，相对10^8来说，10000小的可以忽略不计了，所以总计算次数约为0.5 * N^2。用O(N^2)就表示了其数量级（忽略前面系数0.5）。</p>
<p><strong>综上所述，冒泡排序的时间复杂度为：O(n²)</strong></p>
<p><strong>本帖附件</strong></p>
<p><a href="https://u21519047.pipipan.com/fs/21519047-395416051" target="_blank" rel="noopener">点击下载</a></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em>乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</em></p>
]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Java面试题之面向对象的设计原则  一次性记忆</title>
    <url>/86.html</url>
    <content><![CDATA[<h2 id="六大原则"><a href="#六大原则" class="headerlink" title="六大原则"></a>六大原则</h2><ul>
<li>单一职责原则——SRP</li>
<li>开闭原则——OCP</li>
<li>里式替换原则——LSP</li>
<li>依赖倒置原则——DIP</li>
<li>接口隔离原则——ISP</li>
<li>迪米特原则——LOD</li>
</ul>
<p><strong>本帖附件</strong></p>
<p><a href="https://u21519047.pipipan.com/fs/21519047-395416051" target="_blank" rel="noopener">点击下载</a></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em>乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</em></p>
]]></content>
      <tags>
        <tag>Java面试题</tag>
      </tags>
  </entry>
  <entry>
    <title>apk反汇编工具apktool问题集锦</title>
    <url>/9.html</url>
    <content><![CDATA[<h2 id="Apktool的基本使用"><a href="#Apktool的基本使用" class="headerlink" title="Apktool的基本使用"></a>Apktool的基本使用</h2><p><strong>解包指令:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apktool d [apk文件] -o [解包存放路径]</span><br></pre></td></tr></table></figure>

<p>如果使用的是jar包,则:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java -jar apktool.jar d [apk文件] -o [解包存放路径]</span><br></pre></td></tr></table></figure>

<p><strong>打包指令:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apktool b [源码目录] -o [apk文件]</span><br><span class="line">或者</span><br><span class="line">java -jar apktool.jar  b [源码目录] -o [apk文件]</span><br></pre></td></tr></table></figure>

<p><strong>签名指令:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">jarsigner -verbose -keystore [签名文件] -signedjar [签名后的apk 可自定义文件名] [需要签名的apk]  [签名文件的别名]</span><br></pre></td></tr></table></figure>

<h3 id="温馨提示"><a href="#温馨提示" class="headerlink" title="温馨提示"></a>温馨提示</h3><p>由于apk在反编译后进行回编时容易出现各种异常情况, 建议解包后立马进行装包测试,以免白费功夫!</p>
<h2 id="问题1-DexBackedDexFile-NotADexFile"><a href="#问题1-DexBackedDexFile-NotADexFile" class="headerlink" title="问题1 DexBackedDexFile$NotADexFile"></a>问题1 DexBackedDexFile$NotADexFile</h2><p><strong>apktool反编apk时报错:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">org.jf.dexlib2.dexbacked.DexBackedDexFile$NotADexFile: Not a valid dex magic value: cf 77 4c c7 9b 21 01 cd</span><br></pre></td></tr></table></figure>

<p> 提示很明显，就是非法Dex，这是因为apk里有加密过后的dex文件，比如有些apk的assets目录下有加密后的Dex文件，添加<code>–only-main-classes</code>参数即可 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apktool d ~/tmp/test.apk -o /tmp/test --only-main-classes</span><br></pre></td></tr></table></figure>

<h2 id="apktool打包时找不到打包后的apk文件"><a href="#apktool打包时找不到打包后的apk文件" class="headerlink" title="apktool打包时找不到打包后的apk文件"></a>apktool打包时找不到打包后的apk文件</h2><p>新版的apktool需要加上 -o 参数, 否则只编译不输出apk 文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apktool b ~/tmp/test -o /tmp/test.apk</span><br></pre></td></tr></table></figure>

<p><strong>本文为作者原创 转载时请注明出处 谢谢</strong></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em>乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</em></p>
]]></content>
      <tags>
        <tag>android反编译</tag>
      </tags>
  </entry>
  <entry>
    <title>kotlin中 data class 到底是个什么鬼</title>
    <url>/91.html</url>
    <content><![CDATA[<p>data class就是一个类中只包含一些数据字段，类似于vo,pojo,java bean。一般而言，我们在Java中定义了这个数据类之后要重写一下toString，equals等方法。要生成get,set方法。</p>
<p>然而在Kotlin中这些都不在需要自己手动去敲了，编译器在背后默默给我们生成了如下的东西：</p>
<ul>
<li>equals()/hashCode()</li>
<li>toString()方法</li>
<li>componentN()方法</li>
<li>copy()方法</li>
</ul>
<h4 id="如何申明一个简单的数据类？-有一下几点要求："><a href="#如何申明一个简单的数据类？-有一下几点要求：" class="headerlink" title="如何申明一个简单的数据类？ 有一下几点要求："></a>如何申明一个简单的数据类？ 有一下几点要求：</h4><ul>
<li>主构造函数必须要至少有一个参数</li>
<li>主构造函数中的所有参数必须被标记为val或者var</li>
<li>数据类不能有以下修饰符：abstract，inner,open,sealed</li>
<li>data class只能实现接口（Kotlin1.1以前的规则），现在也可以继承其它类</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">data class User(var id: Int, var name: String)</span><br></pre></td></tr></table></figure>

<p>就这么一行代码，你已然拥有了一个数据类</p>
<p>主构造函数中的所有参数必须被标记为var或者val，var就表示可读写，val就表示只读，这就相当于表明了数据字段的访问权限</p>
<h4 id="componentN-方法是干嘛用的"><a href="#componentN-方法是干嘛用的" class="headerlink" title="componentN()方法是干嘛用的?"></a>componentN()方法是干嘛用的?</h4><p>在主构造函数中有多少个参数，就会依次生成对应的component1,component2,component3……这些函数返回的就是对应字段的值</p>
<p>componentN函数是用来实现解构申明的</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">data class User(var id: Int,var name:String) </span><br><span class="line">fun main(args: Array&lt;String&gt;) &#123;</span><br><span class="line">    var user: User = User(123, &quot;liuliqianxiao&quot;)</span><br><span class="line">    var (id,name) = user//多重赋值</span><br><span class="line">    print(&quot;$id,$name&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>拿上面的例子来说，给id赋值，其实调用的是user.component1()，给name赋值其实调用的是component2()函数。</p>
<p>有了这个解构申明，想在一个函数中返回多个结果，就可以申明一个简单的数据类来返回了，然后取值也很方便。</p>
<h4 id="copy函数"><a href="#copy函数" class="headerlink" title="copy函数"></a>copy函数</h4><p>默认生成的copy函数就是用现在的数据字段生成了一个新的对象。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fun copy(id: Int = this.id,name: String = this.name) = User(id,name)</span><br></pre></td></tr></table></figure>

<p>如果只想改变其中的某些字段，就可以在调用copy的时候采用命名参数的方法进行调用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fun main(args: Array&lt;String&gt;) &#123;</span><br><span class="line">    var user: User = User(123, &quot;liuliqianxiao&quot;)</span><br><span class="line">    var other: User = user.copy(name = &quot;mdzz&quot;)//只想改变名字</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em>乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</em></p>
]]></content>
      <tags>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title>Java中getName()、getCanonicalName()和getSimpleName()的异同</title>
    <url>/89.html</url>
    <content><![CDATA[<p><strong>最简单的方法, 就是写个测试类测试一下:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.getname.pkg;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo1</span> </span>&#123;</span><br><span class="line">		<span class="class"><span class="keyword">class</span> <span class="title">Demo2</span> </span>&#123;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">/* 三种方式获取普通类Main的名字 */</span></span><br><span class="line">		System.out.println(<span class="string">"-----三种方式获取普通类的名字-----"</span>);</span><br><span class="line">		String name = Main.class.getName();</span><br><span class="line">		System.out.println(<span class="string">"\t"</span> + <span class="string">"getName()方法："</span> + name);</span><br><span class="line"> </span><br><span class="line">		String canonicalname = Main.class.getCanonicalName();</span><br><span class="line">		System.out.println(<span class="string">"getCanonicalName()方法："</span> + <span class="string">"\t"</span> + canonicalname);</span><br><span class="line"> </span><br><span class="line">		String simplename = Main.class.getSimpleName();</span><br><span class="line">		System.out.println(<span class="string">"getSimpleName()方法："</span> + <span class="string">"\t"</span> + simplename);</span><br><span class="line"> </span><br><span class="line">		<span class="comment">/* getName()和getCanonicalName()获取数组名比较 */</span></span><br><span class="line">		<span class="keyword">int</span>[] aaa = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;</span><br><span class="line">		System.out.println(<span class="string">"\r\n"</span> + <span class="string">"-----对于数组 int[]-----"</span>);</span><br><span class="line">		name = aaa.getClass().getName();</span><br><span class="line">		System.out.println(<span class="string">"\t"</span> + <span class="string">"getName()方法："</span> + name);</span><br><span class="line"> </span><br><span class="line">		canonicalname = aaa.getClass().getCanonicalName();</span><br><span class="line">		System.out.println(<span class="string">"getCanonicalName()方法："</span> + <span class="string">"\t"</span> + canonicalname);</span><br><span class="line"> </span><br><span class="line">		<span class="comment">/* getName()和getCanonicalName()获取内部类名比较 */</span></span><br><span class="line">		System.out.println(<span class="string">"\r\n"</span> + <span class="string">"-----对于内部类-----"</span>);</span><br><span class="line">		name = Demo1.Demo2.class.getName();</span><br><span class="line">		System.out.println(<span class="string">"\t"</span> + <span class="string">"getName()方法："</span> + name);</span><br><span class="line"> </span><br><span class="line">		canonicalname = Demo1.Demo2.class.getCanonicalName();</span><br><span class="line">		System.out.println(<span class="string">"getCanonicalName()方法："</span> + <span class="string">"\t"</span> + canonicalname);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>打印结果为:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-----三种方式获取普通类的名字-----</span><br><span class="line"> getName()方法：com.getname.pkg.Main</span><br><span class="line">getCanonicalName()方法： com.getname.pkg.Main</span><br><span class="line">getSimpleName()方法： Main</span><br><span class="line"></span><br><span class="line">-----对于数组 int[]-----</span><br><span class="line"> getName()方法：[I</span><br><span class="line">getCanonicalName()方法： int[]</span><br><span class="line"></span><br><span class="line">-----对于内部类-----</span><br><span class="line"> getName()方法：com.getname.pkg.Main$Demo1$Demo2</span><br><span class="line">getCanonicalName()方法： com.getname.pkg.Main.Demo1.Demo2</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em>乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</em></p>
]]></content>
      <tags>
        <tag>java基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux常用指令集</title>
    <url>/93.html</url>
    <content><![CDATA[<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/20200122180946.png" alt></p>
<h3 id="常用指令集介绍如下"><a href="#常用指令集介绍如下" class="headerlink" title="常用指令集介绍如下:"></a>常用指令集介绍如下:</h3><ol>
<li>访问源列表中的每个网址，并读取软件列表，然后保存在我们的电脑上</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get update</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>安装可以更新的软件</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get upgrade</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>编辑sources文件</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo edit /etc/apt/sources.list</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>拷贝文件</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo cp /etc/apt/sources.list  /etc/apt/sources.list_save</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>安装指定软件</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get install [软件名称]</span><br></pre></td></tr></table></figure>

<ol start="6">
<li>将<code>sources.list</code>文件中的<code>archive.ubuntu.com</code>全部替换成<code>mirrors.ustc.edu.cn</code></li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo sed -i &apos;s/archive.ubuntu.com/mirrors.ustc.edu.cn/g&apos; /etc/apt/sources.list</span><br></pre></td></tr></table></figure>

<ol start="7">
<li>只查看文件的第100行到第200行</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sed -n ‘100,200p’+文件</span><br></pre></td></tr></table></figure>

<ol start="8">
<li>删除第二到第五行</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sed &apos;2,5d&apos;+文件</span><br></pre></td></tr></table></figure>

<ol start="9">
<li>删除包含”My”的行到包含”You”的行之间的行</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sed &apos;My/,/You/d&apos;+文件</span><br></pre></td></tr></table></figure>

<ol start="10">
<li>删除包含”My”的行到第十行的内容</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sed &apos;/My/,10d&apos;+文件</span><br></pre></td></tr></table></figure>

<ol start="11">
<li>设置文件可读可写可执行</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo chmod 777 /etc/apt/sources.list</span><br></pre></td></tr></table></figure>

<ol start="12">
<li>查看当前系统版本</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cat /proc/version</span><br></pre></td></tr></table></figure>

<ol start="13">
<li>查看当前ip地址</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ifconfig</span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ip addr</span><br></pre></td></tr></table></figure>

<ol start="14">
<li>连续创建目录</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mkdir -p ~/python ~/python/myapp</span><br></pre></td></tr></table></figure>

<ol start="15">
<li>查看端口是否开启</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">netstat -na |grep [端口号]</span><br></pre></td></tr></table></figure>

<ol start="16">
<li>查看当前用户</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">whoami</span><br></pre></td></tr></table></figure>

<p><strong>本帖附件</strong></p>
<p><a href="https://u21519047.pipipan.com/fs/21519047-395416051" target="_blank" rel="noopener">点击下载</a></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em>乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</em></p>
]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>java五大排序算法之选择排序</title>
    <url>/88.html</url>
    <content><![CDATA[<h3 id="一-选择排序介绍"><a href="#一-选择排序介绍" class="headerlink" title="一.选择排序介绍"></a>一.选择排序介绍</h3><p>选出最小的一个数与第一个位置的数交换</p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/7789414-5893f3ff1b915c38.gif" alt></p>
<h3 id="二-选择排序原理分析"><a href="#二-选择排序原理分析" class="headerlink" title="二.选择排序原理分析"></a>二.选择排序原理分析</h3><p>第1趟比较：拿第1个元素依次和它后面的每个元素进行比较，如果第1个元素大于后面某个元素，交换它们，经过第1趟比较，数组中最小的元素被选出，它被排在第一位</p>
<p>第2趟比较：拿第2个元素依次和它后面的每个元素进行比较，如果第2个元素大于后面某个元素，交换它们，经过第2趟比较，数组中第2小的元素被选出，它被排在第二位</p>
<p>……</p>
<p>第n-1趟比较：第n-1个元素和第n个元素作比较，如果第n-1个元素大于第n个元素，交换它们</p>
<h3 id="三-选择排序代码实现"><a href="#三-选择排序代码实现" class="headerlink" title="三.选择排序代码实现"></a>三.选择排序代码实现</h3><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">selectionSort</span>(<span class="params"><span class="keyword">int</span>[] nums</span>)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (nums == <span class="literal">null</span> || nums.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; nums.length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &gt; nums[j]) &#123;</span><br><span class="line">                swap(nums, i, j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span>(<span class="params"><span class="keyword">int</span>[] arr, <span class="keyword">int</span> i, <span class="keyword">int</span> j</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">int</span> temp = arr[i];</span><br><span class="line">    arr[i] = arr[j];</span><br><span class="line">    arr[j] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="四-选择排序的优化"><a href="#四-选择排序的优化" class="headerlink" title="四.选择排序的优化"></a>四.选择排序的优化</h3><p>使用临时变量存储最小值的角标值,减少交换的次数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void selectSort(int[] numbers) &#123;</span><br><span class="line">int size = numbers.length; // 数组长度</span><br><span class="line">int temp = 0; // 中间变量</span><br><span class="line">for (int i = 0; i &lt; size-1; i++) &#123;</span><br><span class="line">    int k = i; // 待确定的位置</span><br><span class="line">    // 选择出应该在第i个位置的数</span><br><span class="line">    for (int j = size - 1; j &gt; i; j--) &#123;</span><br><span class="line">        if (numbers[j] &lt; numbers[k]) &#123;</span><br><span class="line">            k = j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // 交换两个数</span><br><span class="line">    temp = numbers[i];</span><br><span class="line">    numbers[i] = numbers[k];</span><br><span class="line">    numbers[k] = temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="五-选择排序的时间复杂度"><a href="#五-选择排序的时间复杂度" class="headerlink" title="五.选择排序的时间复杂度"></a>五.选择排序的时间复杂度</h3><p><strong>时间复杂度：O(n²)</strong></p>
<p> <strong>空间复杂度：O(1)</strong>，只需要一个附加程序单元用于交换</p>
<p>稳定性：选择排序是不稳定的排序算法，因为无法保证值相等的元素的相对位置不变，例如 [3, 4, 3, 1, 5]这个数组，第一次交换，第一个3和1交换位置，此时原来两个3的相对位置发生了变化。</p>
<p><strong>本帖附件</strong></p>
<p><a href="https://u21519047.pipipan.com/fs/21519047-395416051" target="_blank" rel="noopener">点击下载</a></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em>乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</em></p>
]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>js十大邪术之一  图片隐写术</title>
    <url>/90.html</url>
    <content><![CDATA[<h2 id="1、什么是图片隐写术？"><a href="#1、什么是图片隐写术？" class="headerlink" title="1、什么是图片隐写术？"></a>1、什么是图片隐写术？</h2><p>权威的<a href="https://zh.wikipedia.org/wiki/隐写术" target="_blank" rel="noopener">wiki</a>说法是“<strong>隐写术</strong>是一门关于信息隐藏的技巧与科学，所谓信息隐藏指的是不让除预期的接收者之外的任何人知晓信息的传递事件或者信息的内容。”，图片隐写术简而言之就是利用图片来隐藏某些数据，让人一眼看去以为是很普通很正常的图片，但其实里面隐藏着某些“机密”数据。</p>
<p>据传911事件里，KB份子就是通过黄色图片来传递信息而躲过了FBI的监控。还有大众点评也是通过图片隐写术来保护自身合法权益。所以图片隐写术是一个双刃剑，就看你用它做什么了。</p>
<p>比如下面这张图片：</p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/25430-20171201151310992-247518948.png" alt></p>
<p>看起来是一张很漂亮的风景照片，但其实它里面却藏着一张美女图（注：美女图片来源于淘宝某店），如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/songjianzaina/SavePicGoPic/img/25430-20171201151405898-1394445312.jpg" alt></p>
<p>是不是很惊艳？看得你热血沸腾鼻血都往外冲呢？这就是图片隐写术的历害之处，“机密”隐藏于无形之中！</p>
<h2 id="2、图片隐写术是怎么做到的？"><a href="#2、图片隐写术是怎么做到的？" class="headerlink" title="2、图片隐写术是怎么做到的？"></a>2、图片隐写术是怎么做到的？</h2><p>　　 图片隐写有多种方式，我这里介绍的是采用图片的最低有效位（LSB）进行隐写。其原理就是图片的像素点都是由三原色（RGB）构成（如下图），由这三原色可以组成各种颜色，如CSS里的颜色定义#FFFFFF，即是三原色的16进制值写法，每个颜色各占用8bit。而LSB隐写就是修改像素中每个颜色值的最低位值，而这些修改，人眼一般是分辨不出来的，从而达到数据隐藏的目的。</p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/25430-20171201152935430-1596403381.jpg" alt></p>
<p>　　譬如我们想把’A’隐藏进来的话，如下图，就可以把A转成16进制的0x61再转成二进制的01100001，再修改为红色通道的最低位为这些二进制串。</p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/25430-20171201153039305-2068174246.jpg" alt></p>
<p>（注：以上图片和示例来源于Wooyun）</p>
<h2 id="3、Javascript实现的图片隐写术"><a href="#3、Javascript实现的图片隐写术" class="headerlink" title="3、Javascript实现的图片隐写术"></a>3、Javascript实现的图片隐写术</h2><p>　　代码项目见GitHub： <a href="https://github.com/kingthy/imagemask" target="_blank" rel="noopener">https://github.com/kingthy/imagemask</a></p>
<ul>
<li>在线演示 <a href="https://ipfs.io/ipfs/QmUG1TKotQYsp6bSw6pX4crFWfhJRNTnJre7buEaYYBV72" target="_blank" rel="noopener">https://ipfs.io/ipfs/QmUG1TKotQYsp6bSw6pX4crFWfhJRNTnJre7buEaYYBV72</a></li>
<li>使用示例</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script type=&quot;text/javascript&quot; src=&quot;imagemask.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">var mask = new ImageMask(&#123;</span><br><span class="line">    debug: false,   //是否开启调试模式</span><br><span class="line">    charSize: 16,   //字符的字节位数，默认为16，即字符最大值为0xFFFF</span><br><span class="line">    mixCount: 2,    //隐写数据要混合到图片颜色值里的最低位数，值范围在1-5，默认为2，如果大于3，则图片会失真很严重</span><br><span class="line">    lengthSize: 24  //数据长度值的占用字节位数，默认为24，也即数据长度最大值为16777215</span><br><span class="line">&#125;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>　　</p>
<ul>
<li>隐写文本</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//脚本里传入页面的canvas对象和要隐写的文件</span><br><span class="line">var output = document.getElementById(&apos;output&apos;);</span><br><span class="line">var canvas = document.getElementById(&apos;canvas&apos;);</span><br><span class="line">var file = document.getElementById(&apos;file&apos;);</span><br><span class="line">mask.hideFile(canvas, file.files[0], , function(result)&#123;</span><br><span class="line">        if(result.success)&#123;</span><br><span class="line">            output.src = canvas.toDataURL();</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            alert(result.message);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>　　</p>
<ul>
<li>隐写文件</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//脚本里传入页面的canvas对象和要隐写的文件</span><br><span class="line">var output = document.getElementById(&apos;output&apos;);</span><br><span class="line">var canvas = document.getElementById(&apos;canvas&apos;);</span><br><span class="line">var file = document.getElementById(&apos;file&apos;);</span><br><span class="line">mask.hideFile(canvas, file.files[0], , function(result)&#123;</span><br><span class="line">        if(result.success)&#123;</span><br><span class="line">            output.src = canvas.toDataURL();</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            alert(result.message);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>　　</p>
<ul>
<li>读出图片里隐写的文本</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var canvas = document.getElementById(&apos;canvas&apos;);</span><br><span class="line">var message = mask.revealText(canvas);</span><br></pre></td></tr></table></figure>

<p>　　</p>
<ul>
<li>读出图片里隐写的文件</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var canvas = document.getElementById(&apos;canvas&apos;);</span><br><span class="line">var file = mask.revealFile(canvas);       //file.name = 文件名称， file.data = 文件数据</span><br></pre></td></tr></table></figure>

<p>　　</p>
<h2 id="4、示例图片"><a href="#4、示例图片" class="headerlink" title="4、示例图片"></a>4、示例图片</h2><ul>
<li>原图<br><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/25430-20171201154457711-816456262.jpg" alt></li>
</ul>
<ul>
<li><p>隐写一章3千多字的小说内容后的图片效果</p>
</li>
<li><p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/25430-20171201154457711-816456262.jpg" alt>（隐写什么小说内容，各位有兴趣的将图片保存下来，然后在演示页面里读出来即可知道。）*</p>
</li>
</ul>
<p>以上两张（包括上面有美女的那张）图片效果几乎是一样的，人眼是看不出来有任何变化。</p>
<h2 id="5、附加说明"><a href="#5、附加说明" class="headerlink" title="5、附加说明"></a>5、附加说明</h2><p>　　1）、LSB方式的隐写图片只能存储为PNG或者BMP图片格式，并且不允许再采用有损压缩（比如JPEG），否则会丢失隐写的数据！</p>
<p>​       2）、图片里可以隐写任何数据，并且可以存储的数据多少由图片的大小（长宽）来决定。也许一张图片就能存储下一部圣经的所有文字。</p>
<h2 id="6、脑洞时间"><a href="#6、脑洞时间" class="headerlink" title="6、脑洞时间"></a>6、脑洞时间</h2><p>　　工具是有了，我们可以用来做些什么呢？发挥你的想象吧：）</p>
<p>​        1）、<strong>防采集</strong>：将文本内容隐写到图片里，这样就能防直接的采集（比如小说网站、内容原创网站）  ，当然了，只能防君子了。</p>
<p>​        2）、<strong>版权水印</strong>：将版权水印（文字或者图片）或者其它身份识别标记（如公司里防泄密）隐写到图片里，如果对方直接盗用，则可以起到鉴别作用（如大众点评网案例）。当然了，如要防“攻击”（压缩，变形，涂改等）则需要更高深的隐写方式。有兴趣的可阅读啊里月饼事件引发的知乎讨论贴里的牛人回复。</p>
<p>​                 传递门：<a href="https://www.zhihu.com/question/50735753/answer/122717091" target="_blank" rel="noopener">https://www.zhihu.com/question/50735753/answer/122717091</a></p>
<p>​        3）、<strong>防监控</strong>：将文本或图片隐写到图片里，可以防机器（某墙？）监控（比如整网站都是好孩子图片或风景图，但其实都是坏孩子图片或者XX小说、XX内容）</p>
<p>​        4）、<strong>文件下载</strong>： 直接将文件存于图片里，绕过文件格式限制问题。比如很多图床只能传图片，但经过隐写后就可以图片里藏任意文件了，比如大家都喜欢的种子，当然了，要求图床不会再进行图片再次压缩。</p>
<p><strong>本帖附件</strong></p>
<p><a href="https://u21519047.pipipan.com/fs/21519047-395416051" target="_blank" rel="noopener">点击下载</a></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em>乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</em></p>
]]></content>
      <tags>
        <tag>大前端</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux各大镜像源连接集合</title>
    <url>/94.html</url>
    <content><![CDATA[<h3 id="官方源"><a href="#官方源" class="headerlink" title="官方源:"></a>官方源:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">deb http://archive.ubuntu.com/ubuntu/ trusty main restricted universe multiverse</span><br><span class="line"></span><br><span class="line">deb http://archive.ubuntu.com/ubuntu/ trusty-security main restricted universe multiverse</span><br><span class="line"></span><br><span class="line">deb http://archive.ubuntu.com/ubuntu/ trusty-updates main restricted universe multiverse</span><br><span class="line"></span><br><span class="line">deb http://archive.ubuntu.com/ubuntu/ trusty-proposed main restricted universe multiverse</span><br><span class="line"></span><br><span class="line">deb http://archive.ubuntu.com/ubuntu/ trusty-backports main restricted universe multiverse</span><br><span class="line"></span><br><span class="line">deb-src http://archive.ubuntu.com/ubuntu/ trusty main restricted universe multiverse</span><br><span class="line"></span><br><span class="line">deb-src http://archive.ubuntu.com/ubuntu/ trusty-security main restricted universe multiverse</span><br><span class="line"></span><br><span class="line">deb-src http://archive.ubuntu.com/ubuntu/ trusty-updates main restricted universe multiverse</span><br><span class="line"></span><br><span class="line">deb-src http://archive.ubuntu.com/ubuntu/ trusty-proposed main restricted universe multiverse</span><br><span class="line"></span><br><span class="line">deb-src http://archive.ubuntu.com/ubuntu/ trusty-backports main restricted universe multiverse</span><br><span class="line"></span><br><span class="line">deb http://mirrors.163.com/ubuntu/ trusty main restricted universe multiverse</span><br></pre></td></tr></table></figure>

<h3 id="阿里"><a href="#阿里" class="headerlink" title="阿里:"></a>阿里:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#阿里公钥</span><br><span class="line">curl -sSL http://acs-public-mirror.oss-cn-hangzhou.aliyuncs.com/docker-engine/internet | sh -</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">deb http://mirrors.aliyun.com/ubuntu/ trusty main restricted universe multiverse</span><br><span class="line"></span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ trusty-security main restricted universe multiverse</span><br><span class="line"></span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ trusty-updates main restricted universe multiverse</span><br><span class="line"></span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ trusty-proposed main restricted universe multiverse</span><br><span class="line"></span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ trusty-backports main restricted universe multiverse</span><br><span class="line"></span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ trusty main restricted universe multiverse</span><br><span class="line"></span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ trusty-security main restricted universe multiverse</span><br><span class="line"></span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ trusty-updates main restricted universe multiverse</span><br><span class="line"></span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ trusty-proposed main restricted universe multiverse</span><br><span class="line"></span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ trusty-backports main restricted universe multiverse</span><br></pre></td></tr></table></figure>

<h3 id="网易-Ubuntu-源（速度很快"><a href="#网易-Ubuntu-源（速度很快" class="headerlink" title="网易 Ubuntu 源（速度很快):"></a>网易 Ubuntu 源（速度很快):</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">deb http://mirrors.163.com/ubuntu/ precise main universe restricted multiverse</span><br><span class="line">   deb-src http://mirrors.163.com/ubuntu/ precise main universe restricted multiverse</span><br><span class="line">   deb http://mirrors.163.com/ubuntu/ precise-security universe main multiverse restricted</span><br><span class="line">   deb-src http://mirrors.163.com/ubuntu/ precise-security universe main multiverse restricted</span><br><span class="line">   deb http://mirrors.163.com/ubuntu/ precise-updates universe main multiverse restricted</span><br><span class="line">   deb http://mirrors.163.com/ubuntu/ precise-proposed universe main multiverse restricted</span><br><span class="line">   deb-src http://mirrors.163.com/ubuntu/ precise-proposed universe main multiverse restricted</span><br><span class="line">   deb http://mirrors.163.com/ubuntu/ precise-backports universe main multiverse restricted</span><br><span class="line">   deb-src http://mirrors.163.com/ubuntu/ precise-backports universe main multiverse restricted</span><br><span class="line">   deb-src http://mirrors.163.com/ubuntu/ precise-updates universe main multiverse restricted</span><br></pre></td></tr></table></figure>

<h3 id="中国科技大学-教育网用户推荐"><a href="#中国科技大学-教育网用户推荐" class="headerlink" title="中国科技大学 (教育网用户推荐):"></a>中国科技大学 (教育网用户推荐):</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#中科大公钥</span><br><span class="line">curl -fsSL https://mirrors.ustc.edu.cn/docker-ce/linux/ubuntu/gpg | sudo apt-key add -</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">deb http://debian.ustc.edu.cn/ubuntu/ precise main restricted universe multiverse</span><br><span class="line">    deb http://debian.ustc.edu.cn/ubuntu/ precise-backports restricted universe multiverse</span><br><span class="line">    deb http://debian.ustc.edu.cn/ubuntu/ precise-proposed main restricted universe multiverse</span><br><span class="line">    deb http://debian.ustc.edu.cn/ubuntu/ precise-security main restricted universe multiverse</span><br><span class="line">    deb http://debian.ustc.edu.cn/ubuntu/ precise-updates main restricted universe multiverse</span><br><span class="line">    deb-src http://debian.ustc.edu.cn/ubuntu/ precise main restricted universe multiverse</span><br><span class="line">    deb-src http://debian.ustc.edu.cn/ubuntu/ precise-backports main restricted universe multiverse</span><br><span class="line">    deb-src http://debian.ustc.edu.cn/ubuntu/ precise-proposed main restricted universe multiverse</span><br><span class="line">    deb-src http://debian.ustc.edu.cn/ubuntu/ precise-security main restricted universe multiverse</span><br><span class="line">    deb-src http://debian.ustc.edu.cn/ubuntu/ precise-updates main restricted universe multiverse</span><br></pre></td></tr></table></figure>

<h3 id="北京理工大学"><a href="#北京理工大学" class="headerlink" title="北京理工大学:"></a>北京理工大学:</h3><pre><code>deb http://mirror.bjtu.edu.cn/ubuntu/ precise main multiverse restricted universe
deb http://mirror.bjtu.edu.cn/ubuntu/ precise-backports main multiverse restricted universe
deb http://mirror.bjtu.edu.cn/ubuntu/ precise-proposed main multiverse restricted universe
deb http://mirror.bjtu.edu.cn/ubuntu/ precise-security main multiverse restricted universe
deb http://mirror.bjtu.edu.cn/ubuntu/ precise-updates main multiverse restricted universe
deb-src http://mirror.bjtu.edu.cn/ubuntu/ precise main multiverse restricted universe
deb-src http://mirror.bjtu.edu.cn/ubuntu/ precise-backports main multiverse restricted universe
deb-src http://mirror.bjtu.edu.cn/ubuntu/ precise-proposed main multiverse restricted universe
deb-src http://mirror.bjtu.edu.cn/ubuntu/ precise-security main multiverse restricted universe
deb-src http://mirror.bjtu.edu.cn/ubuntu/ precise-updates main multiverse restricted universe</code></pre><h3 id="兰州大学"><a href="#兰州大学" class="headerlink" title="兰州大学:"></a>兰州大学:</h3><pre><code>deb ftp://mirror.lzu.edu.cn/ubuntu/ precise main multiverse restricted universe
deb ftp://mirror.lzu.edu.cn/ubuntu/ precise-backports main multiverse restricted universe
deb ftp://mirror.lzu.edu.cn/ubuntu/ precise-proposed main multiverse restricted universe
deb ftp://mirror.lzu.edu.cn/ubuntu/ precise-security main multiverse restricted universe
deb ftp://mirror.lzu.edu.cn/ubuntu/ precise-updates main multiverse restricted universe
deb ftp://mirror.lzu.edu.cn/ubuntu-cn/ precise main multiverse restricted universe</code></pre><h3 id="上海交通大学"><a href="#上海交通大学" class="headerlink" title="上海交通大学:"></a>上海交通大学:</h3><pre><code>deb http://ftp.sjtu.edu.cn/ubuntu/ precise main multiverse restricted universe
deb http://ftp.sjtu.edu.cn/ubuntu/ precise-backports main multiverse restricted universe
deb http://ftp.sjtu.edu.cn/ubuntu/ precise-proposed main multiverse restricted universe
deb http://ftp.sjtu.edu.cn/ubuntu/ precise-security main multiverse restricted universe
deb http://ftp.sjtu.edu.cn/ubuntu/ precise-updates main multiverse restricted universe
deb http://ftp.sjtu.edu.cn/ubuntu-cn/ precise main multiverse restricted universe
deb-src http://ftp.sjtu.edu.cn/ubuntu/ precise main multiverse restricted universe
deb-src http://ftp.sjtu.edu.cn/ubuntu/ precise-backports main multiverse restricted universe
deb-src http://ftp.sjtu.edu.cn/ubuntu/ precise-proposed main multiverse restricted universe
deb-src http://ftp.sjtu.edu.cn/ubuntu/ precise-security main multiverse restricted universe
deb-src http://ftp.sjtu.edu.cn/ubuntu/ precise-updates main multiverse restricted universe</code></pre><h3 id="centos源（放心使用）"><a href="#centos源（放心使用）" class="headerlink" title="centos源（放心使用）:"></a>centos源（放心使用）:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">deb http://centos.bitcomm.cn/ubuntu trusty main restricted universe multiverse</span><br><span class="line"></span><br><span class="line">deb http://centos.bitcomm.cn/ubuntu trusty-security main restricted universe multiverse</span><br><span class="line"></span><br><span class="line">deb http://centos.bitcomm.cn/ubuntu trusty-updates main restricted universe multiverse</span><br><span class="line"></span><br><span class="line">deb http://centos.bitcomm.cn/ubuntu trusty-backports main restricted universe multiverse</span><br><span class="line"></span><br><span class="line">deb http://centos.bitcomm.cn/ubuntu trusty-proposed main restricted universe multiverse</span><br><span class="line"></span><br><span class="line">deb-src http://centos.bitcomm.cn/ubuntu trusty main restricted universe multiverse</span><br><span class="line"></span><br><span class="line">deb-src http://centos.bitcomm.cn/ubuntu trusty-security main restricted universe multiverse</span><br><span class="line"></span><br><span class="line">deb-src http://centos.bitcomm.cn/ubuntu trusty-updates main restricted universe multiverse</span><br><span class="line"></span><br><span class="line">deb-src http://centos.bitcomm.cn/ubuntu trusty-backports main restricted universe multiverse</span><br><span class="line"></span><br><span class="line">deb-src http://centos.bitcomm.cn/ubuntu trusty-proposed main restricted universe multiverse</span><br></pre></td></tr></table></figure>

<h3 id="搜狐源："><a href="#搜狐源：" class="headerlink" title="搜狐源："></a>搜狐源：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">deb http://mirrors.sohu.com/ubuntu/ trusty main restricted universe multiverse</span><br><span class="line"></span><br><span class="line">deb http://mirrors.sohu.com/ubuntu/ trusty-security main restricted universe multiverse</span><br><span class="line"></span><br><span class="line">deb http://mirrors.sohu.com/ubuntu/ trusty-updates main restricted universe multiverse</span><br><span class="line"></span><br><span class="line">deb http://mirrors.sohu.com/ubuntu/ trusty-proposed main restricted universe multiverse</span><br><span class="line"></span><br><span class="line">deb http://mirrors.sohu.com/ubuntu/ trusty-backports main restricted universe multiverse</span><br><span class="line"></span><br><span class="line">deb-src http://mirrors.sohu.com/ubuntu/ trusty main restricted universe multiverse</span><br><span class="line"></span><br><span class="line">deb-src http://mirrors.sohu.com/ubuntu/ trusty-security main restricted universe multiverse</span><br><span class="line"></span><br><span class="line">deb-src http://mirrors.sohu.com/ubuntu/ trusty-updates main restricted universe multiverse</span><br><span class="line"></span><br><span class="line">deb-src http://mirrors.sohu.com/ubuntu/ trusty-proposed main restricted universe multiverse</span><br><span class="line"></span><br><span class="line">deb-src http://mirrors.sohu.com/ubuntu/ trusty-backports main restricted universe multiverse</span><br></pre></td></tr></table></figure>

<p><strong>本帖附件</strong></p>
<p><a href="https://u21519047.pipipan.com/fs/21519047-395416051" target="_blank" rel="noopener">点击下载</a></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em>乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</em></p>
]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Kotlin中@JvmOverloads 注解</title>
    <url>/92.html</url>
    <content><![CDATA[<p>在Kotlin中@JvmOverloads注解的作用就是：在有默认参数值的方法中使用@JvmOverloads注解，则Kotlin就会暴露多个重载方法。<br> 可能还是云里雾里，直接上代码，代码解释一切：<br> 如果我们再kotlin中写如下代码：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">f</span><span class="params">(a: <span class="type">String</span>, b: <span class="type">Int</span> = <span class="number">0</span>, c: <span class="type">String</span>=<span class="string">"abc"</span>)</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>相当于在Java中声明</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> f(<span class="built_in">String</span> a, <span class="built_in">int</span> b, <span class="built_in">String</span> c)&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>默认参数没有起到任何作用。</p>
<p>但是如果使用的了@JvmOverloads注解：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@JvmOverloads</span> <span class="function"><span class="keyword">fun</span> <span class="title">f</span><span class="params">(a: <span class="type">String</span>, b: <span class="type">Int</span>=<span class="number">0</span>, c:<span class="type">String</span>=<span class="string">"abc"</span>)</span></span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>相当于在Java中声明了3个方法：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> f(<span class="built_in">String</span> a)</span><br><span class="line"><span class="keyword">void</span> f(<span class="built_in">String</span> a, <span class="built_in">int</span> b)</span><br><span class="line"><span class="keyword">void</span> f(<span class="built_in">String</span> a, <span class="built_in">int</span> b, <span class="built_in">String</span> c)</span><br></pre></td></tr></table></figure>

<p>是不是很方便，再也不用写那么多重载方法了。</p>
<p>注：该注解也可用在构造方法和静态方法。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyLayout</span>: <span class="type">RelativeLayout &#123;</span></span></span><br><span class="line"></span><br><span class="line">   <span class="meta">@JvmOverloads</span></span><br><span class="line">   <span class="keyword">constructor</span>(context:Context, attributeSet: AttributeSet? = <span class="literal">null</span>, defStyleAttr: <span class="built_in">Int</span> = <span class="number">0</span>): <span class="keyword">super</span>(context, attributeSet, defStyleAttr)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>相当Java中的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyLayout</span> <span class="keyword">extends</span> <span class="title">RelativeLayout</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyLayout</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(context, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyLayout</span><span class="params">(Context context, AttributeSet attrs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(context, attrs, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyLayout</span><span class="params">(Context context, AttributeSet attrs, <span class="keyword">int</span> defStyleAttr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context, attrs, defStyleAttr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em>乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</em></p>
]]></content>
      <tags>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title>markdown导出带目录PDF的三种方法</title>
    <url>/96.html</url>
    <content><![CDATA[<blockquote>
<p>将文档导出PDF, 内容一旦比较多, 如果没有目录跳转的话找起来特别费劲, 以下是解决方案</p>
</blockquote>
<h3 id="第一种-使用CSDN"><a href="#第一种-使用CSDN" class="headerlink" title="第一种 使用CSDN"></a>第一种 使用CSDN</h3><h4 id="1-编辑好文章后-点击导出-选择导出为HTML"><a href="#1-编辑好文章后-点击导出-选择导出为HTML" class="headerlink" title="1. 编辑好文章后 点击导出, 选择导出为HTML"></a>1. 编辑好文章后 点击导出, 选择导出为HTML</h4><p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/20200121154509845.png" alt></p>
<h4 id="2-选择导出的模板"><a href="#2-选择导出的模板" class="headerlink" title="2. 选择导出的模板"></a>2. 选择导出的模板</h4><p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/20200121152330894.png" alt></p>
<h4 id="3-使用HTML转PDF工具进行格式转换"><a href="#3-使用HTML转PDF工具进行格式转换" class="headerlink" title="3. 使用HTML转PDF工具进行格式转换"></a>3. 使用HTML转PDF工具进行格式转换</h4><pre><code>软件下载链接:https://wkhtmltopdf.org/downloads.html</code></pre><h6 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法:"></a>使用方法:</h6><pre><code>wkhtmltopdf --disable-smart-shrinking html文件路径 导出的pdf文件路径 //html路径可使用网络路径</code></pre><h4 id="4-如果嫌下载软件麻烦-也可以直接使用浏览器导出"><a href="#4-如果嫌下载软件麻烦-也可以直接使用浏览器导出" class="headerlink" title="4. 如果嫌下载软件麻烦, 也可以直接使用浏览器导出"></a>4. 如果嫌下载软件麻烦, 也可以直接使用浏览器导出</h4><p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/20200121154853909.png" alt></p>
<h3 id="第二种-使用i5ting-toc工具"><a href="#第二种-使用i5ting-toc工具" class="headerlink" title="第二种 使用i5ting_toc工具"></a>第二种 使用i5ting_toc工具</h3><p>此法需要nodejs环境</p>
<h6 id="使用方法-1"><a href="#使用方法-1" class="headerlink" title="使用方法:"></a>使用方法:</h6><p>第一步.安装i5ting_toc</p>
<pre><code>npm install i5ting_toc -g</code></pre><p>第二步 使用转换指令 先将md转成html </p>
<pre><code>i5ting_toc -f [需要转换文件名].md</code></pre><p>第三步 预览转换后的文件</p>
<pre><code>i5ting_toc -o //默认在同级目录生成preview文件夹</code></pre><p>第四步 用浏览器或者将HTML转成PDF即可<br><strong>效果如下:</strong><br><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/20200121163421261.png" alt></p>
<h3 id="第三种-使用vscode插件-Markdown-Preview-Enhanced"><a href="#第三种-使用vscode插件-Markdown-Preview-Enhanced" class="headerlink" title="第三种 使用vscode插件 Markdown Preview Enhanced"></a>第三种 使用vscode插件 Markdown Preview Enhanced</h3><h5 id="使用方法-2"><a href="#使用方法-2" class="headerlink" title="使用方法:"></a>使用方法:</h5><p>第一步: 安装插件<br><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/2020012116002755.png" alt><br>第二步:打开需要转换的.md文件，右键选择打开同步预览<br><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/20200121160244207.png" alt><br>第三步 将光标放置想要生成目录的输出位置 右键打开命令面板 并输入<code>Markdown Preview Enhanced: Create Toc</code><br><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/20200121160600743.png" alt></p>
<p>​    <img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/20200121160743903.png" alt></p>
<p>第四步 点击保存 文档将自动生成目录</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/20200121160850389.png" alt></p>
<p>第五步 导出你需要的格式 建议导出HTML 然后进行相应的转换即可</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/20200121161014388.png" alt></p>
<p><strong>最终效果如下:</strong><br><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/20200121161510122.png" alt></p>
<p><strong>本帖附件</strong></p>
<p><a href="https://u21519047.pipipan.com/fs/21519047-395416051" target="_blank" rel="noopener">点击下载</a></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em>乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</em></p>
]]></content>
      <tags>
        <tag>实用技巧</tag>
      </tags>
  </entry>
  <entry>
    <title>linux下的线程与进程</title>
    <url>/95.html</url>
    <content><![CDATA[<h2 id="两种线程设计模型"><a href="#两种线程设计模型" class="headerlink" title="两种线程设计模型"></a>两种线程设计模型</h2><ul>
<li><p><strong>核心级线程设计模型</strong>:</p>
<p>由操作系统内核实现, 特点是: 速度快  <em>windows系统采用的是这种设计模型</em></p>
<p>可以比喻为用自己的大脑控制自己十根手指头</p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/%E5%9B%BE%E7%89%871.png" alt></p>
</li>
<li><p><strong>用户级线程设计模型</strong>:</p>
<p>操作系统核外实现的线程模式, 特点是: 线程调度在核外 速度不如核内 <em>Linux系统采用的是这种</em></p>
</li>
</ul>
<p>​        可以比喻为自己的十根手指头需要借助外力才能动</p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/%E5%9B%BE%E7%89%872.png" alt></p>
<h2 id="Linux系统下有真正意义的多线程么"><a href="#Linux系统下有真正意义的多线程么" class="headerlink" title="Linux系统下有真正意义的多线程么?"></a>Linux系统下有真正意义的多线程么?</h2><p>由上面Linux采用的线程设计模型可知,Linux系统并没有真正意义上的多线程</p>
<p>因此, Linux系统里处理多线程不如Windows强悍</p>
<h2 id="Linux系统的两个线程库"><a href="#Linux系统的两个线程库" class="headerlink" title="Linux系统的两个线程库"></a>Linux系统的两个线程库</h2><ul>
<li>LinuxThreads线程库</li>
<li>RedHat的NPTL</li>
</ul>
<p>这两个线程库实际上并没有完全按照线程模式进行实现</p>
<h2 id="进程的生命周期"><a href="#进程的生命周期" class="headerlink" title="进程的生命周期"></a>进程的生命周期</h2><h4 id="进程的创建及回收"><a href="#进程的创建及回收" class="headerlink" title="进程的创建及回收"></a>进程的创建及回收</h4><p>在Android中, ActivityThead的创建预示着进程的创建</p>
<h4 id="进程的级别-由高到低"><a href="#进程的级别-由高到低" class="headerlink" title="进程的级别(由高到低)"></a>进程的级别(由高到低)</h4><ul>
<li><strong>前台进程</strong>: 优先级最高, 正处于Activity Resume()状态, 杀死前台进程需要用户响应</li>
<li><strong>可见进程</strong></li>
<li><strong>服务进程</strong></li>
<li><strong>后台进程</strong></li>
<li><strong>空进程:</strong> 无组件启动,做进程缓存使用, 恢复速度快</li>
</ul>
<p>当一个应用启动的时候, 它的进程级别不是保持固定的, Android内部通过Handler进行轮询检测当前进程的状态,ActivityThread掌控的Activity 的生命周期, 如果栈中无Activity存在, 但是有Service存在的情况下, 此时的进程级别就会从前台进程降为服务进程</p>
<p>如果想要查询当前进程的级别, 可以通过ActivityManager .RuningAppProcessInfo进行查询,内部有对应的变量和方法</p>
<h4 id="进程级别的记忆方法"><a href="#进程级别的记忆方法" class="headerlink" title="进程级别的记忆方法"></a>进程级别的记忆方法</h4><p>前见服后空</p>
<p>谐音: 权健服后空 (懂?)</p>
<p><strong>本帖附件</strong></p>
<p><a href="https://u21519047.pipipan.com/fs/21519047-395416051" target="_blank" rel="noopener">点击下载</a></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em>乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</em></p>
]]></content>
      <tags>
        <tag>Android系统</tag>
      </tags>
  </entry>
  <entry>
    <title>Source Insight 4.0 安装与破解(附下载地址)</title>
    <url>/97.html</url>
    <content><![CDATA[<h2 id="Source-Insight4-0简介"><a href="#Source-Insight4-0简介" class="headerlink" title="Source Insight4.0简介"></a>Source Insight4.0简介</h2><p> <strong>Source Insight 4.0</strong>是一款功能强大的程序编辑器和代码浏览器，只要你拥有相应的程序语言包就能够进行程序分析， 比如说目前最好的开源语言java </p>
<p>作为一个android开发人员, 如果你想在windows平台上阅读程序源码, 那么Source Insight是你的布尔首选</p>
<h2 id="Source-Insight4-0-下载地址"><a href="#Source-Insight4-0-下载地址" class="headerlink" title="Source Insight4.0 下载地址"></a>Source Insight4.0 下载地址</h2><h5 id="如果您已经安装了sourceinsight4-0，只是需要破解，则直接下载以下资源"><a href="#如果您已经安装了sourceinsight4-0，只是需要破解，则直接下载以下资源" class="headerlink" title="如果您已经安装了sourceinsight4.0，只是需要破解，则直接下载以下资源:"></a>如果您已经安装了sourceinsight4.0，只是需要破解，则直接下载以下资源:</h5><p><strong>链接:</strong> <a href="https://pan.baidu.com/s/1dFWD4YX" target="_blank" rel="noopener">https://pan.baidu.com/s/1dFWD4YX</a>   <strong>密码:</strong> icjm</p>
<p><strong>解压密码:</strong> biu <em>因可能被检测版权问题，故必须加密打包分享</em>。</p>
<h5 id="如果需要全部重新安装，请下载-完全安装包-破解exe-lisence-压缩包："><a href="#如果需要全部重新安装，请下载-完全安装包-破解exe-lisence-压缩包：" class="headerlink" title="如果需要全部重新安装，请下载 完全安装包+破解exe+lisence 压缩包："></a>如果需要全部重新安装，请下载 完全安装包+破解exe+lisence 压缩包：</h5><p><strong>链接:</strong> <a href="https://pan.baidu.com/s/1eSZtsbw" target="_blank" rel="noopener">https://pan.baidu.com/s/1eSZtsbw</a>  <strong>密码:</strong> 3kjj</p>
<p><strong>解压密码: biu</strong> <em>因可能被检测版权问题，故必须加密打包分享。</em></p>
<h4 id="备用破解版下载"><a href="#备用破解版下载" class="headerlink" title="备用破解版下载:"></a>备用破解版下载:</h4><p><a href="https://545c.com/f/21042697-503735264-7eb2bc" target="_blank" rel="noopener">https://545c.com/f/21042697-503735264-7eb2bc</a><br>（访问密码：312306）</p>
<h2 id="Source-Insight4-0破解方法"><a href="#Source-Insight4-0破解方法" class="headerlink" title="Source Insight4.0破解方法"></a>Source Insight4.0破解方法</h2><h4 id="第一步-安装Source-Insight4-0"><a href="#第一步-安装Source-Insight4-0" class="headerlink" title="第一步 安装Source Insight4.0"></a>第一步 安装Source Insight4.0</h4><p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/201811161715414378.jpg" alt></p>
<h4 id="第二步-替换Source-Insight-exe文件"><a href="#第二步-替换Source-Insight-exe文件" class="headerlink" title="第二步 替换Source Insight.exe文件"></a>第二步 替换Source Insight.exe文件</h4><p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20181116171557242.jpg" alt></p>
<h4 id="第三步-加载lic注册文件"><a href="#第三步-加载lic注册文件" class="headerlink" title="第三步 加载lic注册文件"></a>第三步 加载lic注册文件</h4><p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/1145504-20170413231115861-1570132634.png" alt></p>
<h4 id="第四步-点击“Next”破解成功！"><a href="#第四步-点击“Next”破解成功！" class="headerlink" title="第四步 点击“Next”破解成功！"></a>第四步 点击“Next”破解成功！</h4><p><strong>附录二：</strong> </p>
<p><strong>如果安装或者安装后提示有问题，请进行完全卸载后，再重装一遍即可。</strong></p>
<p><strong>完全卸载方式：</strong></p>
<p><strong>1、清除注册表信息：</strong></p>
<blockquote>
<ul>
<li>“win ”+ R  或者  “开始” -&gt; “运行”，输入“regedit”，回车；</li>
<li>在弹出的注册表管理器中，选择“编辑”-&gt; “查找”-&gt;“source insight”，或按照下述路径展开：HKEY_CURRENT_USER -&gt; software -&gt; Source Dynamics -&gt; Source Insight;</li>
<li>将该项下面的source insight 需要清除的对应版本项目选中，右键“删除“。</li>
</ul>
</blockquote>
<p><strong>2、删除全局配置信息：</strong></p>
<blockquote>
<ul>
<li>在 ./user/document/source insight 3.0/4.0 下的所有文件及该文件夹</li>
<li><strong>注意此处的路径可能不同</strong> 也可能是:“库”-&gt;“用户”(也可能是你的名字) -&gt; 文档 -&gt; source insight3.0/4.0</li>
<li><strong>或者</strong> 你上次安装的时候所指定的其他位置</li>
</ul>
</blockquote>
<p><strong>本帖附件</strong></p>
<p><a href="https://u21519047.pipipan.com/fs/21519047-395416051" target="_blank" rel="noopener">点击下载</a></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em>乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</em></p>
]]></content>
      <tags>
        <tag>Android源码</tag>
      </tags>
  </entry>
  <entry>
    <title>Source Insight快捷键大全</title>
    <url>/98.html</url>
    <content><![CDATA[<h2 id="Source-Insight快捷键大全"><a href="#Source-Insight快捷键大全" class="headerlink" title="Source Insight快捷键大全"></a>Source Insight快捷键大全</h2><p>退出程序 : Alt+F4</p>
<p>重画屏幕 : Ctrl+Alt+Space</p>
<p>完成语法 : Ctrl+E</p>
<p>复制一行 : Ctrl+K</p>
<p>恰好复制该位置右边的该行的字符 : Ctrl+Shift+K</p>
<p>复制到剪贴板 : Ctrl+Del</p>
<p>剪切一行 : Ctrl+U</p>
<p>剪切该位置右边的该行的字符 : Ctrl+;</p>
<p>剪切到剪贴板 : Ctrl+Shift+X</p>
<p>剪切一个字 : Ctrl+,</p>
<p>左边缩进 : F9</p>
<p>右边缩进 : F10</p>
<p>插入一行 : Ctrl+I</p>
<p>插入新行 : Ctrl+Enter</p>
<p>加入一行 : Ctrl+J</p>
<p>从剪切板粘贴 : Ctrl+Ins</p>
<p>粘贴一行 : Ctrl+P</p>
<p>重复上一个动作 : Ctrl+Y</p>
<p>重新编号 : Ctrl+R</p>
<p>重复输入 : Ctrl+</p>
<p>替换 : Ctrl+H</p>
<p>智能重命名 : Ctrl+’</p>
<p>关闭文件 : Ctrl+W</p>
<p>关闭所有文件 : Ctrl+Shift+W</p>
<p>新建 : Ctrl+N</p>
<p>转到下一个文件 : Ctrl+Shift+N</p>
<p>打开 : Ctrl+O</p>
<p>重新装载文件 : Ctrl+Shift+O</p>
<p>另存为 : Ctrl+Shift+S</p>
<p>显示文件状态 : Shift+F10</p>
<p>激活语法窗口 : Alt+L</p>
<p>回到该行的开始 : Home</p>
<p>回到选择的开始 : Ctrl+Alt+[</p>
<p>到块的下面 : Ctrl+Shift+]</p>
<p>到块的上面 : Ctrl+Shift+[</p>
<p>书签 : Ctrl+M</p>
<p>到文件底部 : Ctrl+End, Ctrl+(KeyPad) End</p>
<p>到窗口底部 : (KeyPad) End (小键盘的END)</p>
<p>到一行的尾部 : End</p>
<p>到选择部分的尾部 : Ctrl+Alt+]</p>
<p>到下一个函数 : 小键盘 +</p>
<p>上一个函数 : 小键盘 -</p>
<p>后退 : Alt+,, Thumb 1 Click</p>
<p>后退到索引 : Alt+M</p>
<p>向前 : Alt+., Thumb 2 Click</p>
<p>转到行 : F5, Ctrl+G</p>
<p>转到下一个修改 : Alt+(KeyPad) +</p>
<p>转到下一个链接 : Shift+F9, Ctrl+Shift+L</p>
<p>回到前一个修改 : Alt+(KeyPad) -</p>
<p>跳到连接(就是语法串口列表的地方) : Ctrl+L</p>
<p>跳到匹配 : Alt+]</p>
<p>下一页 : PgDn, (KeyPad) PgDn</p>
<p>上一页 : PgUp, (KeyPad) PgUp</p>
<p>向上滚动半屏 : Ctrl+PgDn, Ctrl+(KeyPad) PgDn, (KeyPad) *</p>
<p>向下滚动半屏 : Ctrl+PgUp, Ctrl+(KeyPad) PgUp, (KeyPad) /</p>
<p>左滚 : Alt+Left</p>
<p>向上滚动一行 : Alt+Down</p>
<p>向下滚动一行 : Alt+Up</p>
<p>右滚 : Alt+Right</p>
<p>选择一块 : Ctrl+-</p>
<p>选择当前位置的左边一个字符 : Shift+Left</p>
<p>选择当前位置右边一个字符 : Shift+Right</p>
<p>选择一行 : Shift+F6</p>
<p>从当前行其开始向下选择 : Shift+Down</p>
<p>从当前行其开始向上选择 : Shift+Up</p>
<p>选择上页 : Shift+PgDn, Shift+(KeyPad) PgDn</p>
<p>选择下页 : Shift+PgUp, Shift+(KeyPad) PgUp</p>
<p>选择句子(直到遇到一个 . 为止) : Shift+F7, Ctrl+.</p>
<p>从当前位置选择到文件结束 : Ctrl+Shift+End</p>
<p>从当前位置选择到行结束 : Shift+End</p>
<p>从当前位置选择到行的开始 : Shift+Home</p>
<p>从当前位置选择到文件顶部 : Ctrl+Shift+Home</p>
<p>选择一个单词 : Shift+F5</p>
<p>选择左边单词 : Ctrl+Shift+Left</p>
<p>选择右边单词 : Ctrl+Shift+Right</p>
<p>到文件顶部 : Ctrl+Home, Ctrl+(KeyPad) Home</p>
<p>到窗口顶部 : (KeyPad) Home</p>
<p>到单词左边(也就是到一个单词的开始) : Ctrl+Left</p>
<p>到单词右边(到该单词的结束) : Ctrl+Right</p>
<p>排列语法窗口(有三种排列方式分别按1,2,3次) : Alt+F7</p>
<p>移除文件 : Alt+Shift+R</p>
<p>同步文件 : Alt+Shift+S</p>
<p>增量搜索(当用Ctrl + F 搜索,然后按F12就会转到下一个匹配) : F12</p>
<p>替换文件 : Ctrl+Shift+H</p>
<p>向后搜索 : F3</p>
<p>在多个文件中搜索 : Ctrl+Shift+F</p>
<p>向前搜索 : F4</p>
<p>搜索选择的(比如选择了一个单词,shift+F4将搜索下一个) : Shift+F4</p>
<p>搜索 : Ctrl+F</p>
<p>浏览本地语法(弹出该文件语法列表窗口,如果你光标放到一个变量/函数等,那么列出本文件该变量/函数等的信息) : F8</p>
<p>浏览工程语法 : F7, Alt+G</p>
<p>跳到基本类型(即跳到原型) : Alt+0</p>
<p>跳到定义出(也就是声明) : Ctrl+=, Ctrl+L Click (select), Ctrl+Double L Click</p>
<p>检查引用 : Ctrl+/</p>
<p>语法信息(弹出该语法的信息) : Alt+/, Ctrl+R Click (select)</p>
<p>高亮当前单词 : Shift+F8</p>
<p>语法窗口(隐藏/显示语法窗口) : Alt+F8</p>
<p>关闭窗口 : Alt+F6, Ctrl+F4</p>
<p>最后一个窗口 : Ctrl+Tab, Ctrl+Shift+Tab</p>
<p><strong>本帖附件</strong></p>
<p><a href="https://u21519047.pipipan.com/fs/21519047-395416051" target="_blank" rel="noopener">点击下载</a></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em>乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</em></p>
]]></content>
      <tags>
        <tag>工具使用</tag>
      </tags>
  </entry>
  <entry>
    <title>Source Insignt4.0的基本使用</title>
    <url>/99.html</url>
    <content><![CDATA[<h3 id="第一步-创建新工程"><a href="#第一步-创建新工程" class="headerlink" title="第一步 创建新工程"></a>第一步 创建新工程</h3><p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191205131720.png" alt></p>
<p><strong>选择默认配置即可</strong></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191205131930.png" alt></p>
<h3 id="第二步-加载源码文件"><a href="#第二步-加载源码文件" class="headerlink" title="第二步 加载源码文件"></a>第二步 加载源码文件</h3><p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191205132148.png" alt></p>
<p><strong>这里有三个Add选项</strong></p>
<ul>
<li>Add : 添加指定文件</li>
<li>Add All: 将选中目录的所有文件加入到工程中</li>
<li>Add Tree: 递归加入所有文件，它采用了部分打开文件的方式，没有用到的文件不会打开，所以，加入数千个文件也不用担心加入的文件超出程序的所能容忍的最大值 推荐使用这种</li>
</ul>
<p><strong>源码加载完成后关闭该窗口</strong></p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20191205133308509.png" alt></p>
<h3 id="第三步-熟悉主界面和源码搜索"><a href="#第三步-熟悉主界面和源码搜索" class="headerlink" title="第三步 熟悉主界面和源码搜索"></a>第三步 熟悉主界面和源码搜索</h3><p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191205131410.png" alt></p>
<h3 id="第四步-更改字体大小"><a href="#第四步-更改字体大小" class="headerlink" title="第四步 更改字体大小"></a>第四步 更改字体大小</h3><h5 id="面板字体设置"><a href="#面板字体设置" class="headerlink" title="面板字体设置"></a>面板字体设置</h5><p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191205133619.png" alt></p>
<p><strong>代码显示窗口字体设置</strong></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191205134323.png" alt></p>
<h3 id="常用快捷键介绍"><a href="#常用快捷键介绍" class="headerlink" title="常用快捷键介绍"></a>常用快捷键介绍</h3><p>各工具栏命令如下：</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/70-20210816102637149.png" alt="img">对应的文件菜单的功能</p>
<p>New（快捷键ctrl+N）     新建一个文件</p>
<p>Open（快捷键ctrl+O）     打开一个文件</p>
<p>Save（快捷键ctrl+S）     保存当前打开的文件</p>
<p>Save As（快捷键ctrl+shift+S） 将当前打开的文件保存为其它名子的文件</p>
<p>Save All（快捷键ctrl+A）   保存所有打开的和修改过的文件</p>
<p>Print              打印当前打开的文件</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/70.png" alt="img">对应的编辑菜单功能</p>
<p>Cut（快捷键ctrl+X）  </p>
<p>Copy（快捷键ctrl+C）</p>
<p>Paste(快捷键ctrl+V)</p>
<p>Undo(快捷键ctrl+Z)</p>
<p>Redo(快捷键ctrl+Y)</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/70-20210816102643954.png" alt="img">对应查找菜单功能</p>
<p>Search（快捷键ctrl+F）      在当前打开的文件中查找</p>
<p>Search Backward(快捷键F3)    在当前光标位置进行向后查找</p>
<p>Search Forward(快捷键F4)     在当前光标位置进行向前查找</p>
<p>Search Files(快捷键ctrl+shift+F) 在多文件（Source Insight工程中）中查找</p>
<p>Replace(快捷键ctrl+H)      在当前文件中进行查找和替代</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/70-20210816102652411.png" alt="img"></p>
<p>对应于窗口功能，与普通的多文档编辑器相同，用来设置打开多个文件时窗口显示方式和规则。</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/70-20210816102658905.png" alt="img"></p>
<p>用来设置Project窗口、Context窗口、Relation窗口和Clip窗口的显示或关闭。当快捷键点亮时，所对应的窗口显示。</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/70-20210816102705593.png" alt="img"></p>
<p>Jump To Definition(快捷键ctrl+=)  跳转到当前光标所在位置的函数或变量的定义处（并打开文件）</p>
<p>Symbol Info             弹出一个窗口来显示当前光标位置的函数或变量的定义原型</p>
<p>Browse Project Symbols(快捷键F7)  在整个工程中查找一个函数或变量的出现位置</p>
<p>Lookup Reference(快捷键ctrl+/)    建立一个Reference链接，所对应的链接处会出现一个链接标志，通过链接标志可以方便的进行函数的查看。</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/70-20210816102710274.png" alt="img"></p>
<p>Go To Previous Link    跳转到前一个Reference链接（此功能必须先建立一个Reference链接）</p>
<p>Go To Next Link(shift+F9) 跳转到前一个Reference链接（同上）</p>
<p>Go Back(Alt+))      光标调转到前一个历史操作位置</p>
<p>Go Forward(Alt+.)     光标调转到后一个历史操作位置</p>
<p>Go To Line(F5)      跳转到指定的行位置</p>
<p>Bookmark(ctrl+M)     书签</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/70-20210816102714740.png" alt="img"></p>
<p>帮助功能</p>
<p><strong>本帖附件</strong></p>
<p><a href="https://u21519047.pipipan.com/fs/21519047-395416051" target="_blank" rel="noopener">点击下载</a></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em>乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</em></p>
]]></content>
      <tags>
        <tag>Android源码</tag>
      </tags>
  </entry>
  <entry>
    <title>汇编语言之MIPS汇编</title>
    <url>/195.html</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>咱们知道x86架构cpu用于PC端和工作站较多,ARM架构cpu常见于手机和单片机,那么MIPS架构的cpu主要在哪些设备可以找到它们的身影呢?</p>
<ul>
<li>中国龙芯</li>
<li>PS游戏机</li>
</ul>
<h3 id="学习环境搭建"><a href="#学习环境搭建" class="headerlink" title="学习环境搭建"></a>学习环境搭建</h3><ul>
<li>安装JDK, 主要用于运行mips模拟器mars</li>
<li>MARS模拟器:<a href="https://courses.missouristate.edu/KenVollmar/mars/download.htm" target="_blank" rel="noopener">https://courses.missouristate.edu/KenVollmar/mars/download.htm</a></li>
</ul>
<h2 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h2><p>在mips中通用寄存器用$开头表示,一共有32个</p>
<table>
<thead>
<tr>
<th align="center">寄存器编号</th>
<th>寄存器名</th>
<th>寄存器用途</th>
</tr>
</thead>
<tbody><tr>
<td align="center">$0</td>
<td>$zero</td>
<td>永远返回0</td>
</tr>
<tr>
<td align="center">$1</td>
<td>$at</td>
<td>保留寄存器</td>
</tr>
<tr>
<td align="center">$2-$3</td>
<td>$v0-$v1</td>
<td>一般用于存储表达式或者函数的返回值(value的简写)</td>
</tr>
<tr>
<td align="center">$4-$7</td>
<td>$a0-$a3</td>
<td>参数寄存器(Argument简写)</td>
</tr>
<tr>
<td align="center">$8-$15</td>
<td>$t0-$t7</td>
<td>一般用于存储临时变量(temp简写)</td>
</tr>
<tr>
<td align="center">$16-$23</td>
<td>$s0-$s7</td>
<td>存放子函数调用过程需要被保留的数据(saved values)</td>
</tr>
<tr>
<td align="center">$24-$25</td>
<td>$t8-$t9</td>
<td>属性同$t0-$t7</td>
</tr>
<tr>
<td align="center">$26-$27</td>
<td>$k0-$k1</td>
<td>一般存储中断函数返回值</td>
</tr>
<tr>
<td align="center">$28</td>
<td>$gp</td>
<td>GlobalPointer简写</td>
</tr>
<tr>
<td align="center">$29</td>
<td>$sp</td>
<td>栈指针，指向栈顶(Stack Pointer简写)</td>
</tr>
<tr>
<td align="center">$30</td>
<td>$s8/$fp</td>
<td>(Save / Frame Pointer)帧指针</td>
</tr>
<tr>
<td align="center">$31</td>
<td>$ra</td>
<td>一般用于存储函数返回地址(return address简写)</td>
</tr>
</tbody></table>
<p>寄存器编号和别名一一对应,<strong>同一个寄存器可以有两种不同表示方法</strong>:<strong>$0</strong>或者<strong>$zero</strong></p>
<blockquote>
<ul>
<li>program counter (PC) 无法直接修改，通过跳转指令可以改动</li>
<li>HI 和 LO ：这两个寄存器特别用来保存乘法、除法、乘法累加的结果。</li>
</ul>
</blockquote>
<h2 id="MIPS汇编中的分段处理"><a href="#MIPS汇编中的分段处理" class="headerlink" title="MIPS汇编中的分段处理"></a>MIPS汇编中的分段处理</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.data #数据段</span><br><span class="line"></span><br><span class="line">.text #代码段</span><br></pre></td></tr></table></figure>

<h2 id="传送指令"><a href="#传送指令" class="headerlink" title="传送指令"></a>传送指令</h2><ol>
<li><strong>加载立即数指令 <code>li</code></strong></li>
</ol>
<p><code>li</code>(load  immediate) :用于将立即数传送给寄存器</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">li $t0,1  ;十六进制数据使用0x前缀表示</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><strong>加载地址指令 <code>la</code></strong></li>
</ol>
<p><code>la</code>(load address) :用于将地址传送至寄存器中, 多用于通过地址获取数据段中的地址</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.data </span><br><span class="line">msg: .ascii &quot;hello world&quot;</span><br><span class="line"></span><br><span class="line">.text</span><br><span class="line">la $a0,msg # 将字符串数据所在的地址赋值给$a0寄存器</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><strong>寄存器数据传送指令<code>move</code></strong></li>
</ol>
<p>用于将一个寄存器中的数据传送至另一个寄存器当中</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">move $t0,$t1  # 将寄存器$t1中的数据传送至$t0</span><br></pre></td></tr></table></figure>

<h2 id="系统服务指令-syscall"><a href="#系统服务指令-syscall" class="headerlink" title="系统服务指令 syscall"></a>系统服务指令 <code>syscall</code></h2><p>在C语言中输出文本可以使用<code>printf</code>函数,但是汇编中没有printf这么一说,如果想要输出文本,需要借助<code>syscall</code>指令</p>
<p>如果想要输出一个数字1,那么<strong><code>syscall</code>指令从$a0寄存器中取出需要输出的数据</strong></p>
<p>因此, 你在执行<code>syscall</code>指令之前需要将数据提前放入<code>$a0</code>之中:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">li $a0,1</span><br><span class="line">syscall</span><br></pre></td></tr></table></figure>

<p><strong>同时,还需要指定输出的数据类型,数据类型的指定保存在$v0寄存器中</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># $v0=1, syscall---&gt;print_int</span><br><span class="line"># $v0=4, syscall---&gt;print_string</span><br></pre></td></tr></table></figure>

<p><code>$v0</code>存入1,表示<code>syscall</code>将<code>$a0</code>中的数据当做数字输出</p>
<p><code>$v0</code>存入4,表示<code>syscall</code>将<code>$a0</code>中的数据当做数据的地址,然后输出对应的数据</p>
<h3 id="syscall指令读写对照表"><a href="#syscall指令读写对照表" class="headerlink" title="syscall指令读写对照表"></a>syscall指令读写对照表</h3><table>
<thead>
<tr>
<th>Service</th>
<th>Code in $v0</th>
<th>Arguments</th>
<th>Result</th>
</tr>
</thead>
<tbody><tr>
<td>print integer</td>
<td>1</td>
<td>$a0 = integer to print</td>
<td></td>
</tr>
<tr>
<td>print float</td>
<td>2</td>
<td>$f12 = float to print</td>
<td></td>
</tr>
<tr>
<td>print double</td>
<td>3</td>
<td>$f12 = double to print</td>
<td></td>
</tr>
<tr>
<td>print string</td>
<td>4</td>
<td>$a0 = address of null-terminated string to print</td>
<td></td>
</tr>
<tr>
<td>read integer</td>
<td>5</td>
<td></td>
<td>$v0 contains integer read</td>
</tr>
<tr>
<td>read float</td>
<td>6</td>
<td></td>
<td>$f0 contains float read</td>
</tr>
<tr>
<td>read double</td>
<td>7</td>
<td></td>
<td>$f0 contains double read</td>
</tr>
<tr>
<td>read string</td>
<td>8</td>
<td>$a0 = address of input buffer $a1 = maximum number of characters to read</td>
<td><em>See note below table</em></td>
</tr>
<tr>
<td>sbrk (allocate heap memory)</td>
<td>9</td>
<td>$a0 = number of bytes to allocate</td>
<td>$v0 contains address of allocated memory</td>
</tr>
<tr>
<td>exit (terminate execution)</td>
<td>10</td>
<td></td>
<td></td>
</tr>
<tr>
<td>print character</td>
<td>11</td>
<td>$a0 = character to print</td>
<td><em>See note below table</em></td>
</tr>
<tr>
<td>read character</td>
<td>12</td>
<td></td>
<td>$v0 contains character read</td>
</tr>
<tr>
<td>open file</td>
<td>13</td>
<td>$a0 = address of null-terminated string containing filename $a1 =           flags $a2 = mode</td>
<td>$v0 contains file descriptor (negative if error). <em>See note below           table</em></td>
</tr>
<tr>
<td>read from file</td>
<td>14</td>
<td>$a0 = file descriptor $a1 = address of input buffer $a2 =           maximum number of characters to read</td>
<td>$v0 contains number of characters read (0 if end-of-file, negative           if error). <em>See note below table</em></td>
</tr>
<tr>
<td>write to file</td>
<td>15</td>
<td>$a0 = file descriptor $a1 = address of output buffer $a2 =           number of characters to write</td>
<td>$v0 contains number of characters written (negative if error). <em>See           note below table</em></td>
</tr>
<tr>
<td>close file</td>
<td>16</td>
<td>$a0 = file descriptor</td>
<td></td>
</tr>
<tr>
<td>exit2 (terminate with value)</td>
<td>17</td>
<td>$a0 = termination result</td>
<td><em>See note below table</em></td>
</tr>
<tr>
<td><em>Services 1 through 17 are compatible with the SPIM simulator,           other than Open File (13) as described in the Notes below the table.           Services 30 and higher are exclusive to MARS.</em></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>time (system time)</td>
<td>30</td>
<td></td>
<td>$a0 = low order 32 bits of system time $a1 = high order 32 bits           of system time. <em>See note below table</em></td>
</tr>
<tr>
<td>MIDI out</td>
<td>31</td>
<td>$a0 = pitch (0-127) $a1 = duration in milliseconds $a2 =           instrument (0-127) $a3 = volume (0-127)</td>
<td>Generate tone and return immediately. <em>See note below table</em></td>
</tr>
<tr>
<td>sleep</td>
<td>32</td>
<td>$a0 = the length of time to sleep in milliseconds.</td>
<td>Causes the MARS Java thread to sleep for (at least) the specified           number of milliseconds. This timing will not be precise, as the Java           implementation will add some overhead.</td>
</tr>
<tr>
<td>MIDI out synchronous</td>
<td>33</td>
<td>$a0 = pitch (0-127) $a1 = duration in milliseconds $a2 =           instrument (0-127) $a3 = volume (0-127)</td>
<td>Generate tone and return upon tone completion. <em>See note below           table</em></td>
</tr>
<tr>
<td>print integer in hexadecimal</td>
<td>34</td>
<td>$a0 = integer to print</td>
<td>Displayed value is 8 hexadecimal digits, left-padding with zeroes if           necessary.</td>
</tr>
<tr>
<td>print integer in binary</td>
<td>35</td>
<td>$a0 = integer to print</td>
<td>Displayed value is 32 bits, left-padding with zeroes if necessary.</td>
</tr>
<tr>
<td>print integer as unsigned</td>
<td>36</td>
<td>$a0 = integer to print</td>
<td>Displayed as unsigned decimal value.</td>
</tr>
<tr>
<td>(not used)</td>
<td>37-39</td>
<td></td>
<td></td>
</tr>
<tr>
<td>set seed</td>
<td>40</td>
<td>$a0 = i.d. of pseudorandom number generator (any int). $a1 = seed           for corresponding pseudorandom number generator.</td>
<td>No values are returned. Sets the seed of the corresponding           underlying Java pseudorandom number generator (<code>java.util.Random</code>).           <em>See note below table</em></td>
</tr>
<tr>
<td>random int</td>
<td>41</td>
<td>$a0 = i.d. of pseudorandom number generator (any int).</td>
<td>$a0 contains the next pseudorandom, uniformly distributed int value           from this random number generator’s sequence. <em>See note below table</em></td>
</tr>
<tr>
<td>random int range</td>
<td>42</td>
<td>$a0 = i.d. of pseudorandom number generator (any int). $a1 =           upper bound of range of returned values.</td>
<td>$a0 contains pseudorandom, uniformly distributed int value in the           range 0 = [int] [upper bound], drawn from this random number           generator’s sequence. <em>See note below table</em></td>
</tr>
<tr>
<td>random float</td>
<td>43</td>
<td>$a0 = i.d. of pseudorandom number generator (any int).</td>
<td>$f0 contains the next pseudorandom, uniformly distributed float           value in the range 0.0 = f 1.0 from this random number generator’s           sequence. <em>See note below table</em></td>
</tr>
<tr>
<td>random double</td>
<td>44</td>
<td>$a0 = i.d. of pseudorandom number generator (any int).</td>
<td>$f0 contains the next pseudorandom, uniformly distributed double           value in the range 0.0 = f 1.0 from this random number generator’s           sequence. <em>See note below table</em></td>
</tr>
<tr>
<td>(not used)</td>
<td>45-49</td>
<td></td>
<td></td>
</tr>
<tr>
<td>ConfirmDialog</td>
<td>50</td>
<td>$a0 = address of null-terminated string that is the message to user</td>
<td>$a0 contains value of user-chosen option 0: Yes 1: No 2:           Cancel</td>
</tr>
<tr>
<td>InputDialogInt</td>
<td>51</td>
<td>$a0 = address of null-terminated string that is the message to user</td>
<td>$a0 contains int read $a1 contains status value 0: OK status -1:           input data cannot be correctly parsed -2: Cancel was chosen -3:           OK was chosen but no data had been input into field</td>
</tr>
<tr>
<td>InputDialogFloat</td>
<td>52</td>
<td>$a0 = address of null-terminated string that is the message to user</td>
<td>$f0 contains float read $a1 contains status value 0: OK status -1:           input data cannot be correctly parsed -2: Cancel was chosen -3:           OK was chosen but no data had been input into field</td>
</tr>
<tr>
<td>InputDialogDouble</td>
<td>53</td>
<td>$a0 = address of null-terminated string that is the message to user</td>
<td>$f0 contains double read $a1 contains status value 0: OK status -1:           input data cannot be correctly parsed -2: Cancel was chosen -3:           OK was chosen but no data had been input into field</td>
</tr>
<tr>
<td>InputDialogString</td>
<td>54</td>
<td>$a0 = address of null-terminated string that is the message to user $a1           = address of input buffer $a2 = maximum number of characters to           read</td>
<td><em>See Service 8 note below table</em> $a1 contains status value 0:           OK status. Buffer contains the input string. -2: Cancel was           chosen. No change to buffer. -3: OK was chosen but no data had           been input into field. No change to buffer. -4: length of the           input string exceeded the specified maximum. Buffer contains the           maximum allowable input string plus a terminating null.</td>
</tr>
<tr>
<td>MessageDialog</td>
<td>55</td>
<td>$a0 = address of null-terminated string that is the message to user $a1           = the type of message to be displayed: 0: error message,           indicated by Error icon           1: information message, indicated by Information icon           2: warning message, indicated by Warning icon           3: question message, indicated by Question icon           other: plain message (no icon displayed)</td>
<td>N/A</td>
</tr>
<tr>
<td>MessageDialogInt</td>
<td>56</td>
<td>$a0 = address of null-terminated string that is an information-type           message to user $a1 = int value to display in string form after           the first string</td>
<td>N/A</td>
</tr>
<tr>
<td>MessageDialogFloat</td>
<td>57</td>
<td>$a0 = address of null-terminated string that is an information-type           message to user $f12 = float value to display in string form           after the first string</td>
<td>N/A</td>
</tr>
<tr>
<td>MessageDialogDouble</td>
<td>58</td>
<td>$a0 = address of null-terminated string that is an information-type           message to user $f12 = double value to display in string form           after the first string</td>
<td>N/A</td>
</tr>
<tr>
<td>MessageDialogString</td>
<td>59</td>
<td>$a0 = address of null-terminated string that is an information-type           message to user $a1 = address of null-terminated string to           display after the first string</td>
<td>N/A</td>
</tr>
</tbody></table>
<p><strong>使用syscall指令输出helloworld示例:</strong> </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.data </span><br><span class="line"></span><br><span class="line">msg: .ascii &quot;hello world\0&quot; #类似于C语言中 char* msg=&quot;hello world&quot;</span><br><span class="line"></span><br><span class="line">.text</span><br><span class="line">la $a0,msg</span><br><span class="line">li $v0,4</span><br><span class="line">syscall</span><br></pre></td></tr></table></figure>

<h2 id="数据定义"><a href="#数据定义" class="headerlink" title="数据定义"></a>数据定义</h2><ol>
<li><p>定义整型数据</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 打印Integer数据</span><br><span class="line">.data</span><br><span class="line">	age: .word 23  #一个字长数据32位</span><br><span class="line"></span><br><span class="line">.text</span><br><span class="line">    li $v0,1</span><br><span class="line">    lw $a0,age</span><br><span class="line">    syscall</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">#========================#</span><br><span class="line">#加法运算</span><br><span class="line">.data</span><br><span class="line">	number1: .word 2</span><br><span class="line">	number2: .word 5</span><br><span class="line">	</span><br><span class="line">.text</span><br><span class="line">	lw $t0,number1</span><br><span class="line">	lw $t1,number2</span><br><span class="line">	</span><br><span class="line">	add $t2,$t0,$t1</span><br><span class="line">	</span><br><span class="line">	li $v0,1</span><br><span class="line">    move $a0 $t2</span><br><span class="line">    syscall</span><br><span class="line">    </span><br><span class="line"># 乘法运算 使用mul</span><br></pre></td></tr></table></figure>
</li>
<li><p>定义Float数据</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#打印float数据</span><br><span class="line">.data</span><br><span class="line">	PI: .float 3.14</span><br><span class="line"></span><br><span class="line">.text</span><br><span class="line">    li $v0,2</span><br><span class="line">    lwc1 $f12,PI</span><br><span class="line">    syscall</span><br><span class="line">    </span><br><span class="line">#float数据 算数运算</span><br><span class="line">.data</span><br><span class="line">	f1: .float 3.14</span><br><span class="line">	f2: .float 3.15</span><br><span class="line">.text</span><br><span class="line">    li $v0,2</span><br><span class="line">    lwc1 $f1,f1</span><br><span class="line">    lwc1 $f2,f2</span><br><span class="line">    add.s $f3,$f2,$f1 #带.s后缀的指令皆为浮点单精度指令</span><br><span class="line">    mov.s $f12,$f3</span><br><span class="line">    syscall</span><br></pre></td></tr></table></figure>
</li>
<li><p>定义Double数据</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#打印double数据</span><br><span class="line">.data</span><br><span class="line">	ayDouble: .double 7.20</span><br><span class="line">	zeroDouble: .double 0.0</span><br><span class="line">.text</span><br><span class="line"></span><br><span class="line">	ldc1 $f2,ayDouble</span><br><span class="line">	ldc1 $f0,zeroDouble</span><br><span class="line">    li $v0,3</span><br><span class="line">    add.d $f12,$f2,$f0 #带.d后缀的指令皆为浮点双精度指令</span><br><span class="line">    syscall</span><br></pre></td></tr></table></figure>
</li>
<li><p>定义字符串数据</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#打印double数据</span><br><span class="line">.data</span><br><span class="line">	msg: .ascii &quot;hello world&quot;</span><br><span class="line">.text</span><br><span class="line">    li $v0,4</span><br><span class="line">    la $a0,msg</span><br><span class="line">    syscall</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="用户输入"><a href="#用户输入" class="headerlink" title="用户输入"></a>用户输入</h2><ol>
<li><p>字符串输入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.data</span><br><span class="line">	userInput: .space 20  #声明一块空间 默认存放0</span><br><span class="line">.text</span><br><span class="line">	li $v0,8</span><br><span class="line">	la $a0,userInput #将用户的输入存放至userInput中</span><br><span class="line">	li $a1,20	#限制用户输入, 一旦超过20个默认回车</span><br><span class="line">	syscall</span><br></pre></td></tr></table></figure>
</li>
<li><p>整型数据输入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 输入的结果系统会存放在$v0寄存器</span><br><span class="line">.text</span><br><span class="line">	li $v0,5</span><br><span class="line">	syscall</span><br></pre></td></tr></table></figure>


</li>
</ol>
<ol start="3">
<li><p>浮点型数据输入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#以float为例  输入的结果会存放在$f0寄存器</span><br><span class="line">.text</span><br><span class="line">	li $v0,6 </span><br><span class="line">	syscall</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="单精度和双精度"><a href="#单精度和双精度" class="headerlink" title="单精度和双精度"></a>单精度和双精度</h3><p>单精度数（float型）在32位计算机中存储占用4字节，也就是32位，有效位数为7位，小数点后6位。</p>
<p>双精度数（double型）在32位计算机中存储占用8字节，也就是64位，有效位数为16位，小数点后15位。</p>
<h2 id="浮点寄存器"><a href="#浮点寄存器" class="headerlink" title="浮点寄存器"></a>浮点寄存器</h2><p>在mips中一共有32个浮点寄存器(其中包含16个双精度浮点寄存器),用于单独处理浮点数</p>
<h2 id="函数声明和调用"><a href="#函数声明和调用" class="headerlink" title="函数声明和调用"></a>函数声明和调用</h2><ol>
<li><p><strong>函数声明</strong></p>
<ul>
<li><p>格式</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">函数名:</span><br><span class="line">	函数体</span><br><span class="line">	jr $ra  #$ra寄存器中保存着调用指令下一条代码所在的地址</span><br></pre></td></tr></table></figure>
</li>
<li><p>示例</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.data</span><br><span class="line"></span><br><span class="line">.text</span><br><span class="line">    show:</span><br><span class="line">        li $v0,1</span><br><span class="line">        li $a0,3</span><br><span class="line">        syscall</span><br><span class="line"></span><br><span class="line">        jr $ra  ;jump registers</span><br></pre></td></tr></table></figure>



</li>
</ul>
</li>
</ol>
<ol start="2">
<li><p><strong>函数调用</strong></p>
<ul>
<li><p>格式</p>
   <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">jal 函数名</span><br></pre></td></tr></table></figure>
</li>
<li><p>示例</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.data</span><br><span class="line"></span><br><span class="line">.text</span><br><span class="line">	jal show  #调用函数时将下一条指令的地址存放至$ra寄存器</span><br><span class="line">	</span><br><span class="line">	#结束程序</span><br><span class="line">	li $v0,10</span><br><span class="line">	syscall</span><br><span class="line">	</span><br><span class="line">    show:</span><br><span class="line">        li $v0,1</span><br><span class="line">        li $a0,3</span><br><span class="line">        syscall</span><br><span class="line"></span><br><span class="line">        jr $ra</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>函数传参和返回值</p>
<p>在mips汇编中,函数的参数一般放在<code>$a</code>系列寄存器当中,最多对应4个参数,超过4个部分使用栈储存. 函数的变量和返回值一般放在<code>$v</code>系列寄存器当中 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#需求:定义加法函数 并调用获取返回值int sum(int v,int b)</span><br><span class="line">main:</span><br><span class="line">	addi $a1,$zero,50</span><br><span class="line">	addi $a2,$zero,100</span><br><span class="line">	</span><br><span class="line">       jal add</span><br><span class="line">	</span><br><span class="line">	li $v0,1</span><br><span class="line">       move $a0,$v1</span><br><span class="line">       syscall</span><br><span class="line">       </span><br><span class="line">       #结束程序</span><br><span class="line">       li $v0,10</span><br><span class="line">       syscall</span><br><span class="line">   </span><br><span class="line">       add:</span><br><span class="line">          add $v1,$a1,$a2</span><br><span class="line">          jr $ra</span><br></pre></td></tr></table></figure>
</li>
<li><p>嵌套函数</p>
<p>由于每执行<code>jal</code>调用一次函数, 就会刷新<code>$ra</code>寄存器中的值,因此,在嵌套函数调用之前,需要临时保存上一次$ra中的值,使用栈空间临时保护即可</p>
</li>
</ol>
<h2 id="栈操作"><a href="#栈操作" class="headerlink" title="栈操作"></a>栈操作</h2><ol>
<li><p>栈空间拉伸和平衡</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">addi $sp,$sp,-4 #栈拉伸 拉伸4个字节空间</span><br><span class="line"></span><br><span class="line">addi $sp,$sp,4 #栈平衡</span><br></pre></td></tr></table></figure>
</li>
<li><p>入栈和出栈</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sw $s0 ,0($sp) #入栈   往内存中写入数据</span><br><span class="line"></span><br><span class="line">lw $s0, 0($sp) #出栈  从内存中读取数据</span><br></pre></td></tr></table></figure>
</li>
<li><p>嵌套函数使用栈保护<code>$ra</code>代码示例</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">main:</span><br><span class="line">	addi $a1,$zero,50</span><br><span class="line">	addi $a2,$zero,100</span><br><span class="line">	</span><br><span class="line">       jal add</span><br><span class="line">	</span><br><span class="line">	li $v0,1</span><br><span class="line">       move $a0,$v1</span><br><span class="line">       syscall</span><br><span class="line">       </span><br><span class="line">       #结束程序</span><br><span class="line">       li $v0,10</span><br><span class="line">       syscall</span><br><span class="line">   </span><br><span class="line">       add:</span><br><span class="line">       	addi $sp,$sp,-4 #栈拉伸</span><br><span class="line">       	sw $ra ,0($sp) #入栈</span><br><span class="line">       	</span><br><span class="line">           jal sub</span><br><span class="line">           add $v1,$a1,$v1</span><br><span class="line">           </span><br><span class="line">           lw $ra, 0($sp) #出栈</span><br><span class="line">           addi $sp,$sp,4 #栈平衡</span><br><span class="line">           jr $ra</span><br><span class="line">          </span><br><span class="line">       sub:</span><br><span class="line">           sub $v1,$a1,$a2</span><br><span class="line">           jr $ra</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="内存空间布局"><a href="#内存空间布局" class="headerlink" title="内存空间布局"></a>内存空间布局</h3><p>从mars中可以查看到内存分布起始物理地址</p>
<p><img src="https://gitee.com/songjianzaina/lunanzb_img/raw/master/img/image-20210108155849172.png" alt></p>
<p><strong>转成图后:</strong></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/a.png" alt></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20210108155756.png" alt></p>
<blockquote>
<p>栈的伸缩在mips和x86架构中是由高地址往低地址进行伸缩, 在arm架构中可升序也可降序</p>
</blockquote>
<h3 id="内存碎片"><a href="#内存碎片" class="headerlink" title="内存碎片"></a>内存碎片</h3><p>在内存动态分配(heap区)过程中容易出现一些小且不连续的空闲内存区域,这些未被使用的内存称作内存碎片</p>
<p>分类:</p>
<ul>
<li>内部碎片:比如数据在内存中采用4个字节对齐的方式进行存储, 比如我们申请一块3个字节的空间用于存储一个数据,但是系统给我们分配了4个字节空间,这时多出来的一个字节的空间就被称之为内部碎片</li>
<li>外部碎片:在我们进行内存回收和分配的时候容易出现外部碎片,比如我连续申请了三块4个字节的内存空间,当我释放第二块内存空间然后紧接着申请一块8个字节的空间,此时由于之前释放的4个字节空间太小无法使用,这就造成了内存块空闲,这种碎片叫做外部碎片</li>
</ul>
<h2 id="PC-寄存器"><a href="#PC-寄存器" class="headerlink" title="PC 寄存器"></a>PC 寄存器</h2><p> 称作 <strong>程序计数寄存器(Program Counter Register)</strong> :用于存储程序即将要执行的指令所对应在内存中的实际物理地址, 如果改变该值可以让指令跳转到我们想要跳转的地方</p>
<p><strong>如何修改pc寄存器中的值</strong></p>
<p>使用以下转移指令</p>
<ol>
<li><p><code>jr</code>指令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">jr 寄存器  #$ra寄存器实际上就是保存着函数调用前的pc寄存器的值</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>jal</code>指令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">jal 标号  #跳转的同时给$ra寄存器赋值</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>j</code>指令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">j 标号   #直接跳转</span><br></pre></td></tr></table></figure>






</li>
</ol>
<h2 id="内存数据的读写"><a href="#内存数据的读写" class="headerlink" title="内存数据的读写"></a>内存数据的读写</h2><ol>
<li><p>从指定内存中读取数据</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">#整型数据</span><br><span class="line">lw $t0,0x10010000 #读取4个字节数据 赋值给t0寄存器</span><br><span class="line">ld $t0,0x10010000 #读取8个字节数据 赋值给t0和t1寄存器</span><br><span class="line"></span><br><span class="line">#单精度浮点数据</span><br><span class="line">lwc1   $f0,0x10010000  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#双精度浮点数据</span><br><span class="line">ldc1   $f0,0x10010000  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#字符数据 </span><br><span class="line">### 由于字符数据是以ascii码16进制的形式存放到内存中,因此只能获取到ascii码值,该值属于整型数据,直接使用lw或者ld即可</span><br><span class="line">lw $t0,0x10010000 #读取4个字节数据 赋值给t0寄存器</span><br><span class="line">ld $t0,0x10010000 #读取8个字节数据 赋值给t0和t1寄存器</span><br></pre></td></tr></table></figure>

<p>从内存中读取数据的宽度取决于寄存器的大小,由于32位cpu寄存器最大存储32位数据,因此<code>lw $t0</code>表示一次性读取4个字节的数据到<code>$t0</code>寄存器, 如果想要连续读取八个字节的数据,那么需要使用<code>ld $t0</code>,表示一次性读取8个字节的数据到<code>$t0,$t1</code>连个连续的寄存器,</p>
</li>
<li><p>往指定内存中写入数据</p>
<ol>
<li>第一种 数据定义的同时指定物理地址</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.data 0x10010020 ;将以下定义的数据存放在0x10010020这个物理地址</span><br><span class="line">	.ascii &quot;a&quot;</span><br><span class="line">	.ascii &quot;b&quot;</span><br><span class="line">	</span><br><span class="line">.data 0x10010000</span><br><span class="line">	.ascii &quot;c&quot;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>第二种 在代码段中使用指令</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#整型数据</span><br><span class="line">li $s1,4</span><br><span class="line">sw $s1,0x10010000  ;将$s1寄存器中的数据存入0x10010000这个物理地址</span><br><span class="line"></span><br><span class="line">#单精度浮点数</span><br><span class="line">.data </span><br><span class="line">	f1: .float 3.14</span><br><span class="line">	</span><br><span class="line">.text</span><br><span class="line">lwc1 $f2,f1</span><br><span class="line">swc1   $f2,0x10010000 </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#双精度浮点数</span><br><span class="line">.data </span><br><span class="line">	d1: .double 3.14</span><br><span class="line">	</span><br><span class="line">.text</span><br><span class="line">ldc1 $f2,d1</span><br><span class="line">sdc1   $f2,0x10010000</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>以上直接使用的是简单粗暴的十六进制表示物理地址,很多时候内存的地址会保存在寄存器中,你可能会看到以下写法:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">lw $s1, $s2</span><br><span class="line">sw $s1, $s2 </span><br><span class="line"></span><br><span class="line">或者</span><br><span class="line">lw $s1, 20($s2)</span><br><span class="line">sw $s1, 20($s2) ;将地址往高位偏移20个字节 相当于sw $s1, 20+$s2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">或者</span><br><span class="line">lw $s1, -20($s2)</span><br><span class="line">sw $s1, -20($s2) ;将地址往低位偏移20个字节</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意: 往指定内存中读取写入数据时,代码段不允许直接写入和读取</p>
</blockquote>
<h2 id="一维数组的定义"><a href="#一维数组的定义" class="headerlink" title="一维数组的定义"></a>一维数组的定义</h2><p>数组本质上就是多个数据的集合,在内存中按照一定顺序排列,角标即为每个数据的偏移值,在mips中内存数据是按照4个字节进行对齐的,也就是说一个数据最少占用4个字节内存空间,因此数组中数据之间的偏移量固定为n*4</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.data</span><br><span class="line">	array: .space 20   #别名的另外一种用法 通过array(寄存器)这种格式 寄存器中存放地址偏移地址量</span><br><span class="line">	</span><br><span class="line">.text </span><br><span class="line"># $t0寄存器存放角标值 $s1中存放需要存入的值</span><br><span class="line">li $s1,1</span><br><span class="line">li $t0,0</span><br><span class="line">sw $s1,array($t0) #相当于 sw $s1,array+$t0</span><br><span class="line"></span><br><span class="line">li $s1,2</span><br><span class="line">li $t0,4</span><br><span class="line">sw $s1,array($t0)</span><br><span class="line"></span><br><span class="line">li $s1,3</span><br><span class="line">li $t0,8</span><br><span class="line">sw $s1,array($t0)</span><br></pre></td></tr></table></figure>

<p><strong>数组的打印</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.data</span><br><span class="line">	array: .space 20   </span><br><span class="line">	</span><br><span class="line">.text </span><br><span class="line">#初始化数组中的数据</span><br><span class="line">li $s1,1</span><br><span class="line">li $t0,0</span><br><span class="line">sw $s1,array($t0) </span><br><span class="line"></span><br><span class="line">li $s1,2</span><br><span class="line">li $t0,4</span><br><span class="line">sw $s1,array($t0)</span><br><span class="line"></span><br><span class="line">li $s1,3</span><br><span class="line">li $t0,8</span><br><span class="line">sw $s1,array($t0)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#查找角标为2的数值</span><br><span class="line">getData:</span><br><span class="line"> la $s1 ,array</span><br><span class="line"> li $a0,2</span><br><span class="line"> mul $a0,$a0,4</span><br><span class="line"> add $s1,$s1,$a0</span><br><span class="line"> lw $a0,0($s1)</span><br><span class="line"> li $v0,1</span><br><span class="line"> syscall</span><br><span class="line"></span><br><span class="line">#将角标临时置为0 方便下面循环操作</span><br><span class="line">li $t0,0</span><br><span class="line">while:</span><br><span class="line">	beq $t0,12,exit</span><br><span class="line">	lw  $t2,array($t0)</span><br><span class="line">	</span><br><span class="line">	addi $t0,$t0,4</span><br><span class="line">	</span><br><span class="line">	li $v0,1</span><br><span class="line">	move $a0,$t2</span><br><span class="line">	syscall</span><br><span class="line">	j while</span><br><span class="line">	</span><br><span class="line">exit:</span><br><span class="line">	li $v0,10</span><br><span class="line">	syscall</span><br></pre></td></tr></table></figure>

<h5 id="快速初始化数组数据的方法"><a href="#快速初始化数组数据的方法" class="headerlink" title="快速初始化数组数据的方法"></a>快速初始化数组数据的方法</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.data</span><br><span class="line">	array: .word 20 :3  #批量定义3个整型数据20</span><br></pre></td></tr></table></figure>

<h2 id="分支跳转指令"><a href="#分支跳转指令" class="headerlink" title="分支跳转指令"></a>分支跳转指令</h2><ol>
<li><strong>整型数据分支比较跳转</strong></li>
</ol>
<ul>
<li><code>bgt</code>(branch if greater than):用于<strong>大于</strong>比较</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bgt $t0,$t1,sub # 如果$t0中的数据大于$t1,则跳转到sub分支,执行sub中的代码,否则,按照顺序执行bgt下面的代码, sub是一个代号,可以自定义</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sub:</span><br></pre></td></tr></table></figure>

<ul>
<li><code>beq</code>(branch equal):用于<strong>等于</strong>比较</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">beq $t0,$t1,sub # 如果$t0中的数据等于$t1,则跳转到sub分支,执行sub中的代码,否则,按照顺序执行bgt下面的代码, sub是一个代号,可以自定义</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sub:</span><br></pre></td></tr></table></figure>

<ul>
<li><code>ble</code>(branch if less than):用于<strong>小于</strong>比较</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ble $t0,$t1,sub # 如果$t0中的数据小于$t1,则跳转到sub分支,执行sub中的代码,否则,按照顺序执行bgt下面的代码, sub是一个代号,可以自定义</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sub:</span><br></pre></td></tr></table></figure>

<p><strong>练习1: 将以下c代码转换成mips汇编代码:</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,$a);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,$b);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(a&gt;b)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"YES"</span>);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"NO"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>汇编代码:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 用$t0指代a ,$t1指代b</span><br><span class="line"></span><br><span class="line">.data</span><br><span class="line">msg_yes: .ascii &quot;YES\0&quot; # \0表示字符串结尾</span><br><span class="line">msg_no: .ascii &quot;NO\0&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">.text</span><br><span class="line">li $v0,5  #控制syscall为读取integer状态</span><br><span class="line">syscall # 此时io控制台显示光标,可输入数字,回车后将输入的数字保存在$v0中</span><br><span class="line">move $t0,$v0 #由于接下来还需要使用$v0 ,为避免数据被覆盖掉 将输入的数据转移到$t0中进行临时保存</span><br><span class="line"></span><br><span class="line">li $v0,5</span><br><span class="line">syscall</span><br><span class="line">move $t1,$v0 </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">bgt $t0,$t1,sub </span><br><span class="line">    li $v0,4</span><br><span class="line">    la $a0,msg_no</span><br><span class="line">    syscall</span><br><span class="line">    </span><br><span class="line">    #结束程序</span><br><span class="line">    li $v0,10</span><br><span class="line">    syscall</span><br><span class="line">sub:</span><br><span class="line"> 	li $v0,4</span><br><span class="line">    la $a0,msg_yes</span><br><span class="line">    syscall</span><br></pre></td></tr></table></figure>

<p><strong>练习2: 将以下c代码转换成mips汇编代码:</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//求累加之和</span></span><br><span class="line"><span class="comment">//1+2+3+.....+100</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">int</span> i=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> s=<span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">while</span>(i&lt;=<span class="number">100</span>)&#123;</span><br><span class="line">    s=s+i;</span><br><span class="line">    i=i+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>,s);</span><br></pre></td></tr></table></figure>

<p>汇编代码:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 用$t0指代i ,$t1指代s</span><br><span class="line"></span><br><span class="line">.text</span><br><span class="line">li $t0 ,1</span><br><span class="line">li $t1 ,0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">loop:</span><br><span class="line"># s=s+i;</span><br><span class="line">add $t1,$t1,$t0</span><br><span class="line">add $t0,$t0,1</span><br><span class="line"></span><br><span class="line">ble $t0,100,loop</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">move $a0,$t1</span><br><span class="line">li $v0,1</span><br><span class="line">syscall</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><strong>浮点型数据分支比较</strong></li>
</ol>
<ul>
<li><p>小于</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.data</span><br><span class="line">num1: .float 3.14</span><br><span class="line">num2: .float 3.16</span><br><span class="line"></span><br><span class="line">.text</span><br><span class="line"></span><br><span class="line">lwc1 $f0,num1</span><br><span class="line">lwc1 $f1,num2</span><br><span class="line"></span><br><span class="line">c.lt.s  $f0,$f1 #关键代码</span><br><span class="line">bc1t sub  #bc1t表示条件满足  bc1f表示不满足条件</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sub:</span><br></pre></td></tr></table></figure>
</li>
<li><p>等于</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.data</span><br><span class="line">num1: .float 3.14</span><br><span class="line">num2: .float 3.16</span><br><span class="line"></span><br><span class="line">.text</span><br><span class="line"></span><br><span class="line">lwc1 $f0,num1</span><br><span class="line">lwc1 $f1,num2</span><br><span class="line"></span><br><span class="line">c.eq.s  $f0,$f1 #关键代码 c表示coproc协处理寄存器 s表示single单精度</span><br><span class="line">bc1t sub  #bc1t表示条件满足  bc1f表示不满足条件</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sub:</span><br></pre></td></tr></table></figure>
</li>
<li><p>小于等于</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.data</span><br><span class="line">num1: .float 3.14</span><br><span class="line">num2: .float 3.16</span><br><span class="line"></span><br><span class="line">.text</span><br><span class="line"></span><br><span class="line">lwc1 $f0,num1</span><br><span class="line">lwc1 $f1,num2</span><br><span class="line"></span><br><span class="line">c.le.s  $f0,$f1 #关键代码</span><br><span class="line">bc1t sub  #bc1t表示条件满足  bc1f表示不满足条件</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sub:</span><br></pre></td></tr></table></figure>

<p>以上是单精度浮点数据的比较示例,如果是双精度,只需将结尾<code>.s</code>改成<code>.d</code>即可</p>
</li>
</ul>
<h2 id="mips多文件开发"><a href="#mips多文件开发" class="headerlink" title="mips多文件开发"></a>mips多文件开发</h2><p>在文件A中定义函数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fun:</span><br><span class="line">  li $v0,1</span><br><span class="line">  li $a0,1</span><br><span class="line">  syscall </span><br><span class="line">  jr $ra</span><br></pre></td></tr></table></figure>

<p>在文件B中使用关键字<code>.include</code>引用A文件中的函数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.text</span><br><span class="line">jal fun</span><br><span class="line"></span><br><span class="line">.include &quot;A.asm&quot;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>所有文件必须在同一目录下</p>
</blockquote>
<h2 id="宏"><a href="#宏" class="headerlink" title="宏"></a>宏</h2><ol>
<li><p><strong>宏替换</strong></p>
<p>全局替换,使用我们之前学过的<code>.include</code>伪指令进行替换</p>
</li>
<li><p><strong>宏匹配</strong></p>
</li>
</ol>
<p>在汇编中,如果我们要依次打印1,2,3三个整数,那么汇编如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">print1:</span><br><span class="line">	li $v0,1</span><br><span class="line">	li $a0,1</span><br><span class="line">	syscall</span><br><span class="line">	jr $ra</span><br><span class="line">	</span><br><span class="line">print2:</span><br><span class="line">	li $v0,1</span><br><span class="line">	li $a0,2</span><br><span class="line">	syscall</span><br><span class="line">	jr $ra</span><br><span class="line">	</span><br><span class="line">print2:</span><br><span class="line">	li $v0,1</span><br><span class="line">	li $a0,3</span><br><span class="line">	syscall</span><br><span class="line">	jr $ra</span><br></pre></td></tr></table></figure>

<p>我们发现使用标签的方式定义函数,当函数体内容存在不确定变量值时,代码非常冗余, 如果使用高级语言进行封装的话,我们一般一个函数就搞定了:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void print(int a)&#123;</span><br><span class="line">	print(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有没有办法使得汇编能像高级语言一样简洁呢?</p>
<p>在MARS中给我们提供了一个扩展伪指令,叫做<strong>宏匹配</strong></p>
<p>宏匹配使用的格式如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.macro 别名</span><br><span class="line">	#汇编指令...</span><br><span class="line">.end_macro</span><br></pre></td></tr></table></figure>

<p>示例:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">li $v0,10</span><br><span class="line">syscall</span><br><span class="line"></span><br><span class="line">#比如我们要对以上两行指令使用宏匹配进行封装</span><br><span class="line"></span><br><span class="line">#封装结果为</span><br><span class="line">.macro exit</span><br><span class="line">	li $v0,10</span><br><span class="line">	syscall</span><br><span class="line">.end_macro	</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#在代码中引用</span><br><span class="line">.text</span><br><span class="line">	exit #直接使用别名调用</span><br></pre></td></tr></table></figure>

<p>如果我们要封装一个打印整型数据的函数,那么我们可以:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#封装结果为</span><br><span class="line">.macro print_int(%param)</span><br><span class="line">	li $v0,1</span><br><span class="line">	li $a0,%param</span><br><span class="line">	syscall</span><br><span class="line">.end_macro	</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#在代码中引用</span><br><span class="line">.text</span><br><span class="line">	print_int(1) #直接使用别名调用</span><br><span class="line">	print_int(2)</span><br><span class="line">	print_int(3)</span><br></pre></td></tr></table></figure>

<p>这样是不是和高级语言没什么区别啦</p>
<p>打印字符串封装示例:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.macro print_str (%str)</span><br><span class="line">    .data</span><br><span class="line">    myLabel: .asciiz %str</span><br><span class="line">    .text</span><br><span class="line">    li $v0, 4</span><br><span class="line">    la $a0, myLabel</span><br><span class="line">    syscall</span><br><span class="line">.end_macro</span><br><span class="line"></span><br><span class="line">    print_str (&quot;test1&quot;)</span><br><span class="line">    print_str (&quot;test1&quot;)</span><br></pre></td></tr></table></figure>

<p>然后结合我们之前学过的多文件开发,完全可以将这个封装好的函数单独放在一个文件中,直接在头部<code>.include</code>就行</p>
<ol start="3">
<li><p><strong>宏定义</strong></p>
<p>全局定义,如果我们想给一个数据或者寄存器,甚至是一行代码取个别名,然后在代码中使用别名的方式指代,那么可以使用宏定义指令<code>.eqv</code>  别名的好处就是方便我们进行记忆</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.eqv  LIMIT      20 #给20这个立即数取个别名为LIMIT</span><br><span class="line">.eqv  CTR        $t2</span><br><span class="line">.eqv  CLEAR_CTR  add  CTR, $zero, 0</span><br></pre></td></tr></table></figure>

<p>当我们有以下代码:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.text</span><br><span class="line">    li   $v0,1</span><br><span class="line">    add  $t2, $zero, 0</span><br><span class="line">    li $t0,20</span><br></pre></td></tr></table></figure>

<p>如果我们使用宏定义,我们可以写成如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.eqv  LIMIT      20 #给20这个立即数取个别名为LIMIT</span><br><span class="line">.eqv  CTR        $t2</span><br><span class="line">.eqv  CLEAR_CTR  add  CTR, $zero, 0</span><br><span class="line"></span><br><span class="line">.text</span><br><span class="line">    li   $v0,1</span><br><span class="line">    CLEAR_CTR</span><br><span class="line">    li $t0,LIMIT</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p><strong>注</strong>:<strong>宏定义</strong>和<strong>宏匹配</strong>必须<strong>先定义后使用</strong>,也就是说定义的代码需要放在前头</p>
<h2 id="二维数组的定义"><a href="#二维数组的定义" class="headerlink" title="二维数组的定义"></a>二维数组的定义</h2><p>二维数组其实就类似于我们数学中的二维坐标系,我们如果要定位一个点的话可以使用(x,y)来表示,在计算机的世界里,二维中所有的点都按照顺序依次存放在内存当中</p>
<p>假设我们将第一维当做行,第二维当做列,那么排列的方式有以下两种:</p>
<p><strong>第一种是 行不动,列轮动</strong></p>
<table>
<thead>
<tr>
<th align="center">内存地址</th>
<th align="center">二维坐标</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0x00000020</td>
<td align="center"><code>arr[2][2]</code></td>
</tr>
<tr>
<td align="center">0x0000001C</td>
<td align="center"><code>arr[2][1]</code></td>
</tr>
<tr>
<td align="center">0x00000018</td>
<td align="center"><code>arr[2][0]</code></td>
</tr>
<tr>
<td align="center">0x00000014</td>
<td align="center"><code>arr[1][2]</code></td>
</tr>
<tr>
<td align="center">0x00000010</td>
<td align="center"><code>arr[1][1]</code></td>
</tr>
<tr>
<td align="center">0x0000000C</td>
<td align="center"><code>arr[1][0]</code></td>
</tr>
<tr>
<td align="center">0x00000008</td>
<td align="center"><code>arr[0][2]</code></td>
</tr>
<tr>
<td align="center">0x00000004</td>
<td align="center"><code>arr[0][1]</code></td>
</tr>
<tr>
<td align="center">0x00000000</td>
<td align="center"><code>arr[0][0]</code></td>
</tr>
</tbody></table>
<p>这种方式获取实际地址的公式为:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">addr=baseAddr+(rowIndex*colSize+colIndex)*dataSize</span><br><span class="line"></span><br><span class="line">实际地址=首地址+(第几行*总列数+第几列)*数据占用的宽度</span><br><span class="line"></span><br><span class="line">比如:我要计算arr[2][1]的实际物理地址, 那么</span><br><span class="line">实际地址=0x00000000+(2*3+1)*4=0x00000000+0x0000001C=0x0000001C</span><br></pre></td></tr></table></figure>

<p><strong>第二种是 列不动,行轮动</strong></p>
<table>
<thead>
<tr>
<th align="center">内存地址</th>
<th align="center">二维坐标</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0x00000020</td>
<td align="center"><code>arr[2][2]</code></td>
</tr>
<tr>
<td align="center">0x0000001C</td>
<td align="center"><code>arr[1][2]</code></td>
</tr>
<tr>
<td align="center">0x00000018</td>
<td align="center"><code>arr[0][2]</code></td>
</tr>
<tr>
<td align="center">0x00000014</td>
<td align="center"><code>arr[2][1]</code></td>
</tr>
<tr>
<td align="center">0x00000010</td>
<td align="center"><code>arr[1][1]</code></td>
</tr>
<tr>
<td align="center">0x0000000C</td>
<td align="center"><code>arr[0][1]</code></td>
</tr>
<tr>
<td align="center">0x00000008</td>
<td align="center"><code>arr[2][0]</code></td>
</tr>
<tr>
<td align="center">0x00000004</td>
<td align="center"><code>arr[1][0]</code></td>
</tr>
<tr>
<td align="center">0x00000000</td>
<td align="center"><code>arr[0][0]</code></td>
</tr>
</tbody></table>
<p>这种方式获取实际地址的公式为:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">addr=baseAddr+(colIndex*rowSize+rowIndex)*dataSize</span><br><span class="line"></span><br><span class="line">实际地址=首地址+(第几列*行数+第几行)*数据占用的宽度</span><br><span class="line"></span><br><span class="line">比如:我要计算arr[2][1]的实际物理地址, 那么</span><br><span class="line">实际地址=0x00000000+(1*3+2)*4=0x00000000+0x00000014=0x00000014</span><br></pre></td></tr></table></figure>

<h4 id="使用mips汇编实现二维数组定义"><a href="#使用mips汇编实现二维数组定义" class="headerlink" title="使用mips汇编实现二维数组定义"></a>使用mips汇编实现二维数组定义</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#需求:实现int a[3][3] = &#123;&#123;1, 2, 3&#125;, &#123;5, 6, 7&#125;, &#123; 10, 11, 12&#125;&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#以下是以 行不动 列轮动的方式实现</span><br><span class="line">.data</span><br><span class="line">	da: .word 1,2,3,5,6,7,10,11,12</span><br><span class="line">	array: .space 36   </span><br><span class="line">	</span><br><span class="line">.text </span><br><span class="line"># void initArry(*arr,row,col,index)</span><br><span class="line">initArry:</span><br><span class="line">    #首地址</span><br><span class="line">    la $a0,array</span><br><span class="line">    #第几行</span><br><span class="line">    li $a1,0</span><br><span class="line">    #第几列</span><br><span class="line">    li $a2,0</span><br><span class="line">    #存第几个数</span><br><span class="line">    li $a3,0</span><br><span class="line"></span><br><span class="line">while:</span><br><span class="line">    # arr[x][y]</span><br><span class="line">    bgt $a1,2,exit</span><br><span class="line">    # 避免寄存器中的参数被子函数覆盖 将数据放置在栈中临时保存   </span><br><span class="line">    add $sp,$sp,-12</span><br><span class="line">    sw $a1,8($sp)</span><br><span class="line">    sw $a2,4($sp)</span><br><span class="line">    sw $a3,0($sp)</span><br><span class="line">    </span><br><span class="line">    jal saveDataToMemory</span><br><span class="line">    #从栈中恢复局部变量值</span><br><span class="line">    lw $a1,8($sp)</span><br><span class="line">    lw $a2,4($sp)</span><br><span class="line">    lw $a3,0($sp)</span><br><span class="line">    add $sp,$sp,12</span><br><span class="line">    </span><br><span class="line">    #累加计数</span><br><span class="line">    add $a3,$a3,4</span><br><span class="line">    #列轮动</span><br><span class="line">    addi $a2,$a2,1</span><br><span class="line">    bgt $a2,2,sub</span><br><span class="line">	</span><br><span class="line">    j while</span><br><span class="line">	</span><br><span class="line">sub:</span><br><span class="line">	li $a2,0</span><br><span class="line">	add $a1,$a1,1</span><br><span class="line">	j while</span><br><span class="line">	</span><br><span class="line">saveDataToMemory:</span><br><span class="line">  # 避免寄存器中的参数被子函数覆盖 将数据放置在栈中临时保存   </span><br><span class="line">    add $sp,$sp,-4</span><br><span class="line">    sw $ra,0($sp)</span><br><span class="line">    </span><br><span class="line">    #计算数据存放的物理地址</span><br><span class="line">    jal getAddr</span><br><span class="line"></span><br><span class="line">	#获取需要存放的数据</span><br><span class="line">	lw $t0,da($a3)</span><br><span class="line">	#将数据存入指定位置中</span><br><span class="line">	sw $t0,0($v0)</span><br><span class="line">	</span><br><span class="line">	lw $ra,0($sp)</span><br><span class="line">    add $sp,$sp,4</span><br><span class="line">	jr $ra</span><br><span class="line">	</span><br><span class="line">	#算法部分</span><br><span class="line">getAddr:</span><br><span class="line">	#实际地址=首地址+(第几行*总列数+第几列)*数据占用的宽度</span><br><span class="line">	mul $a1,$a1,3</span><br><span class="line">	add $a2,$a2,$a1</span><br><span class="line">	mul $a2,$a2,4</span><br><span class="line">	add $v0,$a2,$a0</span><br><span class="line"></span><br><span class="line">	jr $ra	</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">exit:</span><br><span class="line">	#程序结束之前测试数据能否正常取出</span><br><span class="line">	jal getDataFromArry</span><br><span class="line">	li $v0,10</span><br><span class="line">	syscall</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">#获取指定坐标位置的数据arr[2][1]  输出值为11</span><br><span class="line">getDataFromArry:</span><br><span class="line">	#第几行</span><br><span class="line">    li $a1,2</span><br><span class="line">    #第几列</span><br><span class="line">    li $a2,1</span><br><span class="line">    #计算物理地址</span><br><span class="line">    jal getAddr</span><br><span class="line">    #获取数据</span><br><span class="line">	lw $t0,0($v0)</span><br><span class="line">	</span><br><span class="line">	#打印数据</span><br><span class="line">	move $a0,$t0</span><br><span class="line">    li $v0,1</span><br><span class="line">	syscall</span><br></pre></td></tr></table></figure>

<h4 id="列不不动-行轮动方式"><a href="#列不不动-行轮动方式" class="headerlink" title="列不不动 行轮动方式:"></a><strong>列不不动 行轮动方式:</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#需求:实现int a[3][3] = &#123;&#123;1, 2, 3&#125;, &#123;5, 6, 7&#125;, &#123; 10, 11, 12&#125;&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#以下是以 列不动,行轮动的方式实现</span><br><span class="line">.data</span><br><span class="line">	da: .word 1,2,3,5,6,7,10,11,12</span><br><span class="line">	array: .space 36   </span><br><span class="line">	</span><br><span class="line">.text </span><br><span class="line"># void initArry(*arr,row,col,index)</span><br><span class="line">initArry:</span><br><span class="line">    #首地址</span><br><span class="line">    la $a0,array</span><br><span class="line">    #第几行</span><br><span class="line">    li $a1,0</span><br><span class="line">    #第几列</span><br><span class="line">    li $a2,0</span><br><span class="line">    #存第几个数</span><br><span class="line">    li $a3,0</span><br><span class="line"></span><br><span class="line">while:</span><br><span class="line">    # arr[x][y]</span><br><span class="line">    bgt $a2,2,exit</span><br><span class="line">    # 避免寄存器中的参数被子函数覆盖 将数据放置在栈中临时保存   </span><br><span class="line">    add $sp,$sp,-12</span><br><span class="line">    sw $a1,8($sp)</span><br><span class="line">    sw $a2,4($sp)</span><br><span class="line">    sw $a3,0($sp)</span><br><span class="line">    </span><br><span class="line">    jal saveDataToMemory</span><br><span class="line">    #从栈中恢复局部变量值</span><br><span class="line">    lw $a1,8($sp)</span><br><span class="line">    lw $a2,4($sp)</span><br><span class="line">    lw $a3,0($sp)</span><br><span class="line">    add $sp,$sp,12</span><br><span class="line">    </span><br><span class="line">    #累加计数</span><br><span class="line">    add $a3,$a3,4</span><br><span class="line">    #行轮动</span><br><span class="line">    addi $a1,$a1,1</span><br><span class="line">    bgt $a1,2,sub</span><br><span class="line">	</span><br><span class="line">    j while</span><br><span class="line">	</span><br><span class="line">sub:</span><br><span class="line">	li $a1,0</span><br><span class="line">	add $a2,$a2,1</span><br><span class="line">	j while</span><br><span class="line">	</span><br><span class="line">saveDataToMemory:</span><br><span class="line">  # 避免寄存器中的参数被子函数覆盖 将数据放置在栈中临时保存   </span><br><span class="line">    add $sp,$sp,-4</span><br><span class="line">    sw $ra,0($sp)</span><br><span class="line">    </span><br><span class="line">    #计算数据存放的物理地址</span><br><span class="line">    jal getAddr</span><br><span class="line"></span><br><span class="line">	#获取需要存放的数据</span><br><span class="line">	lw $t0,da($a3)</span><br><span class="line">	#将数据存入指定位置中</span><br><span class="line">	sw $t0,0($v0)</span><br><span class="line">	</span><br><span class="line">	lw $ra,0($sp)</span><br><span class="line">    add $sp,$sp,4</span><br><span class="line">	jr $ra</span><br><span class="line">	</span><br><span class="line">	#算法部分</span><br><span class="line">getAddr:</span><br><span class="line">	#实际地址=首地址+(第几列*行数+第几行)*数据占用的宽度</span><br><span class="line">	mul $a2,$a2,3</span><br><span class="line">	add $a1,$a1,$a2</span><br><span class="line">	mul $a1,$a1,4</span><br><span class="line">	add $v0,$a1,$a0</span><br><span class="line"></span><br><span class="line">	jr $ra	</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">exit:</span><br><span class="line">	#程序结束之前测试数据能否正常取出</span><br><span class="line">	jal getDataFromArry</span><br><span class="line">	li $v0,10</span><br><span class="line">	syscall</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">#获取指定坐标位置的数据arr[2][1] 输出7</span><br><span class="line">getDataFromArry:</span><br><span class="line">	#第几行</span><br><span class="line">    li $a1,2</span><br><span class="line">    #第几列</span><br><span class="line">    li $a2,1</span><br><span class="line">    #计算物理地址</span><br><span class="line">    jal getAddr</span><br><span class="line">    #获取数据</span><br><span class="line">	lw $t0,0($v0)</span><br><span class="line">	</span><br><span class="line">	#打印数据</span><br><span class="line">	move $a0,$t0</span><br><span class="line">    li $v0,1</span><br><span class="line">	syscall</span><br></pre></td></tr></table></figure>

<h4 id="更为简便的方法实现二维数组的搭建"><a href="#更为简便的方法实现二维数组的搭建" class="headerlink" title="更为简便的方法实现二维数组的搭建"></a>更为简便的方法实现二维数组的搭建</h4><p>由于数组中数据是在内存中连续进行排列存储的,那么我们可以之间将数据 依次存入内存之中,然后使用算法进行数据获取即可(以下示例皆采用 行不动,列动 的方式)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#需求:实现int a[3][3] = &#123;&#123;1, 2, 3&#125;, &#123;5, 6, 7&#125;, &#123; 10, 11, 12&#125;&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#由于数组中的数据是存放在堆内存中,需要在程序执行时动态分配</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">.text </span><br><span class="line">	#堆地址从0x10040000开始</span><br><span class="line">	la $a0,0x10040000 </span><br><span class="line">	#将数据按照顺序存放至内存中</span><br><span class="line">	jal initData</span><br><span class="line"></span><br><span class="line">	#获取数据	</span><br><span class="line">	jal getDataFromArry</span><br><span class="line">	j exit</span><br><span class="line">	</span><br><span class="line">initData:</span><br><span class="line">    li $s1,1</span><br><span class="line">    sw $s1,0($a0)</span><br><span class="line">    </span><br><span class="line">    li $s1,2</span><br><span class="line">    sw $s1,4($a0)</span><br><span class="line">    </span><br><span class="line">    li $s1,3</span><br><span class="line">    sw $s1,8($a0)</span><br><span class="line">    </span><br><span class="line">    li $s1,5</span><br><span class="line">    sw $s1,12($a0)</span><br><span class="line">    </span><br><span class="line">    li $s1,6</span><br><span class="line">    sw $s1,16($a0)</span><br><span class="line">    </span><br><span class="line">    li $s1,7</span><br><span class="line">    sw $s1,20($a0)</span><br><span class="line">    </span><br><span class="line">    li $s1,10</span><br><span class="line">    sw $s1,24($a0)</span><br><span class="line">    </span><br><span class="line">    li $s1,11</span><br><span class="line">    sw $s1,28($a0)</span><br><span class="line">    </span><br><span class="line">    li $s1,12</span><br><span class="line">    sw $s1,32($a0)</span><br><span class="line"></span><br><span class="line">    	 </span><br><span class="line">	jr $ra</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	#算法部分</span><br><span class="line">getAddr:</span><br><span class="line">	#实际地址=首地址+(第几行*总列数+第几列)*数据占用的宽度</span><br><span class="line">	mul $a1,$a1,3</span><br><span class="line">	add $a2,$a2,$a1</span><br><span class="line">	mul $a2,$a2,4</span><br><span class="line">	add $v0,$a2,$a0</span><br><span class="line"></span><br><span class="line">	jr $ra	</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">exit:</span><br><span class="line">	#程序退出</span><br><span class="line">	li $v0,10</span><br><span class="line">	syscall</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">#获取指定坐标位置的数据arr[2][1]  输出值为11</span><br><span class="line">getDataFromArry:</span><br><span class="line">	#第几行</span><br><span class="line">    li $a1,2</span><br><span class="line">    #第几列</span><br><span class="line">    li $a2,1</span><br><span class="line">    #计算物理地址</span><br><span class="line">    jal getAddr</span><br><span class="line">    #获取数据</span><br><span class="line">	lw $t0,0($v0)</span><br><span class="line">	</span><br><span class="line">	#打印数据</span><br><span class="line">	move $a0,$t0</span><br><span class="line">    li $v0,1</span><br><span class="line">	syscall</span><br></pre></td></tr></table></figure>

<p><strong>再简化一下:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#需求:实现int a[3][3] = &#123;&#123;1, 2, 3&#125;, &#123;5, 6, 7&#125;, &#123; 10, 11, 12&#125;&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">.data</span><br><span class="line">	da: .word 1,2,3,5,6,7,10,11,12</span><br><span class="line">	# 假如以上数据是动态写入的 当做数组中的数据来用</span><br><span class="line">	</span><br><span class="line">.text </span><br><span class="line">	#那么只需要提供首地址然后配合算法就能获取到指定坐标的数据</span><br><span class="line">	la $a0,da</span><br><span class="line">	jal getDataFromArry</span><br><span class="line">	j exit</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	#算法部分</span><br><span class="line">getAddr:</span><br><span class="line">	#实际地址=首地址+(第几行*总列数+第几列)*数据占用的宽度</span><br><span class="line">	mul $a1,$a1,3</span><br><span class="line">	add $a2,$a2,$a1</span><br><span class="line">	mul $a2,$a2,4</span><br><span class="line">	add $v0,$a2,$a0</span><br><span class="line"></span><br><span class="line">	jr $ra	</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">exit:</span><br><span class="line">	#程序退出</span><br><span class="line">	li $v0,10</span><br><span class="line">	syscall</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">#获取指定坐标位置的数据arr[2][1]  输出值为11</span><br><span class="line">getDataFromArry:</span><br><span class="line">	#第几行</span><br><span class="line">    li $a1,2</span><br><span class="line">    #第几列</span><br><span class="line">    li $a2,1</span><br><span class="line">    #计算物理地址</span><br><span class="line">    jal getAddr</span><br><span class="line">    #获取数据</span><br><span class="line">	lw $t0,0($v0)</span><br><span class="line">	</span><br><span class="line">	#打印数据</span><br><span class="line">	move $a0,$t0</span><br><span class="line">    li $v0,1</span><br><span class="line">	syscall</span><br></pre></td></tr></table></figure>

<blockquote>
<p>按照正常的编程思维,我们一般使用第一种行不动 列动的存储方式 第一维为行,第二维为列,如果你想改成行动存储方式,有两种方法:要么将数据的存储顺序进行变动,配合第二种算法,要么将第二维当成行,第一维当成列,配合第二种算法进行处理</p>
</blockquote>
<h2 id="Mips汇编指令汇总表"><a href="#Mips汇编指令汇总表" class="headerlink" title="Mips汇编指令汇总表"></a>Mips汇编指令汇总表</h2><table class="lake-table" style="width: 1133px;"><colgroup><col width="75" span="1"><col width="172" span="1"><col width="226" span="1"><col width="226" span="1"><col width="232" span="1"><col width="202" span="1"></colgroup><tbody><tr style="height: 33px;"><td style="background-color: #D9D9D9; vertical-align: middle; text-align: center;"><p data-lake-id="19f3ab8f472dbd9bf0bd3966e53ca440">类别</p></td><td style="background-color: #D9D9D9; vertical-align: middle; text-align: center;"><p data-lake-id="a6e5e54fbd1a6a759ab4854adf387653_p_0">指令名称</p></td><td style="background-color: #D9D9D9; vertical-align: middle; text-align: center;"><p data-lake-id="c3487b02cba2d01aa0a850022ba97e2c_p_0">实例</p></td><td style="background-color: #D9D9D9; vertical-align: middle; text-align: center;"><p data-lake-id="61147b9e8308a7250d535b19e9e6f5aa_p_0">含义</p></td><td style="background-color: #D9D9D9; vertical-align: middle; text-align: center;"><p data-lake-id="57eb3e4e08731e12883f9415e3f6aa7b_p_0">注释</p></td><td rowspan="1" style="text-align: center; vertical-align: middle; background-color: #D9D9D9; color: #404040;"><p data-lake-id="a20d224c568e48b9d67847a2c66a8c01_p_0">英文注解</p></td></tr><tr style="height: 33px;"><td rowspan="3" colspan="1" style="vertical-align: middle; text-align: center; background-color: #F5F5F5;"><p data-lake-id="c87053132644fbc37095a17624a01aff">算</p><p data-lake-id="119ee079321edf8371d1cdd74f0e80c0">数</p></td><td style="vertical-align: middle; text-align: center; background-color: #F5F5F5;"><p data-lake-id="19c858d65778e2c97fa93f4059bcad3e_p_0"><strong>加法</strong></p></td><td style="vertical-align: middle; text-align: center; background-color: #F5F5F5;"><p data-lake-id="938dbaf44547b2e6b8b7d9b7887bf487_p_0">add $s1,&nbsp;<span> $s2,&nbsp;</span><span> $s3</span></p></td><td rowspan="1" colspan="1" style="vertical-align: middle; text-align: center; background-color: #F5F5F5;">$s1 =&nbsp;<span>$s2 +</span><span>&nbsp;$s3</span></td><td style="vertical-align: middle; text-align: center; background-color: #F5F5F5;"><p data-lake-id="f699b6228a0ee572bf4fb4d49a92b3a0_p_0">三个寄存器操作数</p></td><td rowspan="1" style="text-align: center; vertical-align: middle; background-color: #F5F5F5; color: #404040;"><p data-lake-id="a20d224c568e48b9d67847a2c66a8c01_p_0">addition 加法</p></td></tr><tr style="height: 33px;"><td colspan="1" style="text-align: center; vertical-align: middle; background-color: #F5F5F5; color: #404040;"><p data-lake-id="8301c240ce4a0e86de4df280d15e9996_p_0"><strong>减法</strong></p></td><td colspan="1" style="text-align: center; vertical-align: middle; background-color: #F5F5F5;"><p data-lake-id="938dbaf44547b2e6b8b7d9b7887bf487_p_0">sub $s1,&nbsp;<span> $s2,&nbsp;</span><span> $s3</span></p></td><td colspan="1" rowspan="1" style="text-align: center; vertical-align: middle; background-color: #F5F5F5; color: #404040;">$s1 =&nbsp;<span>$s2 -</span><span>&nbsp;$s3</span></td><td colspan="1" style="text-align: center; vertical-align: middle; background-color: #F5F5F5; color: #404040;"><p data-lake-id="6a124af3720fef14782fa82f47a477d3_p_0">三个寄存器操作数</p></td><td rowspan="1" style="text-align: center; vertical-align: middle; background-color: #F5F5F5; color: #404040;"><p data-lake-id="bb535201959b494d8694990ce487fda0_p_0">subtraction 减法</p></td></tr><tr style="height: 33px;"><td colspan="1" style="text-align: center; vertical-align: middle; background-color: #F5F5F5; color: #404040;"><p data-lake-id="5f3b8ccfba7555de4cb86d81545981bc_p_0"><strong>立即数加法</strong></p></td><td colspan="1" style="text-align: center; vertical-align: middle; background-color: #F5F5F5; color: #404040;"><p data-lake-id="36fdd57c35a089ba13183c01d4d5f50e_p_0">addi&nbsp;$s1, <span> $s2,&nbsp;</span><span>&nbsp;20</span></p></td><td colspan="1" style="text-align: center; vertical-align: middle; background-color: #F5F5F5; color: #404040;"><p data-lake-id="896a61e3dfbf16d245703c553baf158d">$s1 = <span>$s2 +</span><span>&nbsp;20</span></p></td><td colspan="1" style="text-align: center; vertical-align: middle; background-color: #F5F5F5; color: #404040;"><p data-lake-id="70b43caffaa5424ac8574688f4303225_p_0">用于加常数数据</p></td><td rowspan="1" style="text-align: center; vertical-align: middle; background-color: #F5F5F5; color: #404040;"><p data-lake-id="36fdd57c35a089ba13183c01d4d5f50e_p_0">add immediate 立即加法</p></td></tr><tr style="height: 33px;"><td colspan="1" rowspan="11" style="text-align: center; vertical-align: middle; background-color: #FFFFFF; color: #404040;"><p data-lake-id="c06fd07af93a87d0a7e7c1e07ad85dcd">数</p><p data-lake-id="24f685ac20381124a98a85b7146bf8a4">据</p><p data-lake-id="c0a927c597da2d7d44aa565a50167c50">传</p><p data-lake-id="ae63a1ce6d91d235ca800710cbe490c7">输</p></td><td colspan="1" style="text-align: center; vertical-align: middle; background-color: #FFFFFF; color: #404040;"><p data-lake-id="97e258fcec56d9b97f128106a7c58515_p_0"><strong>取字</strong></p></td><td colspan="1" style="text-align: center; vertical-align: middle; background-color: #FFFFFF; color: #404040;"><p data-lake-id="0c48301f8e48fd1503b902aa041034c7_p_0">lw $s1, 20 ($s2)</p></td><td colspan="1" style="text-align: center; vertical-align: middle; background-color: #FFFFFF; color: #404040;"><p data-lake-id="5b134b4fa86e3fbc1f4e08d0b5cc2e59_p_0">$s1 = Memory[$s2 + 20]</p></td><td colspan="1" style="text-align: center; vertical-align: middle; background-color: #FFFFFF; color: #404040;"><p data-lake-id="9be41bd898970beaef453015a11fc209_p_0">将一个字从内存中取到寄存器中</p></td><td rowspan="1" style="text-align: center; vertical-align: middle; background-color: #FFFFFF; color: #404040;"><p data-lake-id="5ad727d684a4cf2fc457d2a0599a1e0c_p_0">load word 加载字</p></td></tr><tr style="height: 33px;"><td colspan="1" style="text-align: center; vertical-align: middle; background-color: #FFFFFF; color: #404040;"><p data-lake-id="dc66f9b30daad7f23e89ef8e56ce8c51_p_0"><strong>存字</strong></p></td><td colspan="1" style="text-align: center; vertical-align: middle; background-color: #FFFFFF; color: #404040;"><p data-lake-id="38f7c7f6ccbc4cb70343e8435b814787_p_0">sw&nbsp;<span>$s1, 20 ($s2)</span></p></td><td colspan="1" style="text-align: center; vertical-align: middle; background-color: #FFFFFF; color: #404040;"><p data-lake-id="b2e28e31a8e4d43a04be214d8616be5e">Memory[$s2 + 20] =&nbsp;<span>$s1</span></p></td><td colspan="1" style="text-align: center; vertical-align: middle; background-color: #FFFFFF; color: #404040;"><p data-lake-id="feb5c05542d161bbc537c4d79f530a5c">将一个字从寄存器中取到内存中</p></td><td rowspan="1" style="text-align: center; vertical-align: middle; background-color: #FFFFFF; color: #404040;"><p data-lake-id="a20d224c568e48b9d67847a2c66a8c01_p_0">store word 存储字</p></td></tr><tr style="height: 33px;"><td colspan="1" style="text-align: center; vertical-align: middle; background-color: #FFFFFF; color: #404040;"><p data-lake-id="2180ea8ecf404d1014aafa4f308e91ce_p_0">取半字</p></td><td colspan="1" style="text-align: center; vertical-align: middle; background-color: #FFFFFF; color: #404040;"><p data-lake-id="3acb5ac10d1a6d88a002afb34c40b882_p_0">lh&nbsp;<span>$s1, 20 ($s2)</span></p></td><td colspan="1" rowspan="1" style="text-align: center; vertical-align: middle; background-color: #FFFFFF; color: #404040;"><p data-lake-id="5b134b4fa86e3fbc1f4e08d0b5cc2e59_p_0">$s1 = Memory[$s2 + 20]</p></td><td colspan="1" rowspan="1" style="text-align: center; vertical-align: middle; background-color: #FFFFFF; color: #404040;"><p data-lake-id="9be41bd898970beaef453015a11fc209_p_0">将半个字从内存中取到寄存器中</p></td><td rowspan="1" style="text-align: center; vertical-align: middle; background-color: #FFFFFF; color: #404040;"><p data-lake-id="5ad727d684a4cf2fc457d2a0599a1e0c_p_0">load halfword 加载半字</p></td></tr><tr style="height: 33px;"><td colspan="1" style="text-align: center; vertical-align: middle; background-color: #FFFFFF; color: #404040;"><p data-lake-id="5e883a4fd23cfa7786abe4795391aff9_p_0">取无符号半字</p></td><td colspan="1" style="text-align: center; vertical-align: middle; background-color: #FFFFFF; color: #404040;"><p data-lake-id="3acb5ac10d1a6d88a002afb34c40b882_p_0">lhu&nbsp;<span>$s1, 20 ($s2)</span></p></td><td colspan="1" rowspan="1" style="text-align: center; vertical-align: middle; background-color: #FFFFFF; color: #404040;"><p data-lake-id="5b134b4fa86e3fbc1f4e08d0b5cc2e59_p_0">$s1 = Memory[$s2 + 20]</p></td><td colspan="1" style="text-align: center; vertical-align: middle; background-color: #FFFFFF; color: #404040;"><p data-lake-id="9be41bd898970beaef453015a11fc209_p_0">将半个字从内存中取到寄存器中</p></td><td rowspan="1" style="text-align: center; vertical-align: middle; background-color: #FFFFFF; color: #404040;"><p data-lake-id="3acb5ac10d1a6d88a002afb34c40b882_p_0">load halfword unsigned</p></td></tr><tr style="height: 33px;"><td colspan="1" style="text-align: center; vertical-align: middle; background-color: #FFFFFF; color: #404040;"><p data-lake-id="41df69f456f8d7fbe98b4dbfd2d91887_p_0">存半字</p></td><td colspan="1" style="text-align: center; vertical-align: middle; background-color: #FFFFFF; color: #404040;"><p data-lake-id="38f7c7f6ccbc4cb70343e8435b814787_p_0">sh&nbsp;<span>$s1, 20 ($s2)</span></p></td><td colspan="1" style="text-align: center; vertical-align: middle; background-color: #FFFFFF; color: #404040;"><p data-lake-id="b2e28e31a8e4d43a04be214d8616be5e">Memory[$s2 + 20] =&nbsp;<span>$s1</span></p></td><td colspan="1" style="text-align: center; vertical-align: middle; background-color: #FFFFFF; color: #404040;"><p data-lake-id="feb5c05542d161bbc537c4d79f530a5c">将半个字从寄存器中取到内存中</p></td><td rowspan="1" style="text-align: center; vertical-align: middle; background-color: #FFFFFF; color: #404040;"><p data-lake-id="ccb740e28773f0a19a2fc1efcb48e40a_p_0">stroe halfword 存储半字</p></td></tr><tr style="height: 33px;"><td colspan="1" style="text-align: center; vertical-align: middle; background-color: #FFFFFF; color: #404040;"><p data-lake-id="2e02995f88cf6ee38c687c8a4bf87447_p_0">取字节</p></td><td colspan="1" style="text-align: center; vertical-align: middle; background-color: #FFFFFF; color: #404040;"><p data-lake-id="3acb5ac10d1a6d88a002afb34c40b882_p_0">lb&nbsp;<span>$s1, 20 ($s2)</span></p></td><td colspan="1" style="text-align: center; vertical-align: middle; background-color: #FFFFFF; color: #404040;"><p data-lake-id="5b134b4fa86e3fbc1f4e08d0b5cc2e59_p_0">$s1 = Memory[$s2 + 20]</p></td><td colspan="1" style="text-align: center; vertical-align: middle; background-color: #FFFFFF; color: #404040;"><p data-lake-id="9be41bd898970beaef453015a11fc209_p_0">将一字节从内存中取到寄存器中</p></td><td rowspan="1" style="text-align: center; vertical-align: middle; background-color: #FFFFFF; color: #404040;"><p data-lake-id="5ad727d684a4cf2fc457d2a0599a1e0c_p_0">load byte</p></td></tr><tr style="height: 33px;"><td colspan="1" style="text-align: center; vertical-align: middle; background-color: #FFFFFF; color: #404040;"><p data-lake-id="e72364d265885d3fa75a0066f7578424_p_0">取无符号字节</p></td><td colspan="1" style="text-align: center; vertical-align: middle; background-color: #FFFFFF; color: #404040;"><p data-lake-id="3acb5ac10d1a6d88a002afb34c40b882_p_0">lbu&nbsp;<span>$s1, 20 ($s2)</span></p></td><td colspan="1" style="text-align: center; vertical-align: middle; background-color: #FFFFFF; color: #404040;"><p data-lake-id="5b134b4fa86e3fbc1f4e08d0b5cc2e59_p_0">$s1 = Memory[$s2 + 20]</p></td><td colspan="1" style="text-align: center; vertical-align: middle; background-color: #FFFFFF; color: #404040;"><p data-lake-id="9be41bd898970beaef453015a11fc209_p_0">将一字节从内存中取到寄存器中</p></td><td rowspan="1" style="text-align: center; vertical-align: middle; background-color: #FFFFFF; color: #404040;"><p data-lake-id="5ad727d684a4cf2fc457d2a0599a1e0c_p_0">load byte unsigned</p></td></tr><tr style="height: 33px;"><td colspan="1" style="text-align: center; vertical-align: middle; background-color: #FFFFFF; color: #404040;"><p data-lake-id="41df69f456f8d7fbe98b4dbfd2d91887_p_0">存字节</p></td><td colspan="1" rowspan="1" style="text-align: center; vertical-align: middle; background-color: #FFFFFF; color: #404040;"><span><span style="color: #404040;">sb $s1, 20 ($s2)</span></span></td><td colspan="1" style="text-align: center; vertical-align: middle; background-color: #FFFFFF; color: #404040;"><p data-lake-id="b2e28e31a8e4d43a04be214d8616be5e">Memory[$s2 + 20] =&nbsp;<span>$s1</span></p></td><td colspan="1" style="text-align: center; vertical-align: middle; background-color: #FFFFFF; color: #404040;"><p data-lake-id="feb5c05542d161bbc537c4d79f530a5c">将一字节从寄存器中取到内存中</p></td><td rowspan="1" style="text-align: center; vertical-align: middle; background-color: #FFFFFF; color: #404040;"><p data-lake-id="1e772fe573b1e2927828f4ea6f45f814_p_0">store byte</p></td></tr><tr style="height: 33px;"><td colspan="1" style="text-align: center; vertical-align: middle; background-color: #FFFFFF; color: #404040;"><p data-lake-id="e72364d265885d3fa75a0066f7578424_p_0">取链接字</p></td><td colspan="1" style="text-align: center; vertical-align: middle; background-color: #FFFFFF; color: #404040;"><p data-lake-id="9c3a049c6baccc1e645853f228073b82_p_0">ll&nbsp;<span>$s1, 20 ($s2)</span></p></td><td colspan="1" style="text-align: center; vertical-align: middle; background-color: #FFFFFF; color: #404040;"><p data-lake-id="5b134b4fa86e3fbc1f4e08d0b5cc2e59_p_0">$s1 = Memory[$s2 + 20]</p></td><td colspan="1" style="text-align: center; vertical-align: middle; background-color: #FFFFFF; color: #404040;"><p data-lake-id="e72364d265885d3fa75a0066f7578424_p_0">取字作为原子交换的前半部</p></td><td rowspan="1" style="text-align: center; vertical-align: middle; background-color: #FFFFFF; color: #404040;"><p data-lake-id="5ad727d684a4cf2fc457d2a0599a1e0c_p_0">load linked</p></td></tr><tr style="height: 33px;"><td colspan="1" style="text-align: center; vertical-align: middle; background-color: #FFFFFF; color: #404040;"><p data-lake-id="41df69f456f8d7fbe98b4dbfd2d91887_p_0">存条件字</p></td><td colspan="1" style="text-align: center; vertical-align: middle; background-color: #FFFFFF; color: #404040;"><p data-lake-id="9c3a049c6baccc1e645853f228073b82_p_0">sc&nbsp;<span>$s1, 20 ($s2)</span></p></td><td colspan="1" style="text-align: center; vertical-align: middle; background-color: #FFFFFF; color: #404040;"><p data-lake-id="b2e28e31a8e4d43a04be214d8616be5e">Memory[$s2 + 20] =&nbsp;<span>$s1;</span></p><p data-lake-id="5495b7df228dc83176fc6d470d460efe"><span>$s1 = 0 or 1</span></p></td><td colspan="1" style="text-align: center; vertical-align: middle; background-color: #FFFFFF; color: #404040;"><p data-lake-id="2180ea8ecf404d1014aafa4f308e91ce_p_0">存字作为原子交换的后半部分</p></td><td rowspan="1" style="text-align: center; vertical-align: middle; background-color: #FFFFFF; color: #404040;"><p data-lake-id="1e772fe573b1e2927828f4ea6f45f814_p_0">store conditional</p></td></tr><tr style="height: 33px;"><td colspan="1" style="text-align: center; vertical-align: middle; background-color: #FFFFFF; color: #404040;"><p data-lake-id="e72364d265885d3fa75a0066f7578424_p_0">取立即数的高位</p></td><td colspan="1" style="text-align: center; vertical-align: middle; background-color: #FFFFFF; color: #404040;"><p data-lake-id="77653b357033343fd1eb53ef9579731b_p_0">lui $s1, 20</p></td><td colspan="1" style="text-align: center; vertical-align: middle; background-color: #FFFFFF; color: #404040;"><p data-lake-id="ddf0718a1e42d32b17b705ca5ee70b45_p_0">$s1 = 20 * 2<sup>16</sup></p></td><td colspan="1" style="text-align: center; vertical-align: middle; background-color: #FFFFFF; color: #404040;"><p data-lake-id="e72364d265885d3fa75a0066f7578424_p_0">取立即数并放到高16位</p></td><td rowspan="1" style="text-align: center; vertical-align: middle; background-color: #FFFFFF; color: #404040;"><p data-lake-id="5ad727d684a4cf2fc457d2a0599a1e0c_p_0">load upper immediate</p></td></tr><tr style="height: 33px;"><td colspan="1" rowspan="7" style="text-align: center; vertical-align: middle; background-color: #F5F5F5; color: #404040;"><p data-lake-id="6f57b43f248e3d13f215c9a6f1f5559a">逻</p><p data-lake-id="04b6beb994377423646f5144e976cd3f">辑</p></td><td colspan="1" style="text-align: center; vertical-align: middle; background-color: #F5F5F5; color: #404040;"><p data-lake-id="92e6c1abf9964caeb0842bea439190db_p_0">与</p></td><td colspan="1" style="text-align: center; vertical-align: middle; background-color: #F5F5F5; color: #404040;"><p data-lake-id="ec1412d74f8f09021b8d3ba97f509a09_p_0">and $s1, $s2, $s3</p></td><td colspan="1" style="text-align: center; vertical-align: middle; background-color: #F5F5F5;">$s1 =&nbsp;<span>$s2 &amp;</span><span>&nbsp;$s3</span></td><td colspan="1" style="text-align: center; vertical-align: middle; background-color: #F5F5F5; color: #404040;"><p data-lake-id="f699b6228a0ee572bf4fb4d49a92b3a0_p_0">三个寄存器操作数按位与</p></td><td colspan="1" style="text-align: center; vertical-align: middle; background-color: #F5F5F5; color: #404040;"><p data-lake-id="ec1412d74f8f09021b8d3ba97f509a09_p_0">and</p></td></tr><tr style="height: 33px;"><td colspan="1" style="text-align: center; vertical-align: middle; background-color: #F5F5F5; color: #404040;"><p data-lake-id="5b3091b46b8e1feee477b8c3d5fb0892_p_0">或</p></td><td colspan="1" style="text-align: center; vertical-align: middle; background-color: #F5F5F5; color: #404040;"><p data-lake-id="369cd10e57cc8116e75e38f39ce806bf_p_0">or&nbsp;<span>$s1, $s2, $s3</span></p></td><td colspan="1" style="text-align: center; vertical-align: middle; background-color: #F5F5F5;">$s1 =&nbsp;<span>$s2 |</span><span>&nbsp;$s3</span></td><td colspan="1" style="text-align: center; vertical-align: middle; background-color: #F5F5F5; color: #404040;"><p data-lake-id="f699b6228a0ee572bf4fb4d49a92b3a0_p_0">三个寄存器操作数按位或</p></td><td colspan="1" style="text-align: center; vertical-align: middle; background-color: #F5F5F5; color: #404040;"><p data-lake-id="369cd10e57cc8116e75e38f39ce806bf_p_0">or</p></td></tr><tr style="height: 33px;"><td colspan="1" style="text-align: center; vertical-align: middle; background-color: #F5F5F5; color: #404040;"><p data-lake-id="5b3091b46b8e1feee477b8c3d5fb0892_p_0">或非</p></td><td colspan="1" style="text-align: center; vertical-align: middle; background-color: #F5F5F5; color: #404040;"><p data-lake-id="538eafe77ec75e052a5c44acaf75f955_p_0">nor&nbsp;<span>$s1, $s2, $s3</span></p></td><td colspan="1" style="text-align: center; vertical-align: middle; background-color: #F5F5F5;">$s1 = ~ (<span>$s2 |</span><span>&nbsp;$s3)</span></td><td colspan="1" style="text-align: center; vertical-align: middle; background-color: #F5F5F5; color: #404040;"><p data-lake-id="f699b6228a0ee572bf4fb4d49a92b3a0_p_0">三个寄存器操作数按位或非</p></td><td colspan="1" style="text-align: center; vertical-align: middle; background-color: #F5F5F5; color: #404040;"><p data-lake-id="86329f51ae33cd3f0301723a69e0b26a_p_0">not or</p></td></tr><tr style="height: 33px;"><td colspan="1" style="text-align: center; vertical-align: middle; background-color: #F5F5F5; color: #404040;"><p data-lake-id="d522d2b4b20eaddeece0b4af549a09c0_p_0">立即数与</p></td><td colspan="1" style="text-align: center; vertical-align: middle; background-color: #F5F5F5; color: #404040;"><p data-lake-id="ec1412d74f8f09021b8d3ba97f509a09_p_0">andi&nbsp;<span>$s1, $s2, 20</span></p></td><td colspan="1" rowspan="1" style="text-align: center; vertical-align: middle; background-color: #F5F5F5; color: #404040;">$s1 =&nbsp;<span>$s2 &amp; 20</span></td><td colspan="1" style="text-align: center; vertical-align: middle; background-color: #F5F5F5; color: #404040;"><p data-lake-id="cc71c8f6f050efe73a6e5cbadec3e873_p_0">和常数按位与</p></td><td colspan="1" style="text-align: center; vertical-align: middle; background-color: #F5F5F5; color: #404040;"><p data-lake-id="ec1412d74f8f09021b8d3ba97f509a09_p_0">and immediate</p></td></tr><tr style="height: 33px;"><td colspan="1" style="text-align: center; vertical-align: middle; background-color: #F5F5F5; color: #404040;"><p data-lake-id="d522d2b4b20eaddeece0b4af549a09c0_p_0">立即数或</p></td><td colspan="1" style="text-align: center; vertical-align: middle; background-color: #F5F5F5; color: #404040;"><p data-lake-id="369cd10e57cc8116e75e38f39ce806bf_p_0">ori <span>$s1, $s2, 20</span></p></td><td colspan="1" style="text-align: center; vertical-align: middle; background-color: #F5F5F5; color: #404040;">$s1 =&nbsp;<span>$s2 | 20</span></td><td colspan="1" style="text-align: center; vertical-align: middle; background-color: #F5F5F5; color: #404040;"><p data-lake-id="cc71c8f6f050efe73a6e5cbadec3e873_p_0">和常数按位或</p></td><td colspan="1" rowspan="1" style="text-align: center; vertical-align: middle; background-color: #F5F5F5; color: #404040;"><p data-lake-id="ec1412d74f8f09021b8d3ba97f509a09_p_0">or immediate</p></td></tr><tr style="height: 33px;"><td colspan="1" style="text-align: center; vertical-align: middle; background-color: #F5F5F5; color: #404040;"><p data-lake-id="b2493fcc6c9b73ebff831c420b772d80_p_0">逻辑左移</p></td><td colspan="1" style="text-align: center; vertical-align: middle; background-color: #F5F5F5; color: #404040;"><p data-lake-id="12a6ee81b0c7707b054b7cefdc29d80a_p_0">sll&nbsp;<span>$s1, $s2, 10</span></p></td><td colspan="1" style="text-align: center; vertical-align: middle; background-color: #F5F5F5; color: #404040;">$s1 =&nbsp;<span>$s2 &lt;&lt; 20</span></td><td colspan="1" style="text-align: center; vertical-align: middle; background-color: #F5F5F5; color: #404040;"><p data-lake-id="6cbbf8f62e3649904064e9a0578d583c_p_0">根据常数左移相应位</p></td><td colspan="1" style="text-align: center; vertical-align: middle; background-color: #F5F5F5; color: #404040;"><p data-lake-id="66b3e042f914f6194effb1f2258fe974">set left logical</p></td></tr><tr style="height: 33px;"><td colspan="1" style="text-align: center; vertical-align: middle; background-color: #F5F5F5; color: #404040;"><p data-lake-id="b2493fcc6c9b73ebff831c420b772d80_p_0">逻辑右移</p></td><td colspan="1" style="text-align: center; vertical-align: middle; background-color: #F5F5F5; color: #404040;"><p data-lake-id="4fdb863283ccd8331e7d6b20ffa53c96">srl&nbsp;<span>$s1, $s2, 10</span></p></td><td colspan="1" style="text-align: center; vertical-align: middle; background-color: #F5F5F5; color: #404040;">$s1 =&nbsp;<span>$s2 &gt;&gt; 20</span></td><td colspan="1" style="text-align: center; vertical-align: middle; background-color: #F5F5F5; color: #404040;"><p data-lake-id="6cbbf8f62e3649904064e9a0578d583c_p_0">根据常数右移相应位</p></td><td colspan="1" style="text-align: center; vertical-align: middle; background-color: #F5F5F5; color: #404040;"><p data-lake-id="a2260bc1b8d9c0a6e09db7ac85b73a5e_p_0">set right logical</p></td></tr><tr style="height: 33px;"><td colspan="1" rowspan="6" style="text-align: center; vertical-align: middle; background-color: #FFFFFF; color: #404040;"><p data-lake-id="ab9c258efee1062b7c2f4607cf888cc8">条</p><p data-lake-id="ffe2163d653650f6a4949f8c8273f628">件</p><p data-lake-id="ec3aea0edd70a303953afc1e9d7d1855">分</p><p data-lake-id="b9b5281e6dbba146a7ce96f2b6aa3240">支</p></td><td colspan="1" style="text-align: center; vertical-align: middle; background-color: #FFFFFF; color: #404040;"><p data-lake-id="b6ecd4dc4aa8e8c660581b280bac88d3_p_0">相等时跳转</p></td><td colspan="1" style="text-align: center; vertical-align: middle; background-color: #FFFFFF; color: #404040;"><p data-lake-id="62207f4a467c0df9447df20012817fff_p_0">beq $s1, $s2, 25</p></td><td colspan="1" style="text-align: center; vertical-align: middle; background-color: #FFFFFF; color: #404040;"><p data-lake-id="fda5fb2592297743fb17f893b76022cc">if ($s1 == $s2) go to&nbsp;</p><p data-lake-id="c8769a060253163489ebd3d912fbc3ee">PC + 4 + 25 * 4</p></td><td colspan="1" style="text-align: center; vertical-align: middle; background-color: #FFFFFF; color: #404040;"><p data-lake-id="80194537a7a8305345072ad8f4ea294e_p_0">相等检测：</p><p data-lake-id="80ba5bf175f8bbb4e322b10bab63814a">和PC相关的跳转</p></td><td colspan="1" style="text-align: center; vertical-align: middle; background-color: #FFFFFF; color: #404040;"><p data-lake-id="3053629cc2f20240a3713b6380a5ebd4">branch on equal</p></td></tr><tr style="height: 33px;"><td colspan="1" style="text-align: center; vertical-align: middle; background-color: #FFFFFF; color: #404040;"><p data-lake-id="e1916fc5d5ddc0e9acc760774b55f8b7_p_0">不相等时跳转</p></td><td colspan="1" style="text-align: center; vertical-align: middle; background-color: #FFFFFF; color: #404040;"><p data-lake-id="62207f4a467c0df9447df20012817fff_p_0">bne $s1, $s2, 25</p></td><td colspan="1" style="text-align: center; vertical-align: middle; background-color: #FFFFFF; color: #404040;"><p data-lake-id="fda5fb2592297743fb17f893b76022cc">if ($s1 != $s2) go to&nbsp;</p><p data-lake-id="c8769a060253163489ebd3d912fbc3ee">PC + 4 + 25 * 4</p></td><td colspan="1" style="text-align: center; vertical-align: middle; background-color: #FFFFFF; color: #404040;"><p data-lake-id="80194537a7a8305345072ad8f4ea294e_p_0">不相等检测：</p><p data-lake-id="80ba5bf175f8bbb4e322b10bab63814a">和PC相关的跳转</p></td><td colspan="1" style="text-align: center; vertical-align: middle; background-color: #FFFFFF; color: #404040;"><p data-lake-id="3053629cc2f20240a3713b6380a5ebd4">branch on not equal</p></td></tr><tr style="height: 33px;"><td colspan="1" style="text-align: center; vertical-align: middle; background-color: #FFFFFF; color: #404040;"><p data-lake-id="03061f9cbcf54ad56211e4d9e1dabcd1_p_0">小于时跳转</p></td><td colspan="1" style="text-align: center; vertical-align: middle; background-color: #FFFFFF; color: #404040;"><p data-lake-id="097bdacfd338f4e1acf4d47b9f8db739_p_0">slt $1, $s2, $3</p></td><td colspan="1" style="text-align: center; vertical-align: middle; background-color: #FFFFFF; color: #404040;"><p data-lake-id="fda5fb2592297743fb17f893b76022cc">if ($s2 &lt; $s3) $s1 = 1;&nbsp;</p><p data-lake-id="c8769a060253163489ebd3d912fbc3ee">else $s1 = 0</p></td><td colspan="1" style="text-align: center; vertical-align: middle; background-color: #FFFFFF; color: #404040;"><p data-lake-id="1d21cc3e5e635fa7fa627af87ec56a8b_p_0">比较是否小于</p></td><td colspan="1" style="text-align: center; vertical-align: middle; background-color: #FFFFFF; color: #404040;"><p data-lake-id="f699b6228a0ee572bf4fb4d49a92b3a0_p_0">set less than</p></td></tr><tr style="height: 33px;"><td colspan="1" style="text-align: center; vertical-align: middle; background-color: #FFFFFF; color: #404040;"><p data-lake-id="c14ef141a1137de8b22ba69ca6d64daa_p_0">无符号数比较小时置位</p></td><td colspan="1" style="text-align: center; vertical-align: middle; background-color: #FFFFFF; color: #404040;"><p data-lake-id="3acb5ac10d1a6d88a002afb34c40b882_p_0">sltu&nbsp;<span>$1, $s2, $3</span></p></td><td colspan="1" style="text-align: center; vertical-align: middle; background-color: #FFFFFF; color: #404040;"><p data-lake-id="fda5fb2592297743fb17f893b76022cc">if ($s2 &lt; $s3) $s1 = 1;&nbsp;</p><p data-lake-id="c8769a060253163489ebd3d912fbc3ee">else $s1 = 0</p></td><td colspan="1" style="text-align: center; vertical-align: middle; background-color: #FFFFFF; color: #404040;"><p data-lake-id="8d5efedb4fdbe061cc194fc98f15df26_p_0">比较是否小于无符号数</p></td><td colspan="1" style="text-align: center; vertical-align: middle; background-color: #FFFFFF; color: #404040;"><p data-lake-id="f699b6228a0ee572bf4fb4d49a92b3a0_p_0">set less than unsigned</p></td></tr><tr style="height: 33px;"><td colspan="1" style="text-align: center; vertical-align: middle; background-color: #FFFFFF; color: #404040;"><p data-lake-id="c14ef141a1137de8b22ba69ca6d64daa_p_0">无符号数小于立即数时置位</p></td><td colspan="1" style="text-align: center; vertical-align: middle; background-color: #FFFFFF; color: #404040;"><p data-lake-id="097bdacfd338f4e1acf4d47b9f8db739_p_0">slti <span>$1, $s2, 20</span></p></td><td colspan="1" style="text-align: center; vertical-align: middle; background-color: #FFFFFF; color: #404040;"><p data-lake-id="fda5fb2592297743fb17f893b76022cc">if ($s2 &lt; 20) $s1 = 1;&nbsp;</p><p data-lake-id="c8769a060253163489ebd3d912fbc3ee">else $s1 = 0</p></td><td colspan="1" style="text-align: center; vertical-align: middle; background-color: #FFFFFF; color: #404040;"><p data-lake-id="8d5efedb4fdbe061cc194fc98f15df26_p_0">比较是否小于常数</p></td><td colspan="1" style="text-align: center; vertical-align: middle; background-color: #FFFFFF; color: #404040;"><p data-lake-id="a2260bc1b8d9c0a6e09db7ac85b73a5e_p_0">set less than immediate</p></td></tr><tr style="height: 33px;"><td colspan="1" style="text-align: center; vertical-align: middle; background-color: #FFFFFF; color: #404040;"><p data-lake-id="084b47be286305d6282baa7b40423b57_p_0">无符号数比较小于无符号立即数时置位</p></td><td colspan="1" style="text-align: center; vertical-align: middle; background-color: #FFFFFF; color: #404040;"><p data-lake-id="7daa01b91d2703b8f9272f5c81563830_p_0">sltiu&nbsp;<span>$1, $s2, 20</span></p></td><td colspan="1" style="text-align: center; vertical-align: middle; background-color: #FFFFFF; color: #404040;"><p data-lake-id="fda5fb2592297743fb17f893b76022cc">if ($s2 &lt; 20) $s1 = 1;&nbsp;</p><p data-lake-id="c8769a060253163489ebd3d912fbc3ee">else $s1 = 0</p></td><td colspan="1" style="text-align: center; vertical-align: middle; background-color: #FFFFFF; color: #404040;"><p data-lake-id="8d5efedb4fdbe061cc194fc98f15df26_p_0">比较是否小于无符号常数</p></td><td colspan="1" style="text-align: center; vertical-align: middle; background-color: #FFFFFF; color: #404040;"><p data-lake-id="a2260bc1b8d9c0a6e09db7ac85b73a5e_p_0">set less than immediate unsigned</p></td></tr><tr style="height: 33px;"><td colspan="1" rowspan="3" style="text-align: center; vertical-align: middle; background-color: #F5F5F5; color: #404040;"><p data-lake-id="299731ade3eb955f7ce6bafbd2c1bc44_p_0">无</p><p data-lake-id="c6426b8ba89c954b9c6e9722313bf9eb">条</p><p data-lake-id="fcf4e9ee92dbefcc989515f662656007">件</p><p data-lake-id="3cfa3347270135183d783c41ffce21f5">跳</p><p data-lake-id="5483dea9fe8e1cdcff2a72c257f99515">转</p></td><td colspan="1" style="text-align: center; vertical-align: middle; background-color: #F5F5F5; color: #404040;"><p data-lake-id="8d15be8749c822bd7d8db17fa912192e_p_0">跳转</p></td><td colspan="1" style="text-align: center; vertical-align: middle; background-color: #F5F5F5; color: #404040;"><p data-lake-id="9be41bd898970beaef453015a11fc209_p_0">j 2500</p></td><td colspan="1" style="text-align: center; vertical-align: middle; background-color: #F5F5F5; color: #404040;"><p data-lake-id="d2669a10370e09c410e955d3e89e586c_p_0">go to 2500 * 4</p></td><td colspan="1" style="text-align: center; vertical-align: middle; background-color: #F5F5F5; color: #404040;"><p data-lake-id="8d15be8749c822bd7d8db17fa912192e_p_0">跳转到目标地址</p></td><td colspan="1" style="text-align: center; vertical-align: middle; background-color: #F5F5F5; color: #404040;"><p data-lake-id="3349b2f2b1697d777427dfd962325c8b_p_0">jump</p></td></tr><tr style="height: 33px;"><td colspan="1" style="text-align: center; vertical-align: middle; background-color: #F5F5F5; color: #404040;"><p data-lake-id="8d15be8749c822bd7d8db17fa912192e_p_0">跳转至寄存器所指位置</p></td><td colspan="1" style="text-align: center; vertical-align: middle; background-color: #F5F5F5; color: #404040;"><p data-lake-id="a20d224c568e48b9d67847a2c66a8c01_p_0">jr $ra</p></td><td colspan="1" style="text-align: center; vertical-align: middle; background-color: #F5F5F5; color: #404040;"><p data-lake-id="a20d224c568e48b9d67847a2c66a8c01_p_0">go to $ra</p></td><td colspan="1" style="text-align: center; vertical-align: middle; background-color: #F5F5F5; color: #404040;"><p data-lake-id="8d15be8749c822bd7d8db17fa912192e_p_0">用于switch语句，以及过程调用</p></td><td colspan="1" style="text-align: center; vertical-align: middle; background-color: #F5F5F5; color: #404040;"><p data-lake-id="3349b2f2b1697d777427dfd962325c8b_p_0">jump register</p></td></tr><tr style="height: 33px;"><td colspan="1" style="text-align: center; vertical-align: middle; background-color: #F5F5F5; color: #404040;"><p data-lake-id="8d15be8749c822bd7d8db17fa912192e_p_0">跳转并链接</p></td><td colspan="1" style="text-align: center; vertical-align: middle; background-color: #F5F5F5; color: #404040;"><p data-lake-id="1bae19900d58b641de05b3ea40796945_p_0">jal 2500</p></td><td colspan="1" style="text-align: center; vertical-align: middle; background-color: #F5F5F5; color: #404040;"><p data-lake-id="5b134b4fa86e3fbc1f4e08d0b5cc2e59_p_0">$ra = PC + 4;</p><p data-lake-id="27f9616c63786ccd8b4b7f9ea3d38b54">go to 2500 * 4;</p></td><td colspan="1" style="text-align: center; vertical-align: middle; background-color: #F5F5F5; color: #404040;"><p data-lake-id="70b43caffaa5424ac8574688f4303225_p_0">用于过程调用(方法)</p><p data-lake-id="ac1fd60a50cec6e2962f27e06822829c">正常的执行流程执行完A自然要执行B指令，现在要跳转执行C方法，这时就把B地址存入寄存器中，执行完C后跳转到B</p></td><td colspan="1" style="text-align: center; vertical-align: middle; background-color: #F5F5F5; color: #404040;"><p data-lake-id="a20d224c568e48b9d67847a2c66a8c01_p_0">jump and link</p></td></tr></tbody></table>


<h3 id="Mips内存结构图"><a href="#Mips内存结构图" class="headerlink" title="Mips内存结构图:"></a>Mips内存结构图:</h3><p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20210106181201.png" alt></p>
<p><strong>本文为作者原创 转载时请注明出处 谢谢</strong></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em>乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</em></p>
]]></content>
      <tags>
        <tag>汇编</tag>
      </tags>
  </entry>
</search>
