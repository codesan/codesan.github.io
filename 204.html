<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">
<meta name="referrer" content="never">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="汇编,">





  <link rel="alternate" href="/atom.xml" title="乱码三千 – 分享实用IT技术" type="application/atom+xml">






<meta name="description" content="ARM两种编译环境两种常用的ARM的编译开发环境  ARM原生编译环境：ARM官方提供的原生编译环境,相关集成开发软件有ADS,Keil等,常用于ARM单片机开发 GNU编译环境： 由GNU的汇编器as,交叉编译器gcc,和链接器ld等组成,一般适用于交叉编译环境需求   以上两种编译环境,使用的指令集都是一致的, 只是语法格式有不同,也就是宏指令,伪指令,伪操作不一样 ARM原生环境搭建使用 K">
<meta name="keywords" content="汇编">
<meta property="og:type" content="article">
<meta property="og:title" content="汇编语言之ARM32汇编">
<meta property="og:url" content="https://code.newban.cn/204.html">
<meta property="og:site_name" content="乱码三千 – 分享实用IT技术">
<meta property="og:description" content="ARM两种编译环境两种常用的ARM的编译开发环境  ARM原生编译环境：ARM官方提供的原生编译环境,相关集成开发软件有ADS,Keil等,常用于ARM单片机开发 GNU编译环境： 由GNU的汇编器as,交叉编译器gcc,和链接器ld等组成,一般适用于交叉编译环境需求   以上两种编译环境,使用的指令集都是一致的, 只是语法格式有不同,也就是宏指令,伪指令,伪操作不一样 ARM原生环境搭建使用 K">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20210105183952.png">
<meta property="og:image" content="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20210120151329.png">
<meta property="og:image" content="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20210120151619.png">
<meta property="og:image" content="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png">
<meta property="og:updated_time" content="2024-04-08T02:36:39.099Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="汇编语言之ARM32汇编">
<meta name="twitter:description" content="ARM两种编译环境两种常用的ARM的编译开发环境  ARM原生编译环境：ARM官方提供的原生编译环境,相关集成开发软件有ADS,Keil等,常用于ARM单片机开发 GNU编译环境： 由GNU的汇编器as,交叉编译器gcc,和链接器ld等组成,一般适用于交叉编译环境需求   以上两种编译环境,使用的指令集都是一致的, 只是语法格式有不同,也就是宏指令,伪指令,伪操作不一样 ARM原生环境搭建使用 K">
<meta name="twitter:image" content="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20210105183952.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":true,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>
<!--谷歌广告验证代码-->
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({
          google_ad_client: "ca-pub-2626449904708114",
          enable_page_level_ads: true
     });
</script>
<!--谷歌广告验证代码-->

<!--短链广告-->
<!--<script type="text/javascript">
    var adfly_id = 25792435;
    var adfly_advert = 'banner';
    var popunder = false;
    var exclude_domains = ['code.newban.cn','newban.cn',  'localhost:4000'];
</script>
<script src="https://cdn.adf.ly/js/link-converter.js"></script>-->
<!--短链广告-->



  <link rel="canonical" href="https://code.newban.cn/204.html">





  <title>汇编语言之ARM32汇编 | 乱码三千 – 分享实用IT技术</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>
  
<a href="https://www.github.com/songjianzaina" class="github-corner" aria-label="View source on Github"><svg width="80" height="80" viewbox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"/><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"/><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"/></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>
    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">乱码三千 – 分享实用IT技术</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">乱码三千 – 码出一个新世界</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="http://www.newban.cn/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="https://code.newban.cn/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://code.newban.cn">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="乱码三千">
      <meta itemprop="description" content>
      <meta itemprop="image" content="images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="乱码三千 – 分享实用IT技术">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">汇编语言之ARM32汇编</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-01-05T16:14:19+08:00">
                2021-01-05
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="#comments" itemprop="discussionUrl">
                  <span class="post-comments-count gitment-comments-count" data-xid itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h2 id="ARM两种编译环境"><a href="#ARM两种编译环境" class="headerlink" title="ARM两种编译环境"></a>ARM两种编译环境</h2><p>两种常用的ARM的编译开发环境</p>
<ul>
<li>ARM原生编译环境：ARM官方提供的原生编译环境,相关集成开发软件有ADS,Keil等,常用于ARM单片机开发</li>
<li>GNU编译环境： 由GNU的汇编器as,交叉编译器gcc,和链接器ld等组成,一般适用于交叉编译环境需求 </li>
</ul>
<p>以上两种编译环境,使用的指令集都是一致的, 只是语法格式有不同,也就是宏指令,伪指令,伪操作不一样</p>
<h2 id="ARM原生环境搭建"><a href="#ARM原生环境搭建" class="headerlink" title="ARM原生环境搭建"></a>ARM原生环境搭建</h2><p>使用 Keil μVision5 这款软件进行ARM32的汇编学习</p>
<p>下载地址:<a href="http://www.mcuzone.com/down/Software.asp?ID=10000503" target="_blank" rel="noopener">http://www.mcuzone.com/down/Software.asp?ID=10000503</a></p>
<h2 id="ARM32系列命名"><a href="#ARM32系列命名" class="headerlink" title="ARM32系列命名"></a>ARM32系列命名</h2><table>
<thead>
<tr>
<th align="center">ARM产品</th>
<th align="center">ARM架构</th>
</tr>
</thead>
<tbody><tr>
<td align="center">ARM7</td>
<td align="center">ARM v4</td>
</tr>
<tr>
<td align="center">ARM9</td>
<td align="center">ARM v5</td>
</tr>
<tr>
<td align="center">ARM11</td>
<td align="center">ARM v6</td>
</tr>
<tr>
<td align="center">Cortex-A</td>
<td align="center">ARM v7-A</td>
</tr>
<tr>
<td align="center">Cortex-R</td>
<td align="center">ARM v7-R</td>
</tr>
<tr>
<td align="center">Cortex-M</td>
<td align="center">ARM v7-M</td>
</tr>
</tbody></table>
<h2 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h2><p>在ARM32中一共有37个寄存器,其中包含16个通用寄存器(R0~R15)和1个状态寄存器 ,15个通用影子寄存器,5个状态影子寄存器</p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20210105183952.png" alt></p>
<h4 id="影子寄存器"><a href="#影子寄存器" class="headerlink" title="影子寄存器"></a>影子寄存器</h4><p>如上图所示,在ARM32中一共有7中不同的处理器模式,分别为:<strong>用户模式</strong>（User）,<strong>快速中断模式</strong>（FIQ）,<strong>普通中断模式</strong>（IRQ）,<strong>管理模式</strong>（Svc）,<strong>数据访问中止模式</strong>（Abort）,<strong>未定义指令中止模式</strong>（Und）,<strong>系统模式</strong>（Sys)</p>
<p> 但是在不同的模式下,同样的一个寄存器名称指向不同的物理寄存器,这些不同的物理寄存器就被称之为影子寄存器</p>
<p>由于这些影子寄存器也属于通用寄存器的范畴, <strong>因此很多人也将ARM32的通用寄存器归纳为31个</strong> </p>
<h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><ol>
<li><p>注释(两种方式)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">; 我是注释</span><br><span class="line"></span><br><span class="line">/*…我是注释..*/</span><br></pre></td></tr></table></figure>
</li>
<li><p>声明一个代码段</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> 	AREA test, CODE	 ;声明一个代码段,段的名称为test(名称可自定义),CODE关键字大小写都可,为了区分,一般大写</span><br><span class="line">   </span><br><span class="line">;=========在此编写汇编代码==========</span><br><span class="line"></span><br><span class="line">   END			;END表示编译结束标记</span><br><span class="line">   </span><br><span class="line">   </span><br><span class="line">   ;段的声明需要以制表符开头,前面留出空</span><br></pre></td></tr></table></figure>
</li>
<li><p>数据表示</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mov R0,#13 ;将十进制13赋值给R0寄存器</span><br><span class="line"></span><br><span class="line">mov R0,#0x13 ;将十六进制0x13赋值给R0寄存器</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">mov R0,#8_12 ;将8进制数12赋值给R0寄存器  N进制则为#N_xxx</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">mov R0,#&apos;a&apos; ;将字符a对应的ascii码值传送给R0寄存器</span><br></pre></td></tr></table></figure>
</li>
<li><p>函数声明和调用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">  	AREA test, CODE</span><br><span class="line">  	</span><br><span class="line">  	</span><br><span class="line">	bl print ;函数调用 </span><br><span class="line"></span><br><span class="line">print ;函数名称</span><br><span class="line">	mov R3,#5</span><br><span class="line"> 	bx lr</span><br><span class="line">    END			;END表示编译结束标记</span><br></pre></td></tr></table></figure>


</li>
</ol>
<ol start="5">
<li><p>声明一个数据段</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">AREA da, DATA	 ;声明一个数据段 默认可读可写状态</span><br><span class="line"> 	;数据定义伪操作</span><br></pre></td></tr></table></figure>


</li>
</ol>
<ol start="6">
<li><p>数据定义</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># DCB   </span><br><span class="line">Str DCB &quot;This is a test！&quot; ;分配一片连续的字节存储单元并初始化。取名为Str 类似于8086中的db</span><br><span class="line">Str = &quot;This is a test！&quot;   ;DCB也可用等号代替</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#DCW</span><br><span class="line">Str DCW 1,2,3 ;定义字型数据 每个字符占用2个字节的空间</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#DCD</span><br><span class="line">Str DCD 1,2,3 ;定义半字型数据 每个字符占用4个字节的空间</span><br></pre></td></tr></table></figure>

<blockquote>
<p>字符串必须使用DCB进行定义</p>
</blockquote>
</li>
<li><p>分配一块连续的内存空间</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sp1 SPACE 100 ;分配一块连续100个字节的空间</span><br><span class="line">   </span><br><span class="line">   ;或者使用%代替SPACE简写</span><br><span class="line">   sp1 % 100 ;分配一块连续100个字节的空间</span><br></pre></td></tr></table></figure>






</li>
</ol>
<h2 id="代码编写规范"><a href="#代码编写规范" class="headerlink" title="代码编写规范"></a>代码编写规范</h2><ol>
<li>所有指令和伪指令不允许顶格</li>
<li>所有变量和标签必须顶格</li>
<li>一般我们将伪指令大写,变量和标签小写</li>
</ol>
<h2 id="内存数据的读写"><a href="#内存数据的读写" class="headerlink" title="内存数据的读写"></a>内存数据的读写</h2><ol>
<li><p>从内存中读取数据</p>
<p><strong>使用中括号表示通过地址取值</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">LDR R0,[R1]               ;将内存地址为R1的字数据读入寄存器R0。</span><br><span class="line">LDR R0,[R1,R2]       ;将内存地址为R1+R2的字数据读入寄存器R0。</span><br><span class="line"></span><br><span class="line">LDR R0,[R1,#8]        ;将内存地址为R1+8的字数据读入寄存器R0。</span><br><span class="line">LDR R0,[R1,R2]!    ;将内存地址为R1+R2的字数据读入寄存器R0,并将新地 址R1＋R2写入R1。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">LDR R0,[R1,＃8]!   ;将内存地址为R1+8的字数据读入寄存器R0,并将新地址 R1＋8写入R1。</span><br><span class="line"></span><br><span class="line">LDR R0,[R1],R2        ;将内存地址为R1的字数据读入寄存器R0,并将新地址 R1＋R2写入R1。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">LDR R0,[R1,R2,LSL＃2]!   ;将内存地址为R1＋R2×4的字数据读入寄存器R0,并将新地址R1＋R2×4写入R1。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">LDR R0,[R1],R2,LSL＃2      ;将内存地址为R1的字数据读入 寄存器R0,并将新地址R1＋R2×4写入R1。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">;从标号即为地址</span><br><span class="line">   LDR R0,label ;将标号对应的内容赋值给R0</span><br></pre></td></tr></table></figure>

</li>
</ol>
<blockquote>
<p>复杂格式如LDR R0,[R1],R2,LSL＃2    其中 []运算优先<br>2. 向内存中写入数据<br>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">STR R0,[R1],＃8           ;将R0中的字数据写入以R1为地址的内存中,并 将新地址R1＋8写入R1。</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> STR R0,[R1,＃8]          ;将R0中的字数据写入以R1＋8为地址的内存中。</span><br><span class="line"> </span><br><span class="line"> STRB    R0,[R1]             ;将寄存器R0中的字节数据写入以R1为地 址的内存中。</span><br><span class="line"> STRB    R0,[R1,＃8]     ;将寄存器R0中的字节数据写入以R1＋8为地址的存 储器中。  </span><br><span class="line"> STR R0,[R1],＃8           ;将R0中的字数据写入以R1为地址的内存中,并 将新地址R1＋8写入R1。</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> STR R0,[R1,＃8]          ;将R0中的字数据写入以R1＋8为地址的内存中。</span><br><span class="line"> </span><br><span class="line"> STRB    R0,[R1]             ;将寄存器R0中的字节数据写入以R1为地 址的内存中。</span><br><span class="line"> STRB    R0,[R1,＃8]     ;将寄存器R0中的字节数据写入以R1＋8为地址的存 储器中。</span><br></pre></td></tr></table></figure></p>
</blockquote>
<h2 id="LDR伪指令"><a href="#LDR伪指令" class="headerlink" title="LDR伪指令"></a>LDR伪指令</h2><p>这个指令和内存读取指令长的一模一样,如果我们在使用的时候加个等号,那么它就是另外一个指令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">;如果不加等号 是内存读取功能</span><br><span class="line">LDR R0,label ;获取标签所对应的内存数据赋给R0  </span><br><span class="line"></span><br><span class="line">;一旦加了等号,则变成了传送指令</span><br><span class="line">LDR R0,=label ;将标号对应的实际物理地址值赋值给R0 此时它的作用和mov无异</span><br><span class="line">LDR R0,=&apos;a&apos; ;直接将字符数据传送给R0</span><br></pre></td></tr></table></figure>

<p>实际上,加了等号的<code>LDR</code>指令,刚好可以弥补<code>mov</code>指令的不足, <code>mov</code>指令只能传送由八个二进制位右移而得的数据,而<code>LDR</code>则没有这个限制</p>
<p>也就是说如果我们想将一个数值传入寄存器,可以有两种方式:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">;第一种</span><br><span class="line">mov R1,#0X100</span><br><span class="line"></span><br><span class="line">;第二种</span><br><span class="line">ldr R1,=0x100 </span><br><span class="line"></span><br><span class="line">;mov指令的限制:只能传送由八个二进制位右移而得的数据, 也就相当于是两个十六进制数据,由于可以不断移位那么数据的大小可以伸缩,比如以下数据都可使用mov指令</span><br><span class="line">0x00000058  0x00000580 0x00005800  0x00058000 0x00580000 0x05800000 0x58000000 </span><br><span class="line">;我们发现一个规律:mov指令只能传送最大两个十六进制空间的数据,注意是空间,这两个数据随意你移动,一旦不满足这个条件则无法传送,比如</span><br><span class="line">0x00000581</span><br></pre></td></tr></table></figure>

<h4 id="LDR伪指令总结"><a href="#LDR伪指令总结" class="headerlink" title="LDR伪指令总结"></a>LDR伪指令总结</h4><p>作用:</p>
<ul>
<li>弥补mov指令的不足</li>
<li>获取数据所对应的内存地址</li>
</ul>
<h4 id="ADR指令"><a href="#ADR指令" class="headerlink" title="ADR指令"></a>ADR指令</h4><p>那么除了通过<code>LDR</code>伪指令来获取数据所在地址外还有一个指令也可以获取数据地址,那就是<code>adr</code>指令,但这个指令只能获取当前段内数据的地址,段外数据无法获取,<code>ldr</code>则没有这个限制</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">	AREA test2,CODE</span><br><span class="line">		mov R3,#8</span><br><span class="line">aaaa dcb 1,2,3</span><br><span class="line">		adr R0,aaaa ;获取aaaa首地址</span><br><span class="line">  	END</span><br></pre></td></tr></table></figure>

<h2 id="段的拓展"><a href="#段的拓展" class="headerlink" title="段的拓展"></a>段的拓展</h2><p> <strong>段属性拓展</strong></p>
<ol>
<li><strong>段读写属性</strong></li>
</ol>
<ul>
<li><p>READONLY</p>
<p>该段内存区域数据只能读取,不能写入,也就是如果使用内存读写指令,数据也写入不了</p>
</li>
<li><p>READWRITE</p>
<p>该段内存区域可读可写,不仅可以使用内存读写指令,还可以在调试的时候直接在memory窗口双击修改</p>
</li>
</ul>
<p>示例:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">AREA code, CODE,READWRITE ;将代码段内存区域设置为可读可写状态,如果不写默认为只读</span><br><span class="line">AREA code, DATA,READONLY ;将数据段内存区域设置为只读状态,如果不写默认为可读可写</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p><strong>段对齐属性 ALIGN</strong> </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AREA code, DATA,ALIGN=3  ;对齐数值范围为0~31</span><br></pre></td></tr></table></figure>

<p>该属性会使得该段的基地址进行相应的偏移,<code>ALIGN=3</code>表示基地址会在上一个段数据的基础之上偏移2^3=8个字节的位置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">   	 AREA test1,DATA  ;假设这个段的基地址为0x00000100</span><br><span class="line">STR1 = &quot;A&quot;  </span><br><span class="line"></span><br><span class="line">	 AREA test2,DATA   ;ALIGN默认为2 那么这个段的基地址为0x00000104</span><br><span class="line">STR2 = &quot;B&quot;</span><br><span class="line"></span><br><span class="line">	 AREA test3,DATA,ALIGN=8   ;这个段的基地址为0x0000010C</span><br><span class="line">STR2 = &quot;B&quot;</span><br></pre></td></tr></table></figure>

<p>我们可以简单理解为,使用ALIGN这个属性可以让我们给上一个段预留除一部分缓冲区域,以ALIGN=2为例,当上一个段中的数据超过4个字节时,当前段基地器会向后再偏移4个字节,避免数据被覆盖,也就是说内存数据位置会进行重新分布,那么我们可以通过这个值来设置内存数据刷新频率,<strong>值越低,内存利用率越高,但是内存刷新频率也越高,负荷加重,反之,内存浪费越大,但是内存数据不需要频繁重新分布</strong></p>
<p><strong>另外:</strong></p>
<p>除了在段属性中可以设置对齐之外,在指令中也可以插入ALGIN关键字:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">AREA code,CODE	   </span><br><span class="line">   </span><br><span class="line">   mov R0,R1</span><br><span class="line"></span><br><span class="line">	ALIGN 4,3  ;下一条指令4字节对齐,并且偏移3个字节 为了补满4个字节,用0填充剩余1个未偏移位置</span><br><span class="line">	mov R2,R0</span><br><span class="line">   </span><br><span class="line">END</span><br></pre></td></tr></table></figure>


</li>
</ol>
<p>   代码中使用AGLIN时用空格代替等号,同时单位为字节</p>
<p><strong>多个代码段入口区分</strong></p>
<p>当我们在同一个源文件中定义两个代码段时,程序从哪个段当做执行入口呢?</p>
<p>这个时候我们需要指定程序的入口,使用伪指令<code>entry</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> AREA test2,CODE </span><br><span class="line"></span><br><span class="line"> 	 	mov R0,#7</span><br><span class="line"></span><br><span class="line">  AREA test3,CODE </span><br><span class="line">entry  ;程序入口</span><br><span class="line">mov R0,#6</span><br><span class="line">mov R1,#0x00000100</span><br><span class="line">str R0,[R1]</span><br><span class="line">END</span><br></pre></td></tr></table></figure>

<h2 id="栈的操作"><a href="#栈的操作" class="headerlink" title="栈的操作"></a>栈的操作</h2><ol>
<li><strong>入栈</strong></li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">push &#123;R0&#125;  ;将R0中的值存入栈内存中  相当于是STR R0,[R13,#-4]</span><br><span class="line"></span><br><span class="line">入栈过程:</span><br><span class="line">* 第一步:将栈顶指针往低地址偏移四个字节</span><br><span class="line">* 第二步:将数据存入指针指向的内存空间</span><br></pre></td></tr></table></figure>

<ol>
<li><strong>出栈</strong></li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pop &#123;R0&#125;  ;将栈顶中的值取出存入R0寄存器 相当于是LDR R0,[R13],#0x0004</span><br><span class="line"></span><br><span class="line">出栈过程:</span><br><span class="line">* 第一步:将栈顶指针指向的内容取出存入寄存器</span><br><span class="line">* 第二步:将指针往高地址恢复四个字节</span><br></pre></td></tr></table></figure>

<blockquote>
<p>pop和push 本质上使用的是LDR和STR内存读写指令</p>
</blockquote>
<h4 id="对栈批量操作"><a href="#对栈批量操作" class="headerlink" title="对栈批量操作"></a>对栈批量操作</h4><p>如果想批量操作多个连续栈空间的话,直接使用逗号分隔开,连续标号的寄存器使用横杠分隔</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">push &#123;R0,R4-R12,LR&#125; ;大括号中寄存器从右往左LR R12...R4 R0依次存入</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">pop &#123;R0,R4-R12,PC&#125; ;从左往右取出</span><br></pre></td></tr></table></figure>

<p>除了使用<code>pop</code>和<code>push</code>之外,可以使用<code>STM</code>(store much)和<code>LDM</code>(load much)指令</p>
<p>格式:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">STM 起始地址/基地址寄存器,&#123;寄存器名称,多个寄存器以逗号或者-分割&#125; ;起始地址寄存器R0-R14任意选择</span><br></pre></td></tr></table></figure>

<p>示例:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">STMFD  R13!,&#123;R0,R4-R12,LR&#125;    ;将寄存器列表中的寄存器（R0,R4到 R12,LR）存入栈,。</span><br><span class="line">等价于</span><br><span class="line">push &#123;R0,R4-R12,LR&#125; ;大括号中寄存器从右往左存入</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">LDMFD  R13!,&#123;R0,R4-R12,PC&#125;     ;将栈内容恢复到寄存器（R0,R4到R12,LR）。           </span><br><span class="line">等价于</span><br><span class="line">pop &#123;R0,R4-R12,PC&#125; ;从左往右取出</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>pop</code>和<code>push</code>,它们内部也是转成<code>STM</code>和<code>LDM</code>指令:</p>
</blockquote>
<h4 id="批量存取指令扩展"><a href="#批量存取指令扩展" class="headerlink" title="批量存取指令扩展"></a>批量存取指令扩展</h4><p>相关后缀含义:</p>
<ul>
<li><strong>IA:（Increase After）</strong>:数据操作后基地址增4</li>
<li><strong>IB:（Increase Before）</strong>:数据操作前基地址增4</li>
<li><strong>DA:（Decrease After</strong>）:数据操作后基地址减4</li>
<li><strong>DB：（Decrease Before）</strong>:数据操作前基地址减4</li>
<li><strong>FD:</strong>  满递减堆栈 (相当于STMDB+LDMIA)</li>
<li><strong>FA:</strong>  满递增堆栈 (相当于STMIB+LDMDA)</li>
<li><strong>ED:</strong>  空递减堆栈(相当于STMDA+LDMIB)</li>
<li><strong>EA:</strong>  空递增堆栈 (相当于STMIA+LDMDB)</li>
</ul>
<blockquote>
<p>我们在使用的时候,要么使用结合的形式比如STMDB+LDMIA,要么直接使用封装形式比如STMFD+LDMFD</p>
</blockquote>
<h4 id="满栈和空栈"><a href="#满栈和空栈" class="headerlink" title="满栈和空栈"></a>满栈和空栈</h4><p>栈的生长方式可以有四种: <strong>满增栈、满减栈、空增栈、空减栈</strong> </p>
<ul>
<li><strong>满栈（full stack）</strong>：栈指针指向下一个将要取出数据的位置,数据入栈时,栈顶指针先偏移再入栈,数据出栈是,先取数据,后指针偏移。</li>
<li><strong>空栈（empty stack）</strong>：栈指针指向下一个将要放入数据的位置,数据入栈时,先存数据后指针偏移,数据出栈时,先指针偏移,后数据取出</li>
<li><strong>递增堆栈(ascending stack)</strong>：堆栈由低地址向高地址生长。</li>
<li><strong>递减堆栈(secending stack)</strong>：堆栈由高地址向低地址生长。</li>
</ul>
<blockquote>
<p>X86和mips架构都是采用满递减堆栈方式处理栈空间,ARM架构四种方式均支持</p>
</blockquote>
<p><strong>内存批量读写示例:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mov  R1,#4</span><br><span class="line">mov  R2,#5</span><br><span class="line">mov  R0,#0x00000008</span><br><span class="line">stm  R0,&#123;R1,R2&#125; </span><br><span class="line">;以上四行代码表示 从0x00000008这个内存地址开始 将R1和R2中的数据依次存入</span><br></pre></td></tr></table></figure>

<p>如果我想在上面的基础上再往后追加数据</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov  R1,#6</span><br><span class="line">mov  R2,#7</span><br><span class="line">stm  R0,&#123;R1,R2&#125;</span><br></pre></td></tr></table></figure>

<p> 我们发现数据并没有追加,而是被覆盖了,因为<code>R0</code>的值依然还是 <code>0x00000008</code>,这个时候我们需要使用扩展指令,如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mov  R1,#4</span><br><span class="line">mov  R2,#5</span><br><span class="line">mov  R0,#0x00000008</span><br><span class="line">STMIA  R0!,&#123;R1,R2&#125; ;只有在寄存器后加上!才能修改寄存器中的值</span><br><span class="line"></span><br><span class="line">mov  R1,#6</span><br><span class="line">mov  R2,#7</span><br><span class="line">stm  R0,&#123;R1,R2&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>事实上 STM指令如果不加后缀写法,默认使用的是STMIA指令,LDM指令默认使用LDMIA</p>
</blockquote>
<h4 id="多寄存器数据存放顺序"><a href="#多寄存器数据存放顺序" class="headerlink" title="多寄存器数据存放顺序"></a>多寄存器数据存放顺序</h4><p>不管使用哪种扩展指令,皆为左低右高的形式,也就是左边的寄存器数据存放在低地址,右边的存放在高地址</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">STMIA  R0!,&#123;R1,R2&#125; ;左边R1的内容放低地址,右边R2的内容放高地址</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">LDMDB   R0!,&#123;R1,R2&#125; ;高地址数据放入R2,低地址数据放入R1</span><br></pre></td></tr></table></figure>

<h2 id="宏"><a href="#宏" class="headerlink" title="宏"></a>宏</h2><ol>
<li><p><strong>宏匹配</strong></p>
<ul>
<li>语法格式</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">MACRO</span><br><span class="line">$label macroname $param</span><br><span class="line">;指令序列   </span><br><span class="line">MEND  </span><br><span class="line"></span><br><span class="line">;例如声明一个宏名为print的宏语句</span><br><span class="line">MACRO</span><br><span class="line">$label print $param   ;带$的表示会被替换的内容</span><br><span class="line"> ;这里写相关汇编代码</span><br><span class="line">MEND</span><br></pre></td></tr></table></figure>

<ul>
<li>使用</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> MACRO</span><br><span class="line">  $label putR0 $param  </span><br><span class="line">  </span><br><span class="line">  mov R0,$param</span><br><span class="line">   </span><br><span class="line"> MEND   </span><br><span class="line"> </span><br><span class="line">; 使用</span><br><span class="line">putR0 #10</span><br></pre></td></tr></table></figure>


</li>
</ol>
<ul>
<li>延伸</li>
</ul>
<p>第一个<code>$label</code>是干嘛用的呢,由于宏的内部处理方式的替换,为了避免标签名称的冲突,增加一个标识</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">;假如我要在宏匹配中定义一个函数fun, 当我调用两次的时候,会出现函数名重复的问题</span><br><span class="line">	MACRO</span><br><span class="line">    $label putR0 $param  </span><br><span class="line">   fun</span><br><span class="line">    mov R0,$param</span><br><span class="line">     </span><br><span class="line">   MEND   </span><br><span class="line">   </span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"> putR0 #10</span><br><span class="line"> putR0 #10</span><br><span class="line"> </span><br><span class="line"> ;那么如果要解决这个问题的话,我可以利用第一个替换参数如下:</span><br><span class="line"> 	MACRO</span><br><span class="line">$label putR0 $param  </span><br><span class="line">$label</span><br><span class="line">    mov R0,$param</span><br><span class="line">     </span><br><span class="line">   MEND   </span><br><span class="line">   </span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">fun1 putR0 #10  ;函数名为fun1</span><br><span class="line">fun2 putR0 #10  ;函数名为fun2</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p><strong>宏定义</strong></p>
<ul>
<li><strong>全局宏</strong>的定义,可跨段访问 </li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">;全局数字变量</span><br><span class="line">GBLA number </span><br><span class="line">number SETA 0Xaa  </span><br><span class="line"></span><br><span class="line">;全局逻辑变量</span><br><span class="line">GBLL flag </span><br><span class="line">flag SETL &#123;TRUE&#125;  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">;全局字符串变量</span><br><span class="line">GBLS str </span><br><span class="line">str SETS &quot;hello world&quot;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>局部宏</strong>的定义,只能在当前宏内被访问</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">;局部数字变量</span><br><span class="line">LCLA number </span><br><span class="line">number SETA 0Xaa  </span><br><span class="line"></span><br><span class="line">;局部逻辑变量</span><br><span class="line">LCLL flag </span><br><span class="line">flag SETL &#123;TRUE&#125;  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">;局部字符串变量</span><br><span class="line">LCLS str </span><br><span class="line">str SETS &quot;hello world&quot;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>全局常量的定义</strong></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">num   EQU      10  ;关键字EQU  数据不允许修改</span><br></pre></td></tr></table></figure>




</li>
</ol>
<ol start="3">
<li><p>宏定义示例</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">;定义一个全局整型数据宏</span><br><span class="line">GBLA number </span><br><span class="line">number SETA 0Xaa  </span><br><span class="line"></span><br><span class="line">;使用</span><br><span class="line">mov R0,#number ;相当于mov R0,#0Xaa</span><br><span class="line">LDR R0,=number ;相当于LDR R0,=0Xaa</span><br></pre></td></tr></table></figure>

<p> 局部宏数据</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">MACRO ;声明一个宏</span><br><span class="line">$label    message  $a ;取名为message 参数为$a</span><br><span class="line"></span><br><span class="line">;定义宏内局部变量</span><br><span class="line">LCLA    number </span><br><span class="line">number SETA $a</span><br><span class="line"></span><br><span class="line">mov R0,#number</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">MEND ;宏结束,局部变量不再起作用</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">message 10 ;直接调用</span><br></pre></td></tr></table></figure>

<p> 常量数据</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">	AREA data ,DATA</span><br><span class="line">num   EQU      10 </span><br><span class="line">	AREA code ,CODE</span><br><span class="line"></span><br><span class="line">	mov R1,#5</span><br><span class="line">	ldr R1,=num</span><br><span class="line"></span><br><span class="line">	END</span><br></pre></td></tr></table></figure>

</li>
</ol>
<blockquote>
<p>宏匹配和宏定义需要遵循先定义后使用的原则</p>
<p>如果需要从宏中跳出,可以使用伪指令MEXIT</p>
</blockquote>
<ol start="3">
<li><p><strong>宏替换</strong></p>
<p>使用<code>include</code>或者<code>get</code>伪指令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">   ;使用get伪指令</span><br><span class="line">   AREA code, CODE</span><br><span class="line">GET pangshu.s         ;通知编译器当前源文件包含源文件 softool.s</span><br><span class="line">   GET C:\pp.s           ;通知编译器当前源文件包含源文件 C:\cn.s</span><br><span class="line">   END</span><br><span class="line">   </span><br><span class="line">   ;使用include伪指令</span><br><span class="line">   AREA code, CODE</span><br><span class="line">   include pangshu.s         ;通知编译器当前源文件包含源文件 softool.s</span><br><span class="line">   include C:\pp.s           ;通知编译器当前源文件包含源文件 C:\cn.s</span><br><span class="line">   END</span><br></pre></td></tr></table></figure>




</li>
</ol>
<h2 id="指令学习"><a href="#指令学习" class="headerlink" title="指令学习"></a>指令学习</h2><h4 id="传送指令"><a href="#传送指令" class="headerlink" title="传送指令"></a>传送指令</h4><ol>
<li><p>正常传送指令<code>mov</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov R0,#4 ;将4传送至R0寄存器</span><br></pre></td></tr></table></figure>
</li>
<li><p>取反传送指令<code>mvn</code>,也叫<strong>数据非传送指令</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn R0,#4 ;将4取反后传送至R0寄存器  0100取反为1011</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h4 id="转移指令"><a href="#转移指令" class="headerlink" title="转移指令"></a>转移指令</h4><ol>
<li><strong>B指令</strong></li>
</ol>
<p>直接跳转,仅更改PC寄存器的值</p>
<p>示例:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">B 0x00040000 ;直接跳转到物理地址0x00040000读取指令并执行</span><br><span class="line"></span><br><span class="line">B 标号  ;直接跳转到标号处</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><strong>BL指令</strong></li>
</ol>
<p>跳转并链接,除了更改PC寄存器的值之外,还会将下一条指令所对应的物理地址存放至<code>lr</code>寄存器中</p>
<p>示例:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">BL 0x00040000</span><br><span class="line">mov r1,3  ;假设这行指令对应物理地址为0x0040004, 那么BL一旦执行,会将该值存入lr寄存器</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">或者</span><br><span class="line">BL 标号</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><p><strong>BX指令</strong></p>
<p>跳转并切换状态</p>
<p><strong>BX指令后面只能跟寄存器</strong>,弥补了B指令和BL指令的不足, 同时会根据寄存器中最低比特位值切换ARM/Thumb模式 </p>
</li>
</ol>
<p>示例:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">BL print</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">print</span><br><span class="line">	mov r1,#1</span><br><span class="line">	BX lr  ;函数返回     如果R0[0]=1,则进入Thumb状态 反之进入ARM模式</span><br></pre></td></tr></table></figure>

<p>除了通过指令来更改PC寄存器值之外,在ARM32中还可以<strong>直接使用传送指令对PC寄存器进行赋值</strong>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov pc,#0x00000008  ;往pc寄存器中写入一个地址值</span><br><span class="line"></span><br><span class="line">mov R0,pc  ;获取pc寄存器中的值</span><br></pre></td></tr></table></figure>

<ol start="4">
<li><p><strong>BLX指令</strong></p>
<p>该指令将以下功能集于一身</p>
<ul>
<li>更改PC寄存器的值</li>
<li>将下一条指令的地址存入lr寄存器</li>
<li>根据寄存器中最低比特位值切换ARM/Thumb模式 </li>
</ul>
</li>
</ol>
<h4 id="算术和逻辑运算指令"><a href="#算术和逻辑运算指令" class="headerlink" title="算术和逻辑运算指令"></a>算术和逻辑运算指令</h4><ol>
<li><p>算术运算</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">add R0,#5</span><br><span class="line">add R0,R1 ;加法 </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sub R0,#5</span><br><span class="line">sub R0,R1 ;减法 </span><br><span class="line"></span><br><span class="line">mul R0,R1,R2 ;乘法指令, 这里至少三个寄存器参与</span><br><span class="line"></span><br><span class="line">mla R0,R1,R2,R3  ;先乘后加      R0 = R1 × R2 + R3</span><br></pre></td></tr></table></figure>
</li>
<li><p>逻辑运算</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">and R0.#3</span><br><span class="line">and R0,R0 ;逻辑与</span><br><span class="line"></span><br><span class="line">orr R0.#3</span><br><span class="line">orr R0,R0 ;逻辑或</span><br><span class="line"></span><br><span class="line">eor R0.#3</span><br><span class="line">eor R0,R0 ;逻辑异或</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h4 id="移位指令"><a href="#移位指令" class="headerlink" title="移位指令"></a>移位指令</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MOV   R0, R1, LSL#2    ;将R1中的内容左移两位后传送到R0中。</span><br><span class="line"></span><br><span class="line">MOV   R0, R1, LSR#2    ;将R1中的内容右移两位后传送到R0中,左端用零来填充。</span><br></pre></td></tr></table></figure>

<h4 id="比较指令"><a href="#比较指令" class="headerlink" title="比较指令"></a>比较指令</h4><ol>
<li><p>比较两个值是否相等</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">cmp R0,R1 </span><br><span class="line">beq sub ;如果两个寄存器中的值相等则跳转到sub函数中,否则继续往下执行</span><br><span class="line"></span><br><span class="line">sub</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">cmp R0,#5</span><br><span class="line">bne sub ;如果两个值不相等,跳转到sub函数,否则继续往下执行</span><br><span class="line"></span><br><span class="line">sub</span><br></pre></td></tr></table></figure>
</li>
<li><p>大于和小于(带符号)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">;大于</span><br><span class="line">cmp R0,R1</span><br><span class="line">bgt sub ;如果R0寄存器中的值大于R1,则跳转至sub</span><br><span class="line"></span><br><span class="line">sub</span><br><span class="line"></span><br><span class="line">;小于</span><br><span class="line">cmp R0,R1</span><br><span class="line">blt sub ;如果R0寄存器中的值大于R1,则跳转至sub</span><br><span class="line"></span><br><span class="line">sub</span><br></pre></td></tr></table></figure>



</li>
</ol>
<h2 id="标志寄存器"><a href="#标志寄存器" class="headerlink" title="标志寄存器"></a>标志寄存器</h2><p>试想一下,我们的比较指令<code>cmp</code>,它内部是如何进行数据大小判断的</p>
<p>在高级语言里,直接使用<code>&gt;</code>或者<code>&lt;</code>运算符,来判断两个值的大小,比较结束后返回<code>True</code>或者<code>Flase</code>,可是在汇编语言里面没有这么简便,那它又是如何对两个数据之间大小进行判断的呢？</p>
<p>别忘了, 计算机最擅长做二进制的算术和逻辑运算</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmp R0,R1</span><br></pre></td></tr></table></figure>

<p>要想判断两个数据是否相等,或者大于小于,直接做个减法运算不就完事了,也就是<code>R0-R1</code>,如果结果为0,那么两个值相等,如果结果为正数,则R0&gt;R1,结果为负数,则小于</p>
<p>但是问题来了,这个结果值放在哪里呢？放内存中还是寄存器呢? 答案是：寄存器</p>
<p>cpu设计者为了方便区分专门用了一个寄存器来存放数据运算后的结果,这个寄存器叫做<strong>状态寄存器</strong>,也叫标志寄存器</p>
<p>ARM32中一个寄存器有32二进制位的数据空间,那该怎么存放呢？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">00000000000000000000000000000000  ;32个二进制位</span><br></pre></td></tr></table></figure>

<p>为了方便程序员开发,设计者给这些二进制位进行了相应的命名：</p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20210120151329.png" alt></p>
<p>当两个比较值相等,进行减法运算时,结果为0,那么Z标志位的值为1,也就是</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">01000000000000000000000000000000  ;32个二进制位</span><br></pre></td></tr></table></figure>

<p>如果不相等,结果不为0,那么Z标志位的值变成0</p>
<p>由于每个二进制位只能存0和1两个值,也就是最多只能表示两种状态,那大于和小于的状态表示就得放到另外一个二进制上了,由于二进制运算涉及到有符号和无符号两种情况,因此需要用到两个二进制分别进行处理,有符号的的结果存放在N标志位,无符号的结果存放在C标志位：</p>
<p><code>cmp</code>指令会同时对两个数据进行有符号和无符号运算</p>
<p><strong>有符号运算</strong>,如果结果为正数,N标志位值为0,如果为负数,N标志位值为1</p>
<p><strong>无符号运算</strong>,如果结果为正数,C标志位值为1,如果为负数,C标志位值为0</p>
<p>那么我们在使用<code>cmp</code>指令的时候,到底是根据那个标志位的结果进行判断的呢？</p>
<p>如果我们使用<code>bne</code>指令,那么取Z标志位的值进行参考</p>
<p>如果我们使用<code>blt</code>,<code>bgt</code>,那么取N标志位,Z标志位和V标志位三者的值进行参考</p>
<p>总结：</p>
<ol>
<li><p><code>cmp</code>指令的功能相当于减法指令,只是对操作数之间运算比较,结果间接保存在标志寄存器高位中</p>
</li>
<li><p><code>bne</code>,<code>blt</code>,<code>bgt</code>等这些指令都是通过获取标志寄存器中的值来得知比较结果从而进行相应跳转,不同的指令需要满足不同的条件</p>
</li>
<li><p>我们可以通过改变状态寄存器中的值来改变代码的走向</p>
</li>
</ol>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  AREA test,CODE</span><br><span class="line"></span><br><span class="line">	mov R0,#5</span><br><span class="line">	mov R1,#6</span><br><span class="line">	cmp R0,R1</span><br><span class="line">	;在跳转之前改变状态寄存器的值 使得bgt必然跳转</span><br><span class="line">	MSR cpsr_f ,0x20000000</span><br><span class="line">	BGT fun</span><br><span class="line">	mov R1,#6</span><br><span class="line"></span><br><span class="line">fun</span><br><span class="line">	mov R0,#4</span><br><span class="line">	bx lr</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  END</span><br></pre></td></tr></table></figure>

<p>知识扩展：</p>
<ol>
<li><p>状态寄存器的读取和写入</p>
<p>读取指令:<strong>MRS</strong>{mov to register from special register）</p>
<p>写入指令: <strong>MSR</strong>(Move to Special register from Register )</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 读取状态寄存器中的值</span><br><span class="line">mrs R0,cpsr  ;将值读取到R0寄存器</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#修改状态寄存器中的值</span><br><span class="line">msr cpsr_c,#0x2d ;修改控制位区域</span><br><span class="line">msr cpsr_x,#0x2d00 ;修改扩展位区域</span><br><span class="line">msr cpsr_s,#0x2d0000 ;修改状态位区域</span><br><span class="line">msr cpsr_f,#0x2d000000 ;修改标志位区域</span><br><span class="line"></span><br><span class="line">#修改状态寄存器高位值时,低位必须补足0,虽然加了0但是不会影响其他区域的值</span><br></pre></td></tr></table></figure>
</li>
<li><p>状态寄存器中各个区域具体描述</p>
<p>一共分位四个大区域,从低到高分别为：<strong>控制位区域</strong>, <strong>扩展位区域,</strong> <strong>状态位区域</strong>, <strong>标志位区域</strong>,每个区域各占8个二进制位的空间</p>
<p>以下是<strong>控制位区域</strong>细分详解图：</p>
</li>
</ol>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20210120151619.png" alt> </p>
<ol start="3">
<li>比较指令标志位条件参考表</li>
</ol>
<table>
<thead>
<tr>
<th align="center">指令</th>
<th align="center">含义</th>
<th align="center">需要满足的条件</th>
</tr>
</thead>
<tbody><tr>
<td align="center">beq</td>
<td align="center">相等</td>
<td align="center">Z标志位为1</td>
</tr>
<tr>
<td align="center">bne</td>
<td align="center">不相等</td>
<td align="center">Z标志位为0</td>
</tr>
<tr>
<td align="center">bgt</td>
<td align="center">带符号大于</td>
<td align="center">Z标志位为0，且N和V标志位值相等</td>
</tr>
<tr>
<td align="center">blt</td>
<td align="center">带符号小于</td>
<td align="center">N不等于V</td>
</tr>
<tr>
<td align="center">bge</td>
<td align="center">带符号大于等于</td>
<td align="center">N等于V</td>
</tr>
<tr>
<td align="center">ble</td>
<td align="center">带符号小于等于</td>
<td align="center">Z标志位为1或者N不等于V</td>
</tr>
<tr>
<td align="center">bls</td>
<td align="center">无符号小于等于</td>
<td align="center">Z标志位为1且C标志位为0</td>
</tr>
<tr>
<td align="center">bhi</td>
<td align="center">无符号大于</td>
<td align="center">Z标志位为0且C标志位为1</td>
</tr>
<tr>
<td align="center">bcs</td>
<td align="center">无符号大于等于</td>
<td align="center">C标志位为1</td>
</tr>
<tr>
<td align="center">bhs</td>
<td align="center">无符号大于等于</td>
<td align="center">C标志位为1</td>
</tr>
<tr>
<td align="center">bcc</td>
<td align="center">无符号小于</td>
<td align="center">C标志位为0</td>
</tr>
<tr>
<td align="center">blo</td>
<td align="center">无符号小于</td>
<td align="center">C标志位为0</td>
</tr>
<tr>
<td align="center">bmi</td>
<td align="center">负数</td>
<td align="center">N标志位为1</td>
</tr>
<tr>
<td align="center">bpl</td>
<td align="center">正数或零</td>
<td align="center">N标志位为0</td>
</tr>
<tr>
<td align="center">bvs</td>
<td align="center">溢出</td>
<td align="center">V标志位为1</td>
</tr>
<tr>
<td align="center">bvc</td>
<td align="center">未溢出</td>
<td align="center">V标志位为0</td>
</tr>
<tr>
<td align="center">bnv</td>
<td align="center">无条件执行</td>
<td align="center">忽略</td>
</tr>
<tr>
<td align="center">bal</td>
<td align="center">无条件执行</td>
<td align="center">忽略</td>
</tr>
</tbody></table>
<h2 id="条件和循环伪指令"><a href="#条件和循环伪指令" class="headerlink" title="条件和循环伪指令"></a>条件和循环伪指令</h2><p>   IF、ELSE 和 ENDIF</p>
<ul>
<li><p>根据条件的成立与否决定是否执行某个程序段</p>
</li>
<li><p>IF、ELSE、ENDIF 伪指令可以嵌套使用</p>
</li>
<li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">GBLL Test ;声明一个全局逻辑变量Test</span><br><span class="line">Test SETL &#123;TRUE&#125; </span><br><span class="line"></span><br><span class="line">IF Test = &#123;TRUE&#125;</span><br><span class="line"> 程序段1 </span><br><span class="line">ELSE</span><br><span class="line"> 程序段2</span><br><span class="line">ENDIF</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="WHILE-和-WEND"><a href="#WHILE-和-WEND" class="headerlink" title="WHILE 和 WEND"></a>WHILE 和 WEND</h4><ul>
<li><p>根据条件的成立与否决定是否重复汇编一个程序段</p>
</li>
<li><p>若 WHILE 后面的逻辑表达式为真,则重复汇编该程序段,直到逻辑表达式为假</p>
</li>
<li><p>WHILE 和 WEND 伪指令可以嵌套使用</p>
</li>
<li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">GBLA Counter  ;声明一个全局数字变量Counter</span><br><span class="line">Counter SETA 3    ;赋值</span><br><span class="line">...</span><br><span class="line">WHILE Counter &lt; 10</span><br><span class="line">程序段</span><br><span class="line">WEND</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="汇编语言和C语言交互"><a href="#汇编语言和C语言交互" class="headerlink" title="汇编语言和C语言交互"></a>汇编语言和C语言交互</h2><ul>
<li>内嵌汇编</li>
<li>外链汇编</li>
</ul>
<h4 id="1-引入其他源文件函数"><a href="#1-引入其他源文件函数" class="headerlink" title="1.引入其他源文件函数"></a>1.引入其他源文件函数</h4><p>使用<code>import</code>或者<code>extern</code>伪指令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">;使用import伪指令</span><br><span class="line">AREA code, CODE</span><br><span class="line">import fun1 ;导入其他源文件中名为fun1的函数</span><br><span class="line">END</span><br><span class="line"></span><br><span class="line">;使用extern伪指令</span><br><span class="line">AREA code, CODE</span><br><span class="line">extern fun1       </span><br><span class="line">END</span><br></pre></td></tr></table></figure>

<p><strong>两者区别:</strong></p>
<ul>
<li><code>import</code>:不管当前文件是否使用该引入的函数,该标签都会加入当前文件符号表,即为静态引用</li>
<li><code>extern</code>:只有当前文件使用了该函数,才会将此标签加入符号表,即为动态引用</li>
</ul>
<h4 id="2-导出当前源文件中函数供其他文件访问"><a href="#2-导出当前源文件中函数供其他文件访问" class="headerlink" title="2.导出当前源文件中函数供其他文件访问"></a>2.导出当前源文件中函数供其他文件访问</h4><p>使用<code>export</code>或者<code>global</code>伪指令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">;使用import伪指令</span><br><span class="line">AREA code, CODE</span><br><span class="line">export fun         ;导出fun函数供其他源文件使用</span><br><span class="line"></span><br><span class="line">fun </span><br><span class="line">	mov R0,#4</span><br><span class="line">	bx lr</span><br><span class="line">END</span><br></pre></td></tr></table></figure>

<h4 id="3-外链汇编之C语言调汇编函数"><a href="#3-外链汇编之C语言调汇编函数" class="headerlink" title="3.外链汇编之C语言调汇编函数"></a>3.外链汇编之C语言调汇编函数</h4><p>第一步,在汇编原文件中将函数暴露出来给供外部调用,使用<code>export</code>或者<code>global</code>伪指令:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">AREA code, CODE</span><br><span class="line">export arm_strcpy  ;或者使用global</span><br><span class="line"></span><br><span class="line">arm_strcpy</span><br><span class="line">loop </span><br><span class="line">	ldrb R4,[R0],#1 ;如果使用ldr 那么将偏移值改成4</span><br><span class="line">	cmp R4,#0</span><br><span class="line">	beq over</span><br><span class="line">	strb R4,[R1],#1</span><br><span class="line">	b loop</span><br><span class="line">over	</span><br><span class="line">END</span><br></pre></td></tr></table></figure>

<p>第二步,在C文件中引用汇编中的函数,C文件中只能使用<code>extern</code>伪指令:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">extern arm_strcpy(char *src,char*des);</span><br><span class="line"></span><br><span class="line">int main2()&#123;</span><br><span class="line">	char *a=&quot;hello pangshu&quot;;</span><br><span class="line">	char b[64];</span><br><span class="line">	arm_strcpy(a,b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-外链汇编之汇编调c语言函数"><a href="#4-外链汇编之汇编调c语言函数" class="headerlink" title="4.外链汇编之汇编调c语言函数"></a>4.外链汇编之汇编调c语言函数</h4><p>第一步,在C文件中编写好函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">c_sum</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a+b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第二步, 在汇编文件中引入函数,使用<code>import</code>或者<code>extern</code>伪指令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">AREA code, CODE</span><br><span class="line">import c_sum  </span><br><span class="line"></span><br><span class="line">mov R0,#1 ;第一个参数</span><br><span class="line">mov R1,#2 ;第二个参数</span><br><span class="line"></span><br><span class="line">END</span><br></pre></td></tr></table></figure>

<p>第三步, 使用BL指令调用函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">AREA code, CODE</span><br><span class="line">import c_sum  </span><br><span class="line"></span><br><span class="line">mov R0,#1 ;第一个参数</span><br><span class="line">mov R1,#2 ;第二个参数</span><br><span class="line">BL c_sum</span><br><span class="line">END</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在ARM中函数参数使用R0~R3这四个寄存器来进行传递,最多传递4个参数,超过4个参数使用栈进行处理,函数返回值通过R0进行传递</p>
</blockquote>
<h4 id="由于keil软件的特殊性-我们可以通过以下方式进行互调测试"><a href="#由于keil软件的特殊性-我们可以通过以下方式进行互调测试" class="headerlink" title="由于keil软件的特殊性,我们可以通过以下方式进行互调测试"></a>由于keil软件的特殊性,我们可以通过以下方式进行互调测试</h4><p>C文件中代码:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="title">arm_strcpy</span><span class="params">(<span class="keyword">char</span> *src,<span class="keyword">char</span>*des)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main2</span><span class="params">()</span></span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">char</span> *a=<span class="string">"hello pangshu"</span>	;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">char</span> b[<span class="number">64</span>];</span><br><span class="line"></span><br><span class="line">	arm_strcpy(a,b); <span class="comment">//调汇编中函数</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">c_sum</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a+b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>汇编文件中代码:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> AREA code, CODE</span><br><span class="line"></span><br><span class="line"> import c_sum   </span><br><span class="line"> export arm_strcpy  </span><br><span class="line"></span><br><span class="line">arm_strcpy</span><br><span class="line"></span><br><span class="line">	mov R0,#1 ;第一个参数</span><br><span class="line">	mov R1,#2 ;第二个参数</span><br><span class="line">	BL c_sum  ;结果存放至R0中</span><br><span class="line">	END</span><br></pre></td></tr></table></figure>

<h4 id="5-内嵌汇编"><a href="#5-内嵌汇编" class="headerlink" title="5.内嵌汇编"></a>5.内嵌汇编</h4><p>在C语言中嵌入汇编代码,格式如下:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a=<span class="number">4</span>;</span><br><span class="line">    <span class="keyword">int</span> b=<span class="number">4</span>;</span><br><span class="line">    <span class="keyword">int</span> c=<span class="number">4</span>;</span><br><span class="line">  </span><br><span class="line">	__asm__&#123;         <span class="comment">//使用__asm或者__asm__</span></span><br><span class="line">	mov R5,#<span class="number">0x00000005</span>   <span class="comment">//在大括号内部直接写入汇编代码即可</span></span><br><span class="line">	mov R6,#<span class="number">0x00000005</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>内嵌汇编的注意事项:</p>
<ul>
<li>不能直接给PC寄存器赋值,如果想改变pc值需要借助转移指令</li>
<li>由于R0<del>R3用于存放函数参数和返回值,R12</del>R15有特殊用途,因此<strong>我们能操作的寄存器只有R4~R11</strong>, 又因为编译器会优先将寄存器分配给函数中的局部变量,因此<strong>我们一般无法在内嵌汇编环境中准确地修改某个寄存器的值</strong>,比如我想修改R5寄存器的值,由于函数有个变量占用了R5这个寄存器,那么编译器会自动将你写的这个R5改成R6或者其他，所以，在内嵌汇编时我们需要把寄存器当作变量来看待，把局部变量也当成寄存器看待，就好理解了</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">void c_strcopy(char *src,char *des)&#123;</span><br><span class="line">	char ch</span><br><span class="line">	__asm__&#123;    </span><br><span class="line">    loop:</span><br><span class="line">    	ldrb ch,[src],#1  //局部变量当成寄存器看待</span><br><span class="line">    	strb ch,[des],#1</span><br><span class="line">    	cmp,ch,#0</span><br><span class="line">    	bne loop</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="ARM32中寄存器别名补充"><a href="#ARM32中寄存器别名补充" class="headerlink" title="ARM32中寄存器别名补充"></a>ARM32中寄存器别名补充</h2><table>
<thead>
<tr>
<th align="left">寄存器</th>
<th align="left">别名</th>
<th align="left">用途</th>
</tr>
</thead>
<tbody><tr>
<td align="left">r0</td>
<td align="left">a1</td>
<td align="left">第一个函数参数和函数返回值</td>
</tr>
<tr>
<td align="left">r1</td>
<td align="left">a2</td>
<td align="left">第二个函数参数</td>
</tr>
<tr>
<td align="left">r2</td>
<td align="left">a3</td>
<td align="left">第三个函数参数</td>
</tr>
<tr>
<td align="left">r3</td>
<td align="left">a4</td>
<td align="left">第四个函数参数</td>
</tr>
<tr>
<td align="left">r4</td>
<td align="left">v1</td>
<td align="left">寄存器变量</td>
</tr>
<tr>
<td align="left">r5</td>
<td align="left">v2</td>
<td align="left">寄存器变量</td>
</tr>
<tr>
<td align="left">r6</td>
<td align="left">v3</td>
<td align="left">寄存器变量</td>
</tr>
<tr>
<td align="left">r7</td>
<td align="left">v4</td>
<td align="left">寄存器变量</td>
</tr>
<tr>
<td align="left">r8</td>
<td align="left">v5</td>
<td align="left">寄存器变量</td>
</tr>
<tr>
<td align="left">r9</td>
<td align="left">v6</td>
<td align="left">寄存器变量 实际的帧指针</td>
</tr>
<tr>
<td align="left">r10</td>
<td align="left">sl</td>
<td align="left">栈接线</td>
</tr>
<tr>
<td align="left">r11</td>
<td align="left">fp</td>
<td align="left">参数指针</td>
</tr>
<tr>
<td align="left">r12</td>
<td align="left">ip</td>
<td align="left">临时</td>
</tr>
<tr>
<td align="left">r13</td>
<td align="left">sp</td>
<td align="left">栈指针</td>
</tr>
<tr>
<td align="left">r14</td>
<td align="left">lr</td>
<td align="left">连接寄存器</td>
</tr>
<tr>
<td align="left">r15</td>
<td align="left">pc</td>
<td align="left">程序计数器</td>
</tr>
</tbody></table>
<h4 id="如何编译16位arm汇编指令"><a href="#如何编译16位arm汇编指令" class="headerlink" title="如何编译16位arm汇编指令"></a>如何编译16位arm汇编指令</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">AREA test, CODE</span><br><span class="line">code16		;声明为16位arm指令 如果不写默认则为code32 </span><br><span class="line"></span><br><span class="line"> END</span><br></pre></td></tr></table></figure>

<h4 id="附-指令集汇总"><a href="#附-指令集汇总" class="headerlink" title="附:指令集汇总"></a>附:指令集汇总</h4><p><strong>(一)</strong>  <strong>ARM</strong> <strong>指令集</strong></p>
<p>1． 指令格式</p>
<p>2． 条件码</p>
<p><strong>3． ARM</strong> <strong>存储器访问指令</strong></p>
<p>1)    LDR/ STR －加载 /存储指令</p>
<p>2)    LDM/ STM －多寄存器加载 /存储指令</p>
<p>3)    SWP －寄存器和存储器交换指令</p>
<p><strong>4． ARM</strong> <strong>数据处理指令</strong></p>
<p>1)    数据传送指令</p>
<p>a)    MOV －数据传送指令</p>
<p>b)    MVN －数据非传送指令</p>
<p>2)    算术逻辑运算指令</p>
<p>a)    ADD －加法运算指令</p>
<p>b)    SUB －减法运算指令</p>
<p>c)    RSB- 逆向减法指令</p>
<p>d)    ADC －带进位加法指令</p>
<p>e)    SBC －带进位减法指令</p>
<p>f)    RSC －带进位逆向减法指令</p>
<p>g)    AND －逻辑“与”</p>
<p>h)    ORR －逻辑“或”</p>
<p>i)    EOR －逻辑“异或”</p>
<p>j)    BIC －位清除指令</p>
<p>3)    比较指令</p>
<p>a)    CMP －比较指令</p>
<p>b)    CMN －负数比较指令</p>
<p>c)    TST －位测试指令</p>
<p>d)    TEQ －相等测试指令</p>
<p>4)    乘法指令</p>
<p>a)    MUL － 32位乘法指令</p>
<p>b)    MLA － 32位乘加指令</p>
<p>c)    UMULL － 64位无符号乘法指令</p>
<p>d)    UMLAL － 64位无符号乘加指令</p>
<p>e)    SMULL － 64位有符号乘法指令</p>
<p>f)    SMLAL － 64位有符号乘加指令</p>
<p><strong>5． ARM</strong> <strong>分支指令</strong></p>
<p>1)    B －分支指令</p>
<p>2)    BL －带连接的分支指令</p>
<p>3)    BX －带状态切换的分支指令</p>
<p><strong>6． ARM</strong> <strong>协处理器指令</strong></p>
<p>1)    CDP －协处理器数据操作指令</p>
<p>2)    LDC －协处理器数据读取指令</p>
<p>3)    STC －协处理器数据写入指令</p>
<p>4)    MCR － ARM处理器到协处理器的数据传送指令</p>
<p>5)    MRC －协处理器到 ARM处理器的数据传送指令</p>
<p><strong>7． ARM</strong> <strong>杂项指令</strong></p>
<p>1)    SWI －软中断指令</p>
<p>2)    MRS －读状态寄存器指令</p>
<p>3)    MSR －写状态寄存器指令</p>
<p><strong>8． ARM</strong> <strong>伪指令</strong></p>
<p>1)    ADR －小范围的地址读取伪指令</p>
<p>2)    ADRL －中等范围的地址读取伪指令</p>
<p>3)    LDR －大范围的地址读取伪指令</p>
<p>4)    NOP －空操作伪指令</p>
<p><strong>(二)</strong>  <strong>Thumb</strong> <strong>指令集</strong></p>
<p>1． Thumb 指令集和 ARM指令集的区别</p>
<p><strong>2． Thumb</strong> <strong>存储器访问指令</strong></p>
<p>1)    LDR/ STR －加载 /存储指令</p>
<p>2)    PUSH/ POP －寄存器入栈 /出栈指令</p>
<p>3)    LDMIA/ STMIA －多寄存器加载 /存储指令</p>
<p><strong>3． Thumb</strong> <strong>数据处理指令</strong></p>
<p>1)    数据传送指令</p>
<p>a)    MOV －数据传送指令</p>
<p>b)    MVN －数据非传送指令</p>
<p>c)    NEG －数据取负指令</p>
<p>2)    算术逻辑运算指令</p>
<p>a)    ADD －加法运算指令</p>
<p>b)    SUB －减法运算指令</p>
<p>c)    ADC －带进位加法指令</p>
<p>d)    SBC －带进位减法指令</p>
<p>e)    MUL －乘法运算指令</p>
<p>f)    AND －逻辑“与”</p>
<p>g)    ORR －逻辑“或”</p>
<p>h)    EOR －逻辑“异或”</p>
<p>i)    BIC －位清除指令</p>
<p>j)    ASR －算术右移指令</p>
<p>k)    LSL －逻辑左移指令</p>
<p>l)    LSR －逻辑右移指令</p>
<p>m)    ROR －循环右移指令</p>
<p>3)    比较指令</p>
<p>a)    CMP －比较指令</p>
<p>b)    CMN －负数比较指令</p>
<p>c)    TST －位测试指令</p>
<p><strong>4． Thumb</strong> <strong>分支指令</strong></p>
<p>1)    B －分支指令</p>
<p>2)    BL －带连接的分支指令</p>
<p>3)    BX －带状态切换的分支指令</p>
<p><strong>5． Thumb</strong> <strong>杂项指令</strong></p>
<p>1)    SWI －软中断指令</p>
<p><strong>6． Thumb</strong> <strong>伪指令</strong></p>
<p>1)    ADR －小范围的地址读取伪指令</p>
<p>2)    LDR －大范围的地址读取伪指令</p>
<p>3)    NOP －空操作伪指令</p>
<p><strong>本文为作者原创 转载时请注明出处 谢谢</strong></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em>乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</em></p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="tags/汇编/" rel="tag"># 汇编</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="201.html" rel="next" title="android设备上如何运行C语言原生程序">
                <i class="fa fa-chevron-left"></i> android设备上如何运行C语言原生程序
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="205.html" rel="prev" title="ARM原生汇编与ARM GNU汇编的区分">
                ARM原生汇编与ARM GNU汇编的区分 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>


    <!-- 乱码三千文章内嵌广告 -->
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<ins class="adsbygoogle" style="display:block; text-align:center;" data-ad-layout="in-article" data-ad-format="fluid" data-ad-client="ca-pub-2626449904708114" data-ad-slot="1549007621"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>

    <div class="post-spread">
      
    </div>
  </div>
  <!-- 乱码三千信息流广告 -->
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<ins class="adsbygoogle" style="display:block" data-ad-format="fluid" data-ad-layout-key="-6t+ed+2i-1n-4w" data-ad-client="ca-pub-2626449904708114" data-ad-slot="9471729671"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>


          </div>
          


          

  
    <div class="comments" id="comments">
      
        <div id="gitment-container"></div>
      
    </div>

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">乱码三千</p>
              <p class="site-description motion-element" itemprop="description">android程序员一枚,擅长java,kotlin,python,金融投资,欢迎交流~</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="https://code.newban.cn/archives/">
              
                  <span class="site-state-item-count">469</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">138</span>
                  <span class="site-state-item-name">标签</span>
                
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#ARM两种编译环境"><span class="nav-number">1.</span> <span class="nav-text">ARM两种编译环境</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ARM原生环境搭建"><span class="nav-number">2.</span> <span class="nav-text">ARM原生环境搭建</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ARM32系列命名"><span class="nav-number">3.</span> <span class="nav-text">ARM32系列命名</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#寄存器"><span class="nav-number">4.</span> <span class="nav-text">寄存器</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#影子寄存器"><span class="nav-number">4.0.1.</span> <span class="nav-text">影子寄存器</span></a></li></ol></li></ol><li class="nav-item nav-level-2"><a class="nav-link" href="#语法"><span class="nav-number">5.</span> <span class="nav-text">语法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#代码编写规范"><span class="nav-number">6.</span> <span class="nav-text">代码编写规范</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#内存数据的读写"><span class="nav-number">7.</span> <span class="nav-text">内存数据的读写</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#LDR伪指令"><span class="nav-number">8.</span> <span class="nav-text">LDR伪指令</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#LDR伪指令总结"><span class="nav-number">8.0.1.</span> <span class="nav-text">LDR伪指令总结</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ADR指令"><span class="nav-number">8.0.2.</span> <span class="nav-text">ADR指令</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#段的拓展"><span class="nav-number">9.</span> <span class="nav-text">段的拓展</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#栈的操作"><span class="nav-number">10.</span> <span class="nav-text">栈的操作</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#对栈批量操作"><span class="nav-number">10.0.1.</span> <span class="nav-text">对栈批量操作</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#批量存取指令扩展"><span class="nav-number">10.0.2.</span> <span class="nav-text">批量存取指令扩展</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#满栈和空栈"><span class="nav-number">10.0.3.</span> <span class="nav-text">满栈和空栈</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#多寄存器数据存放顺序"><span class="nav-number">10.0.4.</span> <span class="nav-text">多寄存器数据存放顺序</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#宏"><span class="nav-number">11.</span> <span class="nav-text">宏</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#指令学习"><span class="nav-number">12.</span> <span class="nav-text">指令学习</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#传送指令"><span class="nav-number">12.0.1.</span> <span class="nav-text">传送指令</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#转移指令"><span class="nav-number">12.0.2.</span> <span class="nav-text">转移指令</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#算术和逻辑运算指令"><span class="nav-number">12.0.3.</span> <span class="nav-text">算术和逻辑运算指令</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#移位指令"><span class="nav-number">12.0.4.</span> <span class="nav-text">移位指令</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#比较指令"><span class="nav-number">12.0.5.</span> <span class="nav-text">比较指令</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#标志寄存器"><span class="nav-number">13.</span> <span class="nav-text">标志寄存器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#条件和循环伪指令"><span class="nav-number">14.</span> <span class="nav-text">条件和循环伪指令</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#WHILE-和-WEND"><span class="nav-number">14.0.1.</span> <span class="nav-text">WHILE 和 WEND</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#汇编语言和C语言交互"><span class="nav-number">15.</span> <span class="nav-text">汇编语言和C语言交互</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-引入其他源文件函数"><span class="nav-number">15.0.1.</span> <span class="nav-text">1.引入其他源文件函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-导出当前源文件中函数供其他文件访问"><span class="nav-number">15.0.2.</span> <span class="nav-text">2.导出当前源文件中函数供其他文件访问</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-外链汇编之C语言调汇编函数"><span class="nav-number">15.0.3.</span> <span class="nav-text">3.外链汇编之C语言调汇编函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-外链汇编之汇编调c语言函数"><span class="nav-number">15.0.4.</span> <span class="nav-text">4.外链汇编之汇编调c语言函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#由于keil软件的特殊性-我们可以通过以下方式进行互调测试"><span class="nav-number">15.0.5.</span> <span class="nav-text">由于keil软件的特殊性,我们可以通过以下方式进行互调测试</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-内嵌汇编"><span class="nav-number">15.0.6.</span> <span class="nav-text">5.内嵌汇编</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ARM32中寄存器别名补充"><span class="nav-number">16.</span> <span class="nav-text">ARM32中寄存器别名补充</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#如何编译16位arm汇编指令"><span class="nav-number">16.0.1.</span> <span class="nav-text">如何编译16位arm汇编指令</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#附-指令集汇总"><span class="nav-number">16.0.2.</span> <span class="nav-text">附:指令集汇总</span></a></li></ol></li></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">乱码三千</span>
  <div>
  <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
  <span id="busuanzi_container_site_pv">本站总访问量<span id="busuanzi_value_site_pv"></span>次</span>
  </div>
  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




  <script type="text/javascript" async src="js/src/mermaid.min.js"></script>
  <script>
  if (window.mermaid) {
        var mermaid_config = {
            startOnLoad: true,
            theme: 'default',
            flowchart:{
                useMaxWidth: false,
                htmlLabels: true
            }                
        }
        mermaid.initialize(mermaid_config);
  }
  </script>
  
        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
          <span id="scrollpercent"><span>0</span>%</span>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  







<!-- LOCAL: You can save these files to your site and update links -->
    
        
        <link rel="stylesheet" href="https://aimingoo.github.io/gitmint/style/default.css">
        <script src="https://aimingoo.github.io/gitmint/dist/gitmint.browser.js"></script>
    
<!-- END LOCAL -->

    
      <style>
        a.gitment-editor-footer-tip { display: none; }
        .gitment-container.gitment-footer-container { display: none; }
      </style>
    

    
      <script type="text/javascript">
      function renderGitment(){
        var gitment = new Gitmint({
            id: window.location.pathname, 
            owner: 'songjianzaina',
            repo: 'codesan_comment',
            
            lang: "zh" || navigator.language || navigator.systemLanguage || navigator.userLanguage,
            
            oauth: {
            
            
                client_secret: '75fa01da04fd1029841debfa65ce027b566a47e3',
            
                client_id: '01a471de64bf7a7789f3'
            }});
        gitment.render('gitment-container');
      }

      
      renderGitment();
      
      </script>
    







  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  

  

  

</body>
</html>
