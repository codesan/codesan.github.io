<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">
<meta name="referrer" content="never">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="../../lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="../../lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="../../css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="../../images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="../../images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="../../images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="../../images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">





  <link rel="alternate" href="../../atom.xml" title="乱码三千 – 分享实用IT技术" type="application/atom+xml">






<meta name="description" content="android程序员一枚,擅长java,kotlin,python,金融投资,欢迎交流~">
<meta name="keywords" content="android,java,kotlin,golang,go,python,自动化,量化,金融,php,docker,linux">
<meta property="og:type" content="website">
<meta property="og:title" content="乱码三千 – 分享实用IT技术">
<meta property="og:url" content="https://code.newban.cn/page/26/index.html">
<meta property="og:site_name" content="乱码三千 – 分享实用IT技术">
<meta property="og:description" content="android程序员一枚,擅长java,kotlin,python,金融投资,欢迎交流~">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="乱码三千 – 分享实用IT技术">
<meta name="twitter:description" content="android程序员一枚,擅长java,kotlin,python,金融投资,欢迎交流~">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":true,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>
<!--谷歌广告验证代码-->
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({
          google_ad_client: "ca-pub-2626449904708114",
          enable_page_level_ads: true
     });
</script>
<!--谷歌广告验证代码-->

<!--短链广告-->
<!--<script type="text/javascript">
    var adfly_id = 25792435;
    var adfly_advert = 'banner';
    var popunder = false;
    var exclude_domains = ['code.newban.cn','newban.cn',  'localhost:4000'];
</script>
<script src="https://cdn.adf.ly/js/link-converter.js"></script>-->
<!--短链广告-->



  <link rel="canonical" href="https://code.newban.cn/page/26/">





  <title>乱码三千 – 分享实用IT技术</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>
  
<a href="https://www.github.com/songjianzaina" class="github-corner" aria-label="View source on Github"><svg width="80" height="80" viewbox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"/><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"/><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"/></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>
    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">乱码三千 – 分享实用IT技术</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">乱码三千 – 码出一个新世界</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="http://www.newban.cn/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="https://code.newban.cn/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://code.newban.cn../../211.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="乱码三千">
      <meta itemprop="description" content>
      <meta itemprop="image" content="../../images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="乱码三千 – 分享实用IT技术">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="../../211.html" itemprop="url">视频帧率和码率对视频质量和文件大小的影响</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-01-24T16:14:19+08:00">
                2021-01-24
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>我们从<strong>画面流畅度</strong>,<strong>画面清晰度</strong>,和<strong>视频文件体积</strong>三个方面进行分析:</p>
<h2 id="帧率-FPS"><a href="#帧率-FPS" class="headerlink" title="帧率(FPS)"></a>帧率(FPS)</h2><p><strong>指每秒显示图像的张数</strong></p>
<p>比如30帧,表示每秒显示30张图像</p>
<p><strong>帧率越大,画面越流畅,帧率越小,画面越卡顿</strong>,如果低到1帧/秒,那么就相当于一个幻灯片了</p>
<p><strong>帧率不会影响到画面的清晰度,只会影响画面的流畅度和文件的体积</strong>,帧率越大,视频对应的体积越大</p>
<h2 id="分辨率-resolution"><a href="#分辨率-resolution" class="headerlink" title="分辨率(resolution)"></a>分辨率(resolution)</h2><p><strong>指像素点分布密度</strong></p>
<p>比如24寸的显示器,设置1920x1080的分辨率,那就是横向由1920个像素点构成,纵向由1080个像素点构成,也就是说在屏幕尺寸固定的情况下,<strong>分辨率越高,画面越清晰细腻,反之,画面越模糊</strong></p>
<p><strong>分辨率不会影响画面的流畅度,只会影响画面的清晰度和文件的体积</strong>,分辨率越大,视频体积越大</p>
<h2 id="码率-Bitrate"><a href="#码率-Bitrate" class="headerlink" title="码率(Bitrate)"></a>码率(Bitrate)</h2><p><strong>指每秒传输的数据位数</strong>,单位kbps 即千位每秒 ,这里的位指的是二进制位</p>
<p>基本的算法是:</p>
<ul>
<li><p>每秒传输的数据量=码率/8 </p>
</li>
<li><p>视频文件体积=码率/8x视频时长(s) =每秒传输的数据量*视频时长(s)</p>
</li>
</ul>
<p>比如500Kbps,也就是每秒传输62K大小的数据, 假如按照帧率30fps进行计算,那么每张图片大小约为2kb大小</p>
<p>也就是说视频时长固定的情况下,<strong>码率越高,文件体积越大,同时视频显示的有效像素越多</strong>,视频更加接近原始分辨率,反之,码率越低,文件体积越小,但是视频能显示的有效像素就越少,原本1080p的分辨率,每帧图像至少需要占用20k的数据量,但是码率过低每帧只能分配2K的量,此时像素点显示不全,就会造成视频模糊不清晰</p>
<p>因此,码率若是过低,再高的分辨率都拯救不了画质,反而会适得其反, </p>
<p>事实上,低码率环境下,低分辨率画面要比高分辨率画面更加清晰</p>
<p><strong>码率不会影响画面的流畅度,但是会影响画面的清晰度和文件的体积</strong></p>
<h2 id="我们的需求"><a href="#我们的需求" class="headerlink" title="我们的需求"></a>我们的需求</h2><p>我们一般<strong>追求高清流畅的画质,同时文件体积尽可能小</strong>,那么该如何找到帧率 码率和分辨率三者的平衡点呢?</p>
<p>首先在我们录制视频的时候,<strong>屏幕的分辨率一般是固定的</strong>,随着不同的电脑分辨率也不同(当然你要手动调整也行)</p>
<p>其次,为了保证视频的流畅度我们一般将<strong>帧率设置在25fps</strong>以上</p>
<p>那么我们想减小视频的体积的话,只能从码率入手了, 找到一个画质能接受,体积小的平衡点</p>
<p>比如1980x1080的分辨率,我使用500kbps左右的码率,差不多可以接受,OBS在录制时默认也是在这个码率内来回波动</p>
<p>以下是常见分辨率和码率之间平衡参考表:</p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20210124171800.png" alt></p>
<p><strong>举例</strong>:如果要想百分百还原1080p HQ的画质,至少需要5.76Mkpbs码率的支撑,如果是直播的话需要至少9M的宽带才能稳定传输对应的数据量,否则画面卡顿</p>
<p>直播中,在分辨率和网速一定的情况下,我们会适当降低码率,牺牲部分清晰度的来保证视频的流畅性</p>
<p>如果网速不行又希望画面还清晰流畅,那么就降低拍摄的分辨率,同时降低数据传输量也就是码率值,当然分辨率降低之后所谓的视频清晰度也只是相对的,凡事总有取舍</p>
<p><strong>本文为作者原创 转载时请注明出处 谢谢</strong></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt="img"></p>
<p><em>乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</em></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://code.newban.cn../../210.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="乱码三千">
      <meta itemprop="description" content>
      <meta itemprop="image" content="../../images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="乱码三千 – 分享实用IT技术">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="../../210.html" itemprop="url">关于mysql崩溃之error establishing a database connection</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-01-22T16:14:19+08:00">
                2021-01-22
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>最近在进行网站检查的时候突然发现我的一个子网站挂了,提示<code>error establishing a database connection</code>, 如果是网站刚建立那好解决,80%的概率是数据连接参数不正确,或者是数据库端口没有开放</p>
<p>但是我这个网站运行很长一段时间了,之前一直好好的,突然之间就挂了, 而且这个数据库我使用的是<code>docker</code>进行维护,同时,在同一个<code>mysql</code>容器中我放置了好几个网站的数据,其他网站运行却是正常的</p>
<p>而且我通过第三方连接数据库的工具可以正常连接到被挂网站的数据库</p>
<p>通过以上情况可以排除以下原因:</p>
<ul>
<li><code>mysql</code>容器没有问题</li>
<li>数据库端口和连接参数也没问题(已经检查过配置文件,没有被外部篡改过)</li>
<li>网站程序正常运行</li>
</ul>
<p>这种情况下该如何处理呢? 当然是找日志了</p>
<p>第一步:查看主程序日志,没问题</p>
<p>第二步:查看<code>mysql</code>容器日志,发现问题</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker logs --tail=50 mysql</span><br></pre></td></tr></table></figure>

<p><code>Table &#39;./wordpress_wai/wp_options&#39; is marked as crashed and should be repaired when using LOCK TABLES</code></p>
<p><strong>数据库没有问题,但是表有问题</strong></p>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p><strong>对表进行修复即可：</strong></p>
<p>首先登录mysql选择指定的数据库,然后执行以下命令:</p>
<ol>
<li><p>执行修复指令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">repair table wp_option</span><br></pre></td></tr></table></figure>
</li>
<li><p>检查表的状态</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">check table wp_option</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>修复前最好先备份数据库</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqldump -uroot -p密码 数据库名 &gt;xxxxx.sql</span><br></pre></td></tr></table></figure>

<p>如果表损坏比较严重,可能无法备份数据库</p>
<p>如果你不知道如何查看<code>mysql</code>日志,那么直接运行备份数据库指令,也能帮你检查数据库是否存在问题</p>
<p>修复完成后无需重启mysql容器, 直接刷新网址即可正常访问</p>
<h3 id="2021年9月1日补充"><a href="#2021年9月1日补充" class="headerlink" title="2021年9月1日补充"></a>2021年9月1日补充</h3><p>突然数据库又崩了, 网站同样提示<code>error establishing a database connection</code></p>
<p>我查看<code>docker</code>日志 报如下错误:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Database page corruption on disk or a failed file read of page [page id: space=0, page number=5]. You may have to recover from a backup</span><br></pre></td></tr></table></figure>

<p>此时<code>mysql</code>容器已经进不去了, 百度了一下说是数据库受损 要在<code>my.cnf</code>配置文件中添加<code>innodb_force_recovery=1</code></p>
<p>可是我在<code>conf</code>目录下并没有找到<code>my.cnf</code>文件 不知道是被谁给删了 难道被入侵了</p>
<p>只好新建一个配置文件看看可不可行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim my.cnf</span><br></pre></td></tr></table></figure>

<p>然后将以下内容拷贝进去:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">pid-file        = /var/run/mysqld/mysqld.pid</span><br><span class="line">socket          = /var/run/mysqld/mysqld.sock</span><br><span class="line">datadir         = /var/lib/mysql</span><br><span class="line">secure-file-priv= NULL</span><br><span class="line"># Disabling symbolic-links is recommended to prevent assorted security risks</span><br><span class="line">symbolic-links=0</span><br><span class="line"></span><br><span class="line"># Custom config should go here</span><br><span class="line">!includedir /etc/mysql/conf.d/</span><br></pre></td></tr></table></figure>

<p><code>wq</code>保存退出 然后重启<code>mysql</code>容器, 重新访问网站 还是不行</p>
<p>紧接着我在配置文件末尾添加了<code>innodb_force_recovery=1</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">pid-file        = /var/run/mysqld/mysqld.pid</span><br><span class="line">socket          = /var/run/mysqld/mysqld.sock</span><br><span class="line">datadir         = /var/lib/mysql</span><br><span class="line">secure-file-priv= NULL</span><br><span class="line"># Disabling symbolic-links is recommended to prevent assorted security risks</span><br><span class="line">symbolic-links=0</span><br><span class="line"></span><br><span class="line"># Custom config should go here</span><br><span class="line">!includedir /etc/mysql/conf.d/</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">innodb_force_recovery=1</span><br></pre></td></tr></table></figure>

<p>保存重启后, 网站正常访问, 问题解决</p>
<p>但是mysql容器日志一直提示:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[ERROR] [MY-012803] [InnoDB] innodb_force_recovery is on. We do not allow database modifications by the user. Shut down mysqld and edit my.cnf to set innodb_force_recovery=0</span><br></pre></td></tr></table></figure>

<p>于是我把<code>innodb_force_recovery</code>值设为0 网站没问题 暂且就这样</p>
<h4 id="关于innodb-force-recovery参数"><a href="#关于innodb-force-recovery参数" class="headerlink" title="关于innodb_force_recovery参数"></a>关于innodb_force_recovery参数</h4><ul>
<li>Mode 1当遇到损坏页时，不使 MySQL 崩溃</li>
<li>Mode 2不运行后台操作</li>
<li>Mode 3不会尝试回滚事务</li>
<li>Mode 4不计算统计数据或应用存储/缓冲的变化</li>
<li>Mode 5在启动过程中不查看撤消日志</li>
<li>Mode 6在启动时不从重做日志（ib_logfiles）前滚</li>
</ul>
<p><strong>本文为作者原创 转载时请注明出处 谢谢</strong></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em>乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</em></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://code.newban.cn../../217.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="乱码三千">
      <meta itemprop="description" content>
      <meta itemprop="image" content="../../images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="乱码三千 – 分享实用IT技术">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="../../217.html" itemprop="url">GCC调试工具GDB的常用指令</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-01-20T16:14:19+08:00">
                2021-01-20
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="常用指令"><a href="#常用指令" class="headerlink" title="常用指令"></a>常用指令</h2><ol>
<li><p>进入调试模式</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gdb 可执行文件</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果忘了指定调试文件可以使用<code>file</code>指令指定</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) file 文件名</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用<code>quit</code>指令退出调试模式 可简写为q</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) q</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用<code>start</code>指令开始调试  停在第一行代码处 </p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) start</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用<code>step</code>指令进行单步执行 可简写为<code>s</code></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) s   <span class="comment">#会进入函数内部</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>使用<code>next</code>执行进行单步执行 可简写为<code>n</code> </p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) n  <span class="comment">#不会进入函数内部</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>汇编级别单步执行(上面<code>n</code>和<code>s</code>为c语言级别单步指令)</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(gdb) ni <span class="comment">#不进入函数内部</span></span><br><span class="line">(gdb) si <span class="comment">#会进入函数内部</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>使用<code>list</code>指令列出所有源代码 可简写为<code>l</code></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) l</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用<code>break</code>指令设置断点位置 可简写为<code>b</code></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(gdb) b main <span class="comment">#在main函数处打断点</span></span><br><span class="line">(gdb) b 10 <span class="comment">#在第十行位置打断点</span></span><br><span class="line">(gdb) b <span class="built_in">test</span>:10 <span class="comment">#在test文件的第十行位置打断点 </span></span><br><span class="line">(gdb) b 0x3400a <span class="comment">#在0x3400a内存位置打断点</span></span><br><span class="line">(gdb) b 10 <span class="keyword">if</span> i==3 <span class="comment">#设置条件断点 i等于3时在第十行位置打断点 适用于循环</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>使用<code>delete+断点编号</code>指令删除断点 可简写为<code>d</code></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) delete 3 <span class="comment">#删除编号为3的断点  清除时GDB不会给出任何提示</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>使用 <code>clear+断点行号</code>指令清除断点</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) clear 3 <span class="comment">#清除第三行的断点  清除时GDB会给出提示</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>使用 <code>disable/enable + 断点编号</code> 指令冻结或启动断点</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">disable</span> 3,4 <span class="comment">#冻结编号为3和4的断点 多个断点使用逗号分隔</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>使用<code>info break</code>指令查看断点的情况</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) info <span class="built_in">break</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>使用 <code>tbreak</code> 指令设置临时断点</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) tbreak 行号/函数名 <span class="comment">#设置临时断点，到达后被自动删除</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>使用 <code>awatch/watch + 变量</code> 设置变量读写观察点</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(gdb) awatch/watch a <span class="comment">#当变量a被读出或写入时程序被暂停 </span></span><br><span class="line">(gdb) rwatch a <span class="comment">#当变量a被读出时程序被暂停</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>使用<code>continue</code>指令运行到断点处 可简写为<code>c</code></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) c</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用<code>print</code>指令打印变量的值 可简写为p</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) p a <span class="comment">#打印变量a的值</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>使用x指令打印指定内存地址数据</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) x /6cb 0x804835c <span class="comment">#打印地址0x804835c起始的内存内容，连续6个字节，以字符格式输出。</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>使用<code>run</code>指令运行整个程序 可简写为<code>r</code></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) r  <span class="comment">#如果此前没有下过断点，则执行完整个程序；如果有断点，则程序暂停在第一个可用断点处</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>使用 call 指令直接运行某个函数</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) call fun <span class="comment">#在当前位置执行函数fun</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>使用<code>display</code> 指令设置需要跟踪的变量</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) display a <span class="comment">#跟踪变量a 每次断点到该处就显示该变量的值</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>使用 <code>info display</code> 显示当前所有跟踪的情况</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) info display</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用<code>undisplay+编号</code> 指令取消对变量的跟踪</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) undisplay 3 <span class="comment">#取消对编号为3的跟踪事件</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>使用 <code>set+ 变量</code> 指令改变变量的值</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) <span class="built_in">set</span> i=3 <span class="comment">#临时设置变量i的值为3</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>使用 <code>set</code>  指令设置运行时参数</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) <span class="built_in">set</span> i=3 <span class="comment">#临时这只变量i的值为3</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>使用 <code>show</code>  指令查看运行时参数</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) show i</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用 <code>finish</code> 指令函数结束</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) finish</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用<code>help</code>指令查看指令使用说明</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(gdb) <span class="built_in">help</span> <span class="built_in">print</span> <span class="comment">#查看print指令的解释说明</span></span><br><span class="line">(gdb) <span class="built_in">help</span> <span class="comment">#查看所有指令</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>使用<code>info reg</code>指令查看寄存器状态</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb)  info reg</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用 <code>info stack</code>指令查看堆栈状态</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) info stack</span><br></pre></td></tr></table></figure>
</li>
<li><p>运行shell指令</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) shell ls   <span class="comment">#运行shell指令ls。</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>其他指令</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(gdb)  path <span class="comment">#可设定程序的运行路径。 </span></span><br><span class="line">(gdb)  show paths <span class="comment">#查看程序的运行路径。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">(gdb) 　<span class="built_in">cd</span>　　  <span class="comment">#相当于shell的cd命令。 </span></span><br><span class="line"></span><br><span class="line">(gdb) 　<span class="built_in">pwd</span>　　<span class="comment">#显示当前的所在目录</span></span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="32">
<li>使用<code>回车</code>重复上一条指令</li>
</ol>
<p><strong>本文为作者原创 转载时请注明出处 谢谢</strong></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt="img"></p>
<p><em>乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</em></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://code.newban.cn../../208.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="乱码三千">
      <meta itemprop="description" content>
      <meta itemprop="image" content="../../images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="乱码三千 – 分享实用IT技术">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="../../208.html" itemprop="url">视频教程录制计划</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-01-17T16:14:19+08:00">
                2021-01-17
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="技术视频"><a href="#技术视频" class="headerlink" title="技术视频"></a>技术视频</h2><ol>
<li><p><strong>《<a href="https://code.newban.cn/450.html">Android进阶之逆向安全反编译视频教程-胖薯出品</a>》</strong></p>
<ul>
<li>录制时间 2020年11月6日</li>
<li>部分视频观看:<a href="https://www.bilibili.com/video/BV1QZ4y1V7zy/" target="_blank" rel="noopener">点击跳转</a></li>
</ul>
</li>
<li><p><strong>《<a href="https://code.newban.cn/449.html">Smali语言从入门到精通视频教程-胖薯出品</a>》</strong></p>
<ul>
<li>录制时间 2020年11月6日</li>
<li>部分视频观看:<a href="https://www.bilibili.com/video/BV1Vf4y1q7gh/" target="_blank" rel="noopener">点击跳转</a></li>
</ul>
</li>
<li><p><strong>《<a href="https://code.newban.cn/451.html">程序员进阶之三大架构汇编语言入门视频教程-胖薯出品</a>》</strong></p>
<ul>
<li>录制时间 2020年12月14日</li>
<li>部分视频观看:<a href="https://www.bilibili.com/video/BV1CK411u76E/" target="_blank" rel="noopener">点击跳转</a></li>
</ul>
</li>
<li><p><strong>《ARM汇编进阶之ARM64汇编视频教程-胖薯出品》</strong></p>
<ul>
<li>录制时间 </li>
<li>部分视频观看:</li>
</ul>
</li>
<li><p><strong>《MIPS汇编进阶之MIPS64汇编视频教程-胖薯出品》</strong></p>
<ul>
<li>录制时间 </li>
<li>部分视频观看:</li>
</ul>
</li>
<li><p><strong>《X86汇编进阶之Win32汇编视频教程-胖薯出品》</strong></p>
<ul>
<li>录制时间 </li>
<li>部分视频观看:</li>
</ul>
</li>
<li><p><strong>《X86汇编进阶之Win64汇编视频教程-胖薯出品》</strong></p>
<ul>
<li>录制时间 </li>
<li>部分视频观看:</li>
</ul>
</li>
<li><p><strong>《lua语言从入门到实战视频教程-胖薯出品》</strong></p>
<ul>
<li>录制时间 </li>
<li>部分视频观看:</li>
</ul>
</li>
<li><p><strong>《硬件开发入门视频教程-胖薯出品》</strong></p>
<ul>
<li>录制时间 </li>
<li>部分视频观看:</li>
</ul>
</li>
<li><p><strong>《从0到1打造一门属于自己的编程语言视频教程-胖薯出品》</strong></p>
<ul>
<li>录制时间 </li>
<li>部分视频观看:</li>
</ul>
</li>
<li><p><strong>《从0到1开发一款操作系统视频教程-胖薯出品》</strong></p>
<ul>
<li>录制时间 </li>
<li>部分视频观看:</li>
</ul>
</li>
<li><p><strong>《音乐制作之视唱练耳视频教程-胖薯出品》</strong></p>
<ul>
<li>录制时间 </li>
<li>部分视频观看:</li>
</ul>
</li>
<li><p><strong>《虚幻游戏开发从0到1视频教程-胖薯出品》</strong></p>
<ul>
<li>录制时间 </li>
<li>部分视频观看:</li>
</ul>
</li>
<li><p><strong>《音频插件开发视频教程-胖薯出品》</strong></p>
<ul>
<li>录制时间 </li>
<li>部分视频观看:</li>
</ul>
</li>
<li><p><strong>《SO库的反编译视频教程-胖薯出品》</strong></p>
<ul>
<li>录制时间 </li>
<li>部分视频观看:</li>
</ul>
</li>
<li><p><strong>《360和腾讯加固的原理和脱壳视频教程-胖薯出品》</strong></p>
<ul>
<li>录制时间 </li>
<li>部分视频观看:</li>
</ul>
</li>
</ol>
<p><strong>本文为作者原创 转载时请注明出处 谢谢</strong></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em>乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</em></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://code.newban.cn../../209.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="乱码三千">
      <meta itemprop="description" content>
      <meta itemprop="image" content="../../images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="乱码三千 – 分享实用IT技术">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="../../209.html" itemprop="url">从0到1打造一门属于自己的编程语言(一)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-01-17T16:14:19+08:00">
                2021-01-17
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>学习编程语言的开发,目的不是为了造轮子,而是为了了解程序语言的本质和原理,方便我们日常的开发</p>
<p>学习此课程前需要提前掌握以下知识:</p>
<ul>
<li>了解汇编语言</li>
<li>熟悉至少一门高级编程语言</li>
</ul>
<h2 id="编程语言的来源"><a href="#编程语言的来源" class="headerlink" title="编程语言的来源"></a>编程语言的来源</h2><p>我们如果想要和外国人交流,那么我们必须学会外语, 或者让外国人学咱们的语言</p>
<p>我们如果想要指挥计算机,那么我们必须学会计算机语言,让计算机学咱们的语言不太可能,至少现在不行! </p>
<p>很多人都认为我们平常使用的编程语言比如C语言 Java语言等就是计算机语言,这种说法不太严谨, 因为计算机压根不认识编程语言,它只认识二进制码, 也就是说 二进制码才是计算机真正的语言</p>
<p>那我们要指挥计算机岂不是得学<strong>二进制码(机器码)</strong>,在编程语言发明之前,确实是如此</p>
<p><strong>科技的进步来源于懒惰</strong></p>
<p>人类势必不会甘愿长期忍受机器码的摧残, 为了摆脱效率低下的编码,于是乎,聪明的人类发明了编程语言,比如汇编, 相比机器码汇编显然要舒服的多, 但是随着时间的推移,人们发现汇编语言存在非常严重的弊端, 最突出的一点就是不同cpu架构需要制定一套不同指令集,通俗一点就是不同cpu对应着不同的一套汇编语言,这就导致了无法跨平台</p>
<p>有人会问,为什么当时大家不使用同一种cpu呢, 历史不能预知未来的发展,每个时代都有各自的商业竞争</p>
<p><strong>新技术的出现往往是因为问题的长期累积</strong></p>
<p>于是乎,跨平台语言C语言问世了, 但是C语言知识语言跨平台,但是其编写的程序并不跨平台</p>
<p>于是乎,可以程序跨平台的Java语言问世了</p>
<p>……..</p>
<p>从这段历史,我们不难发现:</p>
<p><strong>编程语言只是一个方便人类与计算机交流的工具</strong></p>
<p>只是工具,仅此而已</p>
<p>我们现在花大量时间和精力所学所用的都是别人制作出来的工具</p>
<p>当我们因熟练掌握几门编程语言而洋洋得意时,是否有想过,我们只是一个工具的熟练运用者</p>
<p>我并不是说学语言很low, 毕竟编程语言的门槛也不低,需要花大量时间和精力才能有效掌握,我只是想说,一旦你明白了语言的创造过程, 那就等于你掌握了现在市面上所有的编程语言, 所有的语言,原理都是一样的,只不过语法和关键字不同,仅此而已</p>
<p>也就是说,我们需要去了解工具的生产过程</p>
<h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>如果你去网上搜相关编程语言制作的视频或资料, 基本上都是词法分析,语法分析,语义分析等等, 让人一头雾水, 直接劝退</p>
<p>试想一下,在若干年前编程语言还没有问世的时候,有词法语法语义符号token等等这一些个含义么? 完全没有!</p>
<p>这些理论都是前人经验总结而成, 经验固然很好,能少走弯路,但是对于初学者来讲极其不友好</p>
<p>只有从初学者的角度出发,才能更平滑地学习到原本复杂的知识</p>
<p>因此抛开这些专业术语吧,从0开始出发</p>
<h2 id="起步"><a href="#起步" class="headerlink" title="起步"></a>起步</h2><p>假如现在编程语言还未问世,你现在要自创一门语言方便人类开发, 你会怎么做?</p>
<p> 比如我想让计算机帮忙算个数,计算1+1</p>
<p>原本使用机器码可能得这样写:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4F 9B 55 7C 2D 3A  ;实际过程中我们一般使用十六进制进行表示,cpu执行的时候执行的是对应的二进制</span><br></pre></td></tr></table></figure>

<p>此时,我可能会考虑用一句话来代替这个计算1加1的功能,比如</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">加:1+1   ;这是不是好理解多了</span><br></pre></td></tr></table></figure>

<p>问题来了, 如果将我这句话转成机器码呢? 也就是说,我们需要将这句话翻译成机器码, 那怎么翻译呢? 是不是得需要一个翻译工具呀</p>
<p>于是乎,我们与此同时需要想办法整一个翻译工具, 由于我设计的这句话是敲在计算机上的,而不是写在纸上的, 如果是写在纸上的,兴许我们可以造一台机器将我写的内容转印成机器码,然后机器码敲入计算机:cry:… 这种愚蠢的做法, 简直就是科技的倒退</p>
<p>既然是直接敲在计算机中,那我们的翻译工具必然也是一个能被cpu执行的程序, 那我们需要先编写翻译工具这个程序的机器码</p>
<p>理论上是这么个逻辑</p>
<p>我们需要一边指定语法规则,一边编写和优化的翻译程序,因为我们的需求不单单是让计算机做加法运算</p>
<blockquote>
<p>这个能把我们指定的语言翻译成机器码的翻译工具，就是当今所说的编译器，后文皆以编译器替代</p>
</blockquote>
<h2 id="编译器该如何写"><a href="#编译器该如何写" class="headerlink" title="编译器该如何写"></a>编译器该如何写</h2><p>由于源代码都是存放在文件中，按照我们的正常思维，最先想到的是将这个文件中的内容读取出来，然后从头到尾进行匹配判断，根据不同的关键字判断不同的功能，然后用与之对应的机器码进行替换</p>
<p>cpu在进行文件读取的时候，本质上读取的是二进制，那我们编写的中文或者英文和二进制数据的一一对应关系就涉及到编码格式问题，常见的编码格式有：</p>
<ul>
<li>ASCII码 (只识别英文)</li>
<li>GBK （识别英文和中文）</li>
<li>UTF-8 （识别各个国家的语言）</li>
<li>…</li>
</ul>
<p>假如我们接下来要使用UTF-8进行编码，那么我们需要指定一张表，也就是二进制码和功能之间的一一对应关系，比如算术运算中<code>加</code>这个关键字：编译器从文本中连续读取两个字节二进制数据然后查表，如果对应上了加法功能，那么继续往后读取需要进行运算的内容，读到结束标记的时候，然后将之前所读取的二进制转化成与之对应功能的机器码，以此类推，这个结束标记也是由我们来定，我们可以使用分号、回车换行或者其它特殊的符号作为一行语句的结束</p>
<p><strong>本文为作者原创 转载时请注明出处 谢谢</strong></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em>乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</em></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://code.newban.cn../../207.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="乱码三千">
      <meta itemprop="description" content>
      <meta itemprop="image" content="../../images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="乱码三千 – 分享实用IT技术">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="../../207.html" itemprop="url">硬件开发之个人PCB电路板制作</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-01-07T16:14:19+08:00">
                2021-01-07
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h2><h4 id="第一步-画电路原理图"><a href="#第一步-画电路原理图" class="headerlink" title="第一步 画电路原理图"></a>第一步 画电路原理图</h4><ol>
<li><p>工具</p>
<p><strong>Altium Designer 19</strong>: 中文官网：<a href="https://www.altium.com.cn/products/downloads" target="_blank" rel="noopener">https://www.altium.com.cn/products/downloads</a> </p>
</li>
</ol>
<h4 id="第二步-联系PCB厂家"><a href="#第二步-联系PCB厂家" class="headerlink" title="第二步 联系PCB厂家"></a>第二步 联系PCB厂家</h4><ol>
<li>廉价厂家推荐<ul>
<li><a href="https://www.jlc.com/" target="_blank" rel="noopener">嘉立创</a> :10x10cm的板子5张 只需5块钱</li>
<li><a href="https://www.jiepei.com" target="_blank" rel="noopener">捷配</a>  :10x10cm的板子5张 19块钱</li>
</ul>
</li>
</ol>
<h4 id="第三步-电子元器件采购"><a href="#第三步-电子元器件采购" class="headerlink" title="第三步 电子元器件采购"></a>第三步 电子元器件采购</h4><h4 id="第四步-电子元器件焊接"><a href="#第四步-电子元器件焊接" class="headerlink" title="第四步 电子元器件焊接"></a>第四步 电子元器件焊接</h4><h4 id="第四步-电路板测试"><a href="#第四步-电路板测试" class="headerlink" title="第四步 电路板测试"></a>第四步 电路板测试</h4><p><strong>本文为作者原创 转载时请注明出处 谢谢</strong></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em>乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</em></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://code.newban.cn../../206.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="乱码三千">
      <meta itemprop="description" content>
      <meta itemprop="image" content="../../images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="乱码三千 – 分享实用IT技术">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="../../206.html" itemprop="url">硬件开发之基础知识(-)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-01-06T16:14:19+08:00">
                2021-01-06
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>随着智能家居的兴起,5G时代的到来, 智能硬件扮演者越来越关键的角色, 对于老百姓的我们而言,占据先机最好的办法的就是了解并掌握它, 因为知识是公平的</p>
<h2 id="基础物理知识"><a href="#基础物理知识" class="headerlink" title="基础物理知识"></a>基础物理知识</h2><p>这些我们在学生时代都学过,现在需要把它们都重新拾起来</p>
<h4 id="1-电压"><a href="#1-电压" class="headerlink" title="1. 电压"></a>1. 电压</h4><p>可以理解为电子移动的动力,压力即是动力,单位:V</p>
<h4 id="2-电流"><a href="#2-电流" class="headerlink" title="2. 电流"></a>2. 电流</h4><p> 电荷的定向流动 ,犹如水流</p>
<p>流动的电才能将电灯点亮</p>
<p>单位:A</p>
<h4 id="3-电的产生"><a href="#3-电的产生" class="headerlink" title="3.电的产生"></a>3.电的产生</h4><p>产生电的方式有很多种,摩擦生电,电解质生电,一般我们日常使用的电,是通过发电机发电,它的原理是:</p>
<p> 闭合电路的一部分导体在磁场里做切割磁感线的运动时，导体中就会产生电流</p>
<p>材料:</p>
<pre><code>1. 磁铁
 2. 线圈</code></pre><p>自制发电机:<a href="https://v.163.com/static/1/VYUIDVSRG.html" target="_blank" rel="noopener">https://v.163.com/static/1/VYUIDVSRG.html</a></p>
<h2 id="电子元器件"><a href="#电子元器件" class="headerlink" title="电子元器件"></a>电子元器件</h2><p>分类:</p>
<ul>
<li>元件:工厂在加工时没改变原材料分子成分的产品可称为元件。元件属于不需要能源的器件。它包括：电阻、电容、电感等</li>
<li>器件:工厂在生产加工时改变了原材料分子结构的产品称为器件。器件需要消耗能源,它包括双极性晶体三极管 场效应晶体管 可控硅 等</li>
</ul>
<h4 id="常见电子元器件"><a href="#常见电子元器件" class="headerlink" title="常见电子元器件"></a>常见电子元器件</h4><ol>
<li>电阻</li>
<li>电容</li>
<li>二极管</li>
<li>三极管</li>
<li>继电器</li>
<li>电容器</li>
<li>电位器</li>
<li>传感器</li>
<li></li>
</ol>
<h3 id="电流的的流向判断"><a href="#电流的的流向判断" class="headerlink" title="电流的的流向判断"></a>电流的的流向判断</h3><p><strong>第一步</strong>:判断是否有一条电路直接将正负极向连,如果有则短路,没有则进入第二步</p>
<p><strong>第二步</strong>:在电流分叉路口,判断是否有一条电路没有连接任何元器件,如果有则走这条路,其他路不通, 如果都连接了器件,那么都有电流通过</p>
<h2 id="串联和并联电路"><a href="#串联和并联电路" class="headerlink" title="串联和并联电路"></a>串联和并联电路</h2><p> 1.串联电路的特点：<br>（1）电流：文字表达：串联电路中各处电流都相等.<br>公式表达：I=I1=I2=I3=……=In<br>（2）电压：文字表达：串联电路中的总电压等于各部分电路电压之和.<br>公式表达：U=U1+U2+U3+……+Un<br>（3）电阻：文字表达：串联电路中的总电阻等于各部分电路的电阻之和.<br>公式表达：R=R1+R2+R3+……+Rn<br>（4）分压定律：文字表达：串联电路中各部分电路两端电压与其电阻成正比.<br>公式表达：U1/R1=U2/R2=U3/R3=.=Un/Rn<br>另种表达：U1：U2：U3：…：Un= R1：R2：R3：…：Rn<br>特例：U1/U2=R1/R2<br>2.并联电路的特点：<br>（1）电流：文字表达：并联电路中总电流等于各支路中的电流之和.<br>公式表达：I=I1+I2+I3+……+In<br>（2）电压：文字表达：并联电路中各支路两端的电压都相等.<br>公式表达：U=U1=U2=U3=……=Un<br>（3）电阻：文字表达：并联电路总电阻的倒数等于各支路电阻倒数之和.<br>公式表达：1/R=1/R1+1/R2+1/R3+……+1/Rn<br>（4）分流定律：文字表达：并联电路中,流过各支路的电流与其电阻成反比.<br>公式表达：I1R1=I2R2=I3R3= …=InRn<br>特例：I1/I2=R2/R1 </p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>在串联电路中</p>
<ul>
<li>电阻越大,截取的电压越大</li>
</ul>
<p>在并联电路中</p>
<ul>
<li>电阻越大, 截取的电流越小</li>
<li>分支电路越多,总电流越大</li>
</ul>
<p><strong>本文为作者原创 转载时请注明出处 谢谢</strong></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em>乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</em></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://code.newban.cn../../203.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="乱码三千">
      <meta itemprop="description" content>
      <meta itemprop="image" content="../../images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="乱码三千 – 分享实用IT技术">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="../../203.html" itemprop="url">关于字节和字长以及半字的关系</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-01-05T16:14:19+08:00">
                2021-01-05
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="关于字节"><a href="#关于字节" class="headerlink" title="关于字节"></a>关于字节</h2><p>一个字节是固定为8个二进制位</p>
<h2 id="关于字-word"><a href="#关于字-word" class="headerlink" title="关于字(word)"></a>关于字(word)</h2><p>字的长度是可变的,它和cpu一次性能操作的实际位数有关</p>
<p>比如16位的cpu一次能操作16位数,因次2个字节代表一个字</p>
<p>如果是32位cpu,那么32位也就是4个字节代表一个字的长度(word)</p>
<h2 id="关于半字"><a href="#关于半字" class="headerlink" title="关于半字"></a>关于半字</h2><p>半字即为字长的一半,在16位cpu中,半字即为一个字节,故在16位中没有半字这个说法,一半32位以上cpu环境中常用</p>
<p><strong>本文为作者原创 转载时请注明出处 谢谢</strong></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em>乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</em></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://code.newban.cn../../205.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="乱码三千">
      <meta itemprop="description" content>
      <meta itemprop="image" content="../../images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="乱码三千 – 分享实用IT技术">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="../../205.html" itemprop="url">ARM原生汇编与ARM GNU汇编的区分</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-01-05T16:14:19+08:00">
                2021-01-05
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="一、ARM汇编开发的两种的方式"><a href="#一、ARM汇编开发的两种的方式" class="headerlink" title="一、ARM汇编开发的两种的方式"></a>一、ARM汇编开发的两种的方式</h2><p>ARM汇编开发指用ARM提供的汇编指令，进行ARM程序的开发。</p>
<p>ARM汇编开发，有两种开发方式，一种是使用ARM汇编，一种是使用ARM GNU汇编。两种汇编开发，使用的汇编指令是完全一样的，区别是宏指令，伪指令，伪操作不一样。其实两种开发方式的区别在于所使用的编译工具不一样。</p>
<p>对于ARM汇编，使用的是ARM公司开发的编译器，而ARM GNU汇编，是使用GNU为ARM指令集开发的编译器，也就是arm-gcc。</p>
<h2 id="二、ARM的编译开发环境"><a href="#二、ARM的编译开发环境" class="headerlink" title="二、ARM的编译开发环境"></a>二、ARM的编译开发环境</h2><p>两种常用的ARM的编译开发环境</p>
<ul>
<li>DS5：ARM提供的集成开发软件。使用的是ARM提供的工具链进行程序编译</li>
<li>GNU开发环境： 由GNU的汇编器as，交叉编译器gcc，和链接器ld等组成</li>
</ul>
<h2 id="三、伪操作，宏指令，伪指令"><a href="#三、伪操作，宏指令，伪指令" class="headerlink" title="三、伪操作，宏指令，伪指令"></a>三、伪操作，宏指令，伪指令</h2><p>伪操作：ARM汇编语言程序里的一些特殊指令助记符，其作用主要是完成汇编程序做各种准备工作，在源程序进行汇编时由汇编程序处理，而不是在计算机运行期间由机器执行。如程序段的定义，就属于伪操作。</p>
<p>宏指令：一段独立的程序代码，可插在源程序中，通过伪操作来定义。</p>
<p>伪指令：ARM汇编语言程序里的一些特殊指令助记符，不在处理器运行期间执行，在汇编时，被合适的ARM的机器指令代替，从而实现真正的指令操作。</p>
<h2 id="四、ARM原生汇编伪操作"><a href="#四、ARM原生汇编伪操作" class="headerlink" title="四、ARM原生汇编伪操作"></a>四、ARM原生汇编伪操作</h2><table>
<thead>
<tr>
<th>伪操作</th>
<th>语法格式</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>GBLA</td>
<td>GBLA  Varible</td>
<td>声明一个全局的算术变量，并将其初始化为0</td>
</tr>
<tr>
<td>GBLL</td>
<td>GBLL  Varible</td>
<td>声明一个全局的逻辑变量，并将其初始化成{FALSE}</td>
</tr>
<tr>
<td>GBLS</td>
<td>GBLS  Varible</td>
<td>声明一个全局的字符串变量，并将其初始化成空串</td>
</tr>
<tr>
<td>LCLA</td>
<td>LCLA  Varible</td>
<td>声明一个局部的算术变量，并将其初始化为0</td>
</tr>
<tr>
<td>LCLL</td>
<td>LCLL  Varible</td>
<td>声明一个局部的逻辑变量，并将其初始化成{FALSE}</td>
</tr>
<tr>
<td>LCLS</td>
<td>LCLS  Varible</td>
<td>声明一个局部的字符串变量，并将其初始化成空串</td>
</tr>
<tr>
<td>SETA</td>
<td>SETA  Varible  expr</td>
<td>给一个全局或局部算术变量赋值</td>
</tr>
<tr>
<td>SETL</td>
<td>SETL  Varible  expr</td>
<td>给一个全局或局部逻辑变量赋值</td>
</tr>
<tr>
<td>SETS</td>
<td>SETS  Varible  expr</td>
<td>给一个全局或局部字符串变量赋值</td>
</tr>
<tr>
<td>RLIST</td>
<td>name LIST {list of registers}</td>
<td>为一个通用寄存器列表定义名称</td>
</tr>
<tr>
<td>CN</td>
<td>name CN expr</td>
<td>为一个协处理器的寄存器定义名称</td>
</tr>
<tr>
<td>CP</td>
<td>name CP expr</td>
<td>为一个协处理器定义名称</td>
</tr>
<tr>
<td>DN/SN</td>
<td>name DN/SN expr</td>
<td>DN/SN为一个双精度/单精度的VFP寄存器定义名称</td>
</tr>
<tr>
<td>FN</td>
<td>name FN  expr</td>
<td>为一个FPA浮点寄存器定义名称</td>
</tr>
<tr>
<td>LTORG</td>
<td>LTONG</td>
<td>声明一个数据缓冲池（文字池）的开始</td>
</tr>
<tr>
<td>MAP</td>
<td>MAP expr {, base-register}</td>
<td>定义一个结构化的内存表(storage map)的首地址</td>
</tr>
<tr>
<td>FIELD</td>
<td>{label}  FIELF  expr</td>
<td>定义一个结构化内存表中的数据域</td>
</tr>
<tr>
<td>SPACE</td>
<td>{label}  SPACE  expr</td>
<td>分配一块连续内存单元，并用0初始化</td>
</tr>
<tr>
<td>DCB</td>
<td>{label}  DCB  expr {,expr}..</td>
<td>分配一块字节内存单元，并用expr初始化</td>
</tr>
<tr>
<td>DCD/ DCDU</td>
<td>{label} DCD/DCDU expr {,expr}…</td>
<td>分配一块字内存单元， 并用expr初始化</td>
</tr>
<tr>
<td>DCDO</td>
<td>{label}  DCDO  expr {,expr}…</td>
<td>分配一块字对齐的字内存单元， 并用expr初始化</td>
</tr>
<tr>
<td>DCFD/DCFDU</td>
<td>{label}  DCFD{U}  fpliteral ,{,fpliteral}…</td>
<td>为双精度的浮点数分配字对齐的内存单元</td>
</tr>
<tr>
<td>DCFS/DCFSU</td>
<td>{label}   DCFS{U}  fpliteral,{,fpliteral}…</td>
<td>为单精度的浮点数分配字对齐的内存单元</td>
</tr>
<tr>
<td>DCI</td>
<td>{label} DCI expr, {expr}…</td>
<td>ARM代码分配一段字对齐的内存单元，填充expr（二进制指令码），THUMB代码中，分配一段半字对齐的半字内存单元。</td>
</tr>
<tr>
<td>DCQ/ DCQU</td>
<td>{label} DCQ{U}  {-} literal, {, {-} literal}…</td>
<td>分配一段以双字（8个字节）为单位的内存</td>
</tr>
<tr>
<td>DCW/DCWU</td>
<td>{label} DCW{U}  {-} literal, {, {-} literal}…</td>
<td>DCW用于分配一段半字对齐的半字内存单元</td>
</tr>
</tbody></table>
<h3 id="1、AREA"><a href="#1、AREA" class="headerlink" title="1、AREA"></a>1、AREA</h3><p>创建一段新的程序代码或数据区。</p>
<p>格式 ： </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AREA  name, &#123;,attr,&#125; …</span><br></pre></td></tr></table></figure>

<p>其中，name是程序段名， atrr是段名属性</p>
<p>对于属性，有以下一些：</p>
<ul>
<li>CODE： 用于定义代码段，默认为是READONLY</li>
<li>DATA： 用于定于数据段，默认为READWRITE</li>
<li>READONLY: 指定本段的内容只读</li>
<li>READWRITE：  指定本段的内容可读可写</li>
<li>ALIGN:  指定对齐为2次幂</li>
<li>COMMON: 定义通用的段。不包含任何用户的代码和数据。各源文件中同名的COMMON属性段共享同一段存储单元</li>
</ul>
<h3 id="2、ALIGN"><a href="#2、ALIGN" class="headerlink" title="2、ALIGN"></a>2、ALIGN</h3><p>指定对齐</p>
<p>  ALIGN  4  表示4字节地址对齐</p>
<p>  ALIGN  8  表示8字节地址对齐</p>
<p>  注意：在AREA中使用和单独使用ALIGN的区别，在于格式和对齐的计算不一样。</p>
<h3 id="3、ENTRY"><a href="#3、ENTRY" class="headerlink" title="3、ENTRY"></a>3、ENTRY</h3><p>指定汇编程序的入口。</p>
<p>一个程序至少有一个入口点，也可以有多个入口点，但是在一个源文件中，最多只能有一个ENTRY。当多个源文件均有ENTRY时，由链接器指定程序真正的入口。</p>
<h3 id="4、END"><a href="#4、END" class="headerlink" title="4、END"></a>4、END</h3><p>表示源程序的结束</p>
<p>所以汇编语言源文件必须以END结束，汇编器遇到END, 将结束编译。</p>
<h3 id="5、EXPORT"><a href="#5、EXPORT" class="headerlink" title="5、EXPORT"></a>5、EXPORT</h3><p>格式：　EXPORT  标号  [,WEAK]</p>
<p>声明一个全局标号，其他源文件可以使用这个标号。WEAK表示碰上其他同名标号时，其他标号优先。</p>
<h3 id="6、IMPORT"><a href="#6、IMPORT" class="headerlink" title="6、IMPORT"></a>6、IMPORT</h3><p>格式:  IMPORT 标号，[,WEAK]</p>
<p>表示该引用的标号在其他源文件中，单要在当前文件中引用。WEAK表示找不到该标号时，也不报错，一般该标号置为0，如果是B 或BL指令用到该标号，该指令置为nop。</p>
<p>该标号会加入到当前源文件的符号表中。</p>
<h3 id="7、EXTERN"><a href="#7、EXTERN" class="headerlink" title="7、EXTERN"></a>7、EXTERN</h3><p>和IMPORT一样，不同在于，如果当前文件没有引用该标号，该标号不会加入到当前源文件的符号表中。</p>
<h3 id="8、GET-或INCLUDE"><a href="#8、GET-或INCLUDE" class="headerlink" title="8、GET(或INCLUDE)"></a>8、GET(或INCLUDE)</h3><p>将一个源文件含到当前的源文件中</p>
<h3 id="9、EQU"><a href="#9、EQU" class="headerlink" title="9、EQU"></a>9、EQU</h3><p>对一个常量标号赋值</p>
<p>格式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">name  EQU  expression</span><br></pre></td></tr></table></figure>

<p>其中： name符号名， expression寄存器相关或者程序相关的固定值</p>
<p>如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">num  EQU  2  ;  为符号赋予数字2</span><br></pre></td></tr></table></figure>

<p>EQU，等同于C语言中用#define定义一个常量</p>
<h3 id="10、SPCAE"><a href="#10、SPCAE" class="headerlink" title="10、SPCAE"></a>10、SPCAE</h3><p>用于分配一片连续内存单元，并用0初始化。SPACE可用%代替。</p>
<p>格式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;label&#125; SPACE expr</span><br></pre></td></tr></table></figure>

<p>label ： 是一个标号, 可选</p>
<p>expr：  分配的内存字节数</p>
<p>如</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stack SPACE 100 ； 分配100个字节内存单元，并用0初始化。标号stack是这片空间的起始地址</span><br></pre></td></tr></table></figure>

<h3 id="11、DCB"><a href="#11、DCB" class="headerlink" title="11、DCB"></a>11、DCB</h3><p>用于分配段字节内存单元，并用伪操作中的expr初始化。</p>
<p>格式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;label&#125; DCB expr &#123;,expr&#125;</span><br></pre></td></tr></table></figure>

<p>label： 是一个标号，可选</p>
<p>expr： 可以是-128~255的数值或者字符串</p>
<p>如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">string  DCB  &quot;HELLO&quot;  ;为HELLO字符串分配空间， string是这块空间的起始地址</span><br></pre></td></tr></table></figure>

<h3 id="12、DCD及DCDU"><a href="#12、DCD及DCDU" class="headerlink" title="12、DCD及DCDU"></a>12、DCD及DCDU</h3><p>用于分配段字内存单元（分配的内存都是字对齐，DCDU并不严格字对齐），并用伪操作中的expr初始化。 DCD 可用 &amp; 代替。</p>
<p>格式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;label&#125; DCD expr, &#123;,expr&#125;</span><br></pre></td></tr></table></figure>

<p>label: 是一个标号，可选，表示这块内存单元的首地址</p>
<p>expr： 数字表达式或程序中的标号</p>
<p>如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data DCD  1,2,3,4   ;分配字对齐的字单元空间，初始化为1，2，3，4</span><br></pre></td></tr></table></figure>

<h2 id="五、ARM原生汇编伪指令"><a href="#五、ARM原生汇编伪指令" class="headerlink" title="五、ARM原生汇编伪指令"></a>五、ARM原生汇编伪指令</h2><p>ARM伪指令包括： ADR, ADRL,LDR ,NOP</p>
<p>THUMB伪指令包括：ADR, LDR, NOP</p>
<table>
<thead>
<tr>
<th>伪指令</th>
<th>语法格式</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>ADR</td>
<td>ADR{cond} register, expr</td>
<td>将基于PC或基于寄存器的地址值读取到寄存器中。小范围的地址读取</td>
</tr>
<tr>
<td>ADRL</td>
<td>ADRL{cond} register, expr</td>
<td>将给予PC或基于寄存器的地址值读取到寄存器中。中等范围的地址读取</td>
</tr>
<tr>
<td>LDR</td>
<td>LDR {cond} register, =[expr|label]</td>
<td>将一个32位的立即数或者一个地址值读取到寄存器中。大范围的地址读取</td>
</tr>
<tr>
<td>NON</td>
<td>NOP</td>
<td>在汇编时，被替换成空操作</td>
</tr>
</tbody></table>
<h2 id="六、ARM-GNU编译环境"><a href="#六、ARM-GNU编译环境" class="headerlink" title="六、ARM GNU编译环境"></a>六、ARM GNU编译环境</h2><table>
<thead>
<tr>
<th>伪操作</th>
<th>语法格式</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>.byte</td>
<td>.byte expr {,expr}…</td>
<td>分配一段字节内存单元，并用expr初始化</td>
</tr>
<tr>
<td>.hword/.short</td>
<td>.hword expr {,expr}…</td>
<td>分配一段半字内存单元，并用expr初始化</td>
</tr>
<tr>
<td>.ascii</td>
<td>.ascii expr {,expr}…</td>
<td>定义字符串expr</td>
</tr>
<tr>
<td>.asciz/.string</td>
<td>.asciz expr {,expr}…</td>
<td>定义字符串expr（会增加/0为结束符）</td>
</tr>
<tr>
<td>.floar/.single</td>
<td>.float expr {,expr}…</td>
<td>定义32bit IEEE浮点数expr</td>
</tr>
<tr>
<td>.double</td>
<td>.doubel expr {,expr}…</td>
<td>定义64bit IEEE浮点数expr</td>
</tr>
<tr>
<td>.word/.long/.int</td>
<td>.word expr {,expr}…</td>
<td>分配一段字内存单元，并用expr初始化</td>
</tr>
<tr>
<td>.fill</td>
<td>.fill  repeat {,size} {,value}</td>
<td>分配一段字节内存单元，用sieze长度value填充repeat次</td>
</tr>
<tr>
<td>.zero</td>
<td>.zero size</td>
<td>分配一段字节内存单元，并用0填充内存</td>
</tr>
<tr>
<td>.space/.skip</td>
<td>.space size, {,value}</td>
<td>分配一段内存单元，用value将内存初始化</td>
</tr>
<tr>
<td>.section</td>
<td>.section expr</td>
<td>定义一个段</td>
</tr>
<tr>
<td>.text</td>
<td>.text {subsection}</td>
<td>代码段，</td>
</tr>
<tr>
<td>.data</td>
<td>.data{subsection}</td>
<td>数据段</td>
</tr>
<tr>
<td>.bss</td>
<td>.bss{subsection}</td>
<td>bss段</td>
</tr>
<tr>
<td>.cond 16/.thumb</td>
<td>.code 16/.thumb</td>
<td>表示之后的汇编指令使用THUMB指令集</td>
</tr>
<tr>
<td>.code 32/.arm</td>
<td>.code 32/.arm</td>
<td>表示之后的汇编指令使用ARM指令集</td>
</tr>
<tr>
<td>.end</td>
<td>.end</td>
<td>标记汇编文件的结束</td>
</tr>
<tr>
<td>.include</td>
<td>.include “filename”</td>
<td>将一个源文件包含到当前源文件中</td>
</tr>
<tr>
<td>.align/.balign</td>
<td>.align {alignment} {,fill},{max}</td>
<td>通过填充字节使当前位置满足一定的对齐格式</td>
</tr>
</tbody></table>
<h2 id="七、两种开发环境的区别"><a href="#七、两种开发环境的区别" class="headerlink" title="七、两种开发环境的区别"></a>七、两种开发环境的区别</h2><p>两种开发环境下的汇编代码，有较多不同的点，主要是符号及伪操作的不同。</p>
<table>
<thead>
<tr>
<th>ARM汇编的伪操作符</th>
<th>GNU汇编的伪操作符</th>
</tr>
</thead>
<tbody><tr>
<td>INLCUDE</td>
<td>.include</td>
</tr>
<tr>
<td>NUM   EQU  25</td>
<td>.equ  NUM,  25</td>
</tr>
<tr>
<td>EXPORT</td>
<td>.global</td>
</tr>
<tr>
<td>IMPORT</td>
<td>.extern</td>
</tr>
<tr>
<td>DCD</td>
<td>.long</td>
</tr>
<tr>
<td>IF:  DEF:</td>
<td>.ifdef</td>
</tr>
<tr>
<td>ELSE</td>
<td>.else</td>
</tr>
<tr>
<td>ENDIF</td>
<td>.endif</td>
</tr>
<tr>
<td>OR</td>
<td>|</td>
</tr>
<tr>
<td>SHL</td>
<td>&lt;&lt;</td>
</tr>
<tr>
<td>RN</td>
<td>.req</td>
</tr>
<tr>
<td>GBLA</td>
<td>.global</td>
</tr>
<tr>
<td>NUM  SETA 16</td>
<td>.equ  NUM , 16</td>
</tr>
<tr>
<td>MACRO</td>
<td>.macro</td>
</tr>
<tr>
<td>MEND</td>
<td>.endm</td>
</tr>
<tr>
<td>END</td>
<td>.end</td>
</tr>
<tr>
<td>AREA WORD, CODE, READONLY</td>
<td>.text</td>
</tr>
<tr>
<td>AREA BLOCK, DATE, READWRITE</td>
<td>.data</td>
</tr>
<tr>
<td>CODE32</td>
<td>.arm</td>
</tr>
<tr>
<td>CODE16</td>
<td>.thumb</td>
</tr>
<tr>
<td>LTORG</td>
<td>.ltorg</td>
</tr>
<tr>
<td>%</td>
<td>.fill</td>
</tr>
<tr>
<td>ENTRY</td>
<td>ENTRY:</td>
</tr>
<tr>
<td>ldr x0,=0xff</td>
<td>ldr x0,=0xff</td>
</tr>
</tbody></table>
<p><strong>本文为作者原创 转载时请注明出处 谢谢</strong></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em>乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</em></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://code.newban.cn../../204.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="乱码三千">
      <meta itemprop="description" content>
      <meta itemprop="image" content="../../images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="乱码三千 – 分享实用IT技术">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="../../204.html" itemprop="url">汇编语言之ARM32汇编</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-01-05T16:14:19+08:00">
                2021-01-05
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="ARM两种编译环境"><a href="#ARM两种编译环境" class="headerlink" title="ARM两种编译环境"></a>ARM两种编译环境</h2><p>两种常用的ARM的编译开发环境</p>
<ul>
<li>ARM原生编译环境：ARM官方提供的原生编译环境,相关集成开发软件有ADS,Keil等,常用于ARM单片机开发</li>
<li>GNU编译环境： 由GNU的汇编器as,交叉编译器gcc,和链接器ld等组成,一般适用于交叉编译环境需求 </li>
</ul>
<p>以上两种编译环境,使用的指令集都是一致的, 只是语法格式有不同,也就是宏指令,伪指令,伪操作不一样</p>
<h2 id="ARM原生环境搭建"><a href="#ARM原生环境搭建" class="headerlink" title="ARM原生环境搭建"></a>ARM原生环境搭建</h2><p>使用 Keil μVision5 这款软件进行ARM32的汇编学习</p>
<p>下载地址:<a href="http://www.mcuzone.com/down/Software.asp?ID=10000503" target="_blank" rel="noopener">http://www.mcuzone.com/down/Software.asp?ID=10000503</a></p>
<h2 id="ARM32系列命名"><a href="#ARM32系列命名" class="headerlink" title="ARM32系列命名"></a>ARM32系列命名</h2><table>
<thead>
<tr>
<th align="center">ARM产品</th>
<th align="center">ARM架构</th>
</tr>
</thead>
<tbody><tr>
<td align="center">ARM7</td>
<td align="center">ARM v4</td>
</tr>
<tr>
<td align="center">ARM9</td>
<td align="center">ARM v5</td>
</tr>
<tr>
<td align="center">ARM11</td>
<td align="center">ARM v6</td>
</tr>
<tr>
<td align="center">Cortex-A</td>
<td align="center">ARM v7-A</td>
</tr>
<tr>
<td align="center">Cortex-R</td>
<td align="center">ARM v7-R</td>
</tr>
<tr>
<td align="center">Cortex-M</td>
<td align="center">ARM v7-M</td>
</tr>
</tbody></table>
<h2 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h2><p>在ARM32中一共有37个寄存器,其中包含16个通用寄存器(R0~R15)和1个状态寄存器 ,15个通用影子寄存器,5个状态影子寄存器</p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20210105183952.png" alt></p>
<h4 id="影子寄存器"><a href="#影子寄存器" class="headerlink" title="影子寄存器"></a>影子寄存器</h4><p>如上图所示,在ARM32中一共有7中不同的处理器模式,分别为:<strong>用户模式</strong>（User）,<strong>快速中断模式</strong>（FIQ）,<strong>普通中断模式</strong>（IRQ）,<strong>管理模式</strong>（Svc）,<strong>数据访问中止模式</strong>（Abort）,<strong>未定义指令中止模式</strong>（Und）,<strong>系统模式</strong>（Sys)</p>
<p> 但是在不同的模式下,同样的一个寄存器名称指向不同的物理寄存器,这些不同的物理寄存器就被称之为影子寄存器</p>
<p>由于这些影子寄存器也属于通用寄存器的范畴, <strong>因此很多人也将ARM32的通用寄存器归纳为31个</strong> </p>
<h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><ol>
<li><p>注释(两种方式)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">; 我是注释</span><br><span class="line"></span><br><span class="line">/*…我是注释..*/</span><br></pre></td></tr></table></figure>
</li>
<li><p>声明一个代码段</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> 	AREA test, CODE	 ;声明一个代码段,段的名称为test(名称可自定义),CODE关键字大小写都可,为了区分,一般大写</span><br><span class="line">   </span><br><span class="line">;=========在此编写汇编代码==========</span><br><span class="line"></span><br><span class="line">   END			;END表示编译结束标记</span><br><span class="line">   </span><br><span class="line">   </span><br><span class="line">   ;段的声明需要以制表符开头,前面留出空</span><br></pre></td></tr></table></figure>
</li>
<li><p>数据表示</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mov R0,#13 ;将十进制13赋值给R0寄存器</span><br><span class="line"></span><br><span class="line">mov R0,#0x13 ;将十六进制0x13赋值给R0寄存器</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">mov R0,#8_12 ;将8进制数12赋值给R0寄存器  N进制则为#N_xxx</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">mov R0,#&apos;a&apos; ;将字符a对应的ascii码值传送给R0寄存器</span><br></pre></td></tr></table></figure>
</li>
<li><p>函数声明和调用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">  	AREA test, CODE</span><br><span class="line">  	</span><br><span class="line">  	</span><br><span class="line">	bl print ;函数调用 </span><br><span class="line"></span><br><span class="line">print ;函数名称</span><br><span class="line">	mov R3,#5</span><br><span class="line"> 	bx lr</span><br><span class="line">    END			;END表示编译结束标记</span><br></pre></td></tr></table></figure>


</li>
</ol>
<ol start="5">
<li><p>声明一个数据段</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">AREA da, DATA	 ;声明一个数据段 默认可读可写状态</span><br><span class="line"> 	;数据定义伪操作</span><br></pre></td></tr></table></figure>


</li>
</ol>
<ol start="6">
<li><p>数据定义</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># DCB   </span><br><span class="line">Str DCB &quot;This is a test！&quot; ;分配一片连续的字节存储单元并初始化。取名为Str 类似于8086中的db</span><br><span class="line">Str = &quot;This is a test！&quot;   ;DCB也可用等号代替</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#DCW</span><br><span class="line">Str DCW 1,2,3 ;定义字型数据 每个字符占用2个字节的空间</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#DCD</span><br><span class="line">Str DCD 1,2,3 ;定义半字型数据 每个字符占用4个字节的空间</span><br></pre></td></tr></table></figure>

<blockquote>
<p>字符串必须使用DCB进行定义</p>
</blockquote>
</li>
<li><p>分配一块连续的内存空间</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sp1 SPACE 100 ;分配一块连续100个字节的空间</span><br><span class="line">   </span><br><span class="line">   ;或者使用%代替SPACE简写</span><br><span class="line">   sp1 % 100 ;分配一块连续100个字节的空间</span><br></pre></td></tr></table></figure>






</li>
</ol>
<h2 id="代码编写规范"><a href="#代码编写规范" class="headerlink" title="代码编写规范"></a>代码编写规范</h2><ol>
<li>所有指令和伪指令不允许顶格</li>
<li>所有变量和标签必须顶格</li>
<li>一般我们将伪指令大写,变量和标签小写</li>
</ol>
<h2 id="内存数据的读写"><a href="#内存数据的读写" class="headerlink" title="内存数据的读写"></a>内存数据的读写</h2><ol>
<li><p>从内存中读取数据</p>
<p><strong>使用中括号表示通过地址取值</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">LDR R0,[R1]               ;将内存地址为R1的字数据读入寄存器R0。</span><br><span class="line">LDR R0,[R1,R2]       ;将内存地址为R1+R2的字数据读入寄存器R0。</span><br><span class="line"></span><br><span class="line">LDR R0,[R1,#8]        ;将内存地址为R1+8的字数据读入寄存器R0。</span><br><span class="line">LDR R0,[R1,R2]!    ;将内存地址为R1+R2的字数据读入寄存器R0,并将新地 址R1＋R2写入R1。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">LDR R0,[R1,＃8]!   ;将内存地址为R1+8的字数据读入寄存器R0,并将新地址 R1＋8写入R1。</span><br><span class="line"></span><br><span class="line">LDR R0,[R1],R2        ;将内存地址为R1的字数据读入寄存器R0,并将新地址 R1＋R2写入R1。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">LDR R0,[R1,R2,LSL＃2]!   ;将内存地址为R1＋R2×4的字数据读入寄存器R0,并将新地址R1＋R2×4写入R1。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">LDR R0,[R1],R2,LSL＃2      ;将内存地址为R1的字数据读入 寄存器R0,并将新地址R1＋R2×4写入R1。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">;从标号即为地址</span><br><span class="line">   LDR R0,label ;将标号对应的内容赋值给R0</span><br></pre></td></tr></table></figure>

</li>
</ol>
<blockquote>
<p>复杂格式如LDR R0,[R1],R2,LSL＃2    其中 []运算优先<br>2. 向内存中写入数据<br>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">STR R0,[R1],＃8           ;将R0中的字数据写入以R1为地址的内存中,并 将新地址R1＋8写入R1。</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> STR R0,[R1,＃8]          ;将R0中的字数据写入以R1＋8为地址的内存中。</span><br><span class="line"> </span><br><span class="line"> STRB    R0,[R1]             ;将寄存器R0中的字节数据写入以R1为地 址的内存中。</span><br><span class="line"> STRB    R0,[R1,＃8]     ;将寄存器R0中的字节数据写入以R1＋8为地址的存 储器中。  </span><br><span class="line"> STR R0,[R1],＃8           ;将R0中的字数据写入以R1为地址的内存中,并 将新地址R1＋8写入R1。</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> STR R0,[R1,＃8]          ;将R0中的字数据写入以R1＋8为地址的内存中。</span><br><span class="line"> </span><br><span class="line"> STRB    R0,[R1]             ;将寄存器R0中的字节数据写入以R1为地 址的内存中。</span><br><span class="line"> STRB    R0,[R1,＃8]     ;将寄存器R0中的字节数据写入以R1＋8为地址的存 储器中。</span><br></pre></td></tr></table></figure></p>
</blockquote>
<h2 id="LDR伪指令"><a href="#LDR伪指令" class="headerlink" title="LDR伪指令"></a>LDR伪指令</h2><p>这个指令和内存读取指令长的一模一样,如果我们在使用的时候加个等号,那么它就是另外一个指令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">;如果不加等号 是内存读取功能</span><br><span class="line">LDR R0,label ;获取标签所对应的内存数据赋给R0  </span><br><span class="line"></span><br><span class="line">;一旦加了等号,则变成了传送指令</span><br><span class="line">LDR R0,=label ;将标号对应的实际物理地址值赋值给R0 此时它的作用和mov无异</span><br><span class="line">LDR R0,=&apos;a&apos; ;直接将字符数据传送给R0</span><br></pre></td></tr></table></figure>

<p>实际上,加了等号的<code>LDR</code>指令,刚好可以弥补<code>mov</code>指令的不足, <code>mov</code>指令只能传送由八个二进制位右移而得的数据,而<code>LDR</code>则没有这个限制</p>
<p>也就是说如果我们想将一个数值传入寄存器,可以有两种方式:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">;第一种</span><br><span class="line">mov R1,#0X100</span><br><span class="line"></span><br><span class="line">;第二种</span><br><span class="line">ldr R1,=0x100 </span><br><span class="line"></span><br><span class="line">;mov指令的限制:只能传送由八个二进制位右移而得的数据, 也就相当于是两个十六进制数据,由于可以不断移位那么数据的大小可以伸缩,比如以下数据都可使用mov指令</span><br><span class="line">0x00000058  0x00000580 0x00005800  0x00058000 0x00580000 0x05800000 0x58000000 </span><br><span class="line">;我们发现一个规律:mov指令只能传送最大两个十六进制空间的数据,注意是空间,这两个数据随意你移动,一旦不满足这个条件则无法传送,比如</span><br><span class="line">0x00000581</span><br></pre></td></tr></table></figure>

<h4 id="LDR伪指令总结"><a href="#LDR伪指令总结" class="headerlink" title="LDR伪指令总结"></a>LDR伪指令总结</h4><p>作用:</p>
<ul>
<li>弥补mov指令的不足</li>
<li>获取数据所对应的内存地址</li>
</ul>
<h4 id="ADR指令"><a href="#ADR指令" class="headerlink" title="ADR指令"></a>ADR指令</h4><p>那么除了通过<code>LDR</code>伪指令来获取数据所在地址外还有一个指令也可以获取数据地址,那就是<code>adr</code>指令,但这个指令只能获取当前段内数据的地址,段外数据无法获取,<code>ldr</code>则没有这个限制</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">	AREA test2,CODE</span><br><span class="line">		mov R3,#8</span><br><span class="line">aaaa dcb 1,2,3</span><br><span class="line">		adr R0,aaaa ;获取aaaa首地址</span><br><span class="line">  	END</span><br></pre></td></tr></table></figure>

<h2 id="段的拓展"><a href="#段的拓展" class="headerlink" title="段的拓展"></a>段的拓展</h2><p> <strong>段属性拓展</strong></p>
<ol>
<li><strong>段读写属性</strong></li>
</ol>
<ul>
<li><p>READONLY</p>
<p>该段内存区域数据只能读取,不能写入,也就是如果使用内存读写指令,数据也写入不了</p>
</li>
<li><p>READWRITE</p>
<p>该段内存区域可读可写,不仅可以使用内存读写指令,还可以在调试的时候直接在memory窗口双击修改</p>
</li>
</ul>
<p>示例:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">AREA code, CODE,READWRITE ;将代码段内存区域设置为可读可写状态,如果不写默认为只读</span><br><span class="line">AREA code, DATA,READONLY ;将数据段内存区域设置为只读状态,如果不写默认为可读可写</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p><strong>段对齐属性 ALIGN</strong> </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AREA code, DATA,ALIGN=3  ;对齐数值范围为0~31</span><br></pre></td></tr></table></figure>

<p>该属性会使得该段的基地址进行相应的偏移,<code>ALIGN=3</code>表示基地址会在上一个段数据的基础之上偏移2^3=8个字节的位置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">   	 AREA test1,DATA  ;假设这个段的基地址为0x00000100</span><br><span class="line">STR1 = &quot;A&quot;  </span><br><span class="line"></span><br><span class="line">	 AREA test2,DATA   ;ALIGN默认为2 那么这个段的基地址为0x00000104</span><br><span class="line">STR2 = &quot;B&quot;</span><br><span class="line"></span><br><span class="line">	 AREA test3,DATA,ALIGN=8   ;这个段的基地址为0x0000010C</span><br><span class="line">STR2 = &quot;B&quot;</span><br></pre></td></tr></table></figure>

<p>我们可以简单理解为,使用ALIGN这个属性可以让我们给上一个段预留除一部分缓冲区域,以ALIGN=2为例,当上一个段中的数据超过4个字节时,当前段基地器会向后再偏移4个字节,避免数据被覆盖,也就是说内存数据位置会进行重新分布,那么我们可以通过这个值来设置内存数据刷新频率,<strong>值越低,内存利用率越高,但是内存刷新频率也越高,负荷加重,反之,内存浪费越大,但是内存数据不需要频繁重新分布</strong></p>
<p><strong>另外:</strong></p>
<p>除了在段属性中可以设置对齐之外,在指令中也可以插入ALGIN关键字:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">AREA code,CODE	   </span><br><span class="line">   </span><br><span class="line">   mov R0,R1</span><br><span class="line"></span><br><span class="line">	ALIGN 4,3  ;下一条指令4字节对齐,并且偏移3个字节 为了补满4个字节,用0填充剩余1个未偏移位置</span><br><span class="line">	mov R2,R0</span><br><span class="line">   </span><br><span class="line">END</span><br></pre></td></tr></table></figure>


</li>
</ol>
<p>   代码中使用AGLIN时用空格代替等号,同时单位为字节</p>
<p><strong>多个代码段入口区分</strong></p>
<p>当我们在同一个源文件中定义两个代码段时,程序从哪个段当做执行入口呢?</p>
<p>这个时候我们需要指定程序的入口,使用伪指令<code>entry</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> AREA test2,CODE </span><br><span class="line"></span><br><span class="line"> 	 	mov R0,#7</span><br><span class="line"></span><br><span class="line">  AREA test3,CODE </span><br><span class="line">entry  ;程序入口</span><br><span class="line">mov R0,#6</span><br><span class="line">mov R1,#0x00000100</span><br><span class="line">str R0,[R1]</span><br><span class="line">END</span><br></pre></td></tr></table></figure>

<h2 id="栈的操作"><a href="#栈的操作" class="headerlink" title="栈的操作"></a>栈的操作</h2><ol>
<li><strong>入栈</strong></li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">push &#123;R0&#125;  ;将R0中的值存入栈内存中  相当于是STR R0,[R13,#-4]</span><br><span class="line"></span><br><span class="line">入栈过程:</span><br><span class="line">* 第一步:将栈顶指针往低地址偏移四个字节</span><br><span class="line">* 第二步:将数据存入指针指向的内存空间</span><br></pre></td></tr></table></figure>

<ol>
<li><strong>出栈</strong></li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pop &#123;R0&#125;  ;将栈顶中的值取出存入R0寄存器 相当于是LDR R0,[R13],#0x0004</span><br><span class="line"></span><br><span class="line">出栈过程:</span><br><span class="line">* 第一步:将栈顶指针指向的内容取出存入寄存器</span><br><span class="line">* 第二步:将指针往高地址恢复四个字节</span><br></pre></td></tr></table></figure>

<blockquote>
<p>pop和push 本质上使用的是LDR和STR内存读写指令</p>
</blockquote>
<h4 id="对栈批量操作"><a href="#对栈批量操作" class="headerlink" title="对栈批量操作"></a>对栈批量操作</h4><p>如果想批量操作多个连续栈空间的话,直接使用逗号分隔开,连续标号的寄存器使用横杠分隔</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">push &#123;R0,R4-R12,LR&#125; ;大括号中寄存器从右往左LR R12...R4 R0依次存入</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">pop &#123;R0,R4-R12,PC&#125; ;从左往右取出</span><br></pre></td></tr></table></figure>

<p>除了使用<code>pop</code>和<code>push</code>之外,可以使用<code>STM</code>(store much)和<code>LDM</code>(load much)指令</p>
<p>格式:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">STM 起始地址/基地址寄存器,&#123;寄存器名称,多个寄存器以逗号或者-分割&#125; ;起始地址寄存器R0-R14任意选择</span><br></pre></td></tr></table></figure>

<p>示例:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">STMFD  R13!,&#123;R0,R4-R12,LR&#125;    ;将寄存器列表中的寄存器（R0,R4到 R12,LR）存入栈,。</span><br><span class="line">等价于</span><br><span class="line">push &#123;R0,R4-R12,LR&#125; ;大括号中寄存器从右往左存入</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">LDMFD  R13!,&#123;R0,R4-R12,PC&#125;     ;将栈内容恢复到寄存器（R0,R4到R12,LR）。           </span><br><span class="line">等价于</span><br><span class="line">pop &#123;R0,R4-R12,PC&#125; ;从左往右取出</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>pop</code>和<code>push</code>,它们内部也是转成<code>STM</code>和<code>LDM</code>指令:</p>
</blockquote>
<h4 id="批量存取指令扩展"><a href="#批量存取指令扩展" class="headerlink" title="批量存取指令扩展"></a>批量存取指令扩展</h4><p>相关后缀含义:</p>
<ul>
<li><strong>IA:（Increase After）</strong>:数据操作后基地址增4</li>
<li><strong>IB:（Increase Before）</strong>:数据操作前基地址增4</li>
<li><strong>DA:（Decrease After</strong>）:数据操作后基地址减4</li>
<li><strong>DB：（Decrease Before）</strong>:数据操作前基地址减4</li>
<li><strong>FD:</strong>  满递减堆栈 (相当于STMDB+LDMIA)</li>
<li><strong>FA:</strong>  满递增堆栈 (相当于STMIB+LDMDA)</li>
<li><strong>ED:</strong>  空递减堆栈(相当于STMDA+LDMIB)</li>
<li><strong>EA:</strong>  空递增堆栈 (相当于STMIA+LDMDB)</li>
</ul>
<blockquote>
<p>我们在使用的时候,要么使用结合的形式比如STMDB+LDMIA,要么直接使用封装形式比如STMFD+LDMFD</p>
</blockquote>
<h4 id="满栈和空栈"><a href="#满栈和空栈" class="headerlink" title="满栈和空栈"></a>满栈和空栈</h4><p>栈的生长方式可以有四种: <strong>满增栈、满减栈、空增栈、空减栈</strong> </p>
<ul>
<li><strong>满栈（full stack）</strong>：栈指针指向下一个将要取出数据的位置,数据入栈时,栈顶指针先偏移再入栈,数据出栈是,先取数据,后指针偏移。</li>
<li><strong>空栈（empty stack）</strong>：栈指针指向下一个将要放入数据的位置,数据入栈时,先存数据后指针偏移,数据出栈时,先指针偏移,后数据取出</li>
<li><strong>递增堆栈(ascending stack)</strong>：堆栈由低地址向高地址生长。</li>
<li><strong>递减堆栈(secending stack)</strong>：堆栈由高地址向低地址生长。</li>
</ul>
<blockquote>
<p>X86和mips架构都是采用满递减堆栈方式处理栈空间,ARM架构四种方式均支持</p>
</blockquote>
<p><strong>内存批量读写示例:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mov  R1,#4</span><br><span class="line">mov  R2,#5</span><br><span class="line">mov  R0,#0x00000008</span><br><span class="line">stm  R0,&#123;R1,R2&#125; </span><br><span class="line">;以上四行代码表示 从0x00000008这个内存地址开始 将R1和R2中的数据依次存入</span><br></pre></td></tr></table></figure>

<p>如果我想在上面的基础上再往后追加数据</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov  R1,#6</span><br><span class="line">mov  R2,#7</span><br><span class="line">stm  R0,&#123;R1,R2&#125;</span><br></pre></td></tr></table></figure>

<p> 我们发现数据并没有追加,而是被覆盖了,因为<code>R0</code>的值依然还是 <code>0x00000008</code>,这个时候我们需要使用扩展指令,如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mov  R1,#4</span><br><span class="line">mov  R2,#5</span><br><span class="line">mov  R0,#0x00000008</span><br><span class="line">STMIA  R0!,&#123;R1,R2&#125; ;只有在寄存器后加上!才能修改寄存器中的值</span><br><span class="line"></span><br><span class="line">mov  R1,#6</span><br><span class="line">mov  R2,#7</span><br><span class="line">stm  R0,&#123;R1,R2&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>事实上 STM指令如果不加后缀写法,默认使用的是STMIA指令,LDM指令默认使用LDMIA</p>
</blockquote>
<h4 id="多寄存器数据存放顺序"><a href="#多寄存器数据存放顺序" class="headerlink" title="多寄存器数据存放顺序"></a>多寄存器数据存放顺序</h4><p>不管使用哪种扩展指令,皆为左低右高的形式,也就是左边的寄存器数据存放在低地址,右边的存放在高地址</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">STMIA  R0!,&#123;R1,R2&#125; ;左边R1的内容放低地址,右边R2的内容放高地址</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">LDMDB   R0!,&#123;R1,R2&#125; ;高地址数据放入R2,低地址数据放入R1</span><br></pre></td></tr></table></figure>

<h2 id="宏"><a href="#宏" class="headerlink" title="宏"></a>宏</h2><ol>
<li><p><strong>宏匹配</strong></p>
<ul>
<li>语法格式</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">MACRO</span><br><span class="line">$label macroname $param</span><br><span class="line">;指令序列   </span><br><span class="line">MEND  </span><br><span class="line"></span><br><span class="line">;例如声明一个宏名为print的宏语句</span><br><span class="line">MACRO</span><br><span class="line">$label print $param   ;带$的表示会被替换的内容</span><br><span class="line"> ;这里写相关汇编代码</span><br><span class="line">MEND</span><br></pre></td></tr></table></figure>

<ul>
<li>使用</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> MACRO</span><br><span class="line">  $label putR0 $param  </span><br><span class="line">  </span><br><span class="line">  mov R0,$param</span><br><span class="line">   </span><br><span class="line"> MEND   </span><br><span class="line"> </span><br><span class="line">; 使用</span><br><span class="line">putR0 #10</span><br></pre></td></tr></table></figure>


</li>
</ol>
<ul>
<li>延伸</li>
</ul>
<p>第一个<code>$label</code>是干嘛用的呢,由于宏的内部处理方式的替换,为了避免标签名称的冲突,增加一个标识</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">;假如我要在宏匹配中定义一个函数fun, 当我调用两次的时候,会出现函数名重复的问题</span><br><span class="line">	MACRO</span><br><span class="line">    $label putR0 $param  </span><br><span class="line">   fun</span><br><span class="line">    mov R0,$param</span><br><span class="line">     </span><br><span class="line">   MEND   </span><br><span class="line">   </span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"> putR0 #10</span><br><span class="line"> putR0 #10</span><br><span class="line"> </span><br><span class="line"> ;那么如果要解决这个问题的话,我可以利用第一个替换参数如下:</span><br><span class="line"> 	MACRO</span><br><span class="line">$label putR0 $param  </span><br><span class="line">$label</span><br><span class="line">    mov R0,$param</span><br><span class="line">     </span><br><span class="line">   MEND   </span><br><span class="line">   </span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">fun1 putR0 #10  ;函数名为fun1</span><br><span class="line">fun2 putR0 #10  ;函数名为fun2</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p><strong>宏定义</strong></p>
<ul>
<li><strong>全局宏</strong>的定义,可跨段访问 </li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">;全局数字变量</span><br><span class="line">GBLA number </span><br><span class="line">number SETA 0Xaa  </span><br><span class="line"></span><br><span class="line">;全局逻辑变量</span><br><span class="line">GBLL flag </span><br><span class="line">flag SETL &#123;TRUE&#125;  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">;全局字符串变量</span><br><span class="line">GBLS str </span><br><span class="line">str SETS &quot;hello world&quot;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>局部宏</strong>的定义,只能在当前宏内被访问</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">;局部数字变量</span><br><span class="line">LCLA number </span><br><span class="line">number SETA 0Xaa  </span><br><span class="line"></span><br><span class="line">;局部逻辑变量</span><br><span class="line">LCLL flag </span><br><span class="line">flag SETL &#123;TRUE&#125;  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">;局部字符串变量</span><br><span class="line">LCLS str </span><br><span class="line">str SETS &quot;hello world&quot;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>全局常量的定义</strong></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">num   EQU      10  ;关键字EQU  数据不允许修改</span><br></pre></td></tr></table></figure>




</li>
</ol>
<ol start="3">
<li><p>宏定义示例</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">;定义一个全局整型数据宏</span><br><span class="line">GBLA number </span><br><span class="line">number SETA 0Xaa  </span><br><span class="line"></span><br><span class="line">;使用</span><br><span class="line">mov R0,#number ;相当于mov R0,#0Xaa</span><br><span class="line">LDR R0,=number ;相当于LDR R0,=0Xaa</span><br></pre></td></tr></table></figure>

<p> 局部宏数据</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">MACRO ;声明一个宏</span><br><span class="line">$label    message  $a ;取名为message 参数为$a</span><br><span class="line"></span><br><span class="line">;定义宏内局部变量</span><br><span class="line">LCLA    number </span><br><span class="line">number SETA $a</span><br><span class="line"></span><br><span class="line">mov R0,#number</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">MEND ;宏结束,局部变量不再起作用</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">message 10 ;直接调用</span><br></pre></td></tr></table></figure>

<p> 常量数据</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">	AREA data ,DATA</span><br><span class="line">num   EQU      10 </span><br><span class="line">	AREA code ,CODE</span><br><span class="line"></span><br><span class="line">	mov R1,#5</span><br><span class="line">	ldr R1,=num</span><br><span class="line"></span><br><span class="line">	END</span><br></pre></td></tr></table></figure>

</li>
</ol>
<blockquote>
<p>宏匹配和宏定义需要遵循先定义后使用的原则</p>
<p>如果需要从宏中跳出,可以使用伪指令MEXIT</p>
</blockquote>
<ol start="3">
<li><p><strong>宏替换</strong></p>
<p>使用<code>include</code>或者<code>get</code>伪指令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">   ;使用get伪指令</span><br><span class="line">   AREA code, CODE</span><br><span class="line">GET pangshu.s         ;通知编译器当前源文件包含源文件 softool.s</span><br><span class="line">   GET C:\pp.s           ;通知编译器当前源文件包含源文件 C:\cn.s</span><br><span class="line">   END</span><br><span class="line">   </span><br><span class="line">   ;使用include伪指令</span><br><span class="line">   AREA code, CODE</span><br><span class="line">   include pangshu.s         ;通知编译器当前源文件包含源文件 softool.s</span><br><span class="line">   include C:\pp.s           ;通知编译器当前源文件包含源文件 C:\cn.s</span><br><span class="line">   END</span><br></pre></td></tr></table></figure>




</li>
</ol>
<h2 id="指令学习"><a href="#指令学习" class="headerlink" title="指令学习"></a>指令学习</h2><h4 id="传送指令"><a href="#传送指令" class="headerlink" title="传送指令"></a>传送指令</h4><ol>
<li><p>正常传送指令<code>mov</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov R0,#4 ;将4传送至R0寄存器</span><br></pre></td></tr></table></figure>
</li>
<li><p>取反传送指令<code>mvn</code>,也叫<strong>数据非传送指令</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn R0,#4 ;将4取反后传送至R0寄存器  0100取反为1011</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h4 id="转移指令"><a href="#转移指令" class="headerlink" title="转移指令"></a>转移指令</h4><ol>
<li><strong>B指令</strong></li>
</ol>
<p>直接跳转,仅更改PC寄存器的值</p>
<p>示例:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">B 0x00040000 ;直接跳转到物理地址0x00040000读取指令并执行</span><br><span class="line"></span><br><span class="line">B 标号  ;直接跳转到标号处</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><strong>BL指令</strong></li>
</ol>
<p>跳转并链接,除了更改PC寄存器的值之外,还会将下一条指令所对应的物理地址存放至<code>lr</code>寄存器中</p>
<p>示例:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">BL 0x00040000</span><br><span class="line">mov r1,3  ;假设这行指令对应物理地址为0x0040004, 那么BL一旦执行,会将该值存入lr寄存器</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">或者</span><br><span class="line">BL 标号</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><p><strong>BX指令</strong></p>
<p>跳转并切换状态</p>
<p><strong>BX指令后面只能跟寄存器</strong>,弥补了B指令和BL指令的不足, 同时会根据寄存器中最低比特位值切换ARM/Thumb模式 </p>
</li>
</ol>
<p>示例:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">BL print</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">print</span><br><span class="line">	mov r1,#1</span><br><span class="line">	BX lr  ;函数返回     如果R0[0]=1,则进入Thumb状态 反之进入ARM模式</span><br></pre></td></tr></table></figure>

<p>除了通过指令来更改PC寄存器值之外,在ARM32中还可以<strong>直接使用传送指令对PC寄存器进行赋值</strong>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov pc,#0x00000008  ;往pc寄存器中写入一个地址值</span><br><span class="line"></span><br><span class="line">mov R0,pc  ;获取pc寄存器中的值</span><br></pre></td></tr></table></figure>

<ol start="4">
<li><p><strong>BLX指令</strong></p>
<p>该指令将以下功能集于一身</p>
<ul>
<li>更改PC寄存器的值</li>
<li>将下一条指令的地址存入lr寄存器</li>
<li>根据寄存器中最低比特位值切换ARM/Thumb模式 </li>
</ul>
</li>
</ol>
<h4 id="算术和逻辑运算指令"><a href="#算术和逻辑运算指令" class="headerlink" title="算术和逻辑运算指令"></a>算术和逻辑运算指令</h4><ol>
<li><p>算术运算</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">add R0,#5</span><br><span class="line">add R0,R1 ;加法 </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sub R0,#5</span><br><span class="line">sub R0,R1 ;减法 </span><br><span class="line"></span><br><span class="line">mul R0,R1,R2 ;乘法指令, 这里至少三个寄存器参与</span><br><span class="line"></span><br><span class="line">mla R0,R1,R2,R3  ;先乘后加      R0 = R1 × R2 + R3</span><br></pre></td></tr></table></figure>
</li>
<li><p>逻辑运算</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">and R0.#3</span><br><span class="line">and R0,R0 ;逻辑与</span><br><span class="line"></span><br><span class="line">orr R0.#3</span><br><span class="line">orr R0,R0 ;逻辑或</span><br><span class="line"></span><br><span class="line">eor R0.#3</span><br><span class="line">eor R0,R0 ;逻辑异或</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h4 id="移位指令"><a href="#移位指令" class="headerlink" title="移位指令"></a>移位指令</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MOV   R0, R1, LSL#2    ;将R1中的内容左移两位后传送到R0中。</span><br><span class="line"></span><br><span class="line">MOV   R0, R1, LSR#2    ;将R1中的内容右移两位后传送到R0中,左端用零来填充。</span><br></pre></td></tr></table></figure>

<h4 id="比较指令"><a href="#比较指令" class="headerlink" title="比较指令"></a>比较指令</h4><ol>
<li><p>比较两个值是否相等</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">cmp R0,R1 </span><br><span class="line">beq sub ;如果两个寄存器中的值相等则跳转到sub函数中,否则继续往下执行</span><br><span class="line"></span><br><span class="line">sub</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">cmp R0,#5</span><br><span class="line">bne sub ;如果两个值不相等,跳转到sub函数,否则继续往下执行</span><br><span class="line"></span><br><span class="line">sub</span><br></pre></td></tr></table></figure>
</li>
<li><p>大于和小于(带符号)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">;大于</span><br><span class="line">cmp R0,R1</span><br><span class="line">bgt sub ;如果R0寄存器中的值大于R1,则跳转至sub</span><br><span class="line"></span><br><span class="line">sub</span><br><span class="line"></span><br><span class="line">;小于</span><br><span class="line">cmp R0,R1</span><br><span class="line">blt sub ;如果R0寄存器中的值大于R1,则跳转至sub</span><br><span class="line"></span><br><span class="line">sub</span><br></pre></td></tr></table></figure>



</li>
</ol>
<h2 id="标志寄存器"><a href="#标志寄存器" class="headerlink" title="标志寄存器"></a>标志寄存器</h2><p>试想一下,我们的比较指令<code>cmp</code>,它内部是如何进行数据大小判断的</p>
<p>在高级语言里,直接使用<code>&gt;</code>或者<code>&lt;</code>运算符,来判断两个值的大小,比较结束后返回<code>True</code>或者<code>Flase</code>,可是在汇编语言里面没有这么简便,那它又是如何对两个数据之间大小进行判断的呢？</p>
<p>别忘了, 计算机最擅长做二进制的算术和逻辑运算</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmp R0,R1</span><br></pre></td></tr></table></figure>

<p>要想判断两个数据是否相等,或者大于小于,直接做个减法运算不就完事了,也就是<code>R0-R1</code>,如果结果为0,那么两个值相等,如果结果为正数,则R0&gt;R1,结果为负数,则小于</p>
<p>但是问题来了,这个结果值放在哪里呢？放内存中还是寄存器呢? 答案是：寄存器</p>
<p>cpu设计者为了方便区分专门用了一个寄存器来存放数据运算后的结果,这个寄存器叫做<strong>状态寄存器</strong>,也叫标志寄存器</p>
<p>ARM32中一个寄存器有32二进制位的数据空间,那该怎么存放呢？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">00000000000000000000000000000000  ;32个二进制位</span><br></pre></td></tr></table></figure>

<p>为了方便程序员开发,设计者给这些二进制位进行了相应的命名：</p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20210120151329.png" alt></p>
<p>当两个比较值相等,进行减法运算时,结果为0,那么Z标志位的值为1,也就是</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">01000000000000000000000000000000  ;32个二进制位</span><br></pre></td></tr></table></figure>

<p>如果不相等,结果不为0,那么Z标志位的值变成0</p>
<p>由于每个二进制位只能存0和1两个值,也就是最多只能表示两种状态,那大于和小于的状态表示就得放到另外一个二进制上了,由于二进制运算涉及到有符号和无符号两种情况,因此需要用到两个二进制分别进行处理,有符号的的结果存放在N标志位,无符号的结果存放在C标志位：</p>
<p><code>cmp</code>指令会同时对两个数据进行有符号和无符号运算</p>
<p><strong>有符号运算</strong>,如果结果为正数,N标志位值为0,如果为负数,N标志位值为1</p>
<p><strong>无符号运算</strong>,如果结果为正数,C标志位值为1,如果为负数,C标志位值为0</p>
<p>那么我们在使用<code>cmp</code>指令的时候,到底是根据那个标志位的结果进行判断的呢？</p>
<p>如果我们使用<code>bne</code>指令,那么取Z标志位的值进行参考</p>
<p>如果我们使用<code>blt</code>,<code>bgt</code>,那么取N标志位,Z标志位和V标志位三者的值进行参考</p>
<p>总结：</p>
<ol>
<li><p><code>cmp</code>指令的功能相当于减法指令,只是对操作数之间运算比较,结果间接保存在标志寄存器高位中</p>
</li>
<li><p><code>bne</code>,<code>blt</code>,<code>bgt</code>等这些指令都是通过获取标志寄存器中的值来得知比较结果从而进行相应跳转,不同的指令需要满足不同的条件</p>
</li>
<li><p>我们可以通过改变状态寄存器中的值来改变代码的走向</p>
</li>
</ol>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  AREA test,CODE</span><br><span class="line"></span><br><span class="line">	mov R0,#5</span><br><span class="line">	mov R1,#6</span><br><span class="line">	cmp R0,R1</span><br><span class="line">	;在跳转之前改变状态寄存器的值 使得bgt必然跳转</span><br><span class="line">	MSR cpsr_f ,0x20000000</span><br><span class="line">	BGT fun</span><br><span class="line">	mov R1,#6</span><br><span class="line"></span><br><span class="line">fun</span><br><span class="line">	mov R0,#4</span><br><span class="line">	bx lr</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  END</span><br></pre></td></tr></table></figure>

<p>知识扩展：</p>
<ol>
<li><p>状态寄存器的读取和写入</p>
<p>读取指令:<strong>MRS</strong>{mov to register from special register）</p>
<p>写入指令: <strong>MSR</strong>(Move to Special register from Register )</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 读取状态寄存器中的值</span><br><span class="line">mrs R0,cpsr  ;将值读取到R0寄存器</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#修改状态寄存器中的值</span><br><span class="line">msr cpsr_c,#0x2d ;修改控制位区域</span><br><span class="line">msr cpsr_x,#0x2d00 ;修改扩展位区域</span><br><span class="line">msr cpsr_s,#0x2d0000 ;修改状态位区域</span><br><span class="line">msr cpsr_f,#0x2d000000 ;修改标志位区域</span><br><span class="line"></span><br><span class="line">#修改状态寄存器高位值时,低位必须补足0,虽然加了0但是不会影响其他区域的值</span><br></pre></td></tr></table></figure>
</li>
<li><p>状态寄存器中各个区域具体描述</p>
<p>一共分位四个大区域,从低到高分别为：<strong>控制位区域</strong>, <strong>扩展位区域,</strong> <strong>状态位区域</strong>, <strong>标志位区域</strong>,每个区域各占8个二进制位的空间</p>
<p>以下是<strong>控制位区域</strong>细分详解图：</p>
</li>
</ol>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20210120151619.png" alt> </p>
<ol start="3">
<li>比较指令标志位条件参考表</li>
</ol>
<table>
<thead>
<tr>
<th align="center">指令</th>
<th align="center">含义</th>
<th align="center">需要满足的条件</th>
</tr>
</thead>
<tbody><tr>
<td align="center">beq</td>
<td align="center">相等</td>
<td align="center">Z标志位为1</td>
</tr>
<tr>
<td align="center">bne</td>
<td align="center">不相等</td>
<td align="center">Z标志位为0</td>
</tr>
<tr>
<td align="center">bgt</td>
<td align="center">带符号大于</td>
<td align="center">Z标志位为0，且N和V标志位值相等</td>
</tr>
<tr>
<td align="center">blt</td>
<td align="center">带符号小于</td>
<td align="center">N不等于V</td>
</tr>
<tr>
<td align="center">bge</td>
<td align="center">带符号大于等于</td>
<td align="center">N等于V</td>
</tr>
<tr>
<td align="center">ble</td>
<td align="center">带符号小于等于</td>
<td align="center">Z标志位为1或者N不等于V</td>
</tr>
<tr>
<td align="center">bls</td>
<td align="center">无符号小于等于</td>
<td align="center">Z标志位为1且C标志位为0</td>
</tr>
<tr>
<td align="center">bhi</td>
<td align="center">无符号大于</td>
<td align="center">Z标志位为0且C标志位为1</td>
</tr>
<tr>
<td align="center">bcs</td>
<td align="center">无符号大于等于</td>
<td align="center">C标志位为1</td>
</tr>
<tr>
<td align="center">bhs</td>
<td align="center">无符号大于等于</td>
<td align="center">C标志位为1</td>
</tr>
<tr>
<td align="center">bcc</td>
<td align="center">无符号小于</td>
<td align="center">C标志位为0</td>
</tr>
<tr>
<td align="center">blo</td>
<td align="center">无符号小于</td>
<td align="center">C标志位为0</td>
</tr>
<tr>
<td align="center">bmi</td>
<td align="center">负数</td>
<td align="center">N标志位为1</td>
</tr>
<tr>
<td align="center">bpl</td>
<td align="center">正数或零</td>
<td align="center">N标志位为0</td>
</tr>
<tr>
<td align="center">bvs</td>
<td align="center">溢出</td>
<td align="center">V标志位为1</td>
</tr>
<tr>
<td align="center">bvc</td>
<td align="center">未溢出</td>
<td align="center">V标志位为0</td>
</tr>
<tr>
<td align="center">bnv</td>
<td align="center">无条件执行</td>
<td align="center">忽略</td>
</tr>
<tr>
<td align="center">bal</td>
<td align="center">无条件执行</td>
<td align="center">忽略</td>
</tr>
</tbody></table>
<h2 id="条件和循环伪指令"><a href="#条件和循环伪指令" class="headerlink" title="条件和循环伪指令"></a>条件和循环伪指令</h2><p>   IF、ELSE 和 ENDIF</p>
<ul>
<li><p>根据条件的成立与否决定是否执行某个程序段</p>
</li>
<li><p>IF、ELSE、ENDIF 伪指令可以嵌套使用</p>
</li>
<li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">GBLL Test ;声明一个全局逻辑变量Test</span><br><span class="line">Test SETL &#123;TRUE&#125; </span><br><span class="line"></span><br><span class="line">IF Test = &#123;TRUE&#125;</span><br><span class="line"> 程序段1 </span><br><span class="line">ELSE</span><br><span class="line"> 程序段2</span><br><span class="line">ENDIF</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="WHILE-和-WEND"><a href="#WHILE-和-WEND" class="headerlink" title="WHILE 和 WEND"></a>WHILE 和 WEND</h4><ul>
<li><p>根据条件的成立与否决定是否重复汇编一个程序段</p>
</li>
<li><p>若 WHILE 后面的逻辑表达式为真,则重复汇编该程序段,直到逻辑表达式为假</p>
</li>
<li><p>WHILE 和 WEND 伪指令可以嵌套使用</p>
</li>
<li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">GBLA Counter  ;声明一个全局数字变量Counter</span><br><span class="line">Counter SETA 3    ;赋值</span><br><span class="line">...</span><br><span class="line">WHILE Counter &lt; 10</span><br><span class="line">程序段</span><br><span class="line">WEND</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="汇编语言和C语言交互"><a href="#汇编语言和C语言交互" class="headerlink" title="汇编语言和C语言交互"></a>汇编语言和C语言交互</h2><ul>
<li>内嵌汇编</li>
<li>外链汇编</li>
</ul>
<h4 id="1-引入其他源文件函数"><a href="#1-引入其他源文件函数" class="headerlink" title="1.引入其他源文件函数"></a>1.引入其他源文件函数</h4><p>使用<code>import</code>或者<code>extern</code>伪指令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">;使用import伪指令</span><br><span class="line">AREA code, CODE</span><br><span class="line">import fun1 ;导入其他源文件中名为fun1的函数</span><br><span class="line">END</span><br><span class="line"></span><br><span class="line">;使用extern伪指令</span><br><span class="line">AREA code, CODE</span><br><span class="line">extern fun1       </span><br><span class="line">END</span><br></pre></td></tr></table></figure>

<p><strong>两者区别:</strong></p>
<ul>
<li><code>import</code>:不管当前文件是否使用该引入的函数,该标签都会加入当前文件符号表,即为静态引用</li>
<li><code>extern</code>:只有当前文件使用了该函数,才会将此标签加入符号表,即为动态引用</li>
</ul>
<h4 id="2-导出当前源文件中函数供其他文件访问"><a href="#2-导出当前源文件中函数供其他文件访问" class="headerlink" title="2.导出当前源文件中函数供其他文件访问"></a>2.导出当前源文件中函数供其他文件访问</h4><p>使用<code>export</code>或者<code>global</code>伪指令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">;使用import伪指令</span><br><span class="line">AREA code, CODE</span><br><span class="line">export fun         ;导出fun函数供其他源文件使用</span><br><span class="line"></span><br><span class="line">fun </span><br><span class="line">	mov R0,#4</span><br><span class="line">	bx lr</span><br><span class="line">END</span><br></pre></td></tr></table></figure>

<h4 id="3-外链汇编之C语言调汇编函数"><a href="#3-外链汇编之C语言调汇编函数" class="headerlink" title="3.外链汇编之C语言调汇编函数"></a>3.外链汇编之C语言调汇编函数</h4><p>第一步,在汇编原文件中将函数暴露出来给供外部调用,使用<code>export</code>或者<code>global</code>伪指令:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">AREA code, CODE</span><br><span class="line">export arm_strcpy  ;或者使用global</span><br><span class="line"></span><br><span class="line">arm_strcpy</span><br><span class="line">loop </span><br><span class="line">	ldrb R4,[R0],#1 ;如果使用ldr 那么将偏移值改成4</span><br><span class="line">	cmp R4,#0</span><br><span class="line">	beq over</span><br><span class="line">	strb R4,[R1],#1</span><br><span class="line">	b loop</span><br><span class="line">over	</span><br><span class="line">END</span><br></pre></td></tr></table></figure>

<p>第二步,在C文件中引用汇编中的函数,C文件中只能使用<code>extern</code>伪指令:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">extern arm_strcpy(char *src,char*des);</span><br><span class="line"></span><br><span class="line">int main2()&#123;</span><br><span class="line">	char *a=&quot;hello pangshu&quot;;</span><br><span class="line">	char b[64];</span><br><span class="line">	arm_strcpy(a,b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-外链汇编之汇编调c语言函数"><a href="#4-外链汇编之汇编调c语言函数" class="headerlink" title="4.外链汇编之汇编调c语言函数"></a>4.外链汇编之汇编调c语言函数</h4><p>第一步,在C文件中编写好函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">c_sum</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a+b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第二步, 在汇编文件中引入函数,使用<code>import</code>或者<code>extern</code>伪指令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">AREA code, CODE</span><br><span class="line">import c_sum  </span><br><span class="line"></span><br><span class="line">mov R0,#1 ;第一个参数</span><br><span class="line">mov R1,#2 ;第二个参数</span><br><span class="line"></span><br><span class="line">END</span><br></pre></td></tr></table></figure>

<p>第三步, 使用BL指令调用函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">AREA code, CODE</span><br><span class="line">import c_sum  </span><br><span class="line"></span><br><span class="line">mov R0,#1 ;第一个参数</span><br><span class="line">mov R1,#2 ;第二个参数</span><br><span class="line">BL c_sum</span><br><span class="line">END</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在ARM中函数参数使用R0~R3这四个寄存器来进行传递,最多传递4个参数,超过4个参数使用栈进行处理,函数返回值通过R0进行传递</p>
</blockquote>
<h4 id="由于keil软件的特殊性-我们可以通过以下方式进行互调测试"><a href="#由于keil软件的特殊性-我们可以通过以下方式进行互调测试" class="headerlink" title="由于keil软件的特殊性,我们可以通过以下方式进行互调测试"></a>由于keil软件的特殊性,我们可以通过以下方式进行互调测试</h4><p>C文件中代码:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="title">arm_strcpy</span><span class="params">(<span class="keyword">char</span> *src,<span class="keyword">char</span>*des)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main2</span><span class="params">()</span></span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">char</span> *a=<span class="string">"hello pangshu"</span>	;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">char</span> b[<span class="number">64</span>];</span><br><span class="line"></span><br><span class="line">	arm_strcpy(a,b); <span class="comment">//调汇编中函数</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">c_sum</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a+b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>汇编文件中代码:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> AREA code, CODE</span><br><span class="line"></span><br><span class="line"> import c_sum   </span><br><span class="line"> export arm_strcpy  </span><br><span class="line"></span><br><span class="line">arm_strcpy</span><br><span class="line"></span><br><span class="line">	mov R0,#1 ;第一个参数</span><br><span class="line">	mov R1,#2 ;第二个参数</span><br><span class="line">	BL c_sum  ;结果存放至R0中</span><br><span class="line">	END</span><br></pre></td></tr></table></figure>

<h4 id="5-内嵌汇编"><a href="#5-内嵌汇编" class="headerlink" title="5.内嵌汇编"></a>5.内嵌汇编</h4><p>在C语言中嵌入汇编代码,格式如下:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a=<span class="number">4</span>;</span><br><span class="line">    <span class="keyword">int</span> b=<span class="number">4</span>;</span><br><span class="line">    <span class="keyword">int</span> c=<span class="number">4</span>;</span><br><span class="line">  </span><br><span class="line">	__asm__&#123;         <span class="comment">//使用__asm或者__asm__</span></span><br><span class="line">	mov R5,#<span class="number">0x00000005</span>   <span class="comment">//在大括号内部直接写入汇编代码即可</span></span><br><span class="line">	mov R6,#<span class="number">0x00000005</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>内嵌汇编的注意事项:</p>
<ul>
<li>不能直接给PC寄存器赋值,如果想改变pc值需要借助转移指令</li>
<li>由于R0<del>R3用于存放函数参数和返回值,R12</del>R15有特殊用途,因此<strong>我们能操作的寄存器只有R4~R11</strong>, 又因为编译器会优先将寄存器分配给函数中的局部变量,因此<strong>我们一般无法在内嵌汇编环境中准确地修改某个寄存器的值</strong>,比如我想修改R5寄存器的值,由于函数有个变量占用了R5这个寄存器,那么编译器会自动将你写的这个R5改成R6或者其他，所以，在内嵌汇编时我们需要把寄存器当作变量来看待，把局部变量也当成寄存器看待，就好理解了</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">void c_strcopy(char *src,char *des)&#123;</span><br><span class="line">	char ch</span><br><span class="line">	__asm__&#123;    </span><br><span class="line">    loop:</span><br><span class="line">    	ldrb ch,[src],#1  //局部变量当成寄存器看待</span><br><span class="line">    	strb ch,[des],#1</span><br><span class="line">    	cmp,ch,#0</span><br><span class="line">    	bne loop</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="ARM32中寄存器别名补充"><a href="#ARM32中寄存器别名补充" class="headerlink" title="ARM32中寄存器别名补充"></a>ARM32中寄存器别名补充</h2><table>
<thead>
<tr>
<th align="left">寄存器</th>
<th align="left">别名</th>
<th align="left">用途</th>
</tr>
</thead>
<tbody><tr>
<td align="left">r0</td>
<td align="left">a1</td>
<td align="left">第一个函数参数和函数返回值</td>
</tr>
<tr>
<td align="left">r1</td>
<td align="left">a2</td>
<td align="left">第二个函数参数</td>
</tr>
<tr>
<td align="left">r2</td>
<td align="left">a3</td>
<td align="left">第三个函数参数</td>
</tr>
<tr>
<td align="left">r3</td>
<td align="left">a4</td>
<td align="left">第四个函数参数</td>
</tr>
<tr>
<td align="left">r4</td>
<td align="left">v1</td>
<td align="left">寄存器变量</td>
</tr>
<tr>
<td align="left">r5</td>
<td align="left">v2</td>
<td align="left">寄存器变量</td>
</tr>
<tr>
<td align="left">r6</td>
<td align="left">v3</td>
<td align="left">寄存器变量</td>
</tr>
<tr>
<td align="left">r7</td>
<td align="left">v4</td>
<td align="left">寄存器变量</td>
</tr>
<tr>
<td align="left">r8</td>
<td align="left">v5</td>
<td align="left">寄存器变量</td>
</tr>
<tr>
<td align="left">r9</td>
<td align="left">v6</td>
<td align="left">寄存器变量 实际的帧指针</td>
</tr>
<tr>
<td align="left">r10</td>
<td align="left">sl</td>
<td align="left">栈接线</td>
</tr>
<tr>
<td align="left">r11</td>
<td align="left">fp</td>
<td align="left">参数指针</td>
</tr>
<tr>
<td align="left">r12</td>
<td align="left">ip</td>
<td align="left">临时</td>
</tr>
<tr>
<td align="left">r13</td>
<td align="left">sp</td>
<td align="left">栈指针</td>
</tr>
<tr>
<td align="left">r14</td>
<td align="left">lr</td>
<td align="left">连接寄存器</td>
</tr>
<tr>
<td align="left">r15</td>
<td align="left">pc</td>
<td align="left">程序计数器</td>
</tr>
</tbody></table>
<h4 id="如何编译16位arm汇编指令"><a href="#如何编译16位arm汇编指令" class="headerlink" title="如何编译16位arm汇编指令"></a>如何编译16位arm汇编指令</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">AREA test, CODE</span><br><span class="line">code16		;声明为16位arm指令 如果不写默认则为code32 </span><br><span class="line"></span><br><span class="line"> END</span><br></pre></td></tr></table></figure>

<h4 id="附-指令集汇总"><a href="#附-指令集汇总" class="headerlink" title="附:指令集汇总"></a>附:指令集汇总</h4><p><strong>(一)</strong>  <strong>ARM</strong> <strong>指令集</strong></p>
<p>1． 指令格式</p>
<p>2． 条件码</p>
<p><strong>3． ARM</strong> <strong>存储器访问指令</strong></p>
<p>1)    LDR/ STR －加载 /存储指令</p>
<p>2)    LDM/ STM －多寄存器加载 /存储指令</p>
<p>3)    SWP －寄存器和存储器交换指令</p>
<p><strong>4． ARM</strong> <strong>数据处理指令</strong></p>
<p>1)    数据传送指令</p>
<p>a)    MOV －数据传送指令</p>
<p>b)    MVN －数据非传送指令</p>
<p>2)    算术逻辑运算指令</p>
<p>a)    ADD －加法运算指令</p>
<p>b)    SUB －减法运算指令</p>
<p>c)    RSB- 逆向减法指令</p>
<p>d)    ADC －带进位加法指令</p>
<p>e)    SBC －带进位减法指令</p>
<p>f)    RSC －带进位逆向减法指令</p>
<p>g)    AND －逻辑“与”</p>
<p>h)    ORR －逻辑“或”</p>
<p>i)    EOR －逻辑“异或”</p>
<p>j)    BIC －位清除指令</p>
<p>3)    比较指令</p>
<p>a)    CMP －比较指令</p>
<p>b)    CMN －负数比较指令</p>
<p>c)    TST －位测试指令</p>
<p>d)    TEQ －相等测试指令</p>
<p>4)    乘法指令</p>
<p>a)    MUL － 32位乘法指令</p>
<p>b)    MLA － 32位乘加指令</p>
<p>c)    UMULL － 64位无符号乘法指令</p>
<p>d)    UMLAL － 64位无符号乘加指令</p>
<p>e)    SMULL － 64位有符号乘法指令</p>
<p>f)    SMLAL － 64位有符号乘加指令</p>
<p><strong>5． ARM</strong> <strong>分支指令</strong></p>
<p>1)    B －分支指令</p>
<p>2)    BL －带连接的分支指令</p>
<p>3)    BX －带状态切换的分支指令</p>
<p><strong>6． ARM</strong> <strong>协处理器指令</strong></p>
<p>1)    CDP －协处理器数据操作指令</p>
<p>2)    LDC －协处理器数据读取指令</p>
<p>3)    STC －协处理器数据写入指令</p>
<p>4)    MCR － ARM处理器到协处理器的数据传送指令</p>
<p>5)    MRC －协处理器到 ARM处理器的数据传送指令</p>
<p><strong>7． ARM</strong> <strong>杂项指令</strong></p>
<p>1)    SWI －软中断指令</p>
<p>2)    MRS －读状态寄存器指令</p>
<p>3)    MSR －写状态寄存器指令</p>
<p><strong>8． ARM</strong> <strong>伪指令</strong></p>
<p>1)    ADR －小范围的地址读取伪指令</p>
<p>2)    ADRL －中等范围的地址读取伪指令</p>
<p>3)    LDR －大范围的地址读取伪指令</p>
<p>4)    NOP －空操作伪指令</p>
<p><strong>(二)</strong>  <strong>Thumb</strong> <strong>指令集</strong></p>
<p>1． Thumb 指令集和 ARM指令集的区别</p>
<p><strong>2． Thumb</strong> <strong>存储器访问指令</strong></p>
<p>1)    LDR/ STR －加载 /存储指令</p>
<p>2)    PUSH/ POP －寄存器入栈 /出栈指令</p>
<p>3)    LDMIA/ STMIA －多寄存器加载 /存储指令</p>
<p><strong>3． Thumb</strong> <strong>数据处理指令</strong></p>
<p>1)    数据传送指令</p>
<p>a)    MOV －数据传送指令</p>
<p>b)    MVN －数据非传送指令</p>
<p>c)    NEG －数据取负指令</p>
<p>2)    算术逻辑运算指令</p>
<p>a)    ADD －加法运算指令</p>
<p>b)    SUB －减法运算指令</p>
<p>c)    ADC －带进位加法指令</p>
<p>d)    SBC －带进位减法指令</p>
<p>e)    MUL －乘法运算指令</p>
<p>f)    AND －逻辑“与”</p>
<p>g)    ORR －逻辑“或”</p>
<p>h)    EOR －逻辑“异或”</p>
<p>i)    BIC －位清除指令</p>
<p>j)    ASR －算术右移指令</p>
<p>k)    LSL －逻辑左移指令</p>
<p>l)    LSR －逻辑右移指令</p>
<p>m)    ROR －循环右移指令</p>
<p>3)    比较指令</p>
<p>a)    CMP －比较指令</p>
<p>b)    CMN －负数比较指令</p>
<p>c)    TST －位测试指令</p>
<p><strong>4． Thumb</strong> <strong>分支指令</strong></p>
<p>1)    B －分支指令</p>
<p>2)    BL －带连接的分支指令</p>
<p>3)    BX －带状态切换的分支指令</p>
<p><strong>5． Thumb</strong> <strong>杂项指令</strong></p>
<p>1)    SWI －软中断指令</p>
<p><strong>6． Thumb</strong> <strong>伪指令</strong></p>
<p>1)    ADR －小范围的地址读取伪指令</p>
<p>2)    LDR －大范围的地址读取伪指令</p>
<p>3)    NOP －空操作伪指令</p>
<p><strong>本文为作者原创 转载时请注明出处 谢谢</strong></p>
<p><img src="https://gitee.com/songjianzaina/SavePicGoPic/raw/master/img/20191119095516.png" alt></p>
<p><em>乱码三千 – 点滴积累 ,欢迎来到乱码三千技术博客站</em></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="../25/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="../../">1</a><span class="space">&hellip;</span><a class="page-number" href="../25/">25</a><span class="page-number current">26</span><a class="page-number" href="../27/">27</a><span class="space">&hellip;</span><a class="page-number" href="../47/">47</a><a class="extend next" rel="next" href="../27/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">乱码三千</p>
              <p class="site-description motion-element" itemprop="description">android程序员一枚,擅长java,kotlin,python,金融投资,欢迎交流~</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="https://code.newban.cn/archives/">
              
                  <span class="site-state-item-count">469</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">138</span>
                  <span class="site-state-item-name">标签</span>
                
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="../../atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">乱码三千</span>
  <div>
  <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
  <span id="busuanzi_container_site_pv">本站总访问量<span id="busuanzi_value_site_pv"></span>次</span>
  </div>
  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




  <script type="text/javascript" async src="js/src/mermaid.min.js"></script>
  <script>
  if (window.mermaid) {
        var mermaid_config = {
            startOnLoad: true,
            theme: 'default',
            flowchart:{
                useMaxWidth: false,
                htmlLabels: true
            }                
        }
        mermaid.initialize(mermaid_config);
  }
  </script>
  
        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
          <span id="scrollpercent"><span>0</span>%</span>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="../../lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="../../lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="../../lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="../../lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="../../lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="../../lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="../../js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="../../js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="../../js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  







<!-- LOCAL: You can save these files to your site and update links -->
    
        
        <link rel="stylesheet" href="https://aimingoo.github.io/gitmint/style/default.css">
        <script src="https://aimingoo.github.io/gitmint/dist/gitmint.browser.js"></script>
    
<!-- END LOCAL -->

    
      <style>
        a.gitment-editor-footer-tip { display: none; }
        .gitment-container.gitment-footer-container { display: none; }
      </style>
    

    







  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  

  

  

</body>
</html>
